{"题目": "【超详细】八大排序算法的各项比较以及各自特点", "作者": "九江董熙", "发布时间": "2021-03-27 15:41:32", "内容": [{"ctype": "p", "data": " "}, {"ctype": "p", "data": "千万不要错过这篇，不然你就亏大发了。"}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "排序是计算机程序设计中一个非常重要的操作，它将一个数据元素（或记录）的任意序列重新排列成一个按关键字有序的序列。在有序的序列中查找元素的效率很高，（例如，折半查找法的平均查找长度为log2(n+1)−1log2(n+1)−1），但是无序序列只能逐一查找，其平均查找长度为(n+1)/2(n+1)/2。又比如构建二叉排序树的过程，就是一个排序的过程，因此，如何进行排序，尤其是高效排序，是一个重要的课题。"}, {"ctype": "p", "data": "提示：以下带大家了解一下各个排序"}, {"ctype": "head", "data": "一、排序的概念"}, {"ctype": "p", "data": "1.1排序的概念"}, {"ctype": "p", "data": "1.2 常见的排序算法"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327001740916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "1.3 稳定性及其复杂度"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327002454253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "二、各算法特点（具体看后面博客实现）"}, {"ctype": "head", "data": "1.选择排序---直接选择排序"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011441920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "直接选择排序的特性总结："}, {"ctype": "p", "data": "直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用时间复杂度：O(N^2)空间复杂度：O(1)稳定性：不稳定"}, {"ctype": "head", "data": "2.选择排序---堆排序"}, {"ctype": "p", "data": "堆的插入："}, {"ctype": "p", "data": "每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，然后将这个新数据插入到这个有序数据中，在这个过程中要进行比较。"}, {"ctype": "p", "data": "排大堆，就是最小的放在最上面，也就是升序排小堆，就是最大的放在最上面，也就是降序  （具体看后面博客）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327004431782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "堆排序的特性总结："}, {"ctype": "p", "data": "堆排序使用堆来选数，效率就高了很多。时间复杂度：O(N*logN)空间复杂度：O(1)稳定性：不稳定 应用：寻找M个数中的前K个最小的数并保持有序 "}, {"ctype": "head", "data": "3. 插入排序---直接插入排序"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327003255469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "直接插入排序的特性总结："}, {"ctype": "p", "data": "元素集合越接近有序，直接插入排序算法的时间效率越高 时间复杂度：O(N^2) 空间复杂度：O(1)，它是一种稳定的排序算法 稳定性：稳定"}, {"ctype": "head", "data": "  4. 插入排序---希尔排序"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327013941579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "适用场景"}, {"ctype": "p", "data": "比较在希尔排序中是最主要的操作，而不是交换。用已知最好的步长序列的希尔排序比直接插入排序要快，甚至在小数组中比快速排序和堆排序还快，但在涉及大量数据时希尔排序还是不如快排；"}, {"ctype": "p", "data": "适合小数组小数据。"}, {"ctype": "p", "data": "希尔排序的特性总结："}, {"ctype": "p", "data": " 希尔排序是对直接插入排序的优化。 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。 希尔排序的时间复杂度不好计算，需要进行推导，推导出来平均时间复杂度： O(N^1.3—N^2） 稳定性：不稳定"}, {"ctype": "head", "data": "5.交换排序---冒泡排序"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327015401590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "冒泡排序的特性总结："}, {"ctype": "p", "data": " 冒泡排序是一种非常容易理解的排序 时间复杂度：O(N^2) 空间复杂度：O(1) 稳定性：稳定缺点：慢，每次只能移动两个相邻的数据；"}, {"ctype": "head", "data": "6.交换排序---快速排序"}, {"ctype": "p", "data": "将区间按照基准值划分为左右两半部分的常见方式有："}, {"ctype": "p", "data": "hoare版本挖坑法前后指针版本"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327021757213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "快速排序的特性总结："}, {"ctype": "p", "data": " 快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序 时间复杂度：O(N*logN) 空间复杂度：O(logN) 稳定性：不稳定适用场景：在给大量数据排序的时候，快排的效率尤为明显效率：此排序算法的效率在序列越乱的时候，效率越高。在数据有序时，会退化成冒泡排序；"}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "7.    归并排序"}, {"ctype": "p", "data": "基本思想："}, {"ctype": "p", "data": "归并排序的特性总结："}, {"ctype": "p", "data": " 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。 时间复杂度：O(N*logN) 空间复杂度：O(N) 稳定性：稳定 适用场景：若n较大，并且要求排序稳定，则可以选择归并排序；"}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "8.基数排序 "}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "总结"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327023538559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "我们会在不同的场景会用到不同的排序算法，具体如何。（后面博客会详细说到）"}, {"ctype": "p", "data": "感谢您的阅读，如有错误，欢迎指正。希望大家关注一波。（谢谢）"}], "cate": "Python"}
{"题目": "python爬虫--selenium模块", "作者": "南岸青栀*", "发布时间": "2021-03-27 19:20:41", "内容": [{"ctype": "head", "data": "selenium模块"}, {"ctype": "head", "data": "selenium基本概念"}, {"ctype": "p", "data": "selenium优势"}, {"ctype": "p", "data": "selenium使用流程："}, {"ctype": "p", "data": "1.环境安装：pip install selenium"}, {"ctype": "p", "data": "2.下载一个浏览器的驱动程序（谷歌浏览器）"}, {"ctype": "p", "data": "3.实例化一个浏览器对象"}, {"ctype": "head", "data": "基本使用"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "from selenium import webdriver\nfrom lxml import etree\nfrom time import sleep\n\nif __name__ == '__main__':\n\n    bro = webdriver.Chrome(r\"E:\\google\\Chrome\\Application\\chromedriver.exe\")\n    bro.get(url='http://scxk.nmpa.gov.cn:81/xk/')\n\n    page_text = bro.page_source\n    tree = etree.HTML(page_text)\n    li_list = tree.xpath('//*[@id=\"gzlist\"]/li')\n    for li in li_list:\n        name = li.xpath('./dl/@title')[0]\n        print(name)\n    sleep(5)\n    bro.quit()\n"}, {"ctype": "head", "data": "基于浏览器自动化的操作代码"}, {"ctype": "code", "data": "#编写基于浏览器自动化的操作代码\n\n- 发起请求: get(url)\n\n- 标签定位: find系列的方法\n\n- 标签交互: send_ keys( 'xxx' )\n\n- 执行js程序: excute_script('jsCod')\n\n- 前进，后退: back(),forward( )\n\n- 关闭浏览器: quit()\n\n"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "from selenium import webdriver\nfrom time import sleep\n\nbro = webdriver.Chrome(executable_path=r\"E:\\google\\Chrome\\Application\\chromedriver.exe\")\n\nbro.get(url='https://www.taobao.com/')\n\n#标签定位\nsearch_input = bro.find_element_by_id('q')\nsleep(2)\n#执行一组js代码，使得滚轮向下滑动\nbro.execute_script('window.scrollTo(0,document.body.scrollHeight)')\nsleep(2)\n#标签交互\nsearch_input.send_keys('女装')\nbutton = bro.find_element_by_class_name('btn-search')\nbutton.click()\n\nbro.get('https://www.baidu.com')\nsleep(2)\nbro.back()\nsleep(2)\nbro.forward()\nsleep(5)\nbro.quit()\n"}, {"ctype": "head", "data": "selenium处理iframe："}, {"ctype": "code", "data": "- 如果定位的标签存在于iframe标签之中，则必须使用switch_to.frame(id)\n\n- 动作链(拖动) : from selenium. webdriver import ActionChains\n\t- 实例化一个动作链对象: action = ActionChains (bro)\n\t- click_and_hold(div) :长按且点击操作\n\t- move_by_offset(x,y)\n\t- perform( )让动作链立即执行\n\t- action.release( )释放动作链对象\n\n"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "from selenium import webdriver\nfrom time import sleep\nfrom selenium.webdriver import ActionChains\nbro = webdriver.Chrome(executable_path=r\"E:\\google\\Chrome\\Application\\chromedriver.exe\")\n\nbro.get('https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable')\n\nbro.switch_to.frame('iframeResult')\n\ndiv = bro.find_element_by_id('draggable')\n\n#动作链\naction = ActionChains(bro)\naction.click_and_hold(div)\n\nfor i in range(5):\n    action.move_by_offset(17,0).perform()\n    sleep(0.3)\n\n#释放动作链\naction.release()\n\nbro.quit()\n\n"}, {"ctype": "head", "data": "selenium模拟登陆QQ空间"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "from selenium import webdriver\nfrom time import sleep\n\n\nbro = webdriver.Chrome(executable_path=r\"E:\\google\\Chrome\\Application\\chromedriver.exe\")\nbro.get('https://qzone.qq.com/')\nbro.switch_to.frame(\"login_frame\")\n\nswitcher = bro.find_element_by_id('switcher_plogin')\nswitcher.click()\n\nuser_tag = bro.find_element_by_id('u')\npassword_tag = bro.find_element_by_id('p')\nuser_tag.send_keys('1234455')\npassword_tag.send_keys('qwer123')\nsleep(1)\n\nbut = bro.find_element_by_id('login_button')\nbut.click()\n\n"}, {"ctype": "head", "data": "无头浏览器和规避检测"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "from  selenium import webdriver\nfrom time import sleep\n#实现无可视化界面\nfrom selenium.webdriver.chrome.options import Options\n#实现规避检测\nfrom selenium.webdriver import ChromeOptions\n\n#实现无可视化界面\nchrome_options = Options()\nchrome_options.add_argument('--headless')\nchrome_options.add_argument('--disable-gpu')\n#实现规避检测\noption = ChromeOptions()\noption.add_experimental_option('excludeSwitches',['enable-automation'])\n\nbro = webdriver.Chrome(executable_path=r\"E:\\google\\Chrome\\Application\\chromedriver.exe\",chrome_options=chrome_options,options=option)\n\nbro.get('https://www.baidu.com')\nprint(bro.page_source)\nsleep(2)\nbro.quit()\n\n\n"}], "cate": "Python"}
{"题目": "量化交易 实战之回归法选股 part 2", "作者": "我是小白呀", "发布时间": "2021-03-27 12:14:22", "内容": [{"ctype": "head", "data": "概述"}, {"ctype": "p", "data": "继上一片的理论, 我们这次来进行一下回测, 看一下结果如何."}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "# 可以自己import我们平台支持的第三方python模块，比如pandas、numpy等。\nimport numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\n# 在这个方法中编写任何的初始化逻辑。context对象将会在你的算法策略的任何方法之间做传递。\ndef init(context):\n\n    # 初始化股票因子权重\n    context.weights = np.array([0.04549957, 0.01249463, -0.02397849, 0.06077185, -0.00195205, -0.00892116, -0.04641399, -0.05644752, -0.08393869]) \n\n    # 定义股票池数量\n    context.stocknum = 20\n\n    # 定时每月运行函数\n    scheduler.run_monthly(regression_select, tradingday=1)\n\n\n\ndef regression_select(context, bar_dict):\n    \"\"\"回归预测选股逻辑\"\"\"\n\n    # 获取沪深300\n    context.hs300 = index_components(\"000300.XSHG\")\n\n    # 1. 查询因子\n    q = query(\n        fundamentals.eod_derivative_indicator.pe_ratio,\n        fundamentals.eod_derivative_indicator.pb_ratio,\n        fundamentals.eod_derivative_indicator.market_cap,\n        fundamentals.financial_indicator.ev,\n        fundamentals.financial_indicator.return_on_asset_net_profit,\n        fundamentals.financial_indicator.du_return_on_equity,\n        fundamentals.financial_indicator.earnings_per_share,\n        fundamentals.income_statement.revenue,\n        fundamentals.income_statement.total_expense\n        ).filter(\n            fundamentals.stockcode.in_(context.hs300)\n        )\n\n    fund = get_fundamentals(q)\n\n    context.factors_data = fund.T\n\n    # 2. 数据预处理\n    process_data(context)\n\n    # 3. 根据每月预测下月的收益率\n    select_stocklist(context)\n\n    # 4. 调仓\n    reblance(context)\n\ndef process_data(context):\n    \"\"\"删除空值, 去极值, 标准化, 因子的市值中性化\"\"\"\n    # 删除空值\n    context.factors_data = context.factors_data.dropna()\n\n    # 市值因子不进行去极值, 标准化处理\n    market_cap_factor = context.factors_data[\"market_cap\"]\n\n    # 去极值化, U型你换对每个因子进行处理\n    for name in context.factors_data.columns:\n        context.factors_data[name] = mad(context.factors_data[name])\n        context.factors_data[name] = stand(context.factors_data[name])\n\n        # 对因子(除了市值因子) 中性化处理\n        if name == \"market_cap\":\n            continue\n        \n        # 建立回归方程, 市值中性化\n        lr = LinearRegression()\n\n        x = market_cap_factor.values\n        y = context.factors_data[name]\n\n        # x: 要求二维, y: 要求一维\n        lr.fit(x.reshape(-1, 1), y)\n\n        y_predict = lr.predict(x.reshape(-1, 1))\n\n        # 得出误差进行替换原有因子值\n        context.factors_data[name] = y - y_predict\n\ndef select_stocklist(context):\n    \"\"\"回归计算预测得出收益率结果, 筛选收益率高的股票\"\"\"\n\n    # 特征值是: context.factors_Date (300, 9) 系数: 因子权重\n\n    # 进行矩阵运算 (300, 9) * (9, 1) = (300, 1)\n    stock_return = np.dot(context.factors_data.values, context.weights)\n    logger.info(stock_return)\n    \n    # 赋值给因子数据, 注意都是默认对应的股票代码和收益率\n    context.factors_data[\"stock_return\"] = stock_return\n\n    # 进行收益率排序\n    ordered = context.factors_data.sort_values(by=\"stock_return\", ascending=False)\n\n    # 加入股票池\n    context.stock_list = ordered.index[:context.stocknum]\n\ndef reblance(context):\n    # ----------------卖出----------------\n\t# 遍历股票池\n    for stock in context.portfolio.positions.keys():\n        # 判断是否还在股票池\n        if stock not in context.stock_list:\n            # 如果不在, 卖出\n            order_target_percent(stock, 0)\n\n    # ----------------买入-----------------\n\t# 买入的百分比\n    weight = 1.0 / len(context.stock_list)\n    # 遍历股票池\n    for stock in context.stock_list:\n        # 等比例买入\n        order_target_percent(stock, weight)\n    \n\n# before_trading此函数会在每天策略交易开始前被调用，当天只会被调用一次\ndef before_trading(context):\n    pass\n\n\n# 你选择的证券的数据更新将会触发此段逻辑，例如日或分钟历史数据切片或者是实时数据切片更新\ndef handle_bar(context, bar_dict):\n    # 开始编写你的主要的算法逻辑\n    pass\n\n# after_trading函数会在每天交易结束后被调用，当天只会被调用一次\ndef after_trading(context):\n    pass\n\n\ndef mad(factor):\n    \"\"\"3倍中位数去极值\"\"\"\n    \n    # 求出因子值的中位数\n    median = np.median(factor)\n    \n    # 求出因子值与中位数的差值, 进行绝对值\n    mad = np.median(abs(factor - median))\n    \n    # 定义几倍的中位数上下限\n    high = median + (3 * 1.4826 * mad)\n    low = median - (3 * 1.4826 * mad)\n    \n    # 替换上下限\n    factor = np.where(factor > high, high, factor)\n    factor = np.where(factor < low, low, factor)\n    return factor\n\ndef stand(factor):\n    \"\"\"数据标准化\"\"\"\n    mean = factor.mean()\n    std = factor.std()\n    \n    return (factor - mean) / std\n"}, {"ctype": "head", "data": "效果"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327121227844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI3NDE2OA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "注: 在实际的应用中大概率不会跑赢大盘 46%, 因为分析的区间较短."}], "cate": "Python"}
{"题目": "多个库，多条路，Python 到底有多少命令行参数解析库？", "作者": "梦想橡皮擦", "发布时间": "2021-03-28 10:06:10", "内容": [{"ctype": "p", "data": "本篇博客将为你带来 10 个 Python 中的参数解析库，Python 自带的这些【模块军火库】，一定要了解，毕竟多掌握一个库，你解决问题的时候就多了一条路。"}, {"ctype": "head", "data": "何为参数解析库"}, {"ctype": "p", "data": "在对 Python 一段小脚本运行的时候，通过 python test.py 参数1 参数2 参数3 形式，可以向 Python 脚本内部传递参数，用于解析参数的库就是参数解析库。"}, {"ctype": "head", "data": "sys.argv"}, {"ctype": "p", "data": "最传统的写法，也是 Python 内置的内容，例如下述代码："}, {"ctype": "code", "data": "import sys\nprint(sys.argv)\n"}, {"ctype": "p", "data": "当你通过下述命令运行 Python 脚本时，就可以获取到一个 list 类型的参数列表。"}, {"ctype": "code", "data": "python test.py 1 2 3\n"}, {"ctype": "head", "data": "getopt 内置的参数解析库"}, {"ctype": "p", "data": "对于 sys.argv 而言，得到的只是一个列表，通过 getopt 参数解析库，可以获取参数。"}, {"ctype": "p", "data": "getopt 库中核心的函数是 getopt.getopt()，具体参数与使用方式，可以参见滚雪球系列这篇文章。"}, {"ctype": "head", "data": "docopt 参数解析库"}, {"ctype": "p", "data": "一个优雅的命令行模块，可以通过 https://github.com/docopt/docopt 进行学习与使用。"}, {"ctype": "head", "data": "optparse 参数解析库"}, {"ctype": "p", "data": "optparse 解析器的命令行选项，3.2 版后 optparse 模块已被弃用并不再继续开发；接力棒，转移到了 argparse 模块。"}, {"ctype": "p", "data": "学习如何使用，可以参考：https://docs.python.org/zh-cn/3/library/optparse.html#module-optparse"}, {"ctype": "head", "data": "argparse 参数解析库"}, {"ctype": "p", "data": "通过 pip install argparse 对该库进行安装，使用方式也比较简单，官方对其的定义是，命令行选项、参数和子命令解析器。"}, {"ctype": "p", "data": "学习如何使用，可以参考：https://docs.python.org/zh-cn/3/library/argparse.html"}, {"ctype": "head", "data": "click 参数解析库"}, {"ctype": "p", "data": "Click 是 Flask 的开发团队 Pallets 的一款开源项目，它是用于快速创建命令行的第三方模块。"}, {"ctype": "p", "data": "官方地址与使用方式，参考 github：https://github.com/pallets/click"}, {"ctype": "head", "data": "fire 参数解析库"}, {"ctype": "p", "data": "fire 用于从任何 Python 对象自动生成命令行接口，只需对 Fire 进行一次调用，即可将任何 Python 组件转变为命令行界面。"}, {"ctype": "p", "data": "该工具库是谷歌开源的。"}, {"ctype": "p", "data": "开源地址：https://github.com/google/python-fire"}, {"ctype": "head", "data": "typer 参数解析库"}, {"ctype": "p", "data": "Typer 是一个用于构建 CLI 应用程序的库。 文档: https://typer.tiangolo.com"}, {"ctype": "p", "data": "代码： https://github.com/tiangolo/typer"}, {"ctype": "head", "data": "Commando 参数解析库"}, {"ctype": "p", "data": "基于 argparse 的封装，允许使用装饰器的方式定义命令和参数。 开源地址：https://github.com/hyde/commando"}, {"ctype": "head", "data": "FLAGS 参数解析库"}, {"ctype": "p", "data": "如果你在做深度学习相关方向，尤其经常使用 tensorflow，那 FLAGS 是一款必备的命令行工具。 该模块的使用需要基于 tensorflow 了，故放在最后一趴。"}, {"ctype": "head", "data": "写在后面"}, {"ctype": "p", "data": "这些优质的第三方库，橡皮擦给大家的推荐顺序是：fire-> click -> argparse -> **getopt **。"}, {"ctype": "p", "data": "这两个项目在 github 上的超高 star，也证明了大家对其的认可。"}, {"ctype": "p", "data": " 本篇博客并未对所有的库进行展开说明，毕竟掌握一个库，已经是基于该库可以解决你的问题。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328100020540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hpaGVsbA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "相关阅读"}, {"ctype": "p", "data": "Python 爬虫 100 例教程，超棒的爬虫教程，立即订阅吧Python 游戏世界（更新中，目标文章数 50+，现在订阅，都是老粉）Python 爬虫小课，精彩 9 讲"}], "cate": "Python"}
{"题目": "字典算法实现及操作 --python（实用）", "作者": "也曾rgnxhw", "发布时间": "2021-03-28 23:31:10", "内容": [{"ctype": "head", "data": "字典算法实现 --python"}, {"ctype": "p", "data": "我在做项目的处理工作时，因为项目数据的需要，我想对字典的每一个最底层的值进行操作，得到所有底层值得路径和值并输出，于是就写了这个算法。"}, {"ctype": "head", "data": "代码及功能："}, {"ctype": "code", "data": "def print_k(area, i=0, a='', key=''):\n    if key != '':\n        a = a + key + ','\n    for k in area:\n        if isinstance(area[k], dict):\n            print_k(area[k], i+1, a=a, key=k)\n        else:\n            for j in (a + k).split(','):\n                print(j, end='--',)\n            print('-------', area[k])\n"}, {"ctype": "p", "data": "这个是一个嵌套函数，我们传入一个字典，它会遍历输出所有的底层值 比如我们先读取一个json文件，并且转换为dict，然后传入这个函数。  读取文件 & 打印"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328225843383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxZVdFRA==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import json\nf1 = open('json_data/empty1.json')\nfile = json.load(f1)\nprint_k(file)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032823024338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxZVdFRA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "格外操作："}, {"ctype": "p", "data": "我们可以通过修改print(）函数得输出流，将输出结果写到文件里边，下面来示例一下。 print函数有个参数为file ,通过修改它就可以实现上功能"}, {"ctype": "code", "data": "def print_k(area, i=0, a='', key=''):\n    if key != '':\n        a = a + key + ','\n    for k in area:\n        if isinstance(area[k], dict):\n            print_k(area[k], i+1, a=a, key=k)\n        else:\n            for j in (a + k).split(','):\n                print(j, end='--', file=f)\n            print('-------', area[k], file=f)\ndicts = {\"a\": \"1层1\", 'j': {\"a\": \"2层1\", \"b\": \"2层2\"}, \"b\": \"一层2\", \"g\": \"一层3\", \"o\": \"一层4\",\n             '1': {\"a\": \"二层\", \"b\": \"2c\", \"g\": \"2c\"}}\n    with open('Txt/test3.txt', 'w') as f:\n        print_k(dicts)\n"}, {"ctype": "p", "data": "可以看到我们进行了输出重定向。我们看到test3.txt本来是空的  在运行了代码之后  字典的值和路劲被逐行写进来了，规则还可以自己修改，非常方便。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328231058235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxZVdFRA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "希望大家多多交流，共同进步！"}], "cate": "Python"}
{"题目": "查题程序，无脑查题拿高分", "作者": "隔壁的程序员老哥", "发布时间": "2021-03-27 16:56:22", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "现在上网课自己答题太累了，所以做一个答题的程序方便自己，后面可能考虑自己做一个浏览器脚本更方便。如果有侵权什么的记得联系博主删除哦"}, {"ctype": "head", "data": "先修知识"}, {"ctype": "p", "data": "PyQt5界面制作、requests模拟请求框架基本使用"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "import sys,requests,json\nfrom PyQt5.QtWidgets import  QMainWindow,QApplication,   QMessageBox\nfrom PyQt5.uic import loadUi\n\n\nclass MainWindow(QMainWindow):\n    def __init__(self, parent=None):\n        super(MainWindow, self).__init__(parent)\n        loadUi('maingui.ui', self)\n        self.init_t()\n\n    def init_t(self):\n        self.pushButton.clicked.connect(self.search)\n\n    def search(self):\n        try:\n            text = self.textEdit.toPlainText().strip()\n            if (len(text) < 6):\n                QMessageBox.warning(self, \"Warning\", \"题目少于6个字\", QMessageBox.Yes, QMessageBox.Yes)\n            else:\n                url=\"http://39.108.63.141:8932/?q=\"+text\n                res=requests.get(url=url)\n                if(res.status_code==200):\n                    res=json.loads(res.text)\n                    if(res[\"status\"]==\"ok\"):\n                        data=res[\"data\"]\n                        s=\"题目：【{}】\\n答案：【{}】\".format(data[\"question\"],data[\"answer\"])\n                        QMessageBox.information(self, \"提醒\",s,\n                                            QMessageBox.Yes, QMessageBox.Yes)\n                        self.textEdit.clear()\n                    else:\n                        QMessageBox.warning(self, \"Warning\", \"api响应异常，响应信息为：{}\".format(res),\n                                            QMessageBox.Yes, QMessageBox.Yes)\n                else:\n                    QMessageBox.warning(self, \"Warning\", \"api响应异常，响应状态码为：{}\".format(res.status_code), QMessageBox.Yes, QMessageBox.Yes)\n        except Exception as e:\n            QMessageBox.warning(self, \"Warning\", \"程序出错：{}\".format(e),\n                                QMessageBox.Yes, QMessageBox.Yes)\n            s = sys.exc_info()\n            print(\"Error '%s' happened on line %d\" % (s[1], s[2].tb_lineno))\n\n\napp = QApplication(sys.argv)\nw = MainWindow()\nw.show()\nsys.exit(app.exec())\n"}, {"ctype": "p", "data": "这里还用到了一个ui文件，附带下载链接，特意设置成了不需要积分（设置成0积分要下载码，所以还是改成要一个积分了）：https://download.csdn.net/download/weixin_45857307/16159847"}, {"ctype": "p", "data": "或者百度云链接: https://pan.baidu.com/s/1HujQJK4_DDz3ScRDek_Trg 提取码: msrc 复制这段内容后打开百度网盘手机App，操作更方便哦"}], "cate": "Python"}
{"题目": "python", "作者": "初来贵地", "发布时间": "2021-03-27 22:38:55", "内容": [{"ctype": "head", "data": "问题"}, {"ctype": "p", "data": "已知列表data中有若干字符串，要求编写程序，对data中的字符串进行过滤，只输出重复字符不超过一半的字符串。"}, {"ctype": "p", "data": "提示：以下是本篇文章正文内容，下面案例可供参考"}, {"ctype": "head", "data": "一、分析"}, {"ctype": "p", "data": "键盘输入字符串后需要使用split()来进行分割操作需要引入collections中的Counter来方便计数通过for循环来对字符串计数通过if语句找出每个字符串中字母重复最多的字母重复最多的那个字母重复的个数与该字符串长度进行比较决定要不要输出该字符串"}, {"ctype": "head", "data": "二、步骤"}, {"ctype": "head", "data": "1.引入库中方法"}, {"ctype": "p", "data": "代码如下（示例）："}, {"ctype": "code", "data": "from collections import Counter     #导入Counter\n"}, {"ctype": "head", "data": "2.键盘输入数据"}, {"ctype": "p", "data": "代码如下（示例）："}, {"ctype": "code", "data": "print(\"输入字符串\")\ndata=input()            #手动输入\ndatalist=data.split(\",\")    #分割字符串\ndata=datalist\nprint(data)         #输出字符串列表\n"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "from collections import Counter     #导入Counter\nprint(\"输入字符串\")\ndata=input()            #手动输入\ndatalist=data.split(\",\")    #分割字符串\n#print(datalist)\ndata=datalist\n#data=['Hello','World','python','aaabbb','cccdd']\nprint(data)         #输出字符串列表\nfor i in data:      #for循环\n    a=Counter(i)        #对列表中每一个字符串进行计数\n    #print(Counter(i))\n    maxlen=0\n    for j in a:\n        #print(key,a[j])        #输出的是字母和个数，例如 \"all\"  输出 a 1  l 2\n        if maxlen< a[j]:\n            maxlen= a[j]        #得到字符串中字母重复最多的\n    #print(maxlen)      #输出重复数量\n    if maxlen <= len(i)/2:      #重复最多的字母的重复个数与该字符长度比较，没有超过一半则输出该字符串\n        print(i)\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327224423522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU0MTQxMDk1,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python常用random随机函数汇总，用法详解及函数之间的区别--一图了解python随机函数", "作者": "若芷兰", "发布时间": "2021-03-27 18:18:03", "内容": [{"ctype": "p", "data": "python中常用的随机函数的用法汇总分类以及相似函数之间的区别： 一图了解python的随机函数 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327181609169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkxNDQ1Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "1. 常用的随机函数总结介绍"}, {"ctype": "p", "data": "1. random.random(): 返回随机生成的一个浮点数，范围在[0,1)之间"}, {"ctype": "p", "data": "2. random.uniform(a, b): 返回随机生成的一个浮点数，范围在[a, b)之间"}, {"ctype": "p", "data": "3. np.random.rand(d0, d1, …, dn): 返回一个或一组浮点数，范围在[0, 1)之间"}, {"ctype": "p", "data": "4. np.random.normal(loc=a, scale=b, size=()): 返回满足条件为均值=a, 标准差=b的正态分布（高斯分布）的概率密度随机数"}, {"ctype": "p", "data": "5. np.random.randn(d0, d1, … dn): 返回标准正态分布(均值=0，标准差=1)的概率密度随机数"}, {"ctype": "p", "data": "6. np.random.standard_normal(size=()): 返回标准正态分布(均值=0，标准差=1)的概率密度随机数"}, {"ctype": "p", "data": "7. random.sample(k): 从总体序列或集合中随机选取k个唯一的元素"}, {"ctype": "p", "data": "8. np.random.randint(a, b, size=(), dtype=int): 返回在范围在[a, b)中的随机整数（含有重复值）"}, {"ctype": "p", "data": "9. random.randrange(a, b, step=c): 在指定范围内，在指定的基数和步长值形成的集合中获取1个随机数值"}, {"ctype": "p", "data": "10. random.choice(x): 从指定的序列x中随机获取一个数据"}, {"ctype": "p", "data": "11. random.shuffle(x): 将一个列表x中的元素打乱，随机排序（俗称：洗牌）"}, {"ctype": "p", "data": "12. random.seed(): 设定随机种子"}, {"ctype": "head", "data": "2. 示例代码（python）"}, {"ctype": "p", "data": "1. random.random() - 返回随机生成的一个浮点数，范围在[0,1)之间"}, {"ctype": "code", "data": "import numpy as np\nimport pandas as pd\nimport random\n\n# 随机生成一个在[0, 1)范围的浮点数\nx = random.random()\nprint(x, type(x))\n"}, {"ctype": "p", "data": "0.5714025946899135 <class ‘float’>"}, {"ctype": "p", "data": "2. random.uniform(x, y) - 返回随机生成的一个浮点数，范围在[x, y)之间"}, {"ctype": "code", "data": "# 随机生成一个在[15.0, 20.0)之间的浮点数\nx = random.uniform(15.0, 20.0)\nprint(x, type(x))\n"}, {"ctype": "p", "data": "17.144445273375574 <class ‘float’>"}, {"ctype": "p", "data": "3. np.random.rand(d0, d1, …, dn) - 返回一个或一组浮点数，范围在[0, 1)之间"}, {"ctype": "code", "data": "x = np.random.rand()\ny = np.random.rand(2)\nprint(x, type(x))\nprint(y, type(y))\n"}, {"ctype": "p", "data": " 小结：np.random.rand()的用法与random.random()相似，都是返回范围在[0, 1)之间的随机浮点数。唯一不同的是，random.random()只能返回一个随机数；而np.random.rand()则可以根据设置返回多个数据。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327153713256.png"}, {"ctype": "p", "data": "4. np.random.normal() - 返回正态分布（高斯分布）的概率密度随机数"}, {"ctype": "code", "data": "# np.random.normal(loc=a, scale=b, size=()) - 返回满足条件为均值=a, 标准差=b的正态分布（高斯分布）的概率密度随机数，size默认为None(返回1个随机数），也可以为int或数组\nx = np.random.normal(10, 0.2, 2)\ny = np.random.normal(0, 0.1, (2, 3))\nprint(x, type(x))\nprint(y, type(y))\n"}, {"ctype": "p", "data": " 5. np.random.randn() - 返回标准正态分布的概率密度随机数"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327145540258.png"}, {"ctype": "code", "data": "# np.random.randn(d0, d1, ... dn): 返回标准正态分布(均值=0，标准差=1)的概率密度随机数, \nx = np.random.randn()\ny = np.random.randn(3)\nz = np.random.randn(2, 2)\nprint(x, type(x))\nprint(y, type(y))\nprint(z, type(z))\n"}, {"ctype": "p", "data": " 6. np.random.standard_normal() - 返回标准正态分布的概率密度随机数"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327152335336.png"}, {"ctype": "code", "data": "# np.random.standard_normal(): 返回标准正态分布(均值=0，标准差=1)的概率密度随机数, size默认为None(返回1个随机数），也可以为int或数组\nx = np.random.standard_normal()\ny = np.random.standard_normal(size=(2,2))\nprint(x, type(x))\nprint(y, type(y))\n"}, {"ctype": "p", "data": " 小结：上述可见np.random.rand()与np.random.standard_normal()的方法结果相似，都是返回合符标准正态分布的随机浮点数或数组。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327151339646.png"}, {"ctype": "p", "data": "7. random.sample(k) - 在总体序列或集合中返回k个唯一的随机元素（不包含重复值）"}, {"ctype": "code", "data": "# 从0-10的序列中返回5个不重复的随机数字\nx = random.sample(range(0, 10), 5)\nprint(x, type(x))\n"}, {"ctype": "p", "data": "[9, 0, 6, 3, 4] <class ‘list’>"}, {"ctype": "p", "data": "8. np.random.randint(a, b, sizie=(), dytpe=int) - 返回在范围在[a, b)中的一组随机整数（包含重复值）"}, {"ctype": "code", "data": "# np.random.randint(a, b, sizie=(), dytpe=int) - size默认为None(返回1个随机数），也可以为int或数组\n# 从序列[0, 10)之间返回shape=(2,5)的10个随机整数（包含重复值）\nx = np.random.randint(0, 10, size=(2, 5))\n# 从序列[15, 20)之间返回1个随机整数（size默认为None, 则返回1个随机整数）\ny = np.random.randint(15, 20)\nprint(x, type(x))\nprint(y, type(y))\n"}, {"ctype": "p", "data": " 小结：random.sample()与np.random.randint()的最大区别在于，random.sample()返回的是唯一的随机元素，即不含有重复值；而np.random.randint()是返回含有重复值的随机数值。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327161306529.png"}, {"ctype": "p", "data": "9. random.randrange(a, b, step=c) - 在指定范围内，在指定的基数和步长值形成的集合中获取1个随机数值"}, {"ctype": "code", "data": "# 在[6, 16]范围内，在6的基础上按步长=3形成的递增集合中获取1个随机数\nx = random.randrange(6, 16, 3)\nprint(x, type(x))\n"}, {"ctype": "p", "data": "15 <class ‘int’>"}, {"ctype": "p", "data": "10. random.choice(x) - 从指定的序列x中随机获取一个数据"}, {"ctype": "code", "data": "# 从x列表中随机返回一个数值\nx = [100, 20, 90, 5, 12]\nprint(random.choice(x))\n"}, {"ctype": "p", "data": "90"}, {"ctype": "p", "data": "11. random.shuffle(x) - 将一个列表x中的元素打乱，随机排序（俗称：洗牌）"}, {"ctype": "code", "data": "# 将x列表中的元素打乱并重新随机排序\nx = [1, 2, 3, 4, 5]\nrandom.shuffle(x)\nprint(x)\n"}, {"ctype": "p", "data": "[3, 4, 2, 1, 5]"}, {"ctype": "p", "data": "12. random.seed() - 设定随机种子"}, {"ctype": "code", "data": "# 在设定随机种子为10之后，random.random()的随机数将被直接设定为：0.5714025946899135\nrandom.seed(10)\nx = random.random()\nx\n"}, {"ctype": "p", "data": "0.5714025946899135"}, {"ctype": "head", "data": "3. 结束语"}, {"ctype": "p", "data": "总结上述随机函数的相似或区别地方："}, {"ctype": "p", "data": "np.random.rand()的用法与random.random()相似，都是返回范围在[0, 1)之间的随机浮点数。唯一不同的是，random.random()只能返回一个随机数，而np.random.rand()则可以根据设置返回多个数据。np.random.rand()与np.random.standard_normal()的方法结果相似，都是返回合符标准正态分布的随机浮点数或数组。random.sample()与np.random.randint()的最大区别在于，random.sample()返回的是唯一的随机元素，即不含有重复值；而np.random.randint()是返回含有重复值的随机数值。"}], "cate": "Python"}
{"题目": "《小白初识python之第二章基础语法》", "作者": "Alex_l_00", "发布时间": "2021-03-26 11:14:14", "内容": [{"ctype": "p", "data": "目录"}, {"ctype": "p", "data": "一、数据类型"}, {"ctype": "p", "data": "1、标准数据类型"}, {"ctype": "p", "data": "2、Number（数字）"}, {"ctype": "p", "data": "二、运算符"}, {"ctype": "p", "data": "1、算术运算符"}, {"ctype": "p", "data": "2、赋值运算符"}, {"ctype": "p", "data": "3、比较运算符"}, {"ctype": "p", "data": "4、逻辑运算符"}, {"ctype": "p", "data": "三、字符串"}, {"ctype": "p", "data": "1、字符串定义"}, {"ctype": "p", "data": "2、字符串操作"}, {"ctype": "p", "data": "字符串访问"}, {"ctype": "p", "data": " 索引值以 0 为开始值，-1 为从末尾的开始位置。"}, {"ctype": "p", "data": "字符串切片"}, {"ctype": "p", "data": "字符串运算"}, {"ctype": "p", "data": "3、字符串转义字符"}, {"ctype": "p", "data": "   "}, {"ctype": "head", "data": "一、数据类型"}, {"ctype": "head", "data": "1、标准数据类型"}, {"ctype": "p", "data": "Python3 中有六个标准的数据类型："}, {"ctype": "p", "data": "Python3 的六个标准数据类型中："}, {"ctype": "head", "data": "2、Number（数字）"}, {"ctype": "p", "data": "Python3 支持 int、float、bool、complex（复数）"}, {"ctype": "p", "data": "在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。"}, {"ctype": "p", "data": "像大多数语言一样，数值类型的赋值和计算都是很直观的。"}, {"ctype": "p", "data": "内置的 type() 函数可以用来查询变量所指的对象类型。"}, {"ctype": "code", "data": ">>> a, b, c, d = 20, 5.5, True, 4+3j\n>>> print(type(a), type(b), type(c), type(d))\n<class 'int'> <class 'float'> <class 'bool'> <class 'complex'>"}, {"ctype": "head", "data": "二、运算符"}, {"ctype": "head", "data": "1、算术运算符"}, {"ctype": "p", "data": "      a：  +、-、*、/"}, {"ctype": "p", "data": "      b:  // 取整"}, {"ctype": "p", "data": "      c:  % 取余"}, {"ctype": "p", "data": "      d: ** 幂运算"}, {"ctype": "code", "data": ">>> 5 + 4  # 加法\n9\n>>> 4.3 - 2 # 减法\n2.3\n>>> 3 * 7  # 乘法\n21\n>>> 2 / 4  # 除法，得到一个浮点数\n0.5\n>>> 2 // 4 # 除法，得到一个整数\n0\n>>> 17 % 3 # 取余\n2\n>>> 2 ** 5 # 乘方\n32"}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "2、赋值运算符"}, {"ctype": "p", "data": "简单的赋值运算符： ="}, {"ctype": "p", "data": "加法赋值运算符： +="}, {"ctype": "p", "data": "减法赋值运算符： -= "}, {"ctype": "p", "data": "乘法赋值运算符： *="}, {"ctype": "p", "data": "除法赋值运算符： /= "}, {"ctype": "p", "data": "取模赋值运算符：%=  "}, {"ctype": "p", "data": "幂赋值运算符： **= "}, {"ctype": "p", "data": "取整除赋值运算符：//= "}, {"ctype": "code", "data": "#!/usr/bin/python3\n \na = 21\nb = 10\nc = 0\n \nc = a + b\nprint (\"1 、 c 的值为：\", c)\n \nc += a  #等价于c = c+a\nprint (\"2 、 c 的值为：\", c)\n \nc *= a  #等价于c = c*a\nprint (\"3 、 c 的值为：\", c)\n \nc /= a  #等价于c = c/a\nprint (\"4 、 c 的值为：\", c)\n \nc = 2\nc %= a  #等价于c = c%a\nprint (\"5 、 c 的值为：\", c)\n \nc **= a #等价于 c = c**a\nprint (\"6 、 c 的值为：\", c)\n \nc //= a  #等价于c = c//a\nprint (\"7 、c 的值为：\", c)"}, {"ctype": "head", "data": "3、比较运算符"}, {"ctype": "p", "data": "以下假设变量x为10，变量y为20："}, {"ctype": "p", "data": "大于号： >      返回x是否大于y    "}, {"ctype": "p", "data": "小于号：<       返回x是否小于y    "}, {"ctype": "p", "data": "大于等于：>=   返回x是否大于等于y   "}, {"ctype": "p", "data": "小于等于：<=   返回x是否小于等于y   "}, {"ctype": "p", "data": "不等于：  ！=  比较两个对象是否不相等  "}, {"ctype": "p", "data": "等于：==     比较对象是否相等       "}, {"ctype": "p", "data": "注意：一个等号是赋值 ，两个等号是等于（比较两个数是否相等）；！= 是不等于"}, {"ctype": "code", "data": "x = 10\ny = 20\nprint(x>y)#返回x是否大于y \nprint(x<y)#返回x是否小于y\nprint(x>=y)#返回x是否大于等于y\nprint(x<=y)#返回x是否小于等于y \nprint(x!=y)#比较两个对象是否不相等 \nprint(x==y)  #比较对象是否相等 "}, {"ctype": "head", "data": "4、逻辑运算符"}, {"ctype": "p", "data": " 与： and   （and进行条件判断时，需要条件都成立才返回True,只要有一个不成立就返回False）"}, {"ctype": "p", "data": " 或：or       （or:进行条件判断时只要有任何一个条件满足就返回True,都不成立才返回False）"}, {"ctype": "p", "data": " 非：  ！     （！：进行取反，不满足条件时才返回TRUE）"}, {"ctype": "code", "data": "a = 10\nb = 20\nprint(a==10 and b==10) #返回false\nprint(a==10 and b==20) #返回true\n\nprint(a==10 or b==10)  #返回true\nprint(a==20 or b==10)  #返回false\n\nprint(a!=20) #返回true\nprint(a!=10) #返回false"}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "三、字符串"}, {"ctype": "head", "data": "1、字符串定义"}, {"ctype": "p", "data": "         Python中的字符串用单引号 ' 或双引号 \" 括起来，\"\"\"也可以。"}, {"ctype": "head", "data": "2、字符串操作"}, {"ctype": "head", "data": "     字符串访问"}, {"ctype": "p", "data": "       a、通过索引访问，索引从0开始，空格也占一个索引位置"}, {"ctype": "head", "data": "    索引值以 0 为开始值，-1 为从末尾的开始位置。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326113741395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhfbF8wMA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "                                                                                 "}, {"ctype": "head", "data": "字符串切片"}, {"ctype": "p", "data": "    a、遵循左闭右开的原则（取左边下标的值，不取右边下标的值）"}, {"ctype": "p", "data": "   b、步长  str[起始索引：结束索引：步长]"}, {"ctype": "p", "data": "          str[0:5:2]    表示步长为2，每隔两个进行取值"}, {"ctype": "p", "data": "注意：1、str[::-1]步长为负数表示倒叙"}, {"ctype": "p", "data": "            2、起始索引的绝对值要小于结束索引的绝对值，要不会取不到值"}, {"ctype": "p", "data": "   c、字符串的截取的语法格式如下（步长默认为1，可以省略不写）： "}, {"ctype": "code", "data": "变量[头下标:尾下标]"}, {"ctype": "p", "data": "d、倒序切片"}, {"ctype": "p", "data": "str1[起始索引:结束索引:步长]"}, {"ctype": "p", "data": "步长： 正数：表示正序切片，负数：倒序切片"}, {"ctype": "p", "data": "正序、倒序 本质是一样的，只是切片的方向不一样，起始索引不一样 ，"}, {"ctype": "p", "data": "切片正序还是倒序只跟步长正负有关系 正序切 用正数 ，倒序切 就用负数 ；"}, {"ctype": "p", "data": "不管是正序切片，还是倒序切片，都有两种写法"}, {"ctype": "p", "data": "1：索引从0开始正序取值；2：索引从-1开始倒序取值"}, {"ctype": "p", "data": "原则：你需要的取值保证在这个范围内"}, {"ctype": "p", "data": "倒序切片起始索引是-1"}, {"ctype": "p", "data": "注意： 正序：索引取值从0开始"}, {"ctype": "p", "data": "倒序：索引取值从-1开始"}, {"ctype": "head", "data": "  字符串运算"}, {"ctype": "p", "data": "1、字符串的拼接是用 + 连接起来的"}, {"ctype": "p", "data": "2、重复输出用 *"}, {"ctype": "code", "data": "#!/usr/bin/python3\n\nstr = 'python'\n\nprint (str)          # 输出字符串\nprint (str[0:-1])    # 输出第一个到倒数第二个的所有字符\nprint (str[0])       # 输出字符串第一个字符\nprint (str[2:5])     # 输出从第三个开始到第五个的字符\nprint (str[2:])      # 输出从第三个开始的后的所有字符\nprint (str * 2)      # 输出字符串两次，也可以写成 print (2 * str)\nprint (str + \"TEST\") # 连接字符串"}, {"ctype": "head", "data": "3、字符串转义字符"}, {"ctype": "p", "data": "1、 \\n    换行"}, {"ctype": "p", "data": "2、 \\  转义字符"}, {"ctype": "p", "data": "3、 r   不进行转义"}, {"ctype": "p", "data": "4、 \\\\  反斜杠符号"}, {"ctype": "code", "data": "print(\"python\\hello\")\nprint(\"python\\nhello\")\nprint(r'python\\nhello')\nprint('python\\\\hello')\nprint(r'python\\\\hello')"}, {"ctype": "table", "data": "转义字符描述实例\\(在行尾时)续行符 >>> print(\"line1 \\\n... line2 \\\n... line3\")\nline1 line2 line3\n>>>  \\\\反斜杠符号 >>> print(\"\\\\\")\n\\ \\'单引号 >>> print('\\'')\n' \\\"双引号 >>> print(\"\\\"\")\n\" \\a响铃 >>> print(\"\\a\") 执行后电脑有响声。\\b退格(Backspace) >>> print(\"Hello \\b World!\")\nHello World! \\000空 >>> print(\"\\000\")\n\n>>>  \\n换行 >>> print(\"\\n\")\n\n\n>>> \\v纵向制表符 >>> print(\"Hello \\v World!\")\nHello \n       World!\n>>> \\t横向制表符 >>> print(\"Hello \\t World!\")\nHello      World!\n>>> \\r回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。 >>> print(\"Hello\\rWorld!\")\nWorld!\n>>> print('google runoob taobao\\r123456')\n123456 runoob taobao \\f换页 >>> print(\"Hello \\f World!\")\nHello \n       World!\n>>>  \\yyy八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 >>> print(\"\\110\\145\\154\\154\\157\\40\\127\\157\\162\\154\\144\\41\")\nHello World! \\xyy十六进制数，以 \\x 开头，y 代表的字符，例如：\\x0a 代表换行 >>> print(\"\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x57\\x6f\\x72\\x6c\\x64\\x21\")\nHello World! \\other其它的字符以普通格式输出 "}, {"ctype": "head", "data": "   "}], "cate": "Python"}
{"题目": "python科学计算——用Weave嵌入C语言", "作者": "薛定猫", "发布时间": "2021-03-27 08:01:44", "内容": [{"ctype": "p", "data": "先提醒一下大家，在2021年2月18日的SciPy 0.15.0 Release Notes中， weave模块已经被弃用，它是唯一一个没有被移植到Python 3的模块。并且不建议在新代码中使用，官方建议使用Cython替代他。 Weave只能在python2环境中使用。"}, {"ctype": "head", "data": "weave简介"}, {"ctype": "p", "data": "Python作为动态语言其功能虽然强大，但是在数值计算方面有一个最大的缺点：速度不够快。在Python级别的循环和计算的速度只有C语言程序的百分之一。因此才有了NumPy, SciPy这样的函数库，将高度优化的C、Fortran的函数库进行包装，以供Python程序调用。如果这些高度优化的函数库无法实现我们的算法，必须从头开始写循环、计算的话，那么用Python来做显然是不合适的。因此SciPy提供了快速调用C++语言程序的方法-- Weave。"}, {"ctype": "head", "data": "安装"}, {"ctype": "p", "data": "为了支持现有的代码，scipy.weave已单独打包:https://github.com/scipy/weave。它是一个纯Python包，可以很容易地用pip安装。 安装："}, {"ctype": "code", "data": "pip install weave\n"}, {"ctype": "head", "data": "测试"}, {"ctype": "code", "data": "# -*- coding: utf-8 -*-\nimport weave\nimport numpy as np\nimport time\n\ndef my_sum(a):\n    n=int(len(a))\n    code=\"\"\"\n    int i;\n\n    double counter;\n    counter =0;\n    for(i=0;i<n;i++){\n        counter=counter+a(i);\n    }\n    return_val=counter;\n    \"\"\"\n\n    err=weave.inline(\n        code,['a','n'],\n        type_converters=weave.converters.blitz,\n        compiler=\"gcc\"\n    )\n    return err\n\na = np.arange(0, 10000000, 1.0)\n# 先调用一次my_sum，weave会自动对C语言进行编译，此后直接运行编译之后的代码\nmy_sum(a)\n\nstart = time.clock()\nfor i in xrange(100):\n    my_sum(a)  # 直接运行编译之后的代码\nprint \"my_sum:\", (time.clock() - start) / 100.0\n\nstart = time.clock()\nfor i in xrange(100):\n    np.sum( a ) # numpy中的sum，其实现也是C语言级别\nprint \"np.sum:\", (time.clock() - start) / 100.0\n\nstart = time.clock()\nprint sum(a) # Python内部函数sum通过数组a的迭代接口访问其每个元素，因此速度很慢\nprint \"sum:\", time.clock() - start\n"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "p", "data": "可以看到用Weave编译的C语言程序比numpy自带的sum函数还要快。而Python的内部函数sum使用数组的迭代器接口进行运算，因此速度是Python语言级别的，只有Weave版本的1/300。"}, {"ctype": "p", "data": "weave.inline函数的第一个参数为需要执行的C++语言代码，第二个参数是一个列表，它告诉weave要把Python中的两个变量a和n传递给C++程序，注意我们用字符串表示变量名。converters.blitz是一个类型转换器，将numpy的数组类型转换为C++的blitz类。C++程序中的变量a不是一个数组，而是blitz类的实例，因此它使用a(i)获得其各个元素的值，而不是用a[i]。最后我们通过compiler参数告诉weave要采用gcc为C++编译器。如果你安装的是python(x,y)的话，gcc(mingw32)也一起安装好了，否则你可能需要手工安装gcc编译器或者微软的Visual C++。"}], "cate": "Python"}
{"题目": "用python实现图片批处理", "作者": "会飞的小菜鸡", "发布时间": "2021-03-27 22:43:43", "内容": [{"ctype": "p", "data": "在训练神经网络之前，我们往往需要对数据集进行批量处理。本文以图片为例，介绍如何使用python实现图片的批量处理，包括批量命名，批量更改图像像素，批量对图片进行Harris、Canny……"}, {"ctype": "p", "data": "在此通过以下示例讲解图片遍历方法，并以shi-Tomasi角点检测算法为例，对图片进行批量处理。"}, {"ctype": "p", "data": "可实现的功能： （1）遍历某一文件夹下的所有图片，示例代码针对所有.jpg格式的图片； （2）对所有图片均进行shi-Tomasi角点检测处理； （3）将处理好后的每张图片保存至新的文件夹下。"}, {"ctype": "code", "data": "import cv2\nimport numpy as np\nimport glob\nimport os\n\ndef Harris(img):\n# 1 读取图像，并转换成灰度图像\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n# 2角点检测——Shi-Tomasi\n    corners = cv2.goodFeaturesToTrack(gray,100,0.01,10)\n    corners = np.int0(corners)\n    print(len(corners))\n    for i in corners:\n        x, y = i.ravel()\n        cv2.circle(img, (x, y), 3, 255, -1)\n    return img\n# 图片批量处理\ndef pichuli():\n    nums = 1\n    for files in glob.glob(r'C:\\Users\\********\\*.jpg'):\n        img = cv2.imread(files)\n        # 输出路径\n        opfile = r'C:\\Users\\***********/'\n        # 判断opfile是否存在，不存在则创建\n        if (os.path.isdir(opfile) == False):\n            os.mkdir(opfile)\n        img = Harris(img)\n        image_path = opfile + '('+str(nums)+')'+'.jpg'\n        cv2.imwrite(image_path,img)\n        nums += 1\n    print('批处理结束')\n\nif __name__ == '__main__':\n    pichuli()\n"}], "cate": "Python"}
{"题目": "Python实验之制作一个公交车站查询系统！！！！！！（附有源代码）", "作者": "Kinght_123", "发布时间": "2021-03-28 20:03:20", "内容": [{"ctype": "head", "data": "一、设计目的"}, {"ctype": "p", "data": "1、教学目的 本课程设计是学生学习完《Python程序设计》课程后，进行的一次全面的综合训练，通过课程设计，更好地掌握使用Python语言进行程序设计的方法，加深对Python语言特点和使用Python语言进行程序设计开发过程的理解，加强动手能力。其主要目的是： （1）进一步培养学生Python程序设计的思想，加深对高级语言基本语言要素和控制结构的理解； （2）针对Python语言中的重点和难点内容进行训练，独立完成有一定工作量的程序设计任务，同时强调好的程序设计风格。 （3）掌握Python语言的编程技巧和上机调试程序的方法。 （4）掌握程序设计的常用算法。 2、教学要求 （1）要求从所给题目中任选若干个，每个学生必须独立完成课程设计，不能互相抄袭。 （2）设计完成后，对所完成的工作进行答辩。 （3&"}], "cate": "Python"}
{"题目": "数据分析Python基础", "作者": "WhiteSouls", "发布时间": "2021-03-27 18:45:50", "内容": [{"ctype": "head", "data": "数据分析Python基础"}, {"ctype": "p", "data": " 文章内容输出来源:拉钩教育数据分析训练营–直达飞机票(想了解的小伙伴)   本人为传统行业ETL,想转行数据分析,感觉自学有点困难,之前偶然接触到拉钩教育中的1元文章,都是各领域大佬的手笔,内容质量很高,刚好拉钩也有数据分析的训练营,看了看课程安排,简单咨询了下,就报名了,现在学到了数据挖掘部分,感觉Python基础的内容有些都忘了,所以特意巩固下,才写的这篇文章"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210320222701282.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY1NTcyNg==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "提示：以下是本篇文章正文内容，下面案例可供参考"}, {"ctype": "head", "data": "Python数据结构"}, {"ctype": "head", "data": "1.序列"}, {"ctype": "p", "data": "  序列是Python中最基本的一种数据结构,指的是一个可迭代的有序的集合,序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置(通过index访问),并且序列中的数据会按照添加的顺序来分配索引,然而通过序列中元素是否可以改变又分为可变序列和不可变序列."}, {"ctype": "head", "data": "1.1 不可变序列"}, {"ctype": "head", "data": "1.11 元组(tuple)"}, {"ctype": "head", "data": "①什么是元组?"}, {"ctype": "p", "data": "  元组是一种不可变的序列,正是由于元组的对象不可变性,所以没有增删改操作,元组中可以存储不同类型的对象."}, {"ctype": "head", "data": "②元组的创建"}, {"ctype": "p", "data": "操作如下:"}, {"ctype": "code", "data": "1.使用()来创建元组\nmy_tup = () # 创建了一个空元组\nprint(my_tuple,type(my_tuple))\n# result: () <class 'tuple'>\nmy_tuple = (1,2,3,4,5) # 创建了一个5个元素的元组\nprint(my_tuple,type(my_tuple))\n# result: (1, 2, 3, 4, 5) <class 'tuple'>\n2.元组是不可变对象，不能尝试为元组中的元素重新赋值\nmy_tuple[3] = 10  #注:体现了元组元素一旦添加不可修改\n# result: TypeError: 'tuple' object does not support item assignment \n3.当元组不是空元组时，括号可以省略\nmy_tuple = 5,2,0\nprint(my_tuple,type(my_tuple))\n# result: (5, 2, 0) <class 'tuple'>\n#注意但当元组中只有一个元素时候必须在元素后加个',',否则识别为原元素的数据类型(加不加括号都可以)\nmy_typle =(40)\ntype(my_typle)\n# result: int  注:结果为int类型,也就是40的类型\n#正确写法\nmy_tuple = 40,  #等价于my_tuple = (40,)\ntype(my_typle)\n# result: tuple 注:此时的my_tuple才是真正的元组\n4.元组的解包（解构）\n# 解包可以理解为就是将元组当中每一个元素都赋值给一个变量\nmy_typle = 4,False,28,'a'\na,b,c,d = my_tuple\nprint(a,b,c,d)\n# result: 4 False 28 a\n5.交互a 和 b的值，这时我们就可以利用元组的解包(相当方便)\n#交换前\na = 5\nb = 8\nprint(a,b)\n# result: 5 8\na , b = b , a\n#交换后\nprint(a , b)\n# result:8 5\n6.在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致\nmy_tuple = 10 , 20 , 30 , 40\nm,n,x,y = my_tuple\nprint(m,n,x,y) \n# result: 10 20 30 40\n# 也可以在变量前边添加一个*，这样变量将会获取元组中所有剩余的元素\nmy_tuple = 1,2,3,4,5,6\na , b , *c = my_tuple\nprint(a,b,c)\n#result: 1 2 [3, 4, 5, 6] 注:[3, 4, 5, 6] 部分为列表(list)后面会讲到\na , *b , c = my_tuple\nprint(a,b,c)\n# result: 1 [2, 3, 4, 5] 6\na , b , *c = 'hello world'\nprint(a,b,c)\n# result: h e ['l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']\n# 不能同时出现两个或以上的*变量\n*a , *b , c = 'hello world'   #两个'*'导致系统不会分配了,怕分不均打起来,它也是个老好人...\n# result: SyntaxError: two starred expressions in assignmenta 注:结果报错                  \n"}, {"ctype": "head", "data": "③元组的CRUD"}, {"ctype": "p", "data": "(由于元组中元素不可变,所以就没有增删改操作,只有查询操作)"}, {"ctype": "code", "data": "1.前面提到元组属于序列,序列的通性就有可以通过索引来访问序列中的元素(tuple,list,str)后面会陆续讲到,而且第一个元素的索引为0,最后一个元素索引为-1\nmy_tuple = (1,'str',False,7.8,None)\nprint(my_tuple[3],my_tuple[0]) #访问元组中第一个元素和第四个元素\n# result: 7.8 1 \n# 访问最后一个元素\nprint(my_tuple[-1])\n# result: None\n2.突然想呼应下元组元素不可修改,真的吗?有'bug'? come to see see \nmy_tuple = (1,[2,'str',False],'hello')\n#操作1\nmy_tuple[0] = 'wahaha'  #哦哦!第一个元素的确不可修改\n# result: 'tuple' object does not support item assignment\n#操作2\nmy_tuple[1][0] = 'bug'\nprint(my_tuple)\n# result: (1, ['bug', 'str', False], 'hello') 注:what fu** ? 啥子情况哟?说好一百年不许变呢?\n#看一下 my_tuple 中第二个元素[2,'str',False] 在修改前后变化\nmy_tuple = (1,[2,'str',False],'hello')\n#修改前:id()函数:打印对象在内存中的地址,id值相同就为同一个对象\nprint(my_tuple,type(my_tuple[1]),id(my_tuple[1]))\n# result: (1, [2, 'str', False], 'hello') <class 'list'> 2595153146560\n#修改后:\nmy_tuple[1][0] = 'bug'\nprint(my_tuple,type(my_tuple[1]),id(my_tuple[1]))\n# result:(1, ['bug', 'str', False], 'hello') <class 'list'> 2595153146560\n'''可以看出my_tuple的第一个元素(也就是[]整体)的地址2595153146560是没变的,变化的是元素中的元素变了,这是由于[2, 'str', False]是列表,my_tuple[1][0] = 'bug'操作是将列表[2, 'str', False]中的第一个元素2给修改成了'bug',而list本身是可变的,也就是list修改元素后,原list的地址是不变的,所以再回到元组中\n元素不可变的说法是没问题的'''\n#也可以如下尝试,尝试将[2,'str',False]整体进行修改\nmy_tuple[1] = 'bug'  #再次验证tuple的元素不可变\n# result: 'tuple' object does not support item assignment\n"}, {"ctype": "head", "data": "④元组的遍历"}, {"ctype": "p", "data": "什么是遍历? 个人理解为就是将对象中所有元素都拿出来瞧瞧"}, {"ctype": "code", "data": "#遍历元组\n1.方式一:for\nmy_tuple = ('a',True,None,1.0,5)\nfor i in my_tuple:\n    print(i, end = ' ') #注:print(end=' ')将末尾默认字符修改为空格,默认为换行符\n# result: a True None 1.0 5 注:遍历就是将元组中所有元素获取一遍 \n\n2.方式二: while\nmy_tuple = ('a',True,None,1.0,5)\ni = 0\nwhile i < len(my_tuple): #相当于java中length\n    print(my_tuple[i],end=' ')\n    i+=1\n# result: a True None 1.0 5 \n\n3.方式三:range()\nmy_tuple = ('a',True,None,1.0,5)\nfor i in range(len(my_tuple)):\n    print(my_tuple[i],end=' ')\n    i+=1\n# result : a True None 1.0 5  注意:熟练一种即可(哪个舒服就用哪个)\n"}, {"ctype": "head", "data": "⑤元组的常用函数"}, {"ctype": "p", "data": "说明:如何查看对象的自带方法(dir)有哪些以及方法如何使用(help)"}, {"ctype": "code", "data": "1.查看对象拥有哪些自带方法(dir)\ndir(tuple)  --查看元组有哪些自带方法(查看其他对象同理)\n''' result: ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', \n'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', \n'__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', \n'__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', \n'__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index'] \n注:我是小白,所以也就关注前后不带'_'的方法玩一玩了,这一看就剩count,和index方法了 '''\n2.每个方法如何使用(help)\n这里以元组的count()方法为例\nhelp(tuple.count)  #查看元组的count方法如何使用(以后学习一个新方法时使用)\n# result: Help on method_descriptor:\n#count(self, value, /) 注:简单看就是查看目标字符在对象中的个数\n#   Return number of occurrences of value. \n下面介绍下这两个方法的使用\n1)count():统计出现次数\nmy_tuple = ('a','b','c','c','c','a',1,1,2)\nprint(my_tuple.count('a')) \n# result: 2   注:元组中有2个'a'\nmy_tuple.count(1)\n# result: 2   注:元组中有2个1\n2)index():查询元素第一次出现的位置,脾气暴躁(找不到就生气)\nmy_tuple = ('a','b','c','c','c','a',1,1,2)\nmy_tuple.index('b') \n# result: 1   注:字符'b'第一次出现的索引为1\nprint(my_tuple.index(1)) \n# result: 6   注:数字1第一次出现的索引为6(虽然7位置也有1但是结果为第一次的位置)\n#找不到就生气()报错\nmy_tuple = ('a','b','c','c','c','a',1,1,2)\nmy_tuple.index('lagou')\n# result: ValueError: tuple.index(x): x not in tuple 注:当前元组没有此元素\n3) in /not in 判断元组中是否包含某个元素\nmy_tuple = ('a','b','c','c','c','a',1,1,2)\n'a' in my_tuple\n# result: True\n'lagou' in my_tuple\n# result: False\n'lagou' not in my_tuple\n# result: True\n4)sum(),如果元组中元素都为int或float,可以sum()直接求和 注:sum()为python自带函数\nmy_tuple = 1,2,3,4,5,3.7\nsum(my_tuple) \n# result: 18.7\n"}, {"ctype": "head", "data": "⑥练习"}, {"ctype": "code", "data": "说明,sales中每个元组为一个销售员的姓名以及第一季度(1,2,3月)的业绩\n需求:求出一季度销冠(名字以及一季度业绩)\nsales = (\n    (\"Peter\", (78, 70, 65)),\n    (\"John\", (88, 80, 85)),\n    (\"Tony\", (90, 99, 95)),\n    (\"Henry\", (80, 70, 55)),\n    (\"Mike\", (95, 90, 95))\n)\n#1.精简前\nchampion = '' #销冠名字初始化为''\nmax = 0       #一季度最高销售额,初始化为0\nfor sale in sales: #遍历\n    name = sale[0] #取出名字\n    quarter = sale[1] #取出一季度(1,2,3月)业绩\n    quarter_sales = 0 #季度总销售额\n    for month_sales in quarter: #遍历每个人的一季度每个月的业绩\n        quarter_sales += month_sales #对一季度每个月业绩加和\n        if quarter_sales > max: #将所有销售员季度总和算出取最大的\n            champion = name  #销冠姓名\n            max = quarter_sales  #销冠季度业绩\nprint('第一季度的销售冠军是{0},总销售额为{1}万元'.format(champion,max))\n# result: 第一季度的销售冠军是Tony,总销售额为284万元\n\n# 2.精简后,简直不要太爽(代码精简)\nchampion = ''\nmax = 0\nfor name,quarter in sales:  #这种写法可以回想元组的解包,(\"Peter\", (78, 70, 65))中的Perter 赋值给name,(78, 70, 65)赋值给quarter\n    total = sum(quarter) #直接将一季度业绩(78, 70, 65)求和\n    if total > max:\n        max,champion = total,name  #解包赋值\nprint('第一季度的销售冠军是{0},总销售额为{1}万元'.format(champion,max))\n# result: 第一季度的销售冠军是Tony,总销售额为284万元\n"}, {"ctype": "head", "data": "1.12 字符串(str)"}, {"ctype": "head", "data": "①什么是字符串?"}, {"ctype": "p", "data": "  字符串其实也是一种序列，可以理解为一串整齐的按顺序排着队的字符，组成了字符串，那每个字符在队伍中都有自己的位置，这个位置就是下标，又叫作索引。"}, {"ctype": "head", "data": "②字符串的创建"}, {"ctype": "p", "data": "  还记得学习Python运行的第一个程序,也是学习每种编程语言的第一个程序,对,没错,打印hello world! 它就是个字符串.   操作如下:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327001330191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY1NTcyNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "1.创建字符串(用单引号''或者双引号\"\"都可以,没什么区别)\nmy_str = 'I love Python'\nprint(my_str,type(my_str))\n# result: I love Python <class 'str'>\nmy_str1 = \"good good study\"\nprint(my_str1,type(my_str1))  #看个人习惯,我比较习惯单引号\n# result: good good study <class 'str'>\n2.三引号(将一大段内容原样输出) --来自某道翻译,不要见怪\nmotto = '''   #注三引号可以是单引号,也可以是双引号\nWhere there is a will there is a way,\nburn one's Bridges, \nthe twelve Qin pass finally belongs to Chu; \nHard days, \nthree thousand more can swallow wu \n'''\n# result:   print(motto)  #原样输出\n#  \t\t\tWhere there is a will there is a way,\n#   \t\tburn one's Bridges, \n#   \t\tthe twelve Qin pass finally belongs to Chu; \n#   \t\tHard days, \n#   \t\tthree thousand more can swallow wu \n3.有时候定义的字符串太长一行放不下,用'\\'进行连接\nstory = 'this is a  long long long long long \\\nstory,a very very very ......' #虽然看着换行了但结果还是一行\nprint(story)\n#result: this is a  long long long long long story,a very very very ......\n"}, {"ctype": "head", "data": "③常用函数及操作"}, {"ctype": "p", "data": "1.字符串的格式化输出 1)格式化占位符"}, {"ctype": "table", "data": "占位符描述%d整数占位符%f浮点数占位符%.f指定精度的浮点数占位符%s字符串占位符%%输出百分号%"}, {"ctype": "p", "data": " 操作如下:"}, {"ctype": "code", "data": "1.%d (整数占位符)\nprint('北上广数据分析师的平均薪资为%dK'% 20) 注:后面%后的20在输出时就替代了前面的%d,使得输出更加灵活\n# result: 北上广数据分析师的平均薪资为20K\n如果给%d 传入一个浮点数，那它会自动将它转换成整数(截断而不是四舍五入)\nprint('%d' % 3.1415926) \n# result: 3\nprint('%d' % 3.9999999)\n# resutl: 3\n2.%f(浮点数占位符)、%.f(指定精度的浮点数占位符)\n1)%f\nprint('%f' % 3.14)\n# result: 3.140000 自动补0\n2)%.f 限定小数位数\nprint('%.2f' % 3.14)\n# result: 3.14\nprint('%.2f' % 3.1415926)\n# result: 3.14\nprint('%.4f' % 3.14)\n# result: 3.1400\n上面的两行代码输出都是\"3.14\"，\"%.2f\" 这种写法指定了小数点后面的位数，即使浮点数后面的小数部\n分超出了2位,也只会输出两位。如果不足位,自动补零到两位,如第三个。\n3.%s是使用最广泛的占位符，它可以对应任何类型的变量\nprint('%s' % 100) \n# resutl: 100\nprint('%s' % 3.14) \n# resutl: 3.14\nprint('%s' % \"python\") \n# resutl: python\n4.一个字符串中也可以出现多个占位符\nreport = '%d年%s公司营收增长了百分之%.2f' % (2088, \"哆音\", 28.28)\nprint(report)\n# result: 2088年哆音公司营收增长了百分之20.28\n5.%% 输出百分号%\nreport = '%d年%s公司营收增长了%.2f%%' % (2088, \"哆音\", 28.28)\nprint(report)\n# result: 2088年哆音公司营收增长了28.28%\n"}, {"ctype": "p", "data": "format函数(实现%相同功能)"}, {"ctype": "code", "data": "report = '{0}年{1}公司营收增长了{2}%'.format(2088, '哆音', 28.28)\nprint(report) #{0},{1},{2},三个参数分别对应(2088, '哆音', 28.28),\n# result: 2088年哆音公司营收增长了28.28%\n#这样做的好处是如果有参数在字符串出现多次，可以不用重复的传入\n#例如:\nreport = '{0}的GDP为{1}...虽然它的GDP只有{1}美元，但它的人均GDP高达18万美元'.format(\"摩纳哥\",7100000000)\nprint(report)\n# result: 摩纳哥的GDP为7100000000...虽然它的GDP只有7100000000美元，但它的人均GDP高达18万美元\n"}, {"ctype": "p", "data": "2.字符串的索引及切片 1)字符串的索引(序列的索引都一样) 正向从0开始,反向从-1开始   操作如下:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032300124537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY1NTcyNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "1.通过索引访问各个字符\nmy_str = 'CHINA'\nmy_str[0] #访问第一个字符\n# result: 'C'\nmy_str[-1] #访问最后一个字符\n# result: 'A'\n2.遍历\nmy_str1 = [ i for i in my_str] #遍历\n# result: ['C', 'H', 'I', 'N', 'A']\n#可以通过join方法将列表拼接回字符串\nmy_str2 = ''.join(my_str1)  #通过''拼接\n# result: 'CHINA'\n"}, {"ctype": "p", "data": "2)字符串的切片(序列的特性) 字符串的切片是基于其索引特点,语法为 str[start :end :step ]"}, {"ctype": "code", "data": "str[start:end:step] #参数说明 start:起始索引,end:结束索引,step:步长 注:[start,end),左闭右开区间\nstr1 = 'I LOVE CHINA'\nstr1[0:5:2] \n# result: 'ILV'\nstr1[1:4] # 注:当只写一个':'时默认':'前后代表start和end,步长默认为1\n# result: ' LO'\nstr1[:5]  # 注:start缺省时默认从头开始(也就是0开始)\n# result: 'I LOV'\nstr1[2:]  #注:end缺省时默认一直取到字符串的最后一个字符\n# result: 'LOVE CHINA'\nstr1[2:-1] # 取不到最后一个字符(左闭右开)\n# result: 'LOVE CHIN'\nstr1[:] #或者str1[::] 结果一样 都是取整个字符串\n# result: 'I LOVE CHINA'\n#当step为负数可以理解为将字符串按从右向左取值\nstr1[::-2]  #从右往左每隔一个取一个\n# result: 'AICEO '\nstr1[::-1]  #相当于逆序输入整个字符串\n# result: 'ANIHC EVOL I'\n"}, {"ctype": "p", "data": "3.字符串其他函数 1)去除空白字符函数(strip())"}, {"ctype": "code", "data": "先来了解一下什么是空白字符，空白符包括空格、换行（\\n）、制表符（\\t）\nprint(\"A\\tB C\\nD\\tE F\")\n# result:  A\tB C\n#          D\tE F\n#按键盘上的空格键会产生一个空格，按回车键则会产生一个换行符，按Tab键则会产生一个制表符，用户在输入数据的时候有时候经常会误输入这几个字符，\n1.所以在在处理用户输入的数据时，要先去除头尾的空白字符。\npsword = 'enterlagou'\ninput_psword = ' enterlagou' #手误密码前输入一个空格\nprint(psword == input_psword )\n# result: False\n此时就需要将空格去掉\npsword = 'enterlagou'\ninput_psword = ' enterlagou' #手误密码前输入一个空格\nprint(psword == input_psword.strip()) #strip()函数将字符串的首尾空格去掉\n# result: True\n#例如:\nstr1 = ' good good study,day day up ' #首尾各一个空格\nstr2 = 'good good study,day day up'\nprint(str1==str2,str1.strip() == str2)\n# result: False True\n2.strip(),还有lstrip(),rstrip()分别表示从首部、尾去除空格\nstr1 = ' Cheer Up '\nprint(str1.lstrip(),'---',str1.rstrip())\n# result: 'Cheer Up '---' Cheer Up' \n"}, {"ctype": "p", "data": "2)字符串大小写"}, {"ctype": "code", "data": "1.所有字符变大写(upper())\nmy_dream = 'I want to be the boss'\nprint(my_dream.upper())\n# result: I WANT TO BE THE BOSS\n2.所有字符变小写(lower())\nmy_dream = 'I want to be the boss'\nprint(my_dream.lower())\n# result: i want to be the boss\n3.字符串的首字母大写(capitalize())\nstr.capitalize('i am chinese')\n# result: 'I am chinese'\n4.字符串中每个单词首字母大写(title())\nstr.title('go to school by bus')\n# result: 'Go To School By Bus'\n"}, {"ctype": "p", "data": "3)字符串其他方法"}, {"ctype": "code", "data": "1.startswith(value,start,end): 在[start,end)范围内,是否以指定的字符串开头\nstr1 = 'Lagou Education'\nstr1.startswith('Lagou ',0,-1) \n# result: True\n2.endswith(value,start,end) 在[start,end)范围内,是否以指定的字符串结尾\nstr1 = 'Lagou Education'\nstr1.endswith('ion')\n# result: True\n3.isdigit() 判断字符串中字符是否都是数字\n'89757'.isdigit()\n# result: True\n4.isalpha() 判断字符串中字符是否都是英文字母(不分大小写)  \n'Thebestwaytosucceedistolearn'.isalpha()\n# result: True\n5.join() 将指定字符串与目标对象进行拼接,返回一个新字符串\n'-'.join(['one','two','three'])\n# result: 'one-two-three'\n6.islower() 判断对象中字母是否为小写字母\n't hebest-waytosucceedistolearn'.islower()  #注意只对对象中的字母进行判断\n# result: True\n7.isupper() 判断对象中字母是否为大写字母\n'T HEBEST-WAYTOSUCCEEDISTOLEARN'.isupper()  #同样只对对象中的字母进行判断\n# result: True\n8.find(value,start,end)  在[start,end)区间中查找第一次出现的字符串的索引位置(查询不到返回-1)\n'The best way to succeed is to learn'.find('succeed')\n# result: 16\n'The best way to succeed is to learn'.find('fail') \n# result: -1      #查询不到返回-1\n9.index(value,start,end)  在[start,end)区间中查找第一次出现的字符串的索引位置(查询不到报错)\n'helloworld'.index('o')  \n# result: 4\n'helloworld'.index('ab')  #查询不要就报错\n# result: ValueError: substring not found\n10.count(value,start,end) 统计指定字符在对象中[start,end)区间出现的次数\n'helloworld'.count('l')\n# result: 3\n11.replace(self, old, new, count) 在对象中将old值替换为new值,count 替换几次\n'in a big big world'.replace('big','small',1)  #将对象中big替换为small并且值替换一个\n# result: 'in a small big world'  结果看出第二个big并没有被替换,count默认-1,替换所有old值\n'in a big big world'.replace('big','small')\n# result: 'in a small small world' 都被替换\n12.split() 按指定字符拆分字符串   返回值结果为list类型\n'Time will dilute everything'.split()  #默认按空格进行拆分\n# result: ['Time', 'will', 'dilute', 'everything']  \n'Time will dilute everything'.split('e') # 按'e'进行拆分\n# result: ['Tim', ' will dilut', ' ', 'v', 'rything']\n13.len() 计算对象的长度(系统函数)\n#它不光可以测量字符串的长度，也可以测量其他所有有长度的对象\nlen('CHINA') #字符串有几个字符\n# result: 5\nlen((1,'2','three')) #元组有几个元素\nlen([1,'2','three']) #列表有几个元素\nlen({1,'2','three'}) #集合有几个元素\nlen({'num':1,'id':'2','age':'three'}) #字典有几个键值对\n# result: 3\n14.in /not in 指定字符串在不在对象中\n'lagou' in 'lagou Education'\n# result: True\n'Education' not in 'lagou Education'\n# result: False\n15.==/!= 判断两字符串元素是否完全相同\nstr1 = 'Real and fake Monkey King'\nstr2 = 'Real and fake Monkey King'\nstr1 == str2\n# result: True\n'True' != 'False'\n# result: True\n16.is / not is 是否是同一个对象(id值相同就是同一个对象)\nstr1 = 'Ilovepython'\nstr2 = 'Ilovepython'\nprint('值是否相等:{0},id值是否相等:{1},是否为同一对象:{2}'\n      .format(str1==str2,id(str1)==id(str2),str1 is str2))\n# result: 值是否相等:True,id值是否相等:True,是否为同一对象:True  \n# 注:发现字符串值相等的时候是同一个对象,回想下其他对象好像不是这样 \n#测试元组\ntup1 = (1,2,3)\ntup2 = (1,2,3)\nprint('值是否相等:{0},id值是否相等:{1},是否为同一对象:{2}'\n      .format(tup1==tup2,id(tup1)==id(tup2),tup1 is tup2))\n# result: 值是否相等:True,id值是否相等:False,是否为同一对象:False\n#测试列表\nlst1 = [1,2,3]\nlst2 = [1,2,3]\nprint('值是否相等:{0},id值是否相等:{1},是否为同一对象:{2}'\n      .format(lst1==lst2,id(lst1)==id(lst2),lst1 is lst2)) \n# result: 值是否相等:True,id值是否相等:False,是否为同一对象:False      \n#测试集合\nset1 = {1,2,3}\nset2 = {1,2,3}\nprint('值是否相等:{0},id值是否相等:{1},是否为同一对象:{2}'\n      .format(set1==set2,id(set1)==id(set2),set1 is set2))  \n# result: 值是否相等:True,id值是否相等:False,是否为同一对象:False       \n#测试字典\ndic1 = {1,2,3}\ndic2 = {1,2,3}\nprint('值是否相等:{0},id值是否相等:{1},是否为同一对象:{2}'\n      .format(dic1==dic2,id(dic1)==id(dic2),dic1 is dic2))  \n# result: 值是否相等:True,id值是否相等:False,是否为同一对象:False\n发现元组,列表,集合,字典在元素值相同时不是一个对象,同时字符串相同元素时是同一对象是有前提的\n例如:\nstr1 = 'I love python' \nstr2 = 'I love python'     \nprint('值是否相等:{0},id值是否相等:{1},是否为同一对象:{2}'\n      .format(str1==str2,id(str1)==id(str2),str1 is str2))   #发现此时元素相同又不是同一对象了\n# result: # result: 值是否相等:True,id值是否相等:False,是否为同一对象:False\n从一个公众号(数据分析与统计学之美公众号中)了解到\nPython支持字符串驻留机制:也就是对于符合标识符的字符串(符合标识符:仅仅包含下划线,字母,数字),\n才会启用字符串驻留机制,即不同的变量用同一份相同且不可变的字符串(打个比方:好比一家卖鞋的线下门店,\n某种鞋子,41码大小的只剩下一双,所以就导致了所有想要试穿41码的这种鞋的顾客试的都是这一双鞋)\nstr1 = '_88level_'  #符合标识符的字符串\nstr2 = '_88level_'\nstr1 is str2\n# result: True\nstr1 = '_88level _'  #不符合标识符的字符串(有个空格)\nstr2 = '_88level _'\nstr1 is str2\n# result: False  不知道我是否表达明白了呢?\n"}, {"ctype": "head", "data": "⑥练习"}, {"ctype": "p", "data": "  结合以上的字符操作知识，我们练习一个电话号码识别程序，用户输入一串数字，程序识别它是不是一个有效的电话号码，如果是有效电话号码，我们再识别它是一个固定电话号码、手机号码、还是400号码。用户输入’exit’后，程序退出. 已知: 手机号:前两位为 13,15,17,18,19 并且总位数为11位 固定电话:区号+号码,并且假设区号只有010、021、022、025、0888、0555这几种,号码为8位,也就是座机号总位数为11位或12位 广告电话:这个特征很明显，以400开头，共10位 实现代码如下："}, {"ctype": "code", "data": "cellphone_number_start = \"13,15,17,18,19\"  #手机号\ntelephone_number_start = \"010,021,022,025,0888,0555\" #座机区号\nwhile True:\n    num = input(\"请输入一个电话号码: \\n\")\n    num = num.strip() #首尾空格去掉\n    if num.strip() == 'exit': \n        break\n    if not num:\n        print(\"电话号码不能为空\")\n        continue\n    if not num.isdigit():\n        print(\"您输入的是一个无效电话号码\")\n        continue\n    if num.startswith('1') and len(num) == 11 and num[0:2] in cellphone_number_start:\n        print(\"这是一个手机号码\")\n        continue\n    elif num.startswith('400') and len(num) == 10:\n        print(\"这是一个广告电话\")\n        continue\n    elif num.startswith(\"0\"):\n        if (len(num) == 12 and num[0:4] in telephone_number_start) or(len(num) == 11 and num[0:3] in telephone_number_start):\n            print(\"这是一个固定电话\")\n            continue\n    print(\"无法识别该号码\")\n"}, {"ctype": "head", "data": "1.2 可变序列"}, {"ctype": "head", "data": "1.21 列表(list)"}, {"ctype": "head", "data": "①什么是列表?"}, {"ctype": "p", "data": "  列表就是一个可变对象,可以理解为可变的元组,元素可以重复,可以存储任意类型对象,由于可变性,所以相对于元组来说,列表就多了增加、修改、删除元素的操作."}, {"ctype": "head", "data": "②列表的创建"}, {"ctype": "p", "data": " 代码如下:"}, {"ctype": "code", "data": "1.创建列表\n1.1 空列表\nlst = []  # []\nlst = list() \nprint(lst,type(lst))\n# result: [] <class 'list'>\n1.2 定义带有初始值的列表\nlst = [1, 2, 3] \n# result: [1, 2, 3] <class 'list'>\nlst = [\"a\", 1, 2, 3, \"b\", \"c\"] \n# result:  ['a', 1, 2, 3, 'b', 'c'] <class 'list'>\nlst = list(range(5)) \n# result: [0, 1, 2, 3, 4] <class 'list'>\nlst = list(\"abc\") #字符串转为list\n# result: ['a', 'b', 'c'] <class 'list'>\nlst = list((1, 2, 3))  #元组转list\n# result: [1, 2, 3] <class 'list'>\n"}, {"ctype": "head", "data": "③列表的CRUD"}, {"ctype": "p", "data": "代码如下:"}, {"ctype": "code", "data": "1.查询元素，与元组类似，可以通过索引或切片访问\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\nprint(my_list[2]) \n# result: 孙悟空\n# 切片[start:end:step] start:开始位置(默认索引为0),end(结束位置),step:步长,也就是从start位置开始,到end的前一位(注意不包括索引为end这一位,左闭右开),每隔step取一个元素\nprint(my_list[1:3])\n# result: ['唐僧', '孙悟空'] 注:从第二位开始取两位,索引为3的沙悟净娶不到(左闭右开)\n2.增,添加到列表末尾,每次只能添加一个\n#前面提到过list元素可变,修改前后地址不变在此再验证下\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\n#修改前\nprint(my_list,id(my_list))\n# result: ['猪八戒', '唐僧', '孙悟空', '沙悟净', '白龙马'] 1544579856000\nmy_list.append('蜘蛛精') \n#修改后(修改前后list内存地址不变)\n# result: ['猪八戒', '唐僧', '孙悟空', '沙悟净', '白龙马', '蜘蛛精'] 1544579856000  \n2.1 要想一次添加多个，用extend\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\nmy_list.extend(['蜘蛛精','蝎子精']) \n# result: ['猪八戒', '唐僧', '孙悟空', '沙悟净', '白龙马', '蜘蛛精', '蝎子精']\n3.删除元素\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\n#开除白龙马\ndel my_list[4] #按照索引位置进行删除\n# result: ['猪八戒', '唐僧', '孙悟空', '沙悟净']\ndel my_list #如果不加索引的这种写法,就会将my_list这个列表对象删除,打印my_list会提示对象未定义,因为已经被整体删除\nprint(my_list)\n# result: NameError: name 'my_list' is not defined\n4.修改元素,与查询类似直接通过索引修改\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\nmy_list[4] = '黑龙驴'  #新物种诞生\n# result: ['猪八戒', '唐僧', '孙悟空', '沙悟净', '黑龙驴']\n"}, {"ctype": "head", "data": "④列表的遍历"}, {"ctype": "p", "data": "遍历与元组相同"}, {"ctype": "code", "data": "#遍历：\nmy_list =  ['魔礼海', '魔礼青', '魔礼寿', '魔礼红']\n1.通过while循环来遍历列表\ni = 0\nwhile i < len(my_list):\n    print(my_list[i])\n    i += 1\n2.通过for循环来遍历列表\n# 语法：\nfor i in my_list :\n      print(i)\n"}, {"ctype": "head", "data": "⑤常用函数"}, {"ctype": "code", "data": "# 列表函数 与tuple一样，list也有index和count函数和支持len，不在赘述\n1.insert()，区别于append()的是，insert可以指定位置插入\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\n#在第一个位置插入\nmy_list.insert(0,'女儿国国王') \n# result: ['女儿国国王', '猪八戒', '唐僧', '孙悟空', '沙悟净', '白龙马']\n#在最后位置插入，注意不是拼接到最后,相当于插入到倒数第二个位置(还记得-1是最后一个位置吗?)\nmy_list.insert(-1,'蜘蛛精') \n# result: ['女儿国国王', '猪八戒', '唐僧', '孙悟空', '沙悟净', '蜘蛛精', '白龙马']\n2.pop(),不加参数则从列表尾部开始删除一个元素，并返回被删除的元素值，\n#加参数，相当于将指定位置的元素删除并返回被删除的元素值\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\n#默认不加参数，删除白龙马并返回白龙马\ndel_user = my_list.pop()\nprint(del_user,my_list) \n# result: 白龙马 ['猪八戒', '唐僧', '孙悟空', '沙悟净']\n#加参数pop\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\ndel_user = my_list.pop(1)\nprint(del_user,my_list)\n# result:  唐僧  ['猪八戒', '孙悟空', '沙悟净', '白龙马']\n3.remove()：通过匹配值来删除元素，前面的del 是通过索引删除元素，\n# remove从左至右找到与指定的值相匹配的第一个元素，并将它删除\nmy_list = ['猪八戒','猪八戒','唐僧','孙悟空','沙悟净','白龙马']\nmy_list.remove('猪八戒')\n#可以看到，尽管有两个猪八戒，但是remove只删除了从左到右的第一个猪八戒\nprint(my_list) \n# result: ['猪八戒', '唐僧', '孙悟空', '沙悟净', '白龙马']\n4.clear()清空列表中所有元素(与del my_list不同的是clear清空元素,my_list还在,只不过里面没有元素了,而del my_list直接将其在内存中删除)\nmy_list = ['猪八戒','唐僧','孙悟空','沙悟净','白龙马']\nmy_list.clear()\nprint(my_list) \n# result: [] 注:没有任何元素的空列表\n5.reverse()，列表反转(与原来顺序相反)\nmy_list = [1,2,3,4,5]\nmy_list.reverse()\nprint(my_list) \n# result: [5, 4, 3, 2, 1]\n6.sort(),将列表中元素排序(按照元素的ASCII码值升序排序）\nmy_list = [5,2,6,1,7]\nmy_list.sort()\nprint(my_list) \n# result: [1, 2, 5, 6, 7]\n# 如果对字符串进行排序，比对每个字符串的第一个字符，\n# 如果第一个字符相同，则比对第二个字符，以此类推\nfruits = ['apple', 'banana', 'orange', 'blueberry']\nfruits.sort()\nprint(fruits)  \n# result: ['apple', 'banana', 'blueberry', 'orange']\n#降序排序\nmy_list.sort(reverse= True)\nprint(my_list) \n# result: [7, 6, 5, 2, 1]\n7.内置函数ord()：将字符转换成对应的ASCII码值\n         chr()：ASCII码值转成对应的字符\nprint(ord('A')) \n# result: 65\nprint(chr(97))  \n# result: a\n8.copy():顾名思义，复制列表\nmy_list = ['魔礼海','魔礼青','魔礼寿','魔礼红']\nprint(my_list) \n# result: ['魔礼海', '魔礼青', '魔礼寿', '魔礼红']\nmy_list1 = my_list.copy()\nmy_list1.append('托塔李天王')\nprint(my_list1,my_list,sep = '---') \n# result: ['魔礼海', '魔礼青', '魔礼寿', '魔礼红', '托塔李天王']---['魔礼海', '魔礼青', '魔礼寿', '魔礼红']\n#可以看出对复制的my_list1进行操作时，不影响原来的my_list\n#可以认为就是复制一份给my_list1,对这个备份进行任何操作都不影响原列表my_list\n9.+ 和 *(千万注意,'+'和'*'操作后是生成一个新列表)\nlst1 = ['魑','魅']\nlst2 = ['魍','魉'] \nprint(id(lst1),id(lst2))\nlst3 = lst1 + lst2\nprint(id(lst3))  #看出lst3的地址与lst1和lst2都不同,'*'同理便不再验证\n# result: 1544576981568 1544577003072\n#         1544574292608\n# +可以将两个列表拼接为一个列表\nmy_list = [1,2,3] + [4,5,6]\nprint(my_list) \n# result: [1, 2, 3, 4, 5, 6]\n# * 可以将列表重复指定的次数\nmy_list = [1,2,3] * 5\nprint(my_list) \n# result: [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\n10.in 和 not in(判断指定元素是在/不在列表中)\nmy_list = ['魔礼海','魔礼青','魔礼寿','魔礼红']\nprint('王二小' not in my_list) \n# result:True\nprint('王二小' in my_list) \n# result: Fales\nprint('魔礼红' in my_list) \n# result: True\n11.附加可变对象\n# 可变对象\na = [1,2,3]\nprint('原列表：', a , id(a))     \n# result: [1, 2, 3] 1940966477056\n#修改元素，不会改变对象地址，只是将这个对象中的value修改了\na[0] = 10\nprint('修改元素后：', a , id(a)) \n# result: [10, 2, 3] 1940966477056\n#重新赋值相当于在内存中重新创建个对象，所以id(a)会改变\na = [4,5,6]\nprint('重新赋值后：', a , id(a)) \n# result: [4, 5, 6] 1940966776576  注:发现地址变了\n#再例如\na = [1,2,3]\n#将变量a指向的地址也指向变量b\nb = a\nb[0] = 10\n#修改b中元素，a中也被修改，因为a和b指向同一个地址\n#可以理解为a为在PC上面的一个文档a.txt,那么b就是a.txt的一个快捷方式,无论修改哪个,都是同步修改的\nprint(\"a\",a,id(a)) #a [10, 2, 3] 1985547734272\nprint(\"b\",b,id(b)) #b [10, 2, 3] 1985547734272\n# 判断对象\n# == != 比较的是对象的值是否相等(包含的元素是否完全相同) \n# is is not 比较的是对象的id是否相等（比较两个对象是否是同一个对象）\na = [1,2,3]\nb = [1,2,3]\nprint(a,b) \n# result: [1, 2, 3] [1, 2, 3]\nprint('a:',id(a),'-----','b:',id(b)) \n# result: a: 1985552309888 ----- b: 198555230995\nprint(a == b) \n# result:  True,值相等\nprint(a is b) \n# result:   False,值虽相等但不是一个对象\n#此时的列表a和b可以理解为:北京的故宫太和殿和华西村故宫太和殿,可以说一模一样(认为一模一样),但是一个在北京,一个在江苏\n"}, {"ctype": "head", "data": "⑥列表推导式"}, {"ctype": "p", "data": "列表推导式是一种快捷的创建列表的表达式，可以将多行代码省略为一行(很好用)"}, {"ctype": "code", "data": "# 列表表达式，多行代码简化成一行，非常酸爽\n#需求： 求20以内偶数\n1.常规写法：range(start,end,step)\nmy_list = []\nfor i in range(20):\n    if i % 2 == 0:\n        my_list.append(i)\nprint(my_list) \n# result: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n2.1.用列表表达式（是不是超级爽）\nmy_list = [i * 2 for i in range(10)]\n2.2或者\nmy_list = [ i for i in range(0,20,2)]\nprint(my_list) \n# result : [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n例子2：快速打印26英文字母 (a:97)\nmy_list = [ chr(i) for i in range(97,97+26)] #chr():将ASCII码-->对应字符\nprint(my_list)\n# result: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', \n#         'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n3.含if的列表推导式\n#语法: [ value for i in x if ×××] 解释:先进入for循环,然后如果×××为真,则返回value\nlst1 = list(range(21))\nlst = [i for i in lst1 if i%2 == 1] #打印20以内所有奇数\nprint(lst) \n# result: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n4.含if...else...的列表表达式\n#语法: [value if...else...for i in y]\nlst1 = list(range(21))\nlst = [ i if i%2 == 1 else 0 for i in lst1] #20以内遇到奇数原样输出,偶数置为0\n# result: [0, 1, 0, 3, 0, 5, 0, 7, 0, 9, 0, 11, 0, 13, 0, 15, 0, 17, 0, 19, 0]\n"}, {"ctype": "head", "data": "⑦练习"}, {"ctype": "code", "data": "#是否还记得这个销冠case,说明：sales中代表每个销售员姓名以一季度（1，2，3月）的业绩\n# 需求：按一季度业绩降序输出各个销售员名字以及对应业绩\nsales = (\n    (\"Peter\", (78, 70, 65)),\n    (\"John\", (88, 80, 85)),\n    (\"Tony\", (90, 99, 95)),\n    (\"Henry\", (80, 70, 55)),\n    (\"Mike\", (95, 90, 95)),\n)\n#常规做法\ntop_sales = []\nfor name, quarter_amount in sales:\n    total_amount = sum(quarter_amount)\n    top_sales.append((name, total_amount))\n    # 此处解释下lambda 输入值: 返回值 --匿名函数,此处也就是输入x,返回x第二列元素,此处的作用是sort排序规则按照第二列的季度业绩进行降序排列\n    top_sales.sort(key=lambda x:x[1], reverse=True)\nprint(top_sales)\n# result: [('Tony', 284), ('Mike', 280), ('John', 253), ('Peter', 213), ('Henry', 205)]\n#列表表达式做法\nname_sales = [(name,sum(quarter_amount))  for name,quarter_amount in sales]\nname_sales.sort(key= lambda sale:sale[1],reverse= True)\nprint(name_sales)\n# result: [('Tony', 284), ('Mike', 280), ('John', 253), ('Peter', 213), ('Henry', 205)]\n"}, {"ctype": "head", "data": "1.3 其他对象"}, {"ctype": "head", "data": "1.31 集合"}, {"ctype": "head", "data": "①什么是集合?"}, {"ctype": "p", "data": "  外面像字典,里面是列表,无序不重复,集合中只能存储不可变对象,一旦添加只能删除,不能修改"}, {"ctype": "head", "data": "②集合的创建"}, {"ctype": "code", "data": "#集合,外面像字典,里面是列表,无序不重复\n1.与字典类型,都是{}但是字典中是键值对,集合中是单个元素\nmy_set = {1,2,3,4,5}\nprint(my_set,type(my_set)) \n# result: {1, 2, 3, 4, 5} <class 'set'>\n2.列表转集合\nmy_set1 = set([1, 2, 3, 4, 5])\nprint(my_set1,type(my_set1))\n# result: {1, 2, 3, 4, 5} <class 'set'>\n# 验证不重复性,达到去重效果\nlst = ['金','木','水','火','土','金','水']\nprint('转换前：',lst)\n#nresult:  转换前： ['金', '木', '水', '火', '土', '金', '水']\nlst1 = list(set(lst))\nprint('转换后：',lst1)\n# result: 转换后： ['水', '土', '金', '木', '火']\n#通过set给元组去重\ntup = ('a','b','a','a','m')\nprint(tup) \n# result : ('a', 'b', 'a', 'a', 'm')\nnum = set(tup) #元组转集合,达到去重效果\ntup1= tuple(num) # 集合转元组\nprint(tup1)  \n# result: ('m', 'b', 'a')\n"}, {"ctype": "head", "data": "③集合的CRUD"}, {"ctype": "code", "data": "#集合中元素一旦添加不可修改,所以集合没有修改方法\n1.添加\nmy_set = {1,2,3,6}\nmy_set.add(5)\nprint(my_set) \n# result:  原来没有则添加：{1, 2, 3, 5, 6}\nmy_set.add(2)\nprint(my_set) \n# result: 原来有则不采取任何动作,保持不变：{1, 2, 3, 5, 6}\n2.删除(set元素无法修改，只能删除）\nmy_set = {1,2,3,6}\nmy_set.remove(2)  #注意此处的2不是索引是值,因为集合无序,所以索引便无意义\nprint(my_set)\n# result: {1, 3, 6}\n#删除不存在的元素，会报错\nmy_set.remove(8)\nprint(my_set) \n# result: KeyError: 8\n#改用discard,如果没有8,没有任何反应\nmy_set.discard(8)\nprint(my_set) \n# result: {1, 3, 6}\n#删除值,并返回被删除的值,pop\nwhile len(my_set) > 0:\n    print(my_set.pop())\nprint(my_set) \n# result: set()\n#clear() 清空集合\nmy_set = {'I','love','Python','!'}\nmy_set.clear()\nprint(my_set)\n# result :  set()  #空集\n3.查：set由于无序，所以不能通过索引访问特定元素，只能通过遍历\n或者将list(set)转换成list进行索引查询， in 也只能判断是否存在\n"}, {"ctype": "head", "data": "④集合的遍历"}, {"ctype": "code", "data": "#遍历集合,与遍历元组和列表是一样的\nmy_set = {'张三','李四','王二','李四','张三','头大'}\nfor st in my_set:\n    print(st)\n#结果再次说明了集合的不重复性以及无序特性\n# result: 王二\n#         头大\n#         张三\n#         李四\n"}, {"ctype": "head", "data": "⑤常用函数"}, {"ctype": "code", "data": "s1 = {'b','c','d'}\ns2 = {'a','b','c'}\n1.交集(查询两个集合中共有的元素)\nprint(s1.intersection(s2))\n# s1 & s2  #不同写法同种功能 \n# result: {'b', 'c'}\n2.并集(查询出两个集合中所有元素并去重)\ns3 = s1.union(s2)\n# s3 = s1 | s2 #不同写法同种功能\nprint(s3)\n# result: {'a', 'b', 'd', 'c'}\n3.判断是否是子集(s3中元是否覆盖s1中所有元素)\ns1 = {'b','c','d'}\ns3 = {'a', 'b', 'd', 'c'}\nprint(s1.issubset(s3)) \n# result: True\n4.判断是否为父级\ns2 = {'a','b','c'}\ns3 = {'a', 'b', 'd', 'c'}\nprint(s3.issuperset(s2)) \n# True\n5.差集\ns = {1,2,3,4,5}\ns2 = {3,4,5,6,7}\nresult = s - s2 \n# result: {1, 2}\n6.异或集 获取只在一个集合中出现在另一个集合没有(也就是两个集合特有的元素组成的并集)的元素\ns = {1,2,3,4,5}  #特有元素 1,2\ns2 = {3,4,5,6,7} #特有元素 6,7\nresult = s ^ s2  # 结果即为 1,2 和 6,7 组成的并集\n# result: {1, 2, 6, 7}\n7.<= 检查一个集合是否是另一个集合的子集\n# 如果a集合中的元素全部都在b集合中出现，那么a集合就是b集合的子集，b集合是a集合超集\na = {1,2,3}\nb = {1,2,3,4,5}\nresult = a <= b \n# result: True\nresult = {1,2,3} <= {1,2,3} \n# result: True\nresult = {1,2,3,4,5} <= {1,2,3} \n# result: False\n8.< 检查一个集合是否是另一个集合的真子集\n# 如果超集b中含有子集a中所有元素，并且b中还有a中没有的元素，则b就是a的真超集，a是b的真子集(简单讲就是,如果集合a是集合b的真子集,则b集合元素个数>a集合元素个数且a集合中元素都存在于b集合)\nresult = {1,2,3} < {1,2,3}  #这种情况是子集,而不是真子集\n# result: False \nresult = {1,2,3} < {1,2,3,4,5} \n# result: True\n同理:>= 检查一个集合是否是另一个的超集(父集)  (这里不再举例说明)\n     > 检查一个集合是否是另一个的真超集(父集)\n9.== 判断两个集合中元素是否完全相同\na = {1,'a',False,None,6.6}\nb = {1,'a',False,None}\nc = {1,'a',False,None,6.6}\nprint(a==b,a==c)\n# result: False True 注:元素相同不一定是同一个对象\n10.is,is not 判断两个集合是否是同一个对象\na = {1,'a',False,None,6.6}\nc = {1,'a',False,None,6.6}\nprint('a和c元素是否相同',a==c)\n# result: a和c元素是否相同 True\nprint('a和c是否为同一对象',a is c)\n# result: a和c是否为同一对象 False\nprint(id(a),id(c)) #显然两者id不同,不是同一个对象\n# result: 2508129052928 2508129051360\n11.in 判断元素是否在集合中(而不是一个集合的元素是否在另一个集合中)\na = {1,'er','three',0.1}\nb = {1,'er'}\nprint('er' in a )  \n# result: True\nprint(b in a)\n# result: False\n12.集合表达式(与列表相似)\nmy_set = { i  if i % 2 == 0 else None for i in range(20)}\nprint(my_set) #结果相当于将所有偶数,以及10个None去重后的并集\n# result: {0, 2, 4, 6, None, 8, 10, 12, 14, 16, 18}\n13.copy()\nmy_set={'魑','魅','魍','魉'}\nmy_set1 = my_set.copy()\nprint(my_set,':',id(my_set))\nprint(my_set1,':',id(my_set1 )) #复制后相当于在内存中新建一个元素与my_set相同的新集合(因为两者地址(id值)不同),只要地址不同,操作任意集合中元素都不会对另一个集合有影响\n# result: {'魅', '魉', '魑', '魍'} : 2508149967776\n#         {'魅', '魉', '魑', '魍'} : 2508149967328\n\n"}, {"ctype": "head", "data": "1.32 字典"}, {"ctype": "head", "data": "①什么是字典?"}, {"ctype": "p", "data": "  字典属于一种新的数据结构,也称为映射(mapping),key:value形式,字典的值可以是任意对象,字典的键可以是任意的不可变对象（int、str、bool、tuple …），但是一般我们都会使用str,字典的键是不能重复的，如果出现重复的,后添加的键值将会覆盖之前的值"}, {"ctype": "head", "data": "②字典的创建"}, {"ctype": "code", "data": "#创建字典\n1.定义一个空字典(用花括号{},还记得元组是小括号'()',列表是中括号'[]')\nmy_dict = {}\nprint(my_dict,type(my_dict))\n# result: {} <class 'dict'>\n2.定义非空字典1:\nsales = {\n    '郭靖': '襄阳',\n    '张无忌': '光明顶',\n    '灭绝师太': '峨眉山',\n    '唐僧': '东土大唐',\n    '黄老邪': '桃花岛'\n}\nprint(sales) \n# result: {'郭靖': '襄阳', '张无忌': '光明顶', '灭绝师太': '峨眉山', '唐僧': '东土大唐', '黄老邪': '桃花岛'}\n3.使用 dict()函数来创建字典\n# 每一个参数都是一个键值对，参数名(name,age,gender)就是键，参数名('Whilesoul'，27，'男')就是值（这种方式创建的字典，key都是字符串）\nmy_dict = dict(name='Whilesoul',age=27,gender='男')\nprint(my_dict,type(my_dict)) \n# result: {'name': 'Whilesoul', 'age': 27, 'gender': '男'} <class 'dict'>\n4.也可以将一个含有元素类型为序列且为双值的序列转换为字典\n# [(1,2),(3,5),'ok',[5,'21']]\nd = dict([('name','曾国藩'),('age',50),('address','湖南'),'AJ',[1,2]])\nprint(d , type(d)) \n# result: {'name': '曾国藩', 'age': 50, 'address': '湖南', 'A': 'J', 1: 2} <class 'dict'>\n5.zip(拉链,很生动,将两个序列拉成一起,一组为key,另一组为value)\nlst1 = ['name','age','gender']\nlst2 = ['林志颖',18,'男']\nmy_dict = dict(zip(lst1,lst2)) # zip(a,b):a为key,b为value\nprint(my_dict)\n# result: {'name': '林志颖', 'age': 18, 'gender': '男'}\n"}, {"ctype": "head", "data": "③字典的CRUD"}, {"ctype": "code", "data": "my_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\n1.查(通过key查询value)\nprint(my_dict['Amy'],my_dict['Bob']) \n# result: 14 15\n#如果查询的key不存在，会报错\nmy_dict['lucy']\n# result: KeyError: 'lucy'\n2.增(也是通过key和value进行添加，判断key如果dict中没有则将key:value加入，如果存在key,则新value覆盖原value)\n#原来不存在则加入\nmy_dict['David'] = '20'\nprint(my_dict)  #没有则新增\n# result: {'Tom': 12, 'Jerry': 8, 'Amy': 14, 'Bob': 15, 'Lucy': 10, 'David': '20'}\n#原来已有对应的key则更新对应的value值\nmy_dict['Lucy'] = '520'\nprint(my_dict)  #将lucy的value 更新为520\n# result: {'Tom': 12, 'Jerry': 8, 'Amy': 14, 'Bob': 15, 'Lucy': '520', 'David': '20'}\n3.改(通过键来改值)\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10,'David':20 }\nmy_dict['David'] = '88'\nprint(my_dict)\n# result: {'Tom': 12, 'Jerry': 8, 'Amy': 14, 'Bob': 15, 'Lucy': 10, 'David': '88'}\n4.删(通过指定key将key:value同时删除)\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10,'David':20 }\ndel my_dict['David']\nprint(my_dict) \n# result: {'Tom': 12, 'Jerry': 8, 'Amy': 14, 'Bob': 15, 'Lucy': 10}\n"}, {"ctype": "head", "data": "④字典的遍历"}, {"ctype": "code", "data": "1.遍历键和值\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\n#遍历,将内容以元组形式输出\nfor key_value in my_dict.items():\n    print(key_value,end= ',')\n# result: ('Tom', 12),('Jerry', 8),('Amy', 14),('Bob', 15),('Lucy', 10)\n2.遍历键和值\n#遍历字典(重要)，key和value同时取出\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\nfor key,value in my_dict.items():\n    print(key,':',value, end = ',')\n# result: Tom : 12 ,Jerry : 8 ,Amy : 14 ,Bob : 15 ,Lucy : 10\n3.不加item（相当于遍历key）\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\nfor key in my_dict:\n    print(key, end = ', ')\n# result: Tom, Jerry, Amy, Bob, Lucy\n"}, {"ctype": "head", "data": "⑤常用函数"}, {"ctype": "code", "data": "1.get(key,defaultvalue)\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\n#前面已经知道如果目标key在字典中没有，执行my_dict['erha']会报错\nprint(my_dict['erha']) \n# result: KeyError: 'erha'\nprint(my_dict.get('erha')) \n# result: None\n#也可以设定一个在查不到时的默认值\nprint(my_dict.get('erha','NoFound')) \n# result: NoFound\n2.keys() 获取keys\n#效果与for key in my_dict:\n       # print(key) 相同\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\nprint(my_dict.keys())  #打印所有的key\n# result: dict_keys(['Tom', 'Jerry', 'Amy', 'Bob', 'Lucy'])\n3.values() 获取values\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\nprint(my_dict.values()) \n# result: dict_values([12, 8, 14, 15, 10])\nfor value in my_dict.values():\n    print(value,end = ', ')\n#result: 12, 8, 14, 15, 10\n#求得所有人员的年龄和\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\nprint(sum(my_dict.values())) \n# result: 59\n4.len() 获取字典中键值对的个数\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\nlen(my_dict)  \n# result: 5\n5.in 检查字典中是否包含指定的键\n# not in 检查字典中是否不包含指定的键\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\n'Jerry' in my_dict #True\n'erha' in my_dict  #False\n'ant' not in my_dict #True\n6.setdefault(key[, default]) 可以用来向字典中添加key-value\n#   如果key已经存在于字典中，则返回value值，不会对字典做任何操作\n#   如果key不存在，则向字典中添加这个key:value,并返回value值\nmy_dict = {'Tom':12,'Jerry': 8,'Amy':14,'Bob':15,'Lucy':10 }\n#没有此key,将key:value加入，并返回value值\nresult1 = my_dict.setdefault('name','猪八戒')\nprint(result1,my_dict) \n# result: 猪八戒 {'Tom': 12, 'Jerry': 8, 'Amy': 14, 'Bob': 15, 'Lucy': 10, 'name': '猪八戒'}\n#有此key,不进行任何操作,返回原value值\nresult2 = my_dict.setdefault('name','二郎神')\nprint(result2,my_dict) \n# result :猪八戒 {'Tom': 12, 'Jerry': 8, 'Amy': 14, 'Bob': 15, 'Lucy': 10, 'name': '猪八戒'}\n7.update([other])\n# 将其他的字典中的key-value添加到当前字典中\n# 如果有重复的key，则后边的value会替换到当前的value(有则改之无则加入)\ndic = {'a':1,'b':2,'c':3}\ndic1 = {'e':5,'d':4,'t':6, 'a':7}\ndic.update(dic1)\nprint(dic)\n# result: {'a': 7, 'b': 2, 'c': 3, 'e': 5, 'd': 4, 't': 6}\n8.popitem()\n# 随机删除字典中的一个键值对，一般都会删除最后一个键值对\n# 删除之后，它会将删除的key-value作为返回值返回\n# 返回的是一个元组，元组中有两个元素，第一个元素是删除的key，第二个是删除的value\n# 当使用popitem()删除一个空字典时，会抛出异常 KeyError: 'popitem(): dictionary is empty'\nmy_dict = dict(name = 'erha',age = 8,hobby = 'destroy')\ndc =my_dict.popitem()\nprint(dc,my_dict) \n# result: ('hobby', 'destroy') {'name': 'erha', 'age': 8}\n9.pop(key[, default])\n# 根据key删除字典中的key-value\n# 会将被删除的value返回！\n# 如果删除不存在的key，会抛出异常\n# 如果指定了默认值，再删除不存在的key时，不会报错，而是直接返回默认值\nmy_dict = dict(name = 'erha',age = 8,hobby = 'destroy')\n#已有key\nresult =my_dict.pop('name')\nprint(result,my_dict) \n# result: erha {'age': 8, 'hobby': 'destroy'}\n#未有key\nresult = my_dict.pop('sha','No found')\nprint(result,my_dict) \n# result: No found {'age': 8, 'hobby': 'destroy'}\n10 clear()用来清空字典\nmy_dict = dict(name = 'erha',age = 8,hobby = 'destroy')\nprint(my_dict) \n# result: {'name': 'erha', 'age': 8, 'hobby': 'destroy'}\nmy_dict.clear()\nprint(my_dict) \n# result: {}\n11.copy()\n# 该方法用于对字典进行浅复制\n# 复制以后的对象，和原对象是独立，修改一个不会影响另一个\n# 注意，浅复制会简单复制对象内部的值，如果值也是一个可变对象，这个可变对象不会被复制\nmy_dict = dict(name = 'erha',age = 8,hobby = 'destroy')\nmy_dict1 = my_dict.copy()\n#修改my_dict看对my_dict1是否有影响，结果：无影响\nmy_dict['name'] = 'lv'\nprint(my_dict,my_dict1)\n# result: {'name': 'lv', 'age': 8, 'hobby': 'destroy'} {'name': 'erha', 'age': 8, 'hobby': 'destroy'}\n#修改my_dict1看对my_dict是否有影响，结果：无影响\nmy_dict = dict(name = 'erha',age = 8,hobby = 'destroy')\nmy_dict1 = my_dict.copy()\nmy_dict1['name'] = 'lv'\nprint(my_dict,my_dict1)\n# result: {'name': 'erha', 'age': 8, 'hobby': 'destroy'} {'name': 'lv', 'age': 8, 'hobby': 'destroy'}\n#内部值也是可变对象（理解为将可变对象的地址复制了一份）\nd = {'a':{'name':'孙悟空','age':18},'b':2,'c':3}\nd2 = d.copy()\nprint(id(d),id(d2))  #赋值后二者地址就不一样\n# result: 1544580798592 1544580800192\nd2['a']['name'] = '猪八戒'\ndd1 = d['a']\ndd2 = d2['a'] \nprint(id(dd1),id(dd2))\n# result:2548494068928 2548494068928 可变key地址相同()\n#也就是说如果key:value中的value也是可变对象，那么复制后，可变对象的地址和复制前相同，修改一个，另一个也会改变\nprint('d = ',d , id(d))     \n# result: d =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 1544580798592\nprint('d2 = ',d2 , id(d2)) \n# result: d2 =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 1544580800192\n"}, {"ctype": "p", "data": "脑图:(目前只写了基础数据结构这块,其他的后续会慢慢更新) "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327182633150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY1NTcyNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "结束语:   各位看客老爷们,感谢您的阅读,到此文章就算完结了,由于本人是小白而且第一次写这种博客,难免有纰漏,如有错误望看客老爷们指出,我会及时修正,同时也希望这篇文章会给像我一样的初学者带来一丢丢的帮助. – 原创不易,转载请说明出处,谢谢!"}], "cate": "Python"}
{"题目": "多个turtle库绘画实例——樱花、哆啦A梦、时钟等", "作者": "KissMoon_", "发布时间": "2021-03-26 22:18:49", "内容": [{"ctype": "head", "data": "有趣的turtle库"}, {"ctype": "head", "data": "1、彩色螺旋线"}, {"ctype": "head", "data": "2、太阳花"}, {"ctype": "head", "data": "3、国旗"}, {"ctype": "head", "data": "4、玫瑰花"}, {"ctype": "head", "data": "5、彩色树"}, {"ctype": "head", "data": "6、随机樱花树"}, {"ctype": "head", "data": "7、表白树"}, {"ctype": "head", "data": "8、圆舞曲"}, {"ctype": "head", "data": "9、哆啦A梦"}, {"ctype": "head", "data": "10、时钟"}, {"ctype": "p", "data": "1、彩色螺旋线"}, {"ctype": "code", "data": "from turtle import *\nspeed(9)            # 画笔速度\npensize(2)\t\t\t# 画笔的宽度\nbgcolor(\"black\")\t\t# 画布背景色\ncolors = [\"red\",\"yellow\",\"purple\",\"blue\"]\t# 定义画笔线色\nfor x in range(400):\t\t# 循环一次 画一条线 \n    forward(2*x) \t        # 向当前方向前进n像素\n    color(colors[x % 4])\t# 根据求余 调整画笔线色\n    left(91)                # 向左旋转91度\n\nmainloop()\n"}, {"ctype": "p", "data": "2、太阳花"}, {"ctype": "code", "data": "import turtle\nturtle=turtle.Turtle()\nscreen=turtle.getscreen()\nturtle.color('red', 'yellow')\nturtle.begin_fill()\nfor i in range(50):\n    turtle.forward(200)\n    turtle.left(170)\nturtle.end_fill()\nturtle.done()\n"}, {"ctype": "p", "data": "3、国旗"}, {"ctype": "code", "data": "from turtle import *\n\nscreensize(2000, 2000, 'white')  # 设置画布大小\nspeed(9)\n# 绘制旗面\npencolor('red')\n# pu()\ngoto(-300, -200)\npd()\nfillcolor('red')\nbegin_fill()\nfor i in range(0, 2):\n    fd(600)\n    lt(90)\n    fd(400)\n    lt(90)\nend_fill()\n\n\n# 绘制大五角星\npu()\npencolor('yellow')\ngoto(-260, 120)\npd()\nfillcolor('yellow')\nbegin_fill()\nfor i in range(0, 5):\n    fd(113.137)  # 大星一划的边长\n    rt(144)\nend_fill()\n\n# 绘制四个小五角星\nlist1 = [(-100, 160), (-60, 120), (-60, 60), (-100, 20)]  # 四个五角星的中心坐标\nlist2 = [31.98, 8.13, -15.59, -38.66]  # 相对角度0的后退1.111需要左转的角度\n\nfor j in range(0, 4):\n    seth(0)  # 这是龟头角度为0\n    pu()\n    goto(list1[j])  # 定位到五角星中心\n    lt(list2[j])  # 旋转角度，以背向指向大五角星的角尖\n    bk(20)  # 从五角星中心到指向大五角星的角尖（龟倒着爬)退一个小圆半径\n    lt(18)  # 五角星的半角角度\n    pd()\n    begin_fill()\n    for i in range(0, 5):\n        fd(113.137 / 3)  # 小星一划的边长\n        rt(144)\n    end_fill()\npu()\nht()\ndone()\n"}, {"ctype": "p", "data": "4、玫瑰花"}, {"ctype": "code", "data": "import turtle\nimport time\nturtle.speed(5)\n# 设置初始位置  \nturtle.penup()  \nturtle.left(90)  \nturtle.fd(200)  \nturtle.pendown()  \nturtle.right(90)\n# 花蕊 \nturtle.fillcolor(\"red\")  \nturtle.begin_fill()  \nturtle.circle(10,180)  \nturtle.circle(25,110)  \nturtle.left(50)  \nturtle.circle(60,45)  \nturtle.circle(20,170)  \nturtle.right(24)  \nturtle.fd(30)  \nturtle.left(10)  \nturtle.circle(30,110)  \nturtle.fd(20)  \nturtle.left(40)  \nturtle.circle(90,70)  \nturtle.circle(30,150)  \nturtle.right(30)  \nturtle.fd(15)  \nturtle.circle(80,90)  \nturtle.left(15)  \nturtle.fd(45)  \nturtle.right(165)  \nturtle.fd(20)  \nturtle.left(155)  \nturtle.circle(150,80)  \nturtle.left(50)  \nturtle.circle(150,90)  \nturtle.end_fill()  \n\n# 花瓣1  \nturtle.left(150)  \nturtle.circle(-90,70)  \nturtle.left(20)  \nturtle.circle(75,105)  \nturtle.setheading(60)  \nturtle.circle(80,98)  \nturtle.circle(-90,40)  \n\n# 花瓣2  \nturtle.left(180)  \nturtle.circle(90,40)  \nturtle.circle(-80,98)  \nturtle.setheading(-83)  \n\n# 叶子1  \nturtle.fd(30)  \nturtle.left(90)  \nturtle.fd(25)  \nturtle.left(45)  \nturtle.fillcolor(\"green\")  \nturtle.begin_fill()  \nturtle.circle(-80,90)  \nturtle.right(90)  \nturtle.circle(-80,90)  \nturtle.end_fill()  \nturtle.right(135)  \nturtle.fd(60)  \nturtle.left(180)  \nturtle.fd(85)  \nturtle.left(90)  \nturtle.fd(80)  \n\n# 叶子2  \nturtle.right(90)  \nturtle.right(45)  \nturtle.fillcolor(\"green\")  \nturtle.begin_fill()  \nturtle.circle(80,90)  \nturtle.left(90)  \nturtle.circle(80,90)  \nturtle.end_fill()  \nturtle.left(135)  \nturtle.fd(60)  \nturtle.left(180)  \nturtle.fd(60)  \nturtle.right(90)  \nturtle.circle(200,60) \nturtle.done()\n"}, {"ctype": "p", "data": "5、彩色树"}, {"ctype": "code", "data": "# 这个比较复杂，画的时间较长\n\nfrom turtle import *\n# 设置色彩模式是RGB:\ncolormode(255)\nlt(90)\nlv = 14\nl = 120\ns = 45\nwidth(lv)\n# 初始化RGB颜色:\nr = 0\ng = 0\nb = 0\npencolor(r, g, b)\npenup()\nbk(l)\npendown()\nfd(l)\ndef draw_tree(l, level):\n    global r, g, b\n    # save the current pen width\n    w = width()\n    # narrow the pen width\n    width(w * 3.0 / 4.0)\n    # set color:\n    r = r + 1\n    g = g + 2\n    b = b + 3\n    pencolor(r % 200, g % 200, b % 200)\n    l = 3.0 / 4.0 * l\n    lt(s)\n    fd(l)\n    if level < lv:\n        draw_tree(l, level + 1)\n    bk(l)\n    rt(2 * s)\n    fd(l)\n    if level < lv:\n        draw_tree(l, level + 1)\n    bk(l)\n    lt(s)\n    # restore the previous pen width\n    width(w)\nspeed(\"fastest\")\ndraw_tree(l, 4)\ndone()\n"}, {"ctype": "p", "data": "6、随机樱花树"}, {"ctype": "code", "data": "# 每次运行 树的形状是随机的\nimport turtle as T\nimport random\nimport time\n\n# 画樱花的躯干(60,t)\ndef Tree(branch, t):\n    time.sleep(0.0005)\n    if branch > 3:\n        if 8 <= branch <= 12:\n            if random.randint(0, 2) == 0:\n                t.color('snow')  # 白\n            else:\n                t.color('lightcoral')  # 淡珊瑚色\n            t.pensize(branch / 3)\n        elif branch < 8:\n            if random.randint(0, 1) == 0:\n                t.color('snow')\n            else:\n                t.color('lightcoral')  # 淡珊瑚色\n            t.pensize(branch / 2)\n        else:\n            t.color('sienna')  # 赭(zhě)色\n            t.pensize(branch / 10)  # 6\n        t.forward(branch)\n        a = 1.5 * random.random()\n        t.right(20 * a)\n        b = 1.5 * random.random()\n        Tree(branch - 10 * b, t)\n        t.left(40 * a)\n        Tree(branch - 10 * b, t)\n        t.right(20 * a)\n        t.up()\n        t.backward(branch)\n        t.down()\n\n# 掉落的花瓣\ndef Petal(m, t):\n    for i in range(m):\n        a = 200 - 400 * random.random()\n        b = 10 - 20 * random.random()\n        t.up()\n        t.forward(b)\n        t.left(90)\n        t.forward(a)\n        t.down()\n        t.color('lightcoral')  # 淡珊瑚色\n        t.circle(1)\n        t.up()\n        t.backward(a)\n        t.right(90)\n        t.backward(b)\n\n# 绘图区域\nt = T.Turtle()\n# 画布大小\nw = T.Screen()\nt.hideturtle()  # 隐藏画笔\nt.getscreen().tracer(5, 0)\nw.screensize(bg='wheat')  # wheat小麦\nt.left(90)\nt.up()\nt.backward(150)\nt.down()\nt.color('sienna')\n\n# 画樱花的躯干\nTree(60, t)\n# 掉落的花瓣\nPetal(200, t)\nw.exitonclick()\nT.done()\n"}, {"ctype": "p", "data": "7、表白树"}, {"ctype": "code", "data": "import random\nimport turtle\ndef love(x, y):  # 在(x,y)处画爱心lalala\n    lv = turtle.Turtle()\n    lv.hideturtle()\n    lv.up()\n    lv.goto(x, y)  # 定位到(x,y)\n \n    def curvemove():  # 画圆弧\n        for i in range(20):\n            lv.right(10)\n            lv.forward(2)\n \n    lv.color('red', 'pink')\n    lv.speed(0)\n    lv.pensize(1)\n    # 开始画爱心lalala\n    lv.down()\n    lv.begin_fill()\n    lv.left(140)\n    lv.forward(22)\n    curvemove()\n    lv.left(120)\n    curvemove()\n    lv.forward(22)\n    lv.write(\"{}\".format(\"他-她\"), font=(\"Arial\", 10, \"normal\"), align=\"center\")\n    lv.left(140)  # 画完复位\n    lv.end_fill()\n \n \ndef tree(branchLen, t):\n    if branchLen > 5:  # 剩余树枝太少要结束递归\n        if branchLen < 20:  # 如果树枝剩余长度较短则变绿\n            t.color(\"green\")\n            t.pensize(random.uniform((branchLen + 5) / 4 - 2, (branchLen + 6) / 4 + 5))\n            t.down()\n            t.forward(branchLen)\n            love(t.xcor(), t.ycor())  # 传输现在turtle的坐标\n            t.up()\n            t.backward(branchLen)\n            t.color(\"brown\")\n            return\n        t.pensize(random.uniform((branchLen + 5) / 4 - 2, (branchLen + 6) / 4 + 5))\n        t.down()\n        t.forward(branchLen)\n        # 以下递归\n        ang = random.uniform(15, 45)\n        t.right(ang)\n        tree(branchLen - random.uniform(12, 16), t)  # 随机决定减小长度\n        t.left(2 * ang)\n        tree(branchLen - random.uniform(12, 16), t)  # 随机决定减小长度\n        t.right(ang)\n        t.up()\n        t.backward(branchLen)\n \n \ndef Fonts():\n    t.penup()\n    t.goto(-500, -300)\n    t.pencolor('black')\n    t.write(\"余生的快乐希望与你一起！^_^\", font=('方正行黑简体', 30, 'normal'))\nmyWin = turtle.Screen()\nt = turtle.Turtle()\nt.hideturtle()\nt.speed(0)\nt.left(90)\nt.up()\nt.backward(200)\nt.down()\nt.color(\"brown\")\nt.pensize(32)\nt.forward(60)\ntree(100, t)\nFonts()\nmyWin.exitonclick()\n"}, {"ctype": "p", "data": "8、圆舞曲"}, {"ctype": "code", "data": "from turtle import *\n\ndef stop():\n    global running\n    running = False\n\ndef main():\n    global running\n    clearscreen()\n    bgcolor(\"gray10\")\n    tracer(False)\n    shape(\"triangle\")\n    f =   0.793402\n    phi = 9.064678\n    s = 5\n    c = 1\n    # create compound shape\n    sh = Shape(\"compound\")\n    for i in range(10):\n        shapesize(s)\n        p =get_shapepoly()\n        s *= f\n        c *= f\n        tilt(-phi)\n        sh.addcomponent(p, (c, 0.25, 1-c), \"black\")\n    register_shape(\"multitri\", sh)\n    # create dancers\n    shapesize(1)\n    shape(\"multitri\")\n    pu()\n    setpos(0, -200)\n    dancers = []\n    for i in range(180):\n        fd(7)\n        tilt(-4)\n        lt(2)\n        update()\n        if i % 12 == 0:\n            dancers.append(clone())\n    home()\n    # dance\n    running = True\n    onkeypress(stop)\n    listen()\n    cs = 1\n    while running:\n        ta = -4\n        for dancer in dancers:\n            dancer.fd(7)\n            dancer.lt(2)\n            dancer.tilt(ta)\n            ta = -4 if ta > 0 else 2\n        if cs < 180:\n            right(4)\n            shapesize(cs)\n            cs *= 1.005\n        update()\n    return \"DONE!\"\n\nif __name__=='__main__':\n    print(main())\n    mainloop()\n"}, {"ctype": "p", "data": "9、哆啦A梦"}, {"ctype": "code", "data": "import turtle\n\n\ndef flyTo(x, y):\n    turtle.penup()\n    turtle.goto(x, y)\n    turtle.pendown()\ndef drawEye():\n    turtle.tracer(False)\n    a = 2.5\n    for i in range(120):\n        if 0 <= i < 30 or 60 <= i < 90:\n            a -= 0.05\n        else:\n            a += 0.05\n        turtle.left(3)\n        turtle.fd(a)\n    turtle.tracer(True)\ndef beard():\n    \"\"\" 画胡子， 一共六根\n    \"\"\"\n    # 左边第一根胡子\n    flyTo(-37, 135)\n    turtle.seth(165)\n    turtle.fd(60)\n    # 左边第二根胡子\n    flyTo(-37, 125)\n    turtle.seth(180)\n    turtle.fd(60)\n    # 左边第三根胡子\n    flyTo(-37, 115)\n    turtle.seth(193)\n    turtle.fd(60)\n    # 右边第一根胡子\n    flyTo(37, 135)\n    turtle.seth(15)\n    turtle.fd(60)\n    # 右边第二根胡子\n    flyTo(37, 125)\n    turtle.seth(0)\n    turtle.fd(60)\n    # 右边第三根胡子\n    flyTo(37, 115)\n    turtle.seth(-13)\n    turtle.fd(60)\ndef drawRedScarf():\n    \"\"\" 画围巾\n    \"\"\"\n    turtle.fillcolor(\"red\")  # 填充颜色\n    turtle.begin_fill()\n    turtle.seth(0)  # 朝向右\n    turtle.fd(200)  # 前进10个单位\n    turtle.circle(-5, 90)\n    turtle.fd(10)\n    turtle.circle(-5, 90)\n    turtle.fd(207)\n    turtle.circle(-5, 90)\n    turtle.fd(10)\n    turtle.circle(-5, 90)\n    turtle.end_fill()\ndef drawMouse():\n    flyTo(5, 148)\n    turtle.seth(270)\n    turtle.fd(100)\n    turtle.seth(0)\n    turtle.circle(120, 50)\n    turtle.seth(230)\n    turtle.circle(-120, 100)\ndef drawRedNose():\n    flyTo(-10, 158)\n    turtle.fillcolor(\"red\")  # 填充颜色\n    turtle.begin_fill()\n    turtle.circle(20)\n    turtle.end_fill()\ndef drawBlackdrawEye():\n    turtle.seth(0)\n    flyTo(-20, 195)\n    turtle.fillcolor(\"#000000\")  # 填充颜色\n    turtle.begin_fill()\n    turtle.circle(13)\n    turtle.end_fill()\n    turtle.pensize(6)\n    flyTo(20, 205)\n    turtle.seth(75)\n    turtle.circle(-10, 150)\n    turtle.pensize(3)\n    flyTo(-17, 200)\n    turtle.seth(0)\n    turtle.fillcolor(\"#ffffff\")\n    turtle.begin_fill()\n    turtle.circle(5)\n    turtle.end_fill()\n    flyTo(0, 0)\ndef drawFace():\n    turtle.forward(183)  # 前行183个单位\n    turtle.fillcolor(\"white\")  # 填充颜色为白色\n    turtle.begin_fill()  # 开始填充\n    turtle.left(45)  # 左转45度\n    turtle.circle(120, 100)  # 右边那半边脸\n    turtle.seth(90)  # 朝向向上\n    drawEye()  # 画右眼睛\n    turtle.seth(180)  # 朝向左\n    turtle.penup()  # 抬笔\n    turtle.fd(60)  # 前行60\n    turtle.pendown()  # 落笔\n    turtle.seth(90)  # 朝向上\n    drawEye()  # 画左眼睛\n    turtle.penup()  # 抬笔\n    turtle.seth(180)  # 朝向左\n    turtle.fd(64)  # 前进64\n    turtle.pendown()  # 落笔\n    turtle.seth(215)  # 修改朝向\n    turtle.circle(120, 100)  # 左边那半边脸\n    turtle.end_fill()  #\ndef drawHead():\n    \"\"\" 画了一个被切掉下半部分的圆\n    \"\"\"\n    turtle.penup()  # 抬笔\n    turtle.circle(150, 40)  # 画圆, 半径150，圆周角40\n    turtle.pendown()  # 落笔\n    turtle.fillcolor(\"#00a0de\")  # 填充色\n    turtle.begin_fill()  # 开始填充\n    turtle.circle(150, 280)  # 画圆，半径150, 圆周角280\n    turtle.end_fill()\ndef drawAll():\n    drawHead()\n    drawRedScarf()\n    drawFace()\n    drawRedNose()\n    drawMouse()\n    beard()\n    flyTo(0, 0)\n    turtle.seth(0)\n    turtle.penup()\n    turtle.circle(150, 50)\n    turtle.pendown()\n    turtle.seth(30)\n    turtle.fd(40)\n    turtle.seth(70)\n    turtle.circle(-30, 270)\n    turtle.fillcolor(\"#00a0de\")\n    turtle.begin_fill()\n    turtle.seth(230)\n    turtle.fd(80)\n    turtle.seth(90)\n    turtle.circle(1000, 1)\n    turtle.seth(-89)\n    turtle.circle(-1000, 10)\n    turtle.seth(180)\n    turtle.fd(70)\n    turtle.seth(90)\n    turtle.circle(30, 180)\n    turtle.seth(180)\n    turtle.fd(70)\n    turtle.seth(100)\n    turtle.circle(-1000, 9)\n    turtle.seth(-86)\n    turtle.circle(1000, 2)\n    turtle.seth(230)\n    turtle.fd(40)\n    turtle.circle(-30, 230)\n    turtle.seth(45)\n    turtle.fd(81)\n    turtle.seth(0)\n    turtle.fd(203)\n    turtle.circle(5, 90)\n    turtle.fd(10)\n    turtle.circle(5, 90)\n    turtle.fd(7)\n    turtle.seth(40)\n    turtle.circle(150, 10)\n    turtle.seth(30)\n    turtle.fd(40)\n    turtle.end_fill()\n    # 左手\n    turtle.seth(70)\n    turtle.fillcolor(\"#FFFFFF\")\n    turtle.begin_fill()\n    turtle.circle(-30)\n    turtle.end_fill()\n    # 脚\n    flyTo(103.74, -182.59)\n    turtle.seth(0)\n    turtle.fillcolor(\"#FFFFFF\")\n    turtle.begin_fill()\n    turtle.fd(15)\n    turtle.circle(-15, 180)\n    turtle.fd(90)\n    turtle.circle(-15, 180)\n    turtle.fd(10)\n    turtle.end_fill()\n    flyTo(-96.26, -182.59)\n    turtle.seth(180)\n    turtle.fillcolor(\"#FFFFFF\")\n    turtle.begin_fill()\n    turtle.fd(15)\n    turtle.circle(15, 180)\n    turtle.fd(90)\n    turtle.circle(15, 180)\n    turtle.fd(10)\n    turtle.end_fill()\n    # 右手\n    flyTo(-133.97, -91.81)\n    turtle.seth(50)\n    turtle.fillcolor(\"#FFFFFF\")\n    turtle.begin_fill()\n    turtle.circle(30)\n    turtle.end_fill()\n    # 口袋\n    flyTo(-103.42, 15.09)\n    turtle.seth(0)\n    turtle.fd(38)\n    turtle.seth(230)\n    turtle.begin_fill()\n    turtle.circle(90, 260)\n    turtle.end_fill()\n    flyTo(5, -40)\n    turtle.seth(0)\n    turtle.fd(70)\n    turtle.seth(-90)\n    turtle.circle(-70, 180)\n    turtle.seth(0)\n    turtle.fd(70)\n    # 铃铛\n    flyTo(-103.42, 15.09)\n    turtle.fd(90)\n    turtle.seth(70)\n    turtle.fillcolor(\"#ffd200\")\n    turtle.begin_fill()\n    turtle.circle(-20)\n    turtle.end_fill()\n    turtle.seth(170)\n    turtle.fillcolor(\"#ffd200\")\n    turtle.begin_fill()\n    turtle.circle(-2, 180)\n    turtle.seth(10)\n    turtle.circle(-100, 22)\n    turtle.circle(-2, 180)\n    turtle.seth(180 - 10)\n    turtle.circle(100, 22)\n    turtle.end_fill()\n    flyTo(-13.42, 15.09)\n    turtle.seth(250)\n    turtle.circle(20, 110)\n    turtle.seth(90)\n    turtle.fd(15)\n    turtle.dot(10)\n    flyTo(0, -150)\n    drawBlackdrawEye()\ndef main():\n    turtle.screensize(800, 6000, \"#F0F0F0\")\n    turtle.pensize(3)\n    turtle.speed(9)\n    drawAll()\nif __name__ == \"__main__\":\n    main()\n    turtle.mainloop()\n"}, {"ctype": "p", "data": "10、时钟"}, {"ctype": "code", "data": "import turtle\nfrom datetime import *\n\n# 抬起画笔，向前运动一段距离放下\ndef Skip(step):\n    turtle.penup()\n    turtle.forward(step)\n    turtle.pendown()\n\n\ndef mkHand(name, length):\n    # 注册Turtle形状，建立表针Turtle\n    turtle.reset()\n    Skip(-length * 0.1)\n    # 开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。\n    turtle.begin_poly()\n    turtle.forward(length * 1.1)\n    # 停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。\n    turtle.end_poly()\n    # 返回最后记录的多边形。\n    handForm = turtle.get_poly()\n    turtle.register_shape(name, handForm)\n\n\ndef Init():\n    global secHand, minHand, hurHand, printer\n    # 重置Turtle指向北\n    turtle.mode(\"logo\")\n    # 建立三个表针Turtle并初始化\n    mkHand(\"secHand\", 135)\n    mkHand(\"minHand\", 125)\n    mkHand(\"hurHand\", 90)\n    secHand = turtle.Turtle()\n    secHand.shape(\"secHand\")\n    minHand = turtle.Turtle()\n    minHand.shape(\"minHand\")\n    hurHand = turtle.Turtle()\n    hurHand.shape(\"hurHand\")\n\n    for hand in secHand, minHand, hurHand:\n        hand.shapesize(1, 1, 3)\n        hand.speed(0)\n\n    # 建立输出文字Turtle\n    printer = turtle.Turtle()\n    # 隐藏画笔的turtle形状\n    printer.hideturtle()\n    printer.penup()\n\n\ndef SetupClock(radius):\n    # 建立表的外框\n    turtle.reset()\n    turtle.pensize(7)\n    for i in range(60):\n        Skip(radius)\n        if i % 5 == 0:\n            turtle.forward(20)\n            Skip(-radius - 20)\n\n            Skip(radius + 20)\n            if i == 0:\n                turtle.write(int(12), align=\"center\", font=(\"Courier\", 14, \"bold\"))\n            elif i == 30:\n                Skip(25)\n                turtle.write(int(i / 5), align=\"center\", font=(\"Courier\", 14, \"bold\"))\n                Skip(-25)\n            elif (i == 25 or i == 35):\n                Skip(20)\n                turtle.write(int(i / 5), align=\"center\", font=(\"Courier\", 14, \"bold\"))\n                Skip(-20)\n            else:\n                turtle.write(int(i / 5), align=\"center\", font=(\"Courier\", 14, \"bold\"))\n            Skip(-radius - 20)\n        else:\n            turtle.dot(5)\n            Skip(-radius)\n        turtle.right(6)\n\n\ndef Week(t):\n    week = [\"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\", \"星期日\"]\n    return week[t.weekday()]\n\n\ndef Date(t):\n    y = t.year\n    m = t.month\n    d = t.day\n    return \"%s-%d-%d\" % (y, m, d)\n\n\ndef Tick():\n    # 绘制表针的动态显示\n    t = datetime.today()\n    second = t.second + t.microsecond * 0.000001\n    minute = t.minute + second / 60.0\n    hour = t.hour + minute / 60.0\n    secHand.setheading(6 * second)\n    minHand.setheading(6 * minute)\n    hurHand.setheading(30 * hour)\n\n    turtle.tracer(False)\n    printer.forward(65)\n    printer.write(Week(t), align=\"center\", font=(\"Courier\", 14, \"bold\"))\n    printer.back(130)\n    printer.write(Date(t), align=\"center\", font=(\"Courier\", 14, \"bold\"))\n    printer.home()\n    turtle.tracer(True)\n\n    # 100ms后继续调用tick\n    turtle.ontimer(Tick, 100)\n\n\ndef main():\n    # 打开/关闭龟动画，并为更新图纸设置延迟。\n    turtle.tracer(False)\n    Init()\n    SetupClock(160)\n    turtle.tracer(True)\n    Tick()\n    turtle.done()\n\n\nif __name__ == \"__main__\":\n    main()\n"}, {"ctype": "p", "data": "还愣着干嘛，赶紧拿去骗小姐姐啊？ "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326221721113.jpg#pic_center"}, {"ctype": "p", "data": "原文链接： https://blog.csdn.net/su_zhen_hua/article/details/113680235"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326221456228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "量化交易 实战之回归法选股 part 1", "作者": "我是小白呀", "发布时间": "2021-03-26 12:14:06", "内容": [{"ctype": "head", "data": "概述"}, {"ctype": "p", "data": "回归法就是用过去的股票的收益率对多因子进行回归. 得到一个回归方程, 然后再把最新的因子值带入回归方程得到一个对未来股票收益的预判. 然后再以此为依据进行选股, 并对选股模型的有效性和收益率进行评价."}, {"ctype": "p", "data": "回归法的优点是能够比较及时地调整股票对各个因子的敏感性也可以不同. 回归法的缺点则是容易受到极端值的影响. 在对因子敏感度变化较大的市场情况下效果会比较差."}, {"ctype": "head", "data": "回归法选股流程"}, {"ctype": "p", "data": "在选股时我们通常按月调仓. 我们回归选择的是该月的最后一天若干个因子值与下一个月的股票收益率来建立横截面回归方程."}, {"ctype": "head", "data": "步骤分析"}, {"ctype": "p", "data": "回归训练区间: 2016-01-01 ~ 2021-01-01回归股票池: (HS300 指数)回归因子数据准备, 收益率计算 \n  因子数据: 横截面数据拼接, 添加日期数据, 去除空值收益率计算:所有样本的收益率计算 目标值特征值提取进行回归估计 \n  数据处理: 去除收益为 0 (价格数据不存在) 的数据, 去极值, 标准化处理 "}, {"ctype": "head", "data": "代码"}, {"ctype": "head", "data": "导包"}, {"ctype": "code", "data": "import numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\n"}, {"ctype": "head", "data": "1. 准备日期数据"}, {"ctype": "code", "data": "# 确定每月日期 2019-01-01 到 2021-01-01\ndates = get_trading_dates(start_date=\"2019-01-01\", end_date=\"2021-01-01\")\n\n# 每月最后一个交易日, 按月计算收益率\nmonth_date = []\nfor i in range(len(dates) - 1):\n    if dates[i].month != dates[i + 1].month:\n        month_date.append(dates[i])\n        \n# 把最后一个交易日加入\nmonth_date.append(dates[-1])\n\n# 调试输出\nprint(month_date)\nprint(month_date[:-1])\nprint(np.shape(month_date))\n"}, {"ctype": "p", "data": "输出结果:"}, {"ctype": "code", "data": "[datetime.date(2019, 1, 31), datetime.date(2019, 2, 28), datetime.date(2019, 3, 29), datetime.date(2019, 4, 30), datetime.date(2019, 5, 31), datetime.date(2019, 6, 28), datetime.date(2019, 7, 31), datetime.date(2019, 8, 30), datetime.date(2019, 9, 30), datetime.date(2019, 10, 31), datetime.date(2019, 11, 29), datetime.date(2019, 12, 31), datetime.date(2020, 1, 23), datetime.date(2020, 2, 28), datetime.date(2020, 3, 31), datetime.date(2020, 4, 30), datetime.date(2020, 5, 29), datetime.date(2020, 6, 30), datetime.date(2020, 7, 31), datetime.date(2020, 8, 31), datetime.date(2020, 9, 30), datetime.date(2020, 10, 30), datetime.date(2020, 11, 30), datetime.date(2020, 12, 31)]\n[datetime.date(2019, 1, 31), datetime.date(2019, 2, 28), datetime.date(2019, 3, 29), datetime.date(2019, 4, 30), datetime.date(2019, 5, 31), datetime.date(2019, 6, 28), datetime.date(2019, 7, 31), datetime.date(2019, 8, 30), datetime.date(2019, 9, 30), datetime.date(2019, 10, 31), datetime.date(2019, 11, 29), datetime.date(2019, 12, 31), datetime.date(2020, 1, 23), datetime.date(2020, 2, 28), datetime.date(2020, 3, 31), datetime.date(2020, 4, 30), datetime.date(2020, 5, 29), datetime.date(2020, 6, 30), datetime.date(2020, 7, 31), datetime.date(2020, 8, 31), datetime.date(2020, 9, 30), datetime.date(2020, 10, 30), datetime.date(2020, 11, 30)]\n(24,)\n"}, {"ctype": "head", "data": "2. 准备因子数据"}, {"ctype": "code", "data": "# 获取沪深300的股票列表\nstocks = index_components(\"000300.XSHG\")\n\nall_data = pd.DataFrame()\n\n# 特征值都是该月的因子数据(避免下个月在日期列表当中不存在)\nfor date in month_date[:-1]:\n    q = query(\n        fundamentals.eod_derivative_indicator.pe_ratio,\n        fundamentals.eod_derivative_indicator.pb_ratio,\n        fundamentals.eod_derivative_indicator.market_cap,\n        fundamentals.financial_indicator.ev,\n        fundamentals.financial_indicator.return_on_asset_net_profit,\n        fundamentals.financial_indicator.du_return_on_equity,\n        fundamentals.financial_indicator.earnings_per_share,\n        fundamentals.income_statement.revenue,\n        fundamentals.income_statement.total_expense\n    ).filter(\n        fundamentals.stockcode.in_(stocks)\n    )\n\n    # 查询因子数据\n    fund = get_fundamentals(q, entry_date=date).iloc[:, 0, :]\n    \n    # 添加时间\n    fund[\"date\"] = date\n    \n    # 进行每月因子数据拼接\n    all_data = pd.concat([all_data, fund])\n    \n    \n# 进行简单的数据处理\nall_data.dropna()\nall_data[\"next_month_return\"] = np.nan\n    \n# 调试输出\nprint(all_data.head())\n"}, {"ctype": "p", "data": "调试输出:"}, {"ctype": "code", "data": "            du_return_on_equity      revenue return_on_asset_net_profit  \\\n000002.XSHE             10.2572  1.76022e+11                     1.6783   \n000001.XSHE              8.9467   8.6664e+10                     0.6198   \n000066.XSHE              3.2718  6.27052e+09                     1.5837   \n000063.XSHE            -26.7064  5.87662e+10                    -5.4534   \n000069.XSHE              9.6044  2.45503e+10                     2.1907   \n\n            pb_ratio pe_ratio earnings_per_share total_expense           ev  \\\n000002.XSHE   1.9667   9.0705              1.267   1.47083e+11  4.96679e+11   \n000001.XSHE    0.866   7.6796               1.14     6.005e+10  3.30656e+12   \n000066.XSHE   2.5219  14.0424              0.071   6.31538e+09  2.24526e+10   \n000063.XSHE   3.6823 -12.0731              -1.73   6.02975e+10  9.32565e+10   \n000069.XSHE   0.8881   4.9651             0.6205    1.7947e+10   1.5581e+11   \n\n              market_cap        date  next_month_return  \n000002.XSHE  3.06336e+11  2019-01-31                NaN  \n000001.XSHE  1.90592e+11  2019-01-31                NaN  \n000066.XSHE  1.57378e+10  2019-01-31                NaN  \n000063.XSHE  8.43146e+10  2019-01-31                NaN  \n000069.XSHE  5.25061e+10  2019-01-31                NaN  \n"}, {"ctype": "head", "data": "3. 获取价格"}, {"ctype": "code", "data": "# 建立每个股票样本, 每个月的因子值对应下个月的收益率\n\n# 获取每月月末价格数据\nall_price = pd.DataFrame()\nfor date in month_date:\n    price = get_price(stocks, start_date=date, end_date=date, fields=\"close\")\n    all_price = pd.concat([all_price, price])\n    \n    \n# 转置\nall_price = all_price.T\n\n# 去除空值\nall_price = all_price.dropna()\n\n# 调试输出\nprint(all_price.head())\n"}, {"ctype": "p", "data": "输出结果:"}, {"ctype": "code", "data": "date         2019-01-31  2019-02-28  2019-03-29  2019-04-30  2019-05-31  \\\n000001.XSHE     10.7961     12.0216     12.4690     13.4708     11.8465   \n000002.XSHE     25.7326     25.9552     28.4867     26.7805     24.7589   \n000063.XSHE     20.0043     29.6434     29.0466     31.9810     28.6089   \n000066.XSHE      5.3014      6.8443     10.4544      8.6543      9.6731   \n000069.XSHE      5.8395      6.3139      7.0256      7.2537      6.4952   \n\ndate         2019-06-28  2019-07-31  2019-08-30  2019-09-30  2019-10-31  ...  \\\n000001.XSHE     13.5490     13.8931     13.9226     15.3286     15.9874  ...   \n000002.XSHE     25.7882     26.6692     24.8829     24.9793     25.5870  ...   \n000063.XSHE     32.3591     32.7470     28.6586     31.8418     33.2245  ...   \n000066.XSHE     10.1676      9.4349     10.5981     12.8251     14.3960  ...   \n000069.XSHE      6.6190      6.8667      6.4857      6.6952      6.7048  ...   \n\ndate         2020-03-31  2020-04-30  2020-05-29  2020-06-30  2020-07-31  \\\n000001.XSHE     12.5854     13.6965     13.0000     12.8000     13.3400   \n000002.XSHE     24.7382     25.8474     24.7865     25.2108     25.8859   \n000063.XSHE     42.5751     40.8741     35.8606     39.9191     38.9642   \n000066.XSHE     11.8707     11.7613     13.6503     13.1234     18.3000   \n000069.XSHE      6.0857      6.2095      5.5619      6.0600      7.1700   \n\ndate         2020-08-31  2020-09-30  2020-10-30  2020-11-30  2020-12-31  \n000001.XSHE       15.08       15.17       17.75       19.74       19.34  \n000002.XSHE       27.27       28.02       27.55       30.70       28.70  \n000063.XSHE       39.00       33.10       32.27       34.73       33.65  \n000066.XSHE       17.71       16.04       15.15       14.42       18.99  \n000069.XSHE        7.15        6.78        6.56        7.28        7.09  \n\n[5 rows x 24 columns]\n"}, {"ctype": "head", "data": "4. 计算对应的收益率"}, {"ctype": "code", "data": "for i in range (len(all_price.columns) - 1):\n    \n    # 利用后一个月的收盘价-这个月的收盘价/这个月的收盘价\n    all_price.iloc[:, i] = all_price.iloc[:, i + 1] / all_price.iloc[:, i] -1\n    \n    \n# 调试输出\nprint(all_price.head())\n"}, {"ctype": "p", "data": "输出结果:"}, {"ctype": "code", "data": "date         2019-01-31  2019-02-28  2019-03-29  2019-04-30  2019-05-31  \\\n000001.XSHE    0.113513    0.037216    0.080343   -0.120579    0.143713   \n000002.XSHE    0.008651    0.097533   -0.059895   -0.075488    0.041573   \n000063.XSHE    0.481851   -0.020133    0.101024   -0.105441    0.131085   \n000066.XSHE    0.291036    0.527461   -0.172186    0.117722    0.051121   \n000069.XSHE    0.081240    0.112720    0.032467   -0.104567    0.019060   \n\ndate         2019-06-28  2019-07-31  2019-08-30  2019-09-30  2019-10-31  ...  \\\n000001.XSHE    0.025397    0.002123    0.100987    0.042978   -0.059653  ...   \n000002.XSHE    0.034163   -0.066980    0.003874    0.024328    0.044101  ...   \n000063.XSHE    0.011987   -0.124848    0.111073    0.043424   -0.080540  ...   \n000066.XSHE   -0.072062    0.123287    0.210132    0.122486    0.025549  ...   \n000069.XSHE    0.037423   -0.055485    0.032302    0.001434   -0.021313  ...   \n\ndate         2020-03-31  2020-04-30  2020-05-29  2020-06-30  2020-07-31  \\\n000001.XSHE    0.088285   -0.050852   -0.015385    0.042187    0.130435   \n000002.XSHE    0.044838   -0.041045    0.017118    0.026778    0.053469   \n000063.XSHE   -0.039953   -0.122657    0.113174   -0.023921    0.000919   \n000066.XSHE   -0.009216    0.160611   -0.038600    0.394456   -0.032240   \n000069.XSHE    0.020343   -0.104292    0.089556    0.183168   -0.002789   \n\ndate         2020-08-31  2020-09-30  2020-10-30  2020-11-30  2020-12-31  \n000001.XSHE    0.005968    0.170073    0.112113   -0.020263       19.34  \n000002.XSHE    0.027503   -0.016774    0.114338   -0.065147       28.70  \n000063.XSHE   -0.151282   -0.025076    0.076232   -0.031097       33.65  \n000066.XSHE   -0.094297   -0.055486   -0.048185    0.316921       18.99  \n000069.XSHE   -0.051748   -0.032448    0.109756   -0.026099        7.09  \n\n[5 rows x 24 columns]\n"}, {"ctype": "head", "data": "5. 填充因子收益率"}, {"ctype": "code", "data": "# 将受益率填充到因子对应的下月受益当中\nfor i in range(len(all_data)):\n    # 每个样本填充对应收益率\n    stock = all_data.index[i]\n    date = all_data.ix[i, \"date\"]\n    \n    # 在all_price里面寻找收益率\n    if stock in all_price.index and date in all_price.columns:\n        \n        all_data.ix[i,\"next_month_return\"] = all_price.loc[stock, date]\n    \n    \n# 把收益率为空删除\nall_data = all_data.dropna()\n\n# 调试输出\nprint(all_data.head())  \n"}, {"ctype": "p", "data": "输出结果:"}, {"ctype": "code", "data": "            du_return_on_equity      revenue return_on_asset_net_profit  \\\n000002.XSHE             10.2572  1.76022e+11                     1.6783   \n000001.XSHE              8.9467   8.6664e+10                     0.6198   \n000066.XSHE              3.2718  6.27052e+09                     1.5837   \n000063.XSHE            -26.7064  5.87662e+10                    -5.4534   \n000069.XSHE              9.6044  2.45503e+10                     2.1907   \n\n            pb_ratio pe_ratio earnings_per_share total_expense           ev  \\\n000002.XSHE   1.9667   9.0705              1.267   1.47083e+11  4.96679e+11   \n000001.XSHE    0.866   7.6796               1.14     6.005e+10  3.30656e+12   \n000066.XSHE   2.5219  14.0424              0.071   6.31538e+09  2.24526e+10   \n000063.XSHE   3.6823 -12.0731              -1.73   6.02975e+10  9.32565e+10   \n000069.XSHE   0.8881   4.9651             0.6205    1.7947e+10   1.5581e+11   \n\n              market_cap        date  next_month_return  \n000002.XSHE  3.06336e+11  2019-01-31           0.008651  \n000001.XSHE  1.90592e+11  2019-01-31           0.113513  \n000066.XSHE  1.57378e+10  2019-01-31           0.291036  \n000063.XSHE  8.43146e+10  2019-01-31           0.481851  \n000069.XSHE  5.25061e+10  2019-01-31           0.081240 \n"}, {"ctype": "head", "data": "6. 特征值和目标值处理"}, {"ctype": "code", "data": "def mad(factor):\n    \"\"\"3倍中位数去极值\"\"\"\n    \n    # 求出因子值的中位数\n    median = np.median(factor)\n    \n    # 求出因子值与中位数的差值, 进行绝对值\n    mad = np.median(abs(factor - median))\n    \n    # 定义几倍的中位数上下限\n    high = median + (3 * 1.4826 * mad)\n    low = median - (3 * 1.4826 * mad)\n    \n    # 替换上下限\n    factor = np.where(factor > high, high, factor)\n    factor = np.where(factor < low, low, factor)\n    return factor\n\ndef stand(factor):\n    \"\"\"数据标准化\"\"\"\n    mean = factor.mean()\n    std = factor.std()\n    \n    return (factor - mean) / std\n    \ny = all_data[\"next_month_return\"]\nx = all_data.drop([\"next_month_return\", \"date\"], axis=1)\nx_market_cap = x[\"market_cap\"]\n\n# 特征处理 (去极值, 标准化, 中心化)\nfor name in x.columns:\n    x[name] = mad(x[name])\n    x[name] = stand(x[name])\n    \n# 中性化处理 (特征值: 市值因子, 目标值: 其他因子)\n\nfor name in x.columns:\n    if name == \"market_cap\":\n        continue\n    # 准备特征值, 目标值\n    y_factor = x[name]\n    \n    # 线性回归方程建立\n    lr = LinearRegression()\n    lr.fit(x_market_cap.values.reshape(-1, 1), y_factor)\n    \n    y_predict = lr.predict(x_market_cap.values.reshape(-1, 1))\n    \n    # 得出真实值与预测之间的误差当做新的因子值\n    x[name] = y_factor - y_predict\n    \n    \n# 收益率目标值y (标准化)\ny = stand(y)\nprint(y)\n"}, {"ctype": "p", "data": "输出结果:"}, {"ctype": "code", "data": "000002.XSHE   -0.190612\n000001.XSHE    0.656175\n000066.XSHE    2.089711\n000063.XSHE    3.630581\n000069.XSHE    0.395561\n000100.XSHE    1.149259\n000157.XSHE    0.781338\n000425.XSHE    1.423916\n000538.XSHE    0.503104\n000568.XSHE    1.361395\n000596.XSHE    1.451692\n000625.XSHE    0.824005\n000627.XSHE    1.834775\n000651.XSHE    0.446647\n000656.XSHE    0.177199\n000661.XSHE    1.485170\n000671.XSHE    1.489377\n000703.XSHE    0.345296\n000708.XSHE    1.240191\n000723.XSHE    1.583630\n000725.XSHE    4.502545\n000728.XSHE    2.082080\n000768.XSHE    1.094074\n000776.XSHE    2.157632\n000783.XSHE    2.334973\n000786.XSHE    1.180269\n000858.XSHE    1.239401\n000860.XSHE    0.213113\n000876.XSHE    2.431267\n000895.XSHE   -0.535029\n                 ...   \n601808.XSHG   -0.451852\n601878.XSHG   -0.843214\n601881.XSHG   -0.498526\n601818.XSHG   -0.911693\n601901.XSHG    0.948128\n601888.XSHG    3.469926\n601877.XSHG    1.296525\n601939.XSHG   -1.243044\n601872.XSHG   -0.781879\n601933.XSHG   -0.921353\n601899.XSHG   -0.260467\n601919.XSHG    1.603668\n601990.XSHG   -0.737300\n601989.XSHG   -0.539564\n601985.XSHG   -0.244020\n603019.XSHG   -0.518526\n601998.XSHG   -0.460806\n601988.XSHG   -0.554111\n603156.XSHG   -0.350088\n603160.XSHG   -0.810521\n603259.XSHG    2.192650\n603288.XSHG    1.836448\n603369.XSHG    1.194465\n603501.XSHG    0.326507\n603658.XSHG   -0.249327\n603799.XSHG    3.903695\n603833.XSHG    0.177536\n603899.XSHG    1.493082\n603986.XSHG   -0.615777\n603993.XSHG    2.659977\nName: next_month_return, Length: 6486, dtype: float64\n"}, {"ctype": "head", "data": "7. 建立回归方程"}, {"ctype": "code", "data": "# 建立特征值因子数据 (处理过的) 与目标值 (标准化) 下期收益率之间的回归方程\nlr = LinearRegression()\n\nlr.fit(x, y)\nprint(lr.coef_)\n"}, {"ctype": "p", "data": "输出结果:"}, {"ctype": "code", "data": "[ 0.04549957  0.01249463 -0.02397849  0.06077185 -0.00195205 -0.00892116\n -0.04641399 -0.05644752 -0.08393869]\n"}], "cate": "Python"}
{"题目": "Django入门-01（超细安装教程）", "作者": "沉舟伟", "发布时间": "2021-03-27 00:24:38", "内容": [{"ctype": "head", "data": "Django安装入门（详细）"}, {"ctype": "p", "data": "如果对你有帮助，希望能你能点个关注，表示你对作者的支持！！谢谢 "}, {"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "Django很多人都说不知道从哪里下手？ 其实是因为Django和我们日常遇见的flask有些不同，学过flask的朋友应该知道，flask非常的简单，但是越学到后面越来越难 但是Django就不一样了，它的刚开始学习的时候非常的困难，但是学到后面越觉得简单"}, {"ctype": "head", "data": "一、安装虚拟环境安装"}, {"ctype": "head", "data": "一.安装virtualenvwrapper（重要）"}, {"ctype": "p", "data": "这个代码直接复制到Pycharm的Terminal "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326223935515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "python -m pip install --ignore-installed virtualenvwrapper-win -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032622410270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "二.但是需要注意的是，python版本要对应相应的Django版本（重要，版本对应即可）"}, {"ctype": "p", "data": "如果Django和python之间的版本没有对应，有可能会出现很多很多bug，所以需要对应版本 提示：version是版本的意思"}, {"ctype": "table", "data": "Django versionpython version1.82.7，3.2，3.3，3.4，3.5 ，3.61.9，1.102.7，3.4，3.51.112.7，3.4，3.5，3.62.03.4，3.5，3.62.13.5，3.6，3.7"}, {"ctype": "p", "data": "我认为：这个是为了配置虚拟环境做准备。就比如windows系统中要装Linux，那就必须要有一个虚拟机，这个就相当于虚拟机软件，为后面的创建虚拟环境做准备。"}, {"ctype": "head", "data": "三.创建虚拟环境（重要）"}, {"ctype": "head", "data": "1.先在电脑建立一个文件夹（这个就是虚拟环境的位置）"}, {"ctype": "p", "data": " 在这里我命名文件名：Django  进入cmd  进入到文件夹路径以后输入这串代码，后面的python36可以改，就是你的虚拟环境名字"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326230131262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "virtualenv -p python3 python36\n"}, {"ctype": "head", "data": "2.进入Django文件夹（有出现python36这个文件夹说明创建虚拟环境成功）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326231305467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.我们需要激活activate（在Django/python36/Scripts中）"}, {"ctype": "p", "data": " 可能要问要怎么做呢？ 具体操作步骤：  在上图出现了一个（python36）说明虚拟环境已经成功激活"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326231654343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4.如果想退出虚拟环境"}, {"ctype": "code", "data": "#输入这行代码，就可以退出虚拟环境\ndeactivate\n"}, {"ctype": "p", "data": "如果之前那个图片的(python36)消失，说明已经退出虚拟环境。"}, {"ctype": "head", "data": "二、对pycharm进行虚拟环境配置"}, {"ctype": "head", "data": "1.打开pycharm以后，点击pycharm的右下角（如图）"}, {"ctype": "p", "data": "   找到Django文件夹中的python36\\Scripts里面的python.exe，然后点击ok（如图所示）  Tips：  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326233412881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "三. 安装Django框架（前面的部分是不可缺少的）"}, {"ctype": "p", "data": "因为我的python版本是3.6，所以我指定Django版本为1.8.2"}, {"ctype": "code", "data": "pip install django==1.8.2\n"}, {"ctype": "p", "data": " 如果安装失败的话可能是没有配置给pip配置国内的镜像站，这个就具体百度（搜索：pip国内镜像源）就可以了"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327000043107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "四. 用pycharm生成一个Django项目"}, {"ctype": "p", "data": "点击生成NewPeoject "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327000937624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "5.最后检查"}, {"ctype": "p", "data": "检查一下：使用pip list，查看一下Django版本  纠正Django版本"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327001405476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "pip install Django==1.8.2\n"}, {"ctype": "p", "data": " 再次pip list 这样子Django就没有问题了 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327001638797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "下一篇: Django的初始化(没有初始化的Django会报错会报错)"}, {"ctype": "p", "data": " 这个是因为没有对Django进行初始化的原因"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327002204255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NjA2NQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python爬取股票数据并存到数据库", "作者": "Harry_2002", "发布时间": "2021-03-28 23:54:17", "内容": [{"ctype": "head", "data": "Python 用Tushare接口获取股票数据并存储到Sqlite数据库"}, {"ctype": "p", "data": " 使用技术介绍： 关于接口 由于tushare旧版本即将不能用了，所以我们这里使用的是tushare pro 接口。 关于数据库 使用了Sqlite轻量级数据库适合本地使用。 关于爬取的数据 共12种数据，如下ts_code,trade_date,open,high,low,close,pre_close,change,pct_chg,vol,amount, avgprice 关于py文件 共三个 分别是Tushare.py, config.py, SQLserver .py  具体实现 "}, {"ctype": "p", "data": "要import的库"}, {"ctype": "code", "data": "import tushare as t1# t1 是旧版本后面的ts = t1.pro_api() 是变为pro版本\nimport time # 用以计时\nfrom config import * # 此库为配置库\nfrom SQLserver import * # 此库为作者所写\n"}, {"ctype": "p", "data": "Tushare Pro 爬取数据 Pro接口需要前往官网（https://tushare.pro/）注册，并获取token，过程较为繁琐，而本文篇幅有限故将在之后更新获取token文章。 将获取到的token值放进config文件中的tushare字典中。"}, {"ctype": "code", "data": "# -*- coding: utf-8 -*-\n\"\"\"此为存放配置信息的config.py\"\"\"\ntushare = {\"token\":\"\", \"column\": ['ts_code', 'trade_date', 'open', 'high', 'low', 'close', 'pre_close', 'change', 'pct_chg', 'vol', 'amount'],} # 冒号里为您的token值\ndbPath = r'\\database.db' # 数据库路径\nStock_list={\"平安银行\": \"000001.SZ\",\"万科A\": \"000002.SZ\",\n              \"国华网安\": \"000004.SZ\",\n              \"世纪星源\": \"000005.SZ\",\n              \"深振业A\": \"000006.SZ\",\n              \"全新好\": \"000007.SZ\"} # 股票名称和代码字典 有需要的我会在后续写如何获取名称和列表的文章\n"}, {"ctype": "code", "data": "\nclass Fetch_Data():\n    \"\"\"code股票代码 sd开始日期 ed结束日期\"\"\"\n\n    def __init__(self, code, start_data, end_data):\n        self.code = code\n        self.sd = start_data\n        self.ed = end_data\n        # self.csv_name = \"csv_data/\" + csv_name + \".csv\"\n\n    def web_spider(self):  # 爬虫tushare接口\n        try:\n            df = ts.daily(ts_code=self.code, start_date=self.sd, end_date=self.ed)  # 爬取数据--dataframe格式\n            # daily方法所获取的数据ts_code,trade_date,open,high,low,close,pre_close,change,pct_chg,vol,amount,avgprice\n            # df.to_csv(self.csv_name) # 转换为csv文件\n            return df  # 返回数据\n        except Exception as e:\n\t\t\tprint(e) # 打印报错信息\n"}, {"ctype": "p", "data": "当然仅有这段代码是不行的，我们还需要初始化tushare接口。初始化本写在main中，这里为了方便大家使用提到前面来说。"}, {"ctype": "code", "data": "        t1.set_token(tushare[\"token\"])  # 存在config里的token值\n        ts = t1.pro_api()  # 初始化pro接口\n"}, {"ctype": "p", "data": "2.存储到Sqlite数据库"}, {"ctype": "code", "data": "# 存储到数据库\nclass Sql_Data_Handle():\n    def __init__(self, df, connect, curs):\n        self.df = df\n        self.connect = connect\n        self.curs = curs\n\n    def character(self):\n        # df = pandas.read_csv(self.csv_name, encoding='gbk') # 用pandas库读取csv文件\n        line_num = self.line_num\n        # pandas的iloc函数读取每行对应数据\n        ts_code = self.df.iloc[line_num][\"ts_code\"]\n        trade_date = self.df.iloc[line_num][\"trade_date\"]\n        open = self.df.iloc[line_num][\"open\"]\n        high = self.df.iloc[line_num][\"high\"]\n        low = self.df.iloc[line_num][\"low\"]\n        close = self.df.iloc[line_num][\"close\"]\n        pre_close = self.df.iloc[line_num][\"pre_close\"]\n        change = self.df.iloc[line_num][\"change\"]\n        pct_chg = self.df.iloc[line_num][\"pct_chg\"]\n        vol = self.df.iloc[line_num][\"vol\"]\n        amount = self.df.iloc[line_num][\"amount\"]\n        # 将数据转换为元祖tuple格式\n        values = (\n            ts_code, trade_date, float(open), float(high), float(low), float(close), float(pre_close),\n            float(change), float(pct_chg), float(vol), float(amount))\n        return values\n    def add_data(self):\n\n        self.line_num = len(self.df) - 1\n        # 循环调用character()函数-读取每行数据\n        while self.line_num >= 0:\n            value_list = self.character()\n            try:\n                # 插入数据库\n                Sql.Sql_execution(\n                    f\"\"\"insert into stock ({tushare[\"Column\"]}) values \"\"\" + f\"(\\'{value_list[0]}\\',\\'{value_list[1]}\\',\\'{value_list[2]}\\',\\'{value_list[3]}\\',\\'{value_list[4]}\\',\\'{value_list[5]}\\',\\'{value_list[6]}\\',\\'{value_list[7]}\\',\\'{value_list[8]}\\',\\'{value_list[9]}\\',\\'{value_list[10]}\\')\")\n            except Exception:\n                # 出错信息\n                print(f\"{value_list[0]}-{value_list[1]}未被添加！\")\n            self.line_num -= 1\n            i += 1\n        print(f\"The data has been added to the stock database\")\n        return i\n"}, {"ctype": "p", "data": "3.主函数 包括了连接数据库 初始化tushare Pro接口 调用Fetch_Data，Sql_Data_Handle类 计算添加用时和添加数据条数的功能。"}, {"ctype": "code", "data": "if __name__ == '__main__':\n    count = 0\n    line_count = len(Stock_list)\n    print(\"连接数据库\")\n    Sql = DataServer_Sqlite3(\"stock\")  # 连接数据库\n    stock_code = Stock_list\n    # Sql.Empty_database()  # 清空数据库\n    # print(\"清空数据库\")\n    # Sql.Zero_Id()  # 将ID归零\n    # print(\"将ID归零\")\nfor key in stock_code:\n    try:\n        column = tushare[\"column\"] # config中的tushare字典\n        t1.set_token(tushare[\"token\"])  # token值\n        ts = t1.pro_api()  # 初始化pro接口\n        print(\"初始化pro接口成功\")\n        input_code = stock_code[key]\n        sd, ed = \"20181231\", \"20201231\"  # 起始日期，结束日期\n        print(f\"抓取{key}股票数据\")\n        start = time.perf_counter()  # 开始时间\n        df = Fetch_Data(input_code, sd, ed).web_spider()  # dataframe格式股票数据\n        line_num = Sql_Data_Handle(df, Sql.connection, Sql.curs).add_data()\n        end = time.perf_counter()  # 结束时间\n        # 记录用时\n        print(f\"添加{key}股票数据到数据库--成功,用时{start - end}\")\n        # 记录添加的数据条数\n        print(f\"{key} 共{line_num}条数据已添加到数据库！\")\n    except Exception as e:\n        print e\n    count += 1\n    print(f\"还剩{line_count - count}支股票...\")\n"}, {"ctype": "p", "data": "4.SQLserver作者用来处理sql语句所写的类。包括了连接数据库，执行sql语句，删除数据，拿取数据，清空数据库，归零id 功能。方便使用者使用。"}, {"ctype": "code", "data": "# -*- coding: utf-8 -*-\n\"\"\"此为处理sql语句的SQLserver.py\"\"\"\nimport sqlite3\nimport config\n\n\nclass DataServer_Sqlite3():\n    def __init__(self, db_name):\n        self.curs = ''\n        self.connection = ''\n        self.header = ''\n        self.data = ''\n        self.db_name = db_name\n        self.Connecting_database()\n\n    def Connecting_database(self):\n        self.connection = sqlite3.connect(config.dbPath)  # 连接数据库\n        self.curs = self.connection.cursor()\n\n    def Sql_execution(self, sql: str):\n        self.curs = self.curs.execute(sql)\n        self.connection.commit()\n\n    def delete_data(self, key, data):\n        self.curs = self.curs.execute(f\"delete from \" + key + \" where trade_date=\" + data)\n        self.connection.commit()\n        print(\"The data has been deleted\")\n\n    def Fetch_data(self):\n        self.header = self.curs.description\n        self.data = self.curs.fetchall()\n\n    def Empty_database(self, db_name: str):\n        self.curs = self.curs.execute(f\"DELETE FROM \\\"{db_name}\\\"\")\n        self.connection.commit()\n\n    def Zero_Id(self):\n        self.curs = self.curs.execute(f\"update sqlite_sequence set seq=0 where name='{self.db_name}'\")\n        self.connection.commit()\n\n    def Create_table(self, name: str, input_header: str):\n        \"\"\"sample: input_header =int primary key,ts_code,symbol,name,area,industry,market,list_date\"\"\"\n        self.Sql_execution(f\"create table {name}({input_header})\")\n"}, {"ctype": "p", "data": "用Tushare接口爬取完整代码"}, {"ctype": "code", "data": "# -*- coding: utf-8 -*-\n \"\"\"此处为用于爬取和存储到数据库的Tushare.py\"\"\"\nimport tushare as t1\nimport time # 用以计时\nfrom config import * # 此库为配置库\nfrom SQLserver import * # 此库为作者所写\n\nclass Fetch_Data():\n    \"\"\"code股票代码 sd开始日期 ed结束日期\"\"\"\n\n    def __init__(self, code, start_data, end_data):\n        self.code = code\n        self.sd = start_data\n        self.ed = end_data\n        # self.csv_name = \"csv_data/\" + csv_name + \".csv\"\n\n    def web_spider(self):  # 爬虫tushare接口\n        try:\n            df = ts.daily(ts_code=self.code, start_date=self.sd, end_date=self.ed)  # 爬取数据--dataframe格式\n            # daily方法所获取的数据ts_code,trade_date,open,high,low,close,pre_close,change,pct_chg,vol,amount,avgprice\n            # df.to_csv(self.csv_name) # 转换为csv文件\n            return df  # 返回数据\n        except Exception as e:\n\t\t\tprint(e) # 打印报错信息\nclass Sql_Data_Handle():\n    def __init__(self, df, connect, curs):\n        self.df = df\n        self.connect = connect\n        self.curs = curs\n\n    def character(self):\n        # df = pandas.read_csv(self.csv_name, encoding='gbk') # 用pandas库读取csv文件\n        line_num = self.line_num\n        # pandas的iloc函数读取每行对应数据\n        ts_code = self.df.iloc[line_num][\"ts_code\"]\n        trade_date = self.df.iloc[line_num][\"trade_date\"]\n        open = self.df.iloc[line_num][\"open\"]\n        high = self.df.iloc[line_num][\"high\"]\n        low = self.df.iloc[line_num][\"low\"]\n        close = self.df.iloc[line_num][\"close\"]\n        pre_close = self.df.iloc[line_num][\"pre_close\"]\n        change = self.df.iloc[line_num][\"change\"]\n        pct_chg = self.df.iloc[line_num][\"pct_chg\"]\n        vol = self.df.iloc[line_num][\"vol\"]\n        amount = self.df.iloc[line_num][\"amount\"]\n        # 将数据转换为元祖tuple格式\n        values = (\n            ts_code, trade_date, float(open), float(high), float(low), float(close), float(pre_close),\n            float(change), float(pct_chg), float(vol), float(amount))\n        return values\n    def add_data(self):\n\n        self.line_num = len(self.df) - 1\n        # 循环调用character()函数-读取每行数据\n        while self.line_num >= 0:\n            value_list = self.character()\n            try:\n                # 插入数据库\n                Sql.Sql_execution(\n                    f\"\"\"insert into stock ({tushare[\"Column\"]}) values \"\"\" + f\"(\\'{value_list[0]}\\',\\'{value_list[1]}\\',\\'{value_list[2]}\\',\\'{value_list[3]}\\',\\'{value_list[4]}\\',\\'{value_list[5]}\\',\\'{value_list[6]}\\',\\'{value_list[7]}\\',\\'{value_list[8]}\\',\\'{value_list[9]}\\',\\'{value_list[10]}\\')\")\n            except Exception:\n                # 出错信息\n                print(f\"{value_list[0]}-{value_list[1]}未被添加！\")\n            self.line_num -= 1\n            i += 1\n        print(f\"The data has been added to the stock database\")\n        return i\n\nif __name__ == '__main__':\n    count = 0\n    line_count = len(Stock_list)\n    print(\"连接数据库\")\n    Sql = DataServer_Sqlite3(\"stock\")  # 连接数据库\n    stock_code = Stock_list\n    # Sql.Empty_database()  # 清空数据库\n    # print(\"清空数据库\")\n    # Sql.Zero_Id()  # 将ID归零\n    # print(\"将ID归零\")\nfor key in stock_code:\n    try:\n        column = tushare[\"column\"] # config中的tushare字典\n        t1.set_token(tushare[\"token\"])  # token值\n        ts = t1.pro_api()  # 初始化pro接口\n        print(\"初始化pro接口成功\")\n        input_code = stock_code[key]\n        sd, ed = \"20181231\", \"20201231\"  # 起始日期，结束日期\n        print(f\"抓取{key}股票数据\")\n        start = time.perf_counter()  # 开始时间\n        df = Fetch_Data(input_code, sd, ed).web_spider()  # dataframe格式股票数据\n        line_num = Sql_Data_Handle(df, Sql.connection, Sql.curs).add_data()\n        end = time.perf_counter()  # 结束时间\n        # 记录用时\n        print(f\"添加{key}股票数据到数据库--成功,用时{start - end}\")\n        # 记录添加的数据条数\n        print(f\"{key} 共{line_num}条数据已添加到数据库！\")\n    except Exception as e:\n        print e\n    count += 1\n    print(f\"还剩{line_count - count}支股票...\")\n"}, {"ctype": "p", "data": "有需要股票代码和名称的私信我。"}, {"ctype": "p", "data": "有问题可以在评论区留言。如果喜欢这篇文章记得点赞哦！！！"}], "cate": "Python"}
{"题目": "开源GIS--geos实现空间连接", "作者": "weixin_45565792", "发布时间": "2021-03-27 00:15:02", "内容": [{"ctype": "p", "data": "开源GIS的官方教程为：https://www.osgeo.cn/pygis/ogr-ogrsa.html"}, {"ctype": "p", "data": "其中关于空间计算的只有简单的判断"}, {"ctype": "p", "data": " 而要真正实现空间连接，是需要将两个shp文件进行里外循环，例如，以其中一个shp的要素个数为外循环，以另一个shp要素数量为内循环，逐一判断是否存在空间上的关联（包含、被包含。。。）"}, {"ctype": "p", "data": "如此做循环肯定会影响程序执行的速度。因此可以使用Rtree作为索引，加快循环的检索。"}, {"ctype": "p", "data": "话不多说，下面上代码，以“包含”的空间关系做空间连接为例"}, {"ctype": "code", "data": "    #-----------------打开OSM数据---------------------------\n        osm_ds = ogr.Open(osmfile)\n        osm_lyr=osm_ds.GetLayer(0)\n        feat=osm_lyr.GetFeature(0)\n        keys_osm=feat.keys()\n        spatial=osm_lyr.GetSpatialRef()\n        count=osm_lyr.GetFeatureCount()\n\n        #---打开BUffer-----------\n        buffer_s=ogr.Open(bufferfile)\n        buff_lyr=buffer_s.GetLayer(0)\n        buff_feature=buff_lyr.GetFeature(0)\n        keys_buff=buff_feature.keys()\n\n        #--创建索引--\n        shp_index=index.Index()\n        #--shp几何数据导入Rtree--\n        for i,feat in enumerate(buff_lyr):\n            # geom=feat.GeometryDef()\n            geom = feat.GetGeometryRef()\n            bbox=geom.GetEnvelope()#<class 'tuple'>--left，right，buttom，top\n            # print(\"Type of bbox\",type(bbox),\"：\",bbox)\n            shp_index.insert(i,(bbox[0],bbox[2],bbox[1],bbox[3]))#---idx.insert(0, (left, bottom, right, top))\n\n        #--空间连接\n        # print()\n        gdal.SetConfigOption( \"GDAL_FILENAME_IS_UTF8\", \"YES\")\n        gdal.SetConfigOption( \"SHAPE_ENCODING\", \"UTF-8\")\n        Spatial_driver = ogr.GetDriverByName(\"ESRI Shapefile\")\n        spatial_ds = Spatial_driver.CreateDataSource(matchedfile)\n        match_lyr = spatial_ds.CreateLayer('matched',spatial)  # 创建缓冲区\n\n        #创建字段\n        # print(\"osm_keys:\",keys_osm)\n        osm_def = osm_lyr.GetLayerDefn()\n        # for i,each in enumerate(keys_osm):\n        #     fielddef=osm_def.GetFieldDefn(i)\n        #     if fielddef==None:\n        #         break\n        #     # print(fielddef)\n        #     # print(each)\n        #     fieldDefn = ogr.FieldDefn(each,fielddef.GetType())\n        #     match_lyr.CreateField(fieldDefn)\n        # print(\"Buffer_keys:\", keys_buff)\n        keys_match=keys_buff.copy()\n        keys_match.extend(keys_osm)\n        # print(\"matchedfile Fields:\", keys_match)\n        buff_def = buff_lyr.GetLayerDefn()\n        count_field=0\n        for i,key in enumerate(keys_match):\n            field=None\n            if key in keys_buff:\n                field=buff_def.GetFieldDefn(i)\n                count_field+=1\n            else:\n                field = osm_def.GetFieldDefn(i-count_field)\n            if field is None:\n                break\n            fieldDef= ogr.FieldDefn(key,ogr.OFTString)\n            fieldDef.SetWidth(254)\n            match_lyr.CreateField(fieldDef)\n\n\n        #---添加几何属性和字段属性----------\n        match_feat = ogr.Feature(match_lyr.GetLayerDefn())\n        # print(\"--创建空间连接...\")\n        for i,osm_feat in enumerate(osm_lyr):\n            # print(i+1,\"/%d\"%count,end=',')\n            geom = osm_feat.geometry().Clone()\n            match_feat.SetGeometry(geom)\n            # print(\"type of  geom\",type(geom))\n            #--buffer属性\n            feat_within=[]\n                #--在Rtree中寻找相交的部分要素\n            bbox=geom.GetEnvelope()\n            feat_id = list(shp_index.intersection((bbox[0],bbox[2],bbox[1],bbox[3])))\n            # for buffer_feat in buff_lyr:\n            #     if geom.Within(buffer_feat.geometry().Clone()):\n            #         feat_within.append(buffer_feat)\n            #---被包含的要素--\n            for idx in feat_id:\n                feat_temp=buff_lyr.GetFeature(idx)\n                if geom.Within(feat_temp.geometry().Clone()):\n                    feat_within.append(feat_temp)\n\n            if len(feat_within)==1:\n                for key in keys_match:\n                    if key in keys_osm:\n                        match_feat.SetField(key, str(osm_feat.GetField(key)))\n                        # print(key, \"(one):\", osm_feat.GetField(key), end=',')\n                    if key in keys_buff:\n                        # print(key, \"(one):\", feat_within[0].GetField(key), end=',')\n                        match_feat.SetField(key, (feat_within[0].GetField(key)))\n            elif len(feat_within)>1:\n                data = getMostvalue(feat_within)\n                for key in keys_match:\n                    if key in keys_osm:\n                        match_feat.SetField(key, str(osm_feat.GetField(key)))\n                        # print(key, \"(one of):\", osm_feat.GetField(key), end=',')\n                    if key in keys_buff:\n                        # print(key,\"(one of):\",feat_within[data].GetField(key),end=',')\n                        match_feat.SetField(key,str(feat_within[data].GetField(key)))\n            else:\n                # --osm属性\n                for key in keys_match:\n                    if key in keys_osm:\n                        match_feat.SetField(key, str(osm_feat.GetField(key)))\n                        # print(key, \"(None):\", osm_feat.GetField(key), end=',')\n                    else:\n                        match_feat.SetField(key,\"None\")\n                        print(key, \"(None):\",\"None\", end=',')\n            match_lyr.CreateFeature(match_feat)\n            # print()\n            feat_within.clear()\n            #--进度条---\n            # time.sleep(0.5)\n            # sys.stdout.write(\"创建空间连接...  %2f%%   \\r\" % (100*(i+1)/count))\n            # sys.stdout.flush()\n        # print()\n        spatial_ds.Destroy()"}, {"ctype": "p", "data": "以上是个人在做的一个项目的程序，简单的实现了快速的空间连接，关于Rtree的教程，可以百度搜索Rtree，使用的库包为geos和rtree。"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "在CSDN上很少看到有开源GIS方面的，这个东西还是太小众了hhh"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "Python创建二叉树", "作者": "English_yang", "发布时间": "2021-03-28 21:23:48", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "本文的内容是数据结构中二叉树部分最基础的，之所以写一下主要是为了方便刷题的时候，能够在自己电脑上很快的使用这种小的demo进行复杂的练习。"}, {"ctype": "head", "data": "二叉树节点定义"}, {"ctype": "p", "data": "二叉树的节点定义如下："}, {"ctype": "code", "data": "class TreeNode():#二叉树节点\n    def __init__(self,val,lchild=None,rchild=None):\n        self.val=val\t\t#二叉树的节点值\n        self.lchild=lchild\t\t#左孩子\n        self.rchild=rchild\t\t#右孩子\n"}, {"ctype": "head", "data": "递归构建二叉树"}, {"ctype": "p", "data": "本文使用的前序递归构建的方法（其余顺序读者自行变化，本文主要意在如何快速构建能够执行的二叉树） 例如，我们想构建一个如下图所示的树（其前序遍历结果为：abcde）:"}, {"ctype": "p", "data": "这里我们需要使用到扩展的二叉树，也就是要告诉计算机什么是叶结点，什么是空节点，否侧无法分辨左右节点。例如先序遍历的顺序为\"abcde\"，扩展的二叉树前序序列为：“abc##d##e##”，#代表此处节点为None，如下图："}, {"ctype": "p", "data": "既然是使用递归的方法构建二叉树，主要需要理解递归的过程，这种思路将在之后的很多地方用的到。 要知道如何递归的构建二叉树，我们不能纠结于递归每一层到底干了什么，这样就会一直纠结下去（所有的递归问题都一样）。我们需要注意的是："}, {"ctype": "p", "data": "在我们的任务中，终止条件是什么？在我们的任务中，本次递归要干嘛？在我们的任务中，本次递归要返回给上一次递归的是啥？"}, {"ctype": "p", "data": "在递归构建二叉树的任务中，我们要做到不纠结于每一层，而是只关注该层在做什么，这样，对于下图左侧的树，我们就可以看作为右侧的树，它只有自己a (a)，左子树B (bcd)和右子树C (e)。"}, {"ctype": "p", "data": "这样我们需要注意的那三个问题的回答自然就有了（做递归问题，心中要想着怎么回答这三个问题）："}, {"ctype": "p", "data": "在我们的任务中，终止条件是什么？ [给我们的字符用完，也就不需要再创建节点了]在我们的任务中，本次递归要干嘛？ [本次递归要创建三个节点，一个根节点，一个左节点，一个右节点]在我们的任务中，本次递归要返回给上一次递归的是啥？ [当然是返回一个本层构造好的树的根节点]"}, {"ctype": "p", "data": "理解了上述三个问题的回答，递归的代码自然可以写出："}, {"ctype": "code", "data": "def Creat_Tree(Root,val):\n    if len(vals)==0:#终止条件：val用完了\n        return Root\n    if vals[0]!='#':#本层需要干的就是构建Root、Root.lchild、Root.rchild三个节点。\n        Root = TreeNode(vals[0])\n        vals.pop(0)\n        Root.lchild = Creat_Tree(Root.lchild,val)\n        Root.rchild = Creat_Tree(Root.rchild,val)\n        return Root#本次递归要返回给上一次的本层构造好的树的根节点\n    else:\n        Root=None\n        vals.pop(0)\n        return Root#本次递归要返回给上一次的本层构造好的树的根节点\n"}, {"ctype": "p", "data": "看动了上述内容，构建一棵我们想象的二叉树就很简单了，只要输入一个我们心目中前序遍历扩展的二叉树序列即可："}, {"ctype": "code", "data": "if __name__ == '__main__':\n    Root = None\n    strs=\"abc##d##e##\"#前序遍历扩展的二叉树序列\n    vals = list(strs)\n    Roots=Creat_Tree(Root,vals)#Roots就是我们要的二叉树的根节点。\n"}], "cate": "Python"}
{"题目": "python pandas常用统计函数总结 -- 以及与groupby, pivot_table, describe, crossTab等方法结合使用的比较", "作者": "若芷兰", "发布时间": "2021-03-27 12:00:21", "内容": [{"ctype": "head", "data": "1. 背景描述"}, {"ctype": "p", "data": "数据分析中经常需要对数据特征的多种不同方式进行分组或归类，然后与统计函数结合使用，寻找信息的规律、数据间的差异或相关性等，从而更好地从数据中挖掘有价值的信息，服务于企业的运营和特定的问题解决。"}, {"ctype": "p", "data": "本文主要在这两方面进行总结："}, {"ctype": "p", "data": "数据分析中常用的统计函数（共12个聚合函数-python）的用法与4种不同的分组、归类方法结合使用的效果比较"}, {"ctype": "head", "data": "2. 数据分析常用统计函数总结"}, {"ctype": "head", "data": "2.1 常用的统计值对应的python函数"}, {"ctype": "p", "data": "平均数：np.mean()总和：np.sum()中位数：np.median()最大值：np.max()最小值：np.min()频次（计数）: np.size()方差：np.var()标准差：np.std()乘积：np.prod()协方差： np.cov(x, y)偏度系数(Skewness): skew(x)峰度系数(Kurtosis): kurt(x)正态性检验结果: normaltest(np.array(x))四分位数：describe() – 显示25%, 50%, 75%位置上的数据"}, {"ctype": "head", "data": "2.2 示例代码"}, {"ctype": "p", "data": "**基本使用方法 **"}, {"ctype": "code", "data": "import numpy as np\nimport pandas as pd\nimport scipy.stats as ss\n\nx = [5, 7, 6, 5, 8, 4, 7, 6, 4, 5]\nprint(\"x的平均值:\", np.mean(x))\nprint(\"x总和是:\", np.sum(x))\nprint(\"x的中位数:\", np.median(x))\nprint(\"x的最大值:\", np.max(x))\nprint(\"x的最小值:\", np.min(x))\nprint(\"x的数据个数:\", np.size(x))\nprint(\"x的方差:\", np.var(x))\nprint(\"x的标准差:\", np.std(x).round(2))\nprint(\"x的乘积:\", np.prod(x))\nprint(\"x的偏度(Skewness):\", skew(x))\nprint(\"x的正态检验结果:\", ss.normaltest(np.array(x)))\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114553249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkxNDQ1Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3. 聚合函数与分组归类方法的联合使用（Python代码）"}, {"ctype": "p", "data": "3.1 DataFrame数据表中分组进行统计 – 与groupby()联合使用"}, {"ctype": "code", "data": "# 3.1.1 建立数据表\nimport numpy as np\nimport pandas as pd \ndf = pd.DataFrame({\"名称\": [\"A\", \"B\", \"A\", \"A\", \"B\", \"A\"],\n                   \"颜色\": [\"红色\", \"蓝色\", \"红色\", \"蓝色\", \"蓝色\", \"红色\"],\n                   \"尺寸\": [\"大\", \"大\", \"小\", \"小\", \"大\", \"大\"],\n                   \"厚度\": [2, 5, 1, 2, 4, 5],\n                   \"数量\": [10, 20, 15, 30, 10, 20]})\ndf\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322234041782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkxNDQ1Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# 3.1.2 使用groupby()根据“名称”对“数量”进行分组统计\ndf.groupby([\"名称\"])[\"数量\"].sum()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322234405117.png"}, {"ctype": "code", "data": "# 3.1.3 groupby()函数传入分组列表，对数据进行多层分组统计\ndf.groupby([\"名称\", \"颜色\"])[\"数量\"].sum()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322234612534.png"}, {"ctype": "code", "data": "# 3.1.4 在之前的基础上，对被统计的数据传入列表，达到多层分组分类统计的效果 \ndf.groupby([\"名称\", \"颜色\"])[[\"数量\", \"厚度\"]].sum()\n"}, {"ctype": "p", "data": " 3.2 数据表中多层筛选的应用 – 透视表pivot_table的应用"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322234919551.png"}, {"ctype": "code", "data": "# 3.2.1 简单的分组分类统计汇总\npd.pivot_table(df, values=[\"数量\"], index=[\"名称\"], columns=[\"颜色\"], aggfunc=np.sum,fill_value=0, margins=True)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323000340661.png"}, {"ctype": "code", "data": "# 3.2.2 多层级的分组和分类统计汇总\npd.pivot_table(df, values=[\"数量\"], index=[\"名称\", \"尺寸\"], columns=[\"颜色\"], aggfunc=np.sum, fill_value=0, margins=True)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323000814259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkxNDQ1Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# 3.2.3 多层分组统计不同指标的不同统计量\npd.pivot_table(df, values=[\"数量\", \"厚度\"], index=[\"名称\"], columns=[\"颜色\"], aggfunc={\"数量\": np.sum, \"厚度\": np.var}, fill_value=0, margins=True)\n"}, {"ctype": "p", "data": " 蓝色框 – 分组计算厚度的方差 红色框 – 分组同步计算数量的总和 这种方法不但快速便捷，还能在同一个平面内展示不同指标使用不同的统计量计算的结果。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032300095260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkxNDQ1Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "3.3 四分位数 – describe()的应用方法"}, {"ctype": "code", "data": "# describe()函数 -- 对数据表中的所有的数值型进行快速的统计\ndf.describe()\n"}, {"ctype": "p", "data": " 3.4. 交叉表crossTab()函数"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327115253586.png"}, {"ctype": "code", "data": "# 交叉表crossTab()函数 -- 交叉表是用于统计分组频率的特殊透视表\ntab_ = pd.crosstab(df[\"名称\"], df[\"颜色\"], margins=True)\ntab_\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323001232688.png"}, {"ctype": "head", "data": "3、结束语"}, {"ctype": "p", "data": "综述以上4种方法，基本上都会认为pivot_table()相对而言是最便捷、灵活且功能强大的统计分析函数，也是在日常工作中常用的方法之一。其实，每种方法都有特色和针对的方向，根据实际情况灵活运用即可。"}], "cate": "Python"}
{"题目": "第三周 列表", "作者": "#江江江江江", "发布时间": "2021-03-27 12:49:56", "内容": [{"ctype": "p", "data": "列表元素的删除 1.del命令删除指定位置元素"}, {"ctype": "code", "data": ">>>a_list=[3,5,7,9]\n>>>del a_list[1]\n>>>a_list\n[3,7,9]\n"}, {"ctype": "p", "data": "2.pop（）方法"}, {"ctype": "code", "data": ">>>a_list=list((3,5,7,9))\n>>>a_list.pop()\n9\n>>>a_list\n[3,5,7]\n"}, {"ctype": "p", "data": "3.remove（）方法删除首次出现的指定元素"}, {"ctype": "code", "data": ">>>a_list=[3,5,7,9,7,11]\n>>>a_list.remove(7)\n>>>a_list\n[3,5,9,7,11]\n"}, {"ctype": "p", "data": "列表元素的访问访问与计数 1.用下标直接访问列表元素（若下标不存在，则抛出异常） 2.用index（）方法获取指定元素首次出现的下标 {index ( value , [ start , [ stop ] ] ) } start和stop指定搜索范围 start默认为0，stop默认为列表长度 例:"}, {"ctype": "code", "data": ">>>alist=[2,3,4,5,6,7]\n>>>alist.index(5)\n3\n"}, {"ctype": "p", "data": "切片操作 切片使用2个冒号分割3个数字来完成：[ start : stop : step ] 分别为开始位置，截至为止(不包含stop这个数) 和步长（默认为1）"}, {"ctype": "p", "data": "切片返回的是浅复制（浅复制指生成一个新的列表，并把原列表中所有元素的引用都复制到新列表中）"}, {"ctype": "p", "data": "列表的排序和逆序 1.使用sort()方法可以进行原地排序"}, {"ctype": "code", "data": ">>>alist=[3,8,9,4,6,2]\n>>>alist.sort()           #默认为升序\n>>>alist\n[2,3,4,6,8,9]\n"}, {"ctype": "code", "data": ">>>blist=[2,9,5,3,6,4,8,7]\n>>>blist.sort(reverse=Ture)    #降序排列\n>>>blist\n[9,8,7,6,5,4,3,2]\n"}, {"ctype": "p", "data": "2.使用内置函数sorted()对列表进行排序（该方法返回新列表，并不对原列表进行任何修改）"}, {"ctype": "code", "data": ">>>sorted(alist)          #升序\n[2,3,4,6,8,9]\n>>>sorted(blist,revers=True)   #降序\n>[9,8,7,6,5,4,3,2]\n"}, {"ctype": "p", "data": "3.使用reverse()方法将所有元素原地逆序"}, {"ctype": "code", "data": ">>>import random\n>>>alist=[random.randint(50,100)for i in range(10)]\n#生成随机数\n>>>alist\n[62, 88, 64, 88, 95, 70, 91, 79, 61, 51]\n>>>alist.reverse()    #逆序，首位交换\n>>>alist\n[51, 61, 79, 91, 70, 95, 88, 64, 88, 62]\n"}, {"ctype": "p", "data": "4.内置函数reversed()可对列表元素进行逆序排列（与reverse()方法不同，该内置函数不对原列表做任何修改，而是返回一个逆序排列后的迭代对象）"}, {"ctype": "code", "data": ">>>alist=[3,4,5,6,7,9,11,13,15,17]\n>>>newlist=reversed(alist)  #返回可迭代reversed对象\n>>>newlist\n<list_reverseiterator object at 0x000001CB6DB04340>\n>>>list(newlist)    #将reversed对象转换为列表\n[17,15,13,11,9,7,6,5,4,3]\n\n"}, {"ctype": "p", "data": "用于序列操作的常用内置函数 例： 1.enumerate(列表):枚举列表元素"}, {"ctype": "code", "data": ">>>for item in enumerate('abcd'):\n     print(item)\n(0,'a')\n(1,'b')\n(2,'c')\n(3,'d')\n"}, {"ctype": "p", "data": "2.map()函数"}, {"ctype": "code", "data": ">>>list(map(str,range(5)))  #把列表中元素转换为字符串\n['0','1','2','3','4']\n>>>def add5(v):\n     return v+5\n>>>list(map(add5,range(10)))\n[5,6,7,8,9,10,11,12,13,14]\n"}, {"ctype": "p", "data": "3.zip()函数"}, {"ctype": "code", "data": ">>>list(zip('abcd',[1,2,3]))\n[('a',1),('b',2),('c',3)]\n"}, {"ctype": "p", "data": "… 习题    做题过程中用输入输出，循环遍历，判断和zip()函数，sort()方法等得出结果。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327124510251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqampqal8=,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python基础——随机漫步", "作者": "按敲打", "发布时间": "2021-03-28 21:34:16", "内容": [{"ctype": "p", "data": "  模仿醉汉在二维空间上的随机漫步：一个醉汉喝醉酒，每次只能走一步，每步分别沿着x，y轴走一个单位长度，试着画出醉汉的轨迹。"}, {"ctype": "p", "data": "方法一：沿坐标轴移动（四个方向选择或八个方向选择）"}, {"ctype": "code", "data": "import numpy as np\nimport matplotlib.pyplot as plt\n# 定义初始位置坐标 a、b\na = 0\nb = 0\n# 定义列表 x、y, 为走过的位置记录\nx = [a]\ny = [b]\n# 下一步可以选择的方向\n# 四个方向\noption = np.array([[0, 1], [1, 0], [0, -1], [-1, 0]])\n# 八个方向\n# option = np.array([[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, -1], [-1, 1]])\n# 设置步数\nsteps = 1000\n# 随机漫步\nfor i in range(steps):\n    # 随机选择下一步的方向\n    next = np.random.randint(len(option))\n    # 更新当前位置\n    a += np.array(option[next])[0]\n    b += np.array(option[next])[1]\n    # 保存到位置记录列表\n    x.append(a)\ny.append(b)\n# 画图\n# 设置初始点为红色\nplt.scatter(0, 0, c='r')\nplt.plot(x, y, c='b')\nplt.show()\n"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "table", "data": "四个方向移动结果八个方向移动结果"}, {"ctype": "p", "data": "方法二：沿任意方向移动一单位长度"}, {"ctype": "code", "data": "import numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# 定义初始位置坐标 a、b\na = np.random.randint(10)\nb = np.random.randint(10)\n# 定义列表 x、y, 为走过的位置记录\nx = [a]\ny = [b]\n# 设置步数\nsteps = 1000\n# 随机漫步\nfor i in range(steps):\n    # 随机选择下一步的方向 0 ~ 360 任意方向\n    next_steps = np.random.randint(360)\n    # 角度转化为对应的弧度制,便于计算一单位长度 x、y 坐标的变化\n    angle = np.deg2rad(next_steps)\n    # 更新当前位置\n    a += math.cos(angle)\n    b += math.sin(angle)\n    # 保存到位置记录列表\n    x.append(a)\n    y.append(b)\n    # 实时画图\n    # plt.clf()    # 清除之前画的图\n    # plt.scatter(x[0], y[0], c='r')\n    # plt.plot(x, y, c='b')\n    # plt.pause(0.1)     # 暂停多少秒\n    # plt.ioff()\n# 画图，设置初始点为红色\nplt.scatter(x[0], y[0], c='r')\nplt.plot(x, y, c='b')\nplt.show()\n"}, {"ctype": "p", "data": "运行结果：    从结果可以看出不管是四个方向移动，还是八个方向移动，还是任意方向移动的，整体的效果都是无序的，因为在每一步选择方向的时候，都是随机选择的，使得下一步是不确定的，所以整体上看都是无序的。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328213208240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzgwMg==,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "#物理实验数据的代码简化处理（Python）", "作者": "AGIN-s", "发布时间": "2021-03-27 01:24:45", "内容": [{"ctype": "p", "data": "**"}, {"ctype": "head", "data": "物理实验数据的代码处理"}, {"ctype": "p", "data": "**"}, {"ctype": "p", "data": "物理实验（测量杨氏模量）数据的处理代码"}, {"ctype": "p", "data": "Time：3/27/17:30.发现了一个Bug,代码已经稍微做了改动"}, {"ctype": "code", "data": "from math import *\n#关于金属丝伸长中标尺数据的处理\nlist1=[]\n#list2=[]\nlist3=[]\n#list4=[]\nm=0\n#t=0\nsum0=0#逐差法得到数据进行差的平方求和\nsum=0#读数逐差法得到的数据求和\nwhile 1:\n    data=eval(input(\"请从小到大输入金属丝在增重时的标尺像读数的平均值（ni），输入负数值停止\"))   #循环输入\n    if data<0:\n        break\n    list1.append(1)\n    list1[m]=data#列表储存源试验数据\n    m+=1\n#while 1:\n    #data = eval(input(\"请从小到大输入金属丝在减重时的标尺像读书，输入负数值停止\"))  # 循环输入\n    #if data < 0:\n        #break\n    #list2.append(1)\n    #list2[t] = data  # 列表储存源试验数据\n    #sum+=data\n    #t+=1\nfor y in range(m-1):\n    list3.append(1)\n    list3[y]=list1[y+1]-list1[y]#原始测量数据逐差法求变化量\n    sum+=list3[y]\n#for y in range(t-1):\n    #list4.append(1)\n    #list4[y]=list2[y+1]-list2[y]\n#list3.extend(list4)\ndn_=sum/(m-1)\ndeltn=dn_\nprint(\"标尺读数变化的平均值是：{}\".format(dn_))\n\nlist3[:]=[y-dn_ for y in list3]#列表每一个都减去平均值\nfor i in list3:\n    sum0+=i**2\non=(sum0/(m-2))**0.5#计算标准差\non_=on/((m-1)**(0.5))\nprint(\"标准差为：{}\".format(on))\n\n#关于金属丝直径d的数据处理\nlist=[]\nsum1=0   #总分\nn=0     #总人数\naverage=0  #平均分\nsum2=0#差平方和\n\nwhile 1:\n    data=eval(input(\"请输入多个金属丝修正后的直径di，输入负数值停止\"))   #循环输入\n    if data<0:\n        break\n    list.append(1)\n    list[n]=data#列表储存源试验数据\n    sum1+=data\n    n+=1\n\naverage = sum1/n#计算d平均值\ndeltaverage=average\nprint(\"金属丝直径的平均值是：{}\".format(average))\nlist[:]=[y-average for y in list]#列表每一个都减去平均值\nfor i in list:\n    sum2+=i**2\noi=(sum2/(n-1))**0.5#计算标准差\noi_=oi/(n**(0.5))\nprint(\"标准差od为：{}\".format(oi))\nprint(\"od除以根号n={}\".format(oi_))\n\n\n#计算被测金属丝的杨氏弹性模量\nd=eval(input(\"输入镜尺距离(mm)：\"))*0.001\nl=eval(input(\"输入金属丝长度(mm)：\"))*0.001\nk=eval(input(\"输入光杠杆常数(mm)：\"))*0.001\ndn=eval(input(\"请输入标尺读数变化的平均值(mm)\"))*0.001#化成国际单位制\naverage*=0.001#化成国际单位制\nod=0\nol=0\nok=0#因为实验中只测了一组数据，为了简化计算，暂且均按照0处理\n\n\nom=0.003\nf=9.79163\nof=om*(9.79163)\nE_=(8*d*l*f)/(pi*(average**2)*k*dn)\nEe=((ol/l)**2+(of/f)**2+(od/d)**2+(oi_/deltaverage)**2+(ok/k)**2+(on_/deltn)**2)**(0.5)\noe_=Ee*E_\n\nprint(\"E={}+/-{}\".format(E_,oe_))\nprint(\"Ee={}*100%\".format(Ee))\n\n#代码结束\n\n\n\n"}], "cate": "Python"}
{"题目": "python爬虫入门学习3 批量爬取小说并生成文件", "作者": "Evol_ve", "发布时间": "2021-03-28 17:53:07", "内容": [{"ctype": "code", "data": "#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@author:Evolve Hsu\n@file:thread_book.py\n@time:2021/03/26\n\"\"\"\nimport re\nimport urllib\nimport threading\nfrom urllib import request, error  # 制定URL 获取网页数据\n\nfrom bs4 import BeautifulSoup  # 网页解析 获取数据\nimport sqlite3  # sqlite3 数据库操作\nimport time\nfrom book import NewBook\n\nheaders = {\n    'User-Agent': ' Mozilla/5.0 (Windows NT 10.0 Win64 x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.54'\n}\nparent_url = 'http://www.xbiquge.me'\n\n\n# 异步线程对象\nclass MyThread(threading.Thread):\n\n    def __init__(self, func, book, book_list):\n        threading.Thread.__init__(self)\n        self.book = book\n        self.book_list = book_list\n        self.func = func\n\n    def run(self):\n        self.func(self.book, self.book_list)\n\n\n# 获取小说首页html\ndef get_index_html(url):\n    while True:\n        request = urllib.request.Request(url=url, headers=headers)\n        try:\n            resp = urllib.request.urlopen(request)\n            html = resp.read().decode(\"utf-8\")\n            break\n        except urllib.error.URLError as e:\n            print(e)\n            print(\"异常链接: \" + url)\n            time.sleep(5)\n    return html\n\n\n# 获取章节list\ndef getElementList(url):\n    link_list = []\n    # 获取首页\n    index = parent_url + url\n    html = get_index_html(index)\n    # 解析首页\n    bs = BeautifulSoup(html, \"lxml\")\n    elementList = bs.find('div', id=\"list\").find_all('a')\n    for data in elementList:\n        # 根据 href名提取内容\n        link = data.get('href')\n        if link != 'chapter.html':\n            link_list.append(link)\n    set(link_list)\n    return link_list\n\n\n# 解析数据\ndef resolve_element(book, book_list):\n    text = []\n    url = parent_url + book.element\n    while True:\n        print(\"准备解析 html: \" + url)\n        request = urllib.request.Request(url=url, headers=headers)\n        try:\n            resp = urllib.request.urlopen(request)\n            html = resp.read().decode(\"utf-8\")\n            bs = BeautifulSoup(html, \"lxml\")\n            for item in bs.find('div', id=\"content\").find_all('p'):\n                text.append(item.text.replace('xbiquge/最快更新！无广告！', ''))\n            # 标题\n            book.__setattr__('title', bs.select('body > div.content_read > div > div.bookname > h1 > a')[0].text)\n            # 链接\n            book.__setattr__('link', url)\n            # 序号\n            book.__setattr__('number', int(url.split('_')[1].replace('.html', '')))\n            # 内容\n            book.__setattr__('text', ''.join(text))\n            book_list.append(book)\n            break\n        except Exception as e:\n            print(e)\n            print('发生异常 休息5秒: ' + url)\n            time.sleep(5)\n    print(\"本线程任务完成: \" + url)\n\n\n# 批量保存数据到数据库\ndef save_new_book(book_list):\n    print('准备保存数据 数量: %d' % len(book_list))\n    db_path = \"newbook.db\"\n    # init_db(db_path)  # 初始化数据库\n    conn = sqlite3.connect(db_path)\n    c = conn.cursor()\n    sql = \"insert into new_book (book_name,author,number,title ,link, data) values\"\n    total = 0\n    for book in book_list:\n        values = \"('\" + book.book_name + \"'\" + ',' + \"'\" + book.author + \"'\" + ',' + \"'\" + str(\n            book.number) + \"'\" + ',' + \"'\" + book.title + \"'\" + ',' + \"'\" + book.link + \"'\" + ',' + \"'\" + book.text + \"')\"\n        total = total + 1\n        if total == len(book_list):\n            values = values + ';'\n        else:\n            values = values + ','\n        sql = sql + values\n    c.execute(sql)\n    conn.commit()\n    c.close()\n    conn.close()\n\n\n# 数据库表初始化\ndef init_db(savePath):\n    sql = '''\n            create table new_book\n            (\n                id integer primary key autoincrement,\n                book_name varchar ,\n                author varchar,\n                number integer ,\n                title varchar,\n                link varchar ,\n                data text \n            );\n        '''\n    conn = sqlite3.connect(savePath)\n    c = conn.cursor()\n    c.execute(sql)\n    conn.commit()\n    conn.close()\n    print(\"init_db success\")\n\n\n# 根据书名查找书\ndef search_book_name(book_name):\n    search_url = 'https://www.xbiquge.me/search/result.html?searchkey=' + urllib.parse.quote(book_name)\n    while True:\n        request = urllib.request.Request(url=search_url, headers=headers)\n        try:\n            resp = urllib.request.urlopen(request)\n            html = resp.read().decode(\"utf-8\")\n            break\n        except urllib.error.URLError as e:\n            print(e)\n            time.sleep(1)\n    return html\n\n\n# 根据查询结果页 保存结果集\ndef resolve_book_base(book_search_html):\n    book_name_list = []\n    book_link_list = []\n    book_author_list = []\n    bs = BeautifulSoup(book_search_html, \"lxml\")\n    name_link_list = bs.find_all('span', class_=re.compile('s2'))\n    author_list = bs.find_all('span', class_=re.compile('s4'))\n    total = 0\n    # 2个集合一起循环解析内容并返回\n    for name_link, author in zip(name_link_list, author_list):\n        if total != 0:\n            book_name_list.append(name_link.text)\n            book_link_list.append(name_link.a.get('href'))\n            book_author_list.append(author.text)\n        total = total + 1\n    return book_name_list, book_link_list, book_author_list\n\n\n# 保存小说到文件\ndef generate_file(book_list, file_name, author, file_path):\n    print('准备写入数据: ' + file_name)\n    fo = open(file_path + file_name + '-' + author + '.txt', \"ab+\")  # 打开小说文件\n    for book in book_list:\n        # 以二进制写入章节题目 需要转换为utf-8编码，否则会出现乱码\n        fo.write(('\\r' + book.title + '\\r\\n').encode('UTF-8'))\n        # 以二进制写入章节内容\n        fo.write((book.text).encode('UTF-8'))\n    fo.close()  # 关闭小说文件\n\n\nif __name__ == '__main__':\n    book_name = '斗破苍穹'\n    file_path = 'C://Users//EvolveHsu//Desktop//爬虫小说下载//'\n    book_search_html = search_book_name(book_name)\n    book_name_list, book_link_list, book_author_list = resolve_book_base(book_search_html)\n    book_list = []\n    for baseUrl, name, author in zip(book_link_list, book_name_list, book_author_list):\n        elementList = getElementList(baseUrl)\n        # 单线程测试用\n        # resolve_element(NewBook(elementList[0], book_name, author, None, None, None, None))\n\n        # 多线程 resolve_element为执行方法\n        threadList = [MyThread(resolve_element, NewBook(element, book_name, author, None, None, None, None), book_list)\n                      for element in elementList]\n        startTotal = 0\n        for t in threadList:\n            startTotal = startTotal + 1\n            t.setDaemon(True)\n            t.start()\n            if startTotal == 10:\n                sleep_time = 5\n                print('启动线程达到 %d 条休息 %d 秒' % (startTotal, sleep_time))\n                time.sleep(sleep_time)\n                startTotal = 0\n        for i in threadList:\n            i.join()\n        # 根据章节编号排序\n        book_list.sort()\n        # 生成文件\n        generate_file(book_list, book_name, author, file_path)\n        book_list = []\n    # 保存数据到数据库\n    # print(\"爬取数据完成 准备保存数据\")\n    # save_new_book(book_list)\n\n"}], "cate": "Python"}
{"题目": "python+opencv实现连通区域分离", "作者": "qq_36104890", "发布时间": "2021-03-27 11:20:23", "内容": [{"ctype": "head", "data": "python+opencv实现连通区域分离"}, {"ctype": "p", "data": "步骤： 1.扫描整幅图像，判断当前像素点是前景点同时还未打上标签，将该像素点入栈。 （1）将当前栈中top元素出栈，通过4邻域判断(也需要同时满足是前景点未打上标签)进行元素入栈，同时对入栈的元素打上标签。 (2) 重复(1)中的操作，直到栈表为空，退出当前循环，至此一个连通域的标签打完。 2.重复1中的所有操作。"}, {"ctype": "head", "data": "代码部分"}, {"ctype": "code", "data": "def Connected_Separation(image):\n    image_shape = image.shape\n    rows = image_shape[0]\n    cols = image_shape[1]\n    index_map = np.zeros((rows, cols))\n    label = 1\n    for row in range(rows):\n        for col in range(cols):\n            # 扫描当前像素为前景且没有被访问过，将其入栈\n            if image[row][col] == 1 and index_map[row][col] == 0:\n                # 创建新站\n                s = []\n                # 入栈\n                s.append((row, col))\n                # 我们将(row,col)赋予一个label值\n                index_map[row][col] = label\n                # 循环判断4连通域是否与这个（row，col）相连，如果相连进行入栈操作，如果这个栈不为空\n                while (len(s) != 0):\n                    # 出栈,判断出栈元素的4领域\n                    a = s.pop()\n                    # 这边出栈的元素是不是还得赋予一个值\n                    # 判断，可以入栈的元素，但是我还需要判断这个栈里面是否有这个元素，如果存在这个元素，那么就不能入栈\n                    p=[]\n                    p.append((a[0],a[1]-1 if a[1]-1>0 else 0))\n                    p.append((a[0],a[1]+1 if a[1]+1<cols-1 else cols-1))\n                    p.append((a[0]-1 if a[0]-1>0 else 0,a[1]))\n                    p.append((a[0]+1 if a[0]+1<rows-1 else rows-1,a[1]))\n                    # 判断栈里面是否以已经存在需要入栈的元素\n                    for i in range(4):\n                        if  image[p[i][0],p[i][1]] == 1 and index_map[p[i][0],p[i][1]] == 0:\n                            s.append(p[i])\n                            index_map[p[i][0], p[i][1]] = label\n                    # 当栈里面的元素全部出去之后，我们的while就结束\n                    if len(s) == 0:\n                        label += 1\n                        break\n    return index_map\n\nif __name__ == '__main__':\n    image = cv2.imread('../imgs/2.jpg', 0)\n    # 进行二值化\n    ret1, th1 = cv2.threshold(image, 0, 255, cv2.THRESH_OTSU)  # 也就是大于0的都写出255\n    # 翻转\n    image = 1 - th1 / 255\n    kernel = np.ones((2, 2))\n    # 孔洞填补(闭运算)\n    image = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel=kernel)\n    index_map =Connected_Separation(image)\n    plt.imshow(image, plt.cm.gray)\n    plt.show()\n"}, {"ctype": "code", "data": "\n"}], "cate": "Python"}
{"题目": "2021-03-27", "作者": "失忆969", "发布时间": "2021-03-27 19:15:23", "内容": [{"ctype": "p", "data": "运算符 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032816520521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjU4NzU3Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "注意："}, {"ctype": "p", "data": "运算符的优先级"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328162635532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjU4NzU3Mg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "接口自动化（四）：框架搭建（Python）", "作者": "芳草乀", "发布时间": "2021-03-28 18:59:20", "内容": [{"ctype": "p", "data": "今天更新最后一篇接口自动化的内容：框架搭建，建议大家提前了解unittest框架"}, {"ctype": "head", "data": "框架目录结构"}, {"ctype": "p", "data": "框架分为五部分（配置、测试数据文件、测试脚本、启动主函数、报告） "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328175617515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTYyNDIyNw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "配置层："}, {"ctype": "p", "data": "配置文件为csv格式，给大家看下样式：主要包括脚本路径，脚本名称，测试是否执行和执行顺序"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032817295867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTYyNDIyNw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "数据层："}, {"ctype": "p", "data": "数据文件也是csv文件格式，主要存放的是接口所需要的数据，这里我只有一个接口用到了数据文件，给大家看下什么样子： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328174008523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTYyNDIyNw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "第一列：请求url 第二列：预期结果（第一个没有预期结果，因为我测试的是更新信息接口，依赖登录，所以我登录成功就行了，没有做断言） 第三列：请求的参数个数 第四列及以后：参数名称及参数值 该文件放在testdatafile目录下的ind_interface"}, {"ctype": "head", "data": "测试脚本："}, {"ctype": "p", "data": "测试脚本，和我前几期讲的差不多，就是发请求，断言，不过这里有个新东西和大家说下，就是sessionID问题，因为实际工作中有好多请求就是依赖这些东西，我这里是更新用户信息，需要用户登录返回来的sessionID，直接上代码："}, {"ctype": "code", "data": "import os\nfrom HTMLTestRunner import HTMLTestRunner\nimport requests\nimport unittest\nimport csv\nclass test_updateuser_v3(unittest.TestCase):\n#unittest框架中setUp方法是在每个测试case前都执行一遍\n    def setUp(self):\n    #获取当前路径，如果路径混乱时，大家可以print打印去调试\n        path = os.getcwd()\n        # 一个点上一级 两个点上上一级\n        p1 = os.path.abspath(os.path.dirname(path) + os.path.sep + \".\")\n        self.fpath = p1 + \"\\\\testdatafile\\ind_interface\\\\test_updateuser.csv\"\n        print(self.fpath)\n        self.file = open(self.fpath, 'r')\n        table = csv.reader(self.file)\n        userinfo = {}\n        拿到登录的用户名和登录密码，所以这里参数写死掉了\n        for row in table:\n            url = row[0]\n            userinfo[row[3]] = row[4]\n            userinfo[row[5]] = row[6]\n            break\n        response = requests.post(url, data=userinfo)\n       #拿到登录返回来的jsessionid\n        self.sessionID = dict(response.cookies)['JSESSIONID']\n        self.file.close()\n        #更新用户信息，unittest框架中测试方法必须以test开头\n    def test_03(self):\n        self.file2 = open(self.fpath, 'r')\n        #这里为什么是num=0呢，是因为文件的第一行是登录请求url,所以我第一行要跳过，下面做判断用\n        num = 0\n        table = csv.reader(self.file2)\n        for row in table:\n            userinfo = {}\n            #第一行就跳过了\n            num = num + 1\n            if num > 1:\n            #拿到url\n                url = row[0]\n               #拿到参数个数，类似我前几篇方法一样，我就不一一解释了\n                j = int(row[2])\n                expresult = row[1]\n                for i in range(3, 2 * j + 3, 2):\n                    userinfo[row[i]] = row[i + 1]\n                # print(userinfo)\n                session = {'JSESSIONID': self.sessionID}\n                #这里多了cookies参数，请注意\n                response = requests.post(url, data=userinfo, cookies=session).text\n                print(response)\n                #这里断言：判断response里面是否有更新个人信息成功字段，比if简单多了\n                self.assertIn(\"更新个人信息成功\", response)\n        self.file2.close()\n"}, {"ctype": "p", "data": "该脚本放在script目录下面的ind_interface"}, {"ctype": "head", "data": "启动主函数"}, {"ctype": "p", "data": "主要记录了怎么去按照配置文件里面的标识去执行脚本："}, {"ctype": "code", "data": "import csv\nimport operator\nimport os\nimport unittest\n#这里用HTMLTestRunner生成报告，需要把该python文件放到项目目录下面\nfrom HTMLTestRunner import HTMLTestRunner\n\nif __name__ == '__main__':\n    path = os.getcwd()\n    p2 = os.path.abspath(os.path.dirname(path) + os.path.sep + \".\")\n    #报告名字\n    filename = p2 + \"\\\\testresultfile\\ind_interface\\\\test_updatauser_report.html\"\n    #以二进制写报告\n    report=open(filename,'wb')\n\n    file = open('D:\\Learn\\\\automation\\interfaceframework\\config\\config.csv', 'r')\n    #下面注释的两行是获取配置文件里一共多少行\n    # line=len(open('D:\\Learn\\\\automation\\interfaceframework\\config\\config.csv').readlines())\n    # print(line)\n    table = csv.reader(file)\n    lis = []\n    n = 0\n    dic = {}\n    for row in table:\n    #跳过第一行\n        if n > 0:\n            dic = {}\n           #拿到测试脚本路径，测试脚本名称\n            dic[row[1]] = row[0]\n            #拿到测试顺序\n            dic['num'] = row[3]\n            #拿到测试状态：即是否执行\n            dic['state']=row[2]\n        # print(dic)\n        if dic != {}:\n        #把他们装到列表里面\n            lis.append(dic)\n      #n为csv行数\n        n = n + 1\n     #这里是把列表按照num排序\n    dicn = sorted(lis, key=operator.itemgetter('num'))\n    #给大家看下dicn结果排序内容：\n    #[{'test_updateuser_v2.py': 'D:\\\\Learn\\\\automation\\\\interfaceframework\\\\script\\\\ind_interface', 'num': '1', 'state': 'YES'}, {'test_updateuser_v3.py': 'D:\\\\Learn\\\\automation\\\\interfaceframework\\\\script\\\\ind_interface', 'num': '2', 'state': 'YES'}]\n    # print(dicn)\n#相当于循环配置文件了\n    for i in range(0, n - 1):\n        m = 0\n        #拿到字典里的值\n        for content in dicn[i].items():\n            if m == 0:\n           #拿到测试文件名，测试文件路径\n                fname = content[0]\n                fpath = content[1]\n                print(fname, fpath)\n            if m==2:\n                state=content[1]\n               #判断是否执行该脚本\n                if state=='YES':\n              #加载测试case\n                    discover = unittest.defaultTestLoader.discover(fpath, pattern=fname)\n                    runner = HTMLTestRunner(stream=report, title=\"测试报告\", description=\"更新接口\")\n                    #执行加载的测试案例\n                    runner.run(discover)\n            m = m + 1\n    report.close()\n"}, {"ctype": "head", "data": "报告层："}, {"ctype": "p", "data": "生成的报告会直接在这个目录下面： 报告样式： 两个测试脚本，两个测试报告 自动化测试差不多就到这里结束了，欢迎大家多多留言，下一期我们讲性能测试了啦"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328185539228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTYyNDIyNw==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "学习Python的第二课总结2021.03.26", "作者": "cai0629yun745", "发布时间": "2021-03-28 01:33:28", "内容": [{"ctype": "head", "data": "学习Python第二课"}, {"ctype": "head", "data": "日期：2021年03月26日 讲师：风陨老师"}, {"ctype": "head", "data": "Python基础知识点及运用方法"}, {"ctype": "head", "data": "一、变量"}, {"ctype": "p", "data": "变量：'装’程序中的数据"}, {"ctype": "p", "data": "变量名---- 标识符： 是独一无二的"}, {"ctype": "p", "data": "​ 1.标识符可以由字母、数字、下划线（_)组成，其中数字不能打头"}, {"ctype": "p", "data": "​ 2.标识符不能是Python关键字，但可以包含关键字"}, {"ctype": "p", "data": "​ 3.标识符不能包含空格"}, {"ctype": "p", "data": "赋值：将数据放入变量的过程"}, {"ctype": "code", "data": "name = 1  # name 就是变量名又称标识符，1 是变量名的赋值\nprint(name)\n1\n"}, {"ctype": "head", "data": "二、运算"}, {"ctype": "head", "data": "运算中的类型"}, {"ctype": "head", "data": "1. + ---- 加法运算"}, {"ctype": "code", "data": "a = 1\nb = 2\nc = a+b\nprint(c)\n3\n"}, {"ctype": "head", "data": "2. — ---- 减法运算"}, {"ctype": "code", "data": "a = 3\nb = 2\nc = a-b\nprint(c)\n1\n"}, {"ctype": "head", "data": "3. * ---- 乘法运算"}, {"ctype": "code", "data": "a = 3\nb = 2\nc = a*b\nprint(c)\n6\n"}, {"ctype": "head", "data": "4. / ---- 除法运算"}, {"ctype": "code", "data": "a = 4\nb = 2\nc = a/b\nprint(c)\n2\n"}, {"ctype": "head", "data": "5. % ---- 取余运算"}, {"ctype": "code", "data": "a = 4\nb = 3\nc = a%b\nprint(c)\n1\t\t\t# 这里为什么会是 1 呢，因为3不能被整除，还有余数1\n\na = 4\nb = 2\nc = a%b\nprint(c)\n0\t\t\t# 能被整除时，余数就是0呢\n"}, {"ctype": "head", "data": "6. ** ---- 幂运算（平方）"}, {"ctype": "code", "data": "a = 2\nb = 2\nc = a**b\nprint(c)\n4\t\t\t# 2平方 2*2=4 \n\na = 2\nb = 4\nc = a**b\nprint(c)\n16\t\t\t# 2的4次方 2*2*2*2=16 \n"}, {"ctype": "head", "data": "7. // ---- 整除运算 向下取整"}, {"ctype": "code", "data": "a = 3\nb = 2\nc1 = a/b \nc2 = a//b\nprint(c1)\n1.5\t\t\t# 不能被整除时，会有小数点\nprint(c2)\n1\t\t\t# 但在整除运算时，会把小数点去掉，只要整数 \n"}, {"ctype": "head", "data": "8. == ---- 判断"}, {"ctype": "code", "data": "a = 1\nb = 1\nprint(a == b)\nTrue\t\t# True 布尔值  判断 a 是否等于 b  是返回 True\n\na = 1\nb = 2\nprint(a == b)\nFalse\t\t# False 布尔值 判断 a 是否等于 b  不是返回 False\n"}, {"ctype": "head", "data": "9. round() ---- 取整 四舍五入"}, {"ctype": "code", "data": "a = 7\nb = 5\nc = a/b     \nprint(round(c))\n1\t\t\t# 7/5 = 1.4 不能被整除，舍掉小数0.4  向下取整\n\na = 7\nb = 4\nc = a/b     \nprint(round(c))\n2\t\t\t# 7/4 = 1.75 不能被整除，大于0.5  向上取整\n\na = 1\nb = 2\nd = 10\nc = a/b \ne = a/d\nprint(round(c))\n0\t\t\t\nprint(round(e))\n0\t\t\t# 当分子为1时 不会四舍五入取整，会直接取值为0 \n"}, {"ctype": "head", "data": "10. math ---- 函数模块"}, {"ctype": "code", "data": "import math\n\na = 6.6\nb = math.ceil(a)\nc = math.floor(a)\nprint('向上取整为', b) \n向上取整为 7\t\t\t\t#向上取整数为 7\nprint('向下取整为', c)\n向上取整为 6\t\t\t\t#向下取整数为 6\n\t\t\t\t\t\t#这里不管小数点后面的大小\n\n网上查找到的一些math函数模块运用方法\nd = 3\ne = math.sqrt(d)\nprint('平方根的值为', e)\n1.7320508075688772\n\nf = math.exp(d)\nprint('e的N次幂的值为', f)\n20.085536923187668\n\ng = 625\nh = 5\ni = math.log(g,h)\nprint('对数计算的值为', i)\n4.0\n\n"}, {"ctype": "head", "data": "11. decimal ---- 模块 精度计算"}, {"ctype": "code", "data": "import decimal\t\t\t\t# 数值需要传入字符串中，未放入字符串的会同下方一样\na = decimal.Decimal('2.2')  \nb = decimal.Decimal('2.0')\nc = a-b\nprint(decimal.Decimal(c))\n0.2\t\t\t\t\n\nimport decimal\t\t\t\t#只是用decimal模块来计算时，会精确到小数点后50位数\na = 2.2\nb = 2.0\nc= a-b\nprint(decimal.Decimal(c))\n0.20000000000000017763568394002504646778106689453125 \n \n"}, {"ctype": "head", "data": "三、数值类型"}, {"ctype": "head", "data": "1. int ---- 整数"}, {"ctype": "code", "data": "1， 2， 3， 4， 5  \t\t  # 整数类型\n"}, {"ctype": "head", "data": "2. float ---- 浮点数"}, {"ctype": "code", "data": "0.5, 1.1, 3.6, 7.7\t\t # 浮点数类型\n"}, {"ctype": "head", "data": "3. bool ---- 布尔值"}, {"ctype": "code", "data": "bool: Ture(1)  False(0)  # 在布尔值中只有两种方式，所对应的就是1和0\n"}, {"ctype": "head", "data": "4. complex ---- 复数"}, {"ctype": "code", "data": "complex(1+2j)   \t\t # 前面的1是实部，后面的2j是虚部，加起来就是一个复数\n"}, {"ctype": "head", "data": "5. type ---- 查看数据类型 注：重点 重点 重点 一个常用的类型"}, {"ctype": "code", "data": "print(type(1))\n<class 'int'>       # 1 是一个整数类型\n\nprint(type(2.5))\n<class 'float'>\t\t# 2.5 是一个浮点数类型\n\nprint(type(Ture))\n<class 'bool'>\t\t# Ture 是一个布尔值类型\n\nprint(type('1'))\n<class 'srt'>\t\t# 1 在这里是一个字符串类型\n"}, {"ctype": "head", "data": "四、数据类型"}, {"ctype": "head", "data": "1. srt ---- 字符串"}, {"ctype": "head", "data": "‘’ ---- 单引号"}, {"ctype": "head", "data": "“” ---- 双引号"}, {"ctype": "head", "data": "“”\"\"\"\" ---- 三引号 在没有变量命名时可作为注释使用"}, {"ctype": "head", "data": "字符串的基本方法： 增 删 改 查"}, {"ctype": "head", "data": "⑴. 增"}, {"ctype": "head", "data": "字符串拼接： + 拼接符"}, {"ctype": "code", "data": "a = '风陨'\nb = '老师'\nc = '很帅'\nd = a + b +c\nprint(d)\n风陨老师很帅\t\t\t#输出结果\n\n"}, {"ctype": "head", "data": "⑵. 删"}, {"ctype": "head", "data": "replace 替换 使用方法 重点 重点 重点"}, {"ctype": "code", "data": "A = 'adfhkmaehfd'\nB = 'adfhkmaehfdadfhkmaehfd'\nprint(A.replace('d', ''))\nprint(B.replace('d', ''))  \nafhkmaehf\nafhkmaehfafhkmaehf\t\t#第一参数'd'为赋值里待删除参数，第二参数''里无任何对像时在原有的赋值里删除所有待删参数\n\nprint(A.replace('d', ' '))\nprint(B.replace('d', ' ')) \na fhkmaehf \na fhkmaehf a fhkmaehf    # 第二个参数为空格时，赋值里待删除参数替换为空格\n\nprint(A.replace('d', '帅', 1))\nprint(A.replace('d', '帅', 2))\nprint(B.replace('d', '帅', 1))\nprint(B.replace('d', '帅', 3))\na帅fhkmaehfd\na帅fhkmaehf帅\na帅fhkmaehfdadfhkmaehfd\na帅fhkmaehf帅a帅fhkmaehfd  # 第三个参数为，赋值里待删除替换参数的替换次数\n\n\n"}, {"ctype": "head", "data": "⑶. 改"}, {"ctype": "head", "data": "upper ---- 改大写 针对的是字母"}, {"ctype": "code", "data": "a = 'ddhf'\nb = '1235'\nc = '小星星'\nprint(a.upper())\nprint(b.upper())\nprint(c.upper())\nDDHF\t\t\t#输出结果：全部改成了大写字母\n1235\t\t\t#输出结果：当是数字时无任何变化\n小星星\t\t\t  #输出结果：当是文字时无任何变化   \n"}, {"ctype": "head", "data": "lower ---- 改小写 针对的是字母"}, {"ctype": "code", "data": "a = 'FdHk'\nprint(a.lower())\nfdhk\t\t\t#输出结果：全部改成了小写字母\n"}, {"ctype": "head", "data": "capitalize ---- 首字母大写"}, {"ctype": "code", "data": "a = 'year'\nb = 'new year'\nprint(a.capitalize())\nprint(b.capitalize())\nYear\t\t\t\nNew year\t\t#输出结果：首字母改成了大写，第二个单词仍然是小写字母\n"}, {"ctype": "head", "data": "title ---- 每个单词首字母大写"}, {"ctype": "code", "data": "a = 'year'\nb = 'new year'\nprint(a.title())\nprint(b.title())\nYear\nNew Year\t\t#输出结果：每个首字母单词改成了大写\n"}, {"ctype": "head", "data": "split ---- 切割"}, {"ctype": "code", "data": "a = 'new year'\nprint(a.split('e'))\n['n', 'w y', 'ar']    #输出结果：显示待切割参数删除，余下切割分离留下的参数\n"}, {"ctype": "head", "data": "strip ---- 去空格"}, {"ctype": "code", "data": "b = ' new year '\nprint(b.strip())   \nprint(b.lstrip())  \nprint(b.rstrip())  \nnew year\t\t\t#去掉开头和结尾空格\nnew year\t\t\t#去掉左边空格 \n new year\t\t\t#去掉右边空格         因空格无法完全显示出来，自己可以去验证下空格的位置\n"}, {"ctype": "head", "data": "⑷. 查"}, {"ctype": "head", "data": "索引切片："}, {"ctype": "p", "data": "下标：位置从第一个开始 编号从0开始 特性：左闭右开"}, {"ctype": "p", "data": "先切片，给下标，索引位置"}, {"ctype": "p", "data": "​ a = ‘1 2 3 4 5 6 7 8 9 0 a b c d’"}, {"ctype": "p", "data": "下标编号： 0 1 2 3 4 5 6 7 8 9 10 11 12 13……以此类推"}, {"ctype": "head", "data": "count ---- 查次数 重点 重点 重点"}, {"ctype": "code", "data": "a = 'hhgauehjdiosdhieh'\nprint(a.count('h'))\n5\t\t\t\t#输出结果：显示待查参数'h'出现5次\n\na = 'hhgauehjdiosdhieh'\nprint(a.count('h', 4, 14))\n2\t\t    #输出结果：\t\t\n#第一参数待查'h'出现2次,\n#第二参数'4'为待查参数下标位置第4位参数'u'开始\n#第三参数'14'为待查参数下标位置第14位参数'i'结束\n"}, {"ctype": "head", "data": "index ---- 查下标 左边开始查，查到第一个就结束 ，如果找不到就报错 重点 重点 重点"}, {"ctype": "code", "data": "a = 'gauehjdhhiosdhieh'\nprint(a.index('h'))\n4\t\t\t#输出结果：当参数待查'h'下标位置在赋值中的第4个位置,\n\na = 'hhgauehjdiosdhieh'\nprint(a.index('h', 5, 14))\n6\t\t\t#输出结果：\n#第一参数为待查参数'h'\n#第二参数'5'为待查参数在赋值中下标位置第5位开始\n#第三参数'14'为待查参数在赋值中下标位置第14位结束\n\na = 'gauejdiosdie'\nprint(a.index('h'))\nTraceback (most recent call last):\n  File \"D:/Python/Python_notebook/课堂笔记/学习Python第二课3.26.py\", line 110, in <module>\n    print(a.index('h'))\nValueError: substring not found   \n#输出结果：当参数待查'h'不在赋值中时就会报错\n"}, {"ctype": "head", "data": "find ---- 查下标 左边开始查，查到第一个就结束 ，如果找不到不报错"}, {"ctype": "code", "data": "a = 'gauejdhiosdhieh'\nprint(a.find('h'))\n6\t\t\t#输出结果：当参数待查'h'下标位置在赋值中的第6个位置,\n\nprint(a.find('h', 3, 13))\n6\t\t\t#输出结果：当参数待查'h'下标位置在赋值中的第6个位置,\n#第一参数为待查参数'h'\n#第二参数'3'为待查参数在赋值中下标位置第3位开始\n#第三参数'13'为待查参数在赋值中下标位置第13位结束\n\nprint(a.find('z'))\n-1\t\t\t#输出结果：当参数待查'z'在赋值中没有时，不会报错，但会显示-1结果，这个根计算机系统有关\n#在32位机器上，整数的位数为32位，取值范围为-2**31～2**31-1，即-2147483648～2147483647\n#在64位系统上，整数的位数为64位，取值范围为-2**63～2**63-1，即-9223372036854775808～9223372036854775807\n#long(长整型)　　跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。\n#注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。（网络查找资料，有待查证，如有问题，请告知，谢谢！）\n"}, {"ctype": "head", "data": "isdigit ---- 判断是否为纯数字"}, {"ctype": "code", "data": "a = '1256'\nb = '12ssd'\nprint(a.isdigit())\nTrue\t\t\t\t#输出结果：a变量中的赋值是纯数字\nprint(b.isdigit())\nFalse\t\t\t\t#输出结果：b变量中的赋值不是纯数字\n"}, {"ctype": "head", "data": "isalpha ---- 判断是否为纯字符"}, {"ctype": "code", "data": "a = '1256'\nb = '11ssd'\nc = '星星最棒'\nprint(a.isalpha())\nFalse\t\t\t\t#输出结果：a变量中的赋值不是纯字符\nprint(b.isalpha())\nFalse\t\t\t\t#输出结果：b变量中的赋值不是纯字符\nprint(c.isalpha())\nTrue\t\t\t\t#输出结果：c变量中的赋值是纯字符\t\t\t\n"}, {"ctype": "head", "data": "starwith ---- 判断开始"}, {"ctype": "code", "data": "a = '23kjidheyghg'\nb = 'kjidh23eyghg'\nprint(a.startswith('23'))\nTrue\t\t\t\t#输出结果：判断a变量中的赋值'23'是开始的\nprint(b.startswith('23'))\nFalse\t\t\t\t#输出结果：判断b变量中的赋值'23'不是开始的\n\n"}, {"ctype": "head", "data": "endswith ---- 判断结束"}, {"ctype": "code", "data": "a = '23kjidheyghg'\nb = 'kjidh23eyggh'\nprint(a.endswith('g'))\nTrue\t\t\t\t#输出结果：判断a变量中的赋值'g'是结束的\nprint(b.endswith('g'))\nFalse\t\t\t\t#输出结果：判断b变量中的赋值'g'不是结束的\n\n"}, {"ctype": "head", "data": "islower ---- 判断全为小写"}, {"ctype": "code", "data": "a = 'ddhf'\nb = 'AsfD'\nc = 'ASDFH'\nprint(a.islower())\nTrue\t\t\t\t#输出结果：判断a变量中的赋值是全部为小写\nprint(b.islower())\nFalse\t\t\t\t#输出结果：判断a变量中的赋值不是全部为小写\nprint(c.islower())\nFalse\t\t\t\t#输出结果：判断a变量中的赋值不是全部为小写\n"}, {"ctype": "head", "data": "isupper ---- 判断全为大写"}, {"ctype": "code", "data": "a = 'ddhf'\nb = 'AsfD'\nc = 'ASDFH'\nprint(a.isupper())\nFalse\t\t\t\t#输出结果：判断a变量中的赋值不是全部为大写\nprint(b.isupper())\nFalse\t\t\t\t#输出结果：判断a变量中的赋值不是全部为大写\nprint(c.isupper())\nTrue\t\t\t\t#输出结果：判断a变量中的赋值是全部为大写\n"}], "cate": "Python"}
{"题目": "大数据分析——Matplotlib入门教程", "作者": "Hello  World!!!", "发布时间": "2021-03-27 17:32:42", "内容": [{"ctype": "head", "data": "问题区"}, {"ctype": "p", "data": "1.为什么 使用 plt.gcf().set_facecolor(np.ones(3)* 240 / 255) 后 plt.figure 会失效。 2."}, {"ctype": "head", "data": "matplotlib.pyplot简介"}, {"ctype": "p", "data": "Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。"}, {"ctype": "p", "data": "matplotlib.pyplot 是命令风格函数的集合，使 Matplotlib 像 MATLAB 一样工作。每个 Pyplot 函数对图形做一些修改，例如：创建一个图形，在图形中创建一个绘图区域，在绘图区域中回值一些线条，用标签装饰图形等等。 博主喜欢上来就看见学习结果，所以"}, {"ctype": "code", "data": "看第一个程序：\n"}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nfrom matplotlib import pyplot as plt\n\nif __name__ == '__main__':\n#定义两个列表分别作为X，Y轴\n    x_data=['2011','2013','2015','2017','2019','2021']\n    y_data=['1','2','3','4','5','6']\n#第一个列表表示横坐标，第二个列表示纵坐标\n    plt.plot(x_data,y_data)\n#调用show()方法\n    plt.show()\n"}, {"ctype": "code", "data": "结果：\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323203046490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " (如果在plot()中只传入一个list，则默认作为Y轴数据)"}, {"ctype": "head", "data": "1.Pyplot中的基础函数解析"}, {"ctype": "table", "data": "matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs)[source]plot([x], y, [fmt], *, data=None, **kwargs)plot([x], y, [fmt], [x2], y2, [fmt2], …, **kwargs)"}, {"ctype": "p", "data": "点或线节点的坐标由x，y给出。"}, {"ctype": "p", "data": "可选参数fmt是定义颜色、标记和线型等基本格式的方便方法。这是一种快捷的字符串表示法，在下面的注释部分有描述。"}, {"ctype": "head", "data": "使用Matplotlib画图基本步骤"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327221934520.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "基础方法解析 ："}, {"ctype": "table", "data": "plot中的方法作用plt.xlabel(“发布日期”)设置x轴名称plt.ylabel(“小说数量”)设置y轴名称xticks()设置x轴刻度yticks()设置y轴刻度plt.title(“80小说网活跃度”)设置图像标题plt.legend(loc=“upper left”)设置折线声明位置plt.show()将图像展示出来"}, {"ctype": "table", "data": "plot中的方法作用plt.gcf().set_facecolor(np.ones(3)* 240 / 255)生成画布的大小plt.grid()生成网格（可以设置线的格式）"}, {"ctype": "code", "data": "plt.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)\n"}, {"ctype": "table", "data": "plt.figure参数作用num图像编号或名称，数字为编号 ，字符串为名称figsize指定figure的宽和高，单位为英寸figsize=(4,3)dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80facecolor背景颜色edgecolor边框颜色frameon是否显示边框"}, {"ctype": "code", "data": "fig=plt.figure(figsize=(4,3),facecolor=‘blue')\n"}, {"ctype": "head", "data": "基础参数解析："}, {"ctype": "table", "data": "函数中不同参数作用plot(x, y)使用默认线型和颜色打印x和yplot(x, y, ‘bo’)使用蓝色圆圈标记绘制x和yplot(y)绘图y使用x作为索引数组0…N-1plot(y, ‘r+’)同上，但带有红色加号linewidth=“ ”设置线宽linestyle=“ ”设置线格式color=“ ”marker=\" h / * / s / p \"用来设置节点样式ms=1/5/10设置节点大小label=\" 折线代表的对象 \"设置折线标题"}, {"ctype": "head", "data": "Line Styles线条形状："}, {"ctype": "table", "data": "characterdescription‘-’solid line style 实线样式‘–’dashed line style 虚线样式‘-.’dash-dot line style 点划线样式‘:’dotted line style 虚线样式"}, {"ctype": "head", "data": "Markers 折点形状选择:"}, {"ctype": "table", "data": "characterdescription‘.’point marker 点标记‘,’pixel marker 像素标记‘o’circle marker o形圈标记‘v’triangle_down marker “v”形三角向下标记‘^’triangle_up marker “^”三角形向上标记‘<’triangle_left marker‘>’triangle_right marker '>'三角形\\u右标记‘1’tri_down marker “1”三角向下标记‘2’tri_up marker “2”三角标记‘3’tri_left marker “3”左标记‘4’tri_right marker “4”tri\\u右标记‘s’square marker “s”方形标记‘p’pentagon marker “p”五边形标记‘*’star marker “*”星形标记‘h’hexagon1 marker “h”六边形标记‘H’hexagon2 marker “H”六边形2标记‘+’plus marker “+”加号‘x’x marker “x”x标记‘D’diamond marker “D”菱形标记‘d’thin_diamond marker “d”细钻石标记’’‘_’hline marker ''线标记"}, {"ctype": "head", "data": "Colors"}, {"ctype": "table", "data": "characterdescription‘b’blue‘g’green‘r’red‘c’cyan 青色‘m’magenta 洋红色‘y’yellow‘k’black‘w’white"}, {"ctype": "code", "data": "Example format strings:\n"}, {"ctype": "table", "data": "字母作用‘b’ blue markers with default shape 带默认形状的蓝色标记‘or’ red circles 红圈‘-g’ green solid line 绿色实线‘–’ dashed line with default color 带默认颜色的虚线‘^k:’ black triangle_up markers connected by a dotted line 黑色三角形#用虚线连接的标记"}, {"ctype": "head", "data": "管理多个子图"}, {"ctype": "code", "data": "在一个数据图上包含多个子图\n"}, {"ctype": "p", "data": "调用subplot()函数可以创建多个子图，然后程序就可以在子图上进行绘制 subplot(nrows,ncols,index,**kwargs）函数中的nrows参数指定将数据图域分为多少行；nclos参数指定将数据图域分为多少列；index参数指定获得第几个区域。"}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nimport numpy as np\nimport math\nplt.figure(facecolor='green')\n\n#生成sin和cos三角函数图像\n#定义从-pi到pi之间的数据平均取640个数据\nx1_data=np.linspace(-np.pi,np.pi,64,endpoint=True)\nx=[-5,-4,-3,-2,-1,0,1,2,3,4,5]\nplt.subplot(2,2,1)\n#将figure分为两行两列将该图形放入第一个网格中\nplt.plot(x1_data,np.sin(x1_data),label='sin')\nplt.grid(c='g',linestyle='-.')  # 生成网格\nplt.plot(x1_data,np.cos(x1_data),label='cos')\n\nplt.subplot(2,2,2)\nplt.plot(x1_data,np.cos(x1_data),label='cos')\nplt.legend('upperleft')\n#生成网格便于观察\nplt.grid(c='r',linestyle=':')  # 生成网格\n\nplt.subplot(2,2,3)\nplt.plot(x1_data,np.tan(x1_data))\nplt.plot(x,x)\n\nplt.plot(x1_data,np.cos(x1_data),label='cos')\nplt.grid(c='m',linestyle='--')  # 生成网格\n\n\n\nplt.subplot(2,2,4)\nplt.grid(c='m',linestyle='--')  # 生成网格\nplt.plot(x,x)\n\n\n\nplt.show()\n\n"}, {"ctype": "code", "data": "结果\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327152106243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "加入plt.gcf().set_facecolor(np.ones(3)* 240 / 255)   # 生成画布的大小之后\n"}, {"ctype": "p", "data": "经过我实际测试我发现这个方法加入后 plt.figure 函数失效了。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327152202896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "实战"}, {"ctype": "head", "data": "2.初级数据可视化——画图"}, {"ctype": "code", "data": "解决中文乱码问题\n"}, {"ctype": "code", "data": "\n# 处理乱码\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']  # 用黑体显示中文\n"}, {"ctype": "head", "data": "简单二维图"}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nfrom matplotlib import pyplot as plt\n\nif __name__ == '__main__':\n\n    x_data=['2011','2013','2015','2017','2019','2021']\n    y_data=['1','3','9','27','81','243']\n    plt.plot(x_data, y_data, 'go-', label='line 4', linewidth=1)\n    plt.show()\n    \n"}, {"ctype": "code", "data": "linewidth=1\n"}, {"ctype": "p", "data": "![在这里插入图片描述](https://img-blog.csdnimg.cn/2021032321193597.png ?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70)"}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nfrom matplotlib import pyplot as plt\n\nif __name__ == '__main__':\n\n    x_data=['2011','2013','2015','2017','2019','2021']\n    y_data=['1','3','9','27','81','243']\n    plt.plot(x_data, y_data, 'm--h',label='line 1', linewidth=1)\n    plt.show()\nplt.plot()\n"}, {"ctype": "p", "data": "  注意这里参数“go-”改为了“m–h”，“m–h其实是“m”,“–”，“h”组合而成，这验证了格式参数可以合并（具体参数上面的表格已经给出了一部分） "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323212652787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "终极案例：\n"}, {"ctype": "code", "data": "# -*- coding:utf-8 -*-\nimport matplotlib\nimport matplotlib.pyplot as plt\n# 处理乱码\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']  # 用黑体显示中文\nx = [1, 2, 3, 4]\ny = [10, 50, 20, 100]\n# \"r\" 表示红色，ms用来设置*的大小\nplt.plot(x, y, \"r\", marker='*', ms=10, label=\"小说1——我的兄弟之顺溜之一战\")\n# plt.plot([1, 2, 3, 4], [20, 30, 80, 40], label=\"b\")\n#label : 给所绘制的曲线一个名字，此名字在图示/图例(legend)中显示\nplt.plot([1, 2, 3, 4], [20, 30, 80, 40], marker=\"h\",ms=10,label=\"小说2——我的兄弟之顺溜之二战\")\nplt.plot([1, 2, 3, 4], [30, 10, 60, 200], marker=\"p\",ms=10,label=\"小说2——我的兄弟之顺溜之三战\")\nplt.plot([1, 2, 3, 4], [0, 80, 50, 150], marker=\"p\",ms=10,label=\"小说2——我的兄弟之顺溜之四战\")\nplt.xticks(rotation=20)\nplt.xlabel(\"发布日期\")\nplt.ylabel(\"小说数量\")\nplt.title(\"80小说网活跃度\")\n# upper left 将图例a显示到左上角\nplt.legend(loc=\"upper left\")\n# 在折线图上显示具体数值, ha参数控制水平对齐方式, va控制垂直对齐方式\nfor x1, y1 in zip(x, y):\n    plt.text(x1, y1 + 1, str(y1), ha='center', va='bottom', fontsize=20, rotation=0)\nplt.savefig(\"a.jpg\")\nplt.show()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323220342648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import matplotlib\nimport matplotlib.pyplot as plt\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']\nplt.xlabel('时间')\nplt.ylabel('数量')\nx=[1,3,5,7]\nx1=[2,4,6,8]\ny=[12,32,54,3]\ny1=[23,56,23,67]\nplt.title(\"柱状图练习\")\nplt.bar(x,y,color='r',label=\"A\")\nplt.bar(x1,y1,color='g',label='B')\nplt.legend('uppper.right')\nplt.show()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210325185458878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "下一章将讲解3D画图和画函数图像 敬请期待："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210329160810971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327173652795.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzI3MjI0Nw==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "Python3 零基础自学笔记_pytest框架", "作者": "Nicooo-929", "发布时间": "2021-03-27 09:10:46", "内容": [{"ctype": "head", "data": "pytest"}, {"ctype": "head", "data": "pytest命名规则"}, {"ctype": "head", "data": "fixture函数\\修饰器"}, {"ctype": "code", "data": "@pytest.fixture(scope='module')\n"}, {"ctype": "p", "data": "scope参数有四种，分别是’function’,‘module’,‘class’,‘session’，默认为function。"}, {"ctype": "head", "data": "备注"}, {"ctype": "p", "data": "可以通过在fixture函数中通过yield实现setup和teardown功能"}, {"ctype": "head", "data": "mark.parametrize装饰器"}, {"ctype": "p", "data": "可以实现测试用例参数化"}, {"ctype": "code", "data": "@pytest.mark.parametrize('参数名',list)\n"}, {"ctype": "head", "data": "setup和teardown操作"}, {"ctype": "p", "data": "在pytest中setup和teardown操作与unittest中相似。"}, {"ctype": "head", "data": "执行测试"}, {"ctype": "head", "data": "命令行形式"}, {"ctype": "code", "data": "pytest # run all tests below current dir\npytest test_mod.py # run tests in module file test_mod.py\npytest somepath # run all tests below somepath like ./tests/\npytest -k stringexpr # only run tests with names that match the\n# the \"string expression\", e.g. \"MyClass and not method\"\n# will select TestMyClass.test_something\n# but not TestMyClass.test_method_simple\npytest test_mod.py::test_func # only run tests that match the \"node ID\",\n# e.g \"test_mod.py::test_func\" will be selected\n# only run test_func in test_mod.py\n"}, {"ctype": "head", "data": "通过 pytest.mark装饰器对测试的test进行分类执行"}, {"ctype": "p", "data": "通过通过@pytest.mark控制需要执行哪些feature的test，例如在执行test前增加修饰@pytest.mark.website"}, {"ctype": "code", "data": "pytest  -v -m \"website\" pytest1.py\n"}, {"ctype": "code", "data": "pytest  -v -m \"not website\" pytest1.py\n"}, {"ctype": "head", "data": "Console参数介绍"}, {"ctype": "head", "data": "断言"}, {"ctype": "p", "data": "使用pytest.raises捕获程序抛出的异常"}, {"ctype": "code", "data": "def test_div_error(self,a,b,expect):\n\twith pytest.raises(ZeroDivisionError):\n\tself.calc.div(a,b)\n"}, {"ctype": "p", "data": "上述用例可通过而不报错"}, {"ctype": "head", "data": "测试报告"}, {"ctype": "p", "data": "pytest可以方便的生成测试报告，即可以生成HTML的测试报告，也可以生成XML格式的测试报告用来与持续集成工具集成。"}, {"ctype": "p", "data": "生成HTML格式报告"}, {"ctype": "code", "data": "py.test --resultlog=path\n"}, {"ctype": "p", "data": "生成XML格式的报告："}, {"ctype": "code", "data": "py.test --junitxml=path\n"}, {"ctype": "head", "data": "拓展性插件"}, {"ctype": "head", "data": "测试报告"}, {"ctype": "head", "data": "pytest-cov"}, {"ctype": "p", "data": "计算pytest覆盖率，支持输出多种格式的测试报告"}, {"ctype": "head", "data": "安装方式与样例"}, {"ctype": "p", "data": "pip install pytest-cov pytest --cov-report=html --cov=./ test_code_target_dir"}, {"ctype": "head", "data": "Console参数介绍"}, {"ctype": "head", "data": "样例结果"}, {"ctype": "code", "data": "---------------------------------------------------------------- coverage: platform linux2, python 2.7.14-final-0 ----------------------------------------------------------------\nName         Stmts   Miss  Cover\n--------------------------------\npytest1.py      18      0   100%\n"}], "cate": "Python"}
{"题目": "吴恩达机器学习课程笔记ex1+python代码实现+课程原文档", "作者": "蓝胖砸～", "发布时间": "2021-03-27 13:09:59", "内容": [{"ctype": "code", "data": "import numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nfrom mpl_toolkits.mplot3d import Axes3D\nimport seaborn as sns\n#**********查看数据************************************************************************************************#\nsns.set(style=\"whitegrid\",color_codes=True)\ndf = pd.read_csv(\"ex1data1.txt\",header=None,names=[\"Population\",\"Profit\"])\ndf.head() #查看数据前5项\n#print(df.head())#查看数据)\ndf.describe()#查看数据相关统计\n#print(df.describe())#查看数据)\n#df.info()#查看数据DataFrame\ndf.plot(kind=\"scatter\",x='Population',y='Profit')  #根据读取数据类型画出散点图，kind意思为：此类型图像为散点图\nplt.show()\n#*************************定义一个代价函数computeCost随时调用*******************************************************#\ndef computeCost(X,Y,theta):\n    h = X.dot(theta.T)\n    cost = np.power((h - Y),2)\n    j = np.sum(cost)/(2 * len(X))\n    return j\n#********划分数据X,Y,并插入一列使x0全为1*****************************************************************************#\ndf.insert(0,\"x_0\",1)\nX = df.loc[:,\"x_0\":\"Population\"]\nY = df.iloc[:,2:3]\n#***********将X,Y转化为矩阵的形式***********************************************************************************#\nX = np.matrix(X.values)\nY = np.matrix(Y.values)\n#**********计算一下初始时theta为0的代价函数***************************************************************************#\ntheta = np.matrix(np.zeros((1, 2)))    ##给theta赋值，此时为1行2列的0数组\nprint(computeCost(X,Y,theta))          ##计算一下初始时theta为0的代价函数\n#***********定义梯度下降过程，供调用*********************************************************************************#\ndef gradientDescent(X,Y,theta,alpha,n):\n    temp = np.matrix(np.zeros(theta.shape))   ##theta为（0，0）\n    s = int(theta.ravel().shape[1])           #得到theta矩阵个数,shape[1]指的是数组的宽度，ravel()将多维数组降为一维。\n    j_theta = np.zeros(n)                     #构建一个数组用来存放每次循环得到的j_theta的值。\n    for i in range(n):\n        cost = (X * theta.T) - Y\n        for j in range(s):                    #range(3)代表的是 （0 1 2）\n            term = np.multiply(cost,X[:,j])     #X[:,j]提取X的每个维度的第j个元素\n            temp[0,j] = theta[0,j] - ((alpha / len(X)) * np.sum(term))     #theta[i,j]：取出来theta的第i行第j列元素\n        theta = temp\n        j_theta[i] = computeCost(X,Y,theta)\n    return theta ,j_theta\nalpha = 0.01\nn = 1000\nth,cost = gradientDescent(X,Y,theta,alpha,n)\nth\na = th[0,1]\nb = th[0,0]\nfig, ax = plt.subplots(figsize=(10,6))\nax.scatter(df.Population, df.Profit, label=\"Training data\")\nax.plot(df.Population, df.Population*a + b, label=\"Prediction\",color = \"red\")\nplt.legend(loc=2)\nax.set_xlabel('Population')\nax.set_ylabel('Profit')\nplt.show()\nfig, ax = plt.subplots(figsize=(10,6))\nax.plot(np.arange(n), cost, 'r')\nax.set_xlabel('Iterations')\nax.set_ylabel('Cost')\nax.set_title('Cost function')\nplt.show()\ntheta0_vals = np.linspace(-10, 10, 100)  # 参数1的取值\ntheta1_vals = np.linspace(-1, 4, 100)  # 参数2的取值\n\nxs, ys = np.meshgrid(theta0_vals, theta1_vals)  # 生成网格\nJ_vals = np.zeros(xs.shape)\n\nfor i in range(0, theta0_vals.size):\n    for j in range(0, theta1_vals.size):\n        t = np.array([theta0_vals[i], theta1_vals[j]])\n        # t = t.T\n        J_vals[i][j] = computeCost(X, Y, t)  # 计算每个网格点的代价函数值\n\nJ_vals = np.transpose(J_vals)\n\nfig1 = plt.figure(1)  # 绘制3d图形\nax = fig1.gca(projection='3d')\nax.plot_surface(xs, ys, J_vals)\nplt.xlabel(r'$\\theta_0$')\nplt.ylabel(r'$\\theta_1$')\n\n# 绘制等高线图 相当于3d图形的投影\nplt.figure(2)\nlvls = np.logspace(-5, 5, 50)\nplt.contour(xs, ys, J_vals, levels=lvls, norm=LogNorm())\nplt.scatter(b, a, marker=\"x\", color=\"red\", linewidth=5)\nplt.show()\n\n\n\n课程资料：\n链接：https://pan.baidu.com/s/1IIxiYW4z2UcIwKcuClYG_w \n提取码：1ov1 \n\n\n\n\n\n\n\n\n\n"}], "cate": "Python"}
{"题目": "【C/C++】拉格朗日插值、牛顿插值、分段线性插值作业", "作者": "eggcode", "发布时间": "2021-03-28 11:49:28", "内容": [{"ctype": "head", "data": "创建项目"}, {"ctype": "p", "data": " 使用VS2019创建C++控制台应用 C++菜鸟教程 "}, {"ctype": "head", "data": "拉格朗日插值"}, {"ctype": "head", "data": "公式"}, {"ctype": "p", "data": "n次的拉格朗日插值多项式：\n    \n     \n      \n       \n        \n         L\n        \n        \n         n\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        =\n       \n       \n        \n         \n          ∑\n         \n         \n          \n           k\n          \n          \n           =\n          \n          \n           0\n          \n         \n         \n          n\n         \n        \n        \n         [\n        \n        \n         \n          y\n         \n         \n          k\n         \n        \n        \n         \n          \n           ∏\n          \n          \n           \n            i\n           \n           \n            =\n           \n           \n            0\n           \n           \n            ,\n           \n           \n            i\n           \n           \n            ≠\n           \n           \n            k\n           \n          \n          \n           n\n          \n         \n         \n          (\n         \n         \n          \n           \n            x\n           \n           \n            −\n           \n           \n            \n             x\n            \n            \n             i\n            \n           \n          \n          \n           \n            \n             x\n            \n            \n             k\n            \n           \n           \n            −\n           \n           \n            \n             x\n            \n            \n             i\n            \n           \n          \n         \n         \n          )\n         \n         \n          ]\n         \n        \n       \n      \n      \n       L_n(x)=\\displaystyle\\sum_{k=0}^{n}[y_k\\displaystyle\\prod_{i=0,i≠k}^{n}(\\frac{x-x_i}{x_k-x_i})]\n      \n     \n    Ln​(x)=k=0∑n​[yk​i=0,i​=k∏n​(xk​−xi​x−xi​​)]"}, {"ctype": "p", "data": "其中，已知点有n+1个，其x值依次为\n    \n     \n      \n       \n        \n         x\n        \n        \n         0\n        \n       \n      \n      \n       x_0\n      \n     \n    x0​、\n    \n     \n      \n       \n        \n         x\n        \n        \n         1\n        \n       \n      \n      \n       x_1\n      \n     \n    x1​、…\n    \n     \n      \n       \n        \n         x\n        \n        \n         i\n        \n       \n      \n      \n       x_i\n      \n     \n    xi​（或\n    \n     \n      \n       \n        \n         x\n        \n        \n         k\n        \n       \n      \n      \n       x_k\n      \n     \n    xk​）、…\n    \n     \n      \n       \n        \n         x\n        \n        \n         n\n        \n       \n      \n      \n       x_n\n      \n     \n    xn​，其y值同理。"}, {"ctype": "p", "data": "当取n=1时，为线性插值；当取n=2时，为抛物插值。"}, {"ctype": "head", "data": "思路"}, {"ctype": "p", "data": "1.编程前，令上述公式中的n取n-1，于是公式为：\n    \n     \n      \n       \n        \n         L\n        \n        \n         \n          n\n         \n         \n          −\n         \n         \n          1\n         \n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        =\n       \n       \n        \n         \n          ∑\n         \n         \n          \n           k\n          \n          \n           =\n          \n          \n           0\n          \n         \n         \n          \n           n\n          \n          \n           −\n          \n          \n           1\n          \n         \n        \n        \n         [\n        \n        \n         \n          y\n         \n         \n          k\n         \n        \n        \n         \n          \n           ∏\n          \n          \n           \n            i\n           \n           \n            =\n           \n           \n            0\n           \n           \n            ,\n           \n           \n            i\n           \n           \n            ≠\n           \n           \n            k\n           \n          \n          \n           \n            n\n           \n           \n            −\n           \n           \n            1\n           \n          \n         \n         \n          (\n         \n         \n          \n           \n            x\n           \n           \n            −\n           \n           \n            \n             x\n            \n            \n             i\n            \n           \n          \n          \n           \n            \n             x\n            \n            \n             k\n            \n           \n           \n            −\n           \n           \n            \n             x\n            \n            \n             i\n            \n           \n          \n         \n         \n          )\n         \n         \n          ]\n         \n        \n       \n      \n      \n       L_{n-1}(x)=\\displaystyle\\sum_{k=0}^{n-1}[y_k\\displaystyle\\prod_{i=0,i≠k}^{n-1}(\\frac{x-x_i}{x_k-x_i})]\n      \n     \n    Ln−1​(x)=k=0∑n−1​[yk​i=0,i​=k∏n−1​(xk​−xi​x−xi​​)]"}, {"ctype": "p", "data": "2.这样编写的程序函数中，接收的形参包含四个部分："}, {"ctype": "p", "data": "3.返回参数："}, {"ctype": "p", "data": "4.数据类型选择：double"}, {"ctype": "p", "data": "5.为了对比不同插值方法的效率和结果，不建立额外的“缓存”"}, {"ctype": "head", "data": "代码"}, {"ctype": "p", "data": "参考博客1，可能有用的博客2（python版）"}, {"ctype": "code", "data": "double lagrange(double arrX[], double arrY[], int n, double x)\n{\n\tint k, i;\n\tdouble temp;\n\tdouble y = 0;\n\tfor (k = 0; k < n; k++)\n\t{\n\t\ttemp = 1;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (i != k) {\n\t\t\t\ttemp *= ((x - arrX[i]) / (arrX[k] - arrX[i]));\n\t\t\t}\n\t\t}\n\t\ty += arrY[k] * temp;\n\t}\n\treturn y;\n}\n"}, {"ctype": "head", "data": "特点"}, {"ctype": "p", "data": "优点：直观、简单、应用广泛。 缺点：当插值精度不够，增加新节点时，必须从头计算，不能利用已有结果。"}, {"ctype": "head", "data": "牛顿插值"}, {"ctype": "p", "data": "为克服拉格朗日插值的缺点，实现灵活增加插值节点，以节省运算次数。"}, {"ctype": "p", "data": "参考博客1"}, {"ctype": "head", "data": "公式"}, {"ctype": "p", "data": "\n    \n     \n      \n       \n        \n         N\n        \n        \n         n\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        =\n       \n       \n        f\n       \n       \n        (\n       \n       \n        \n         x\n        \n        \n         0\n        \n       \n       \n        )\n       \n       \n        +\n       \n       \n        \n         \n          ∑\n         \n         \n          \n           i\n          \n          \n           =\n          \n          \n           1\n          \n         \n         \n          n\n         \n        \n        \n         [\n        \n        \n         \n          \n           ∏\n          \n          \n           \n            k\n           \n           \n            =\n           \n           \n            0\n           \n          \n          \n           \n            i\n           \n           \n            −\n           \n           \n            1\n           \n          \n         \n         \n          (\n         \n         \n          \n           x\n          \n          \n           −\n          \n          \n           \n            x\n           \n           \n            i\n           \n          \n         \n         \n          )\n         \n         \n          ]\n         \n         \n          f\n         \n         \n          [\n         \n         \n          \n           x\n          \n          \n           0\n          \n         \n         \n          ,\n         \n         \n          \n           x\n          \n          \n           1\n          \n         \n         \n          ,\n         \n         \n          .\n         \n         \n          .\n         \n         \n          .\n         \n         \n          ,\n         \n         \n          \n           x\n          \n          \n           i\n          \n         \n         \n          ]\n         \n        \n       \n      \n      \n       N_n(x)=f(x_0)+\\displaystyle\\sum_{i=1}^{n}[\\displaystyle\\prod_{k=0}^{i-1}({x-x_i})]f[x_0,x_1,...,x_i]\n      \n     \n    Nn​(x)=f(x0​)+i=1∑n​[k=0∏i−1​(x−xi​)]f[x0​,x1​,...,xi​]"}, {"ctype": "head", "data": "思路"}, {"ctype": "p", "data": "根据已知数据的个数n，建立差商表，表内共需要存储\n     \n      \n       \n        \n         \n          \n           n\n          \n          \n           (\n          \n          \n           n\n          \n          \n           −\n          \n          \n           1\n          \n          \n           )\n          \n         \n         \n          2\n         \n        \n       \n       \n        \\frac{n(n-1)}{2}\n       \n      \n     2n(n−1)​个差商值。根据差商表，将插值数据代入公式。"}, {"ctype": "head", "data": "代码"}, {"ctype": "p", "data": "计算差商表："}, {"ctype": "code", "data": "//计算差商表，n表示有n个节点,n>1，f为差商表数组\nvoid calcChaShang(double x[], double y[], double f[], int n)\n{ //建立牛顿插值多项式的系数\n\tint i, j, k = 0;\n\t//一阶差商计算\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tf[k++] = (y[i] - y[i + 1]) / (x[i] - x[i + 1]);\n\t}\n\n\t//在一阶差商的基础上，计算到n-1阶\n\tfor (i = 1; i < n - 1; i++)\n\t{\n\t\t//j用来遍历第i阶的所有差商(共有n-i个)\n\t\tfor (j = 0; j < n - i - 1; j++)\n\t\t{\n\t\t\t//调试时所用\n\t\t\t/*double y1 = f[k - (n - i)];\n\t\t\tdouble y2 = f[k - (n - i) + 1];\n\t\t\tdouble x1 = x[j];\n\t\t\tdouble x2 = x[j + i + 1];*/\n\t\t\t//由于k自增会影响y[]，所以y[]中的j可以去掉，否则错误写法：\n\t\t\t//f[k] = (f[k - (n - i) + j] - f[k - (n - i) + j + 1]) / (x[j] - x[j + i + 1]);\n\t\t\tf[k] = (f[k - (n - i)] - f[k - (n - i) + 1]) / (x[j] - x[j + i + 1]);\n\t\t\tk++;\n\t\t}\n\t}\n}\n"}, {"ctype": "p", "data": "基于差商表的牛顿插值："}, {"ctype": "code", "data": "double newvalue(double* xArr, double* yArr, double* f, int n, double x)\n{ \n\t//将连乘结果存储到数组中（multiplication）\n\tdouble *m = (double*)malloc(sizeof(double) * n);\n\tm[0] = 1.0;\n\tint i = 0;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tm[i + 1] = m[i] * (x - xArr[i]);\n\t}\n\t\t\n\t//最终计算\n\tint k = 0;//通过此下标，访问差商数组\n\tdouble y = yArr[0];\n\tfor (i = 1; i < n; i++) \n\t{\n\t\ty += m[i] * f[k];\n\t\tk += n - i;\n\t}\n\treturn y;\n}\n"}, {"ctype": "head", "data": "线性分段插值"}, {"ctype": "head", "data": "公式"}, {"ctype": "p", "data": "在区间[a,b]，划分\n    \n     \n      \n       \n        a\n       \n       \n        =\n       \n       \n        \n         x\n        \n        \n         0\n        \n       \n       \n        <\n       \n       \n        \n         x\n        \n        \n         1\n        \n       \n       \n        <\n       \n       \n        \n         x\n        \n        \n         2\n        \n       \n       \n        <\n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        <\n       \n       \n        \n         x\n        \n        \n         n\n        \n       \n       \n        =\n       \n       \n        b\n       \n      \n      \n       a=x_0<x_1<x_2<...<x_n=b\n      \n     \n    a=x0​<x1​<x2​<...<xn​=b，对于[a,b]之间的任一小区间\n    \n     \n      \n       \n        [\n       \n       \n        \n         x\n        \n        \n         \n          j\n         \n         \n          −\n         \n         \n          1\n         \n        \n       \n       \n        ,\n       \n       \n        \n         x\n        \n        \n         j\n        \n       \n       \n        ]\n       \n      \n      \n       [x_{j-1},x_j]\n      \n     \n    [xj−1​,xj​]，在该小区间上作线性插值："}, {"ctype": "p", "data": "\n     \n      \n       \n        \n         f\n        \n        \n         (\n        \n        \n         x\n        \n        \n         )\n        \n        \n         ≈\n        \n        \n         \n          L\n         \n         \n          1\n         \n        \n        \n         (\n        \n        \n         x\n        \n        \n         )\n        \n        \n         =\n        \n        \n         \n          y\n         \n         \n          \n           j\n          \n          \n           −\n          \n          \n           1\n          \n         \n        \n        \n         \n          \n           x\n          \n          \n           −\n          \n          \n           \n            x\n           \n           \n            j\n           \n          \n         \n         \n          \n           \n            x\n           \n           \n            \n             j\n            \n            \n             −\n            \n            \n             1\n            \n           \n          \n          \n           −\n          \n          \n           \n            x\n           \n           \n            j\n           \n          \n         \n        \n        \n         +\n        \n        \n         \n          y\n         \n         \n          j\n         \n        \n        \n         \n          \n           x\n          \n          \n           −\n          \n          \n           \n            x\n           \n           \n            \n             j\n            \n            \n             −\n            \n            \n             1\n            \n           \n          \n         \n         \n          \n           \n            x\n           \n           \n            j\n           \n          \n          \n           −\n          \n          \n           \n            x\n           \n           \n            \n             j\n            \n            \n             −\n            \n            \n             1\n            \n           \n          \n         \n        \n       \n       \n        f(x)≈L_1(x)=y_{j-1}\\frac{x-x_j}{x_{j-1}-x_j}+y_j\\frac{x-x_{j-1}}{x_j-x_{j-1}}\n       \n      \n     f(x)≈L1​(x)=yj−1​xj−1​−xj​x−xj​​+yj​xj​−xj−1​x−xj−1​​"}, {"ctype": "head", "data": "思路"}, {"ctype": "p", "data": "已知数据的x值需要从小到大排列。插值前先找到被插数据x值所在的分段，通过比较\n     \n      \n       \n        \n         x\n        \n       \n       \n        x\n       \n      \n     x和\n     \n      \n       \n        \n         \n          x\n         \n         \n          \n           j\n          \n          \n           −\n          \n          \n           1\n          \n         \n        \n       \n       \n        x_{j-1}\n       \n      \n     xj−1​的值，找到其所在的小区间\n     \n      \n       \n        \n         [\n        \n        \n         \n          x\n         \n         \n          \n           j\n          \n          \n           −\n          \n          \n           1\n          \n         \n        \n        \n         ,\n        \n        \n         \n          x\n         \n         \n          j\n         \n        \n        \n         ]\n        \n       \n       \n        [x_{j-1},x_j]\n       \n      \n     [xj−1​,xj​]中的j的值。找到j，代入公式。"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "double linear(double xArr[], double yArr[], int n, double x) \n{\n\tint j;\n\tdouble y = 0;\n\tfor (j = 0; j < n - 1; j++)\n\t{\n\t\t//找到所在的分段\n\t\tif (x >= xArr[j])\n\t\t{\n\t\t\ty = yArr[j] * ((x - xArr[j + 1]) / (xArr[j] - xArr[j + 1])) \n\t\t\t\t+ yArr[j + 1] * ((x - xArr[j]) / (xArr[j + 1] - xArr[j]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn y;\n}\n"}, {"ctype": "head", "data": "参考"}], "cate": "Python"}
{"题目": "分而治之  之 快速排序python版", "作者": "夕看", "发布时间": "2021-03-27 19:35:39", "内容": [{"ctype": "p", "data": "分而治之：快速排序"}, {"ctype": "code", "data": "#快速排序,忘了一件事，数组和列表每次操作的是地址，类似指针，已经排序好了就不需要动这个元素了\ndef partition(n,left,right):\n    if left==right:\n        return left\n    temp=0\n    start=left\n    left=left-1\n    for j in range(start,right+1):\n        if n[j]<n[right]:\n              left+=1\n              temp=n[left]\n              n[left]=n[j]\n              n[j]=temp              \n        elif j==right:\n            temp=n[left+1]\n            n[left+1]=n[right]\n            n[right]=temp\n    return left+1\ndef swiftsort(n,left,right):         #竞赛中最好不要使用sys.exit()函数,可以换成if判断比较合适:     \n    mid=partition(n,left,right)\n    if left<right:\n      swiftsort(n,left,mid-1)\n      swiftsort(n,mid+1,right)\n    return n\nn=input().split()\nfor i in range(len(n)):\n    n[i]=int(n[i])\nl=len(n)-1\n#k=int(input())\nprint(swiftsort(n,0,len(n)-1))\n\n"}], "cate": "Python"}
{"题目": "震惊！！！Python验证回文串居然可以这么简单~", "作者": "SeeYouEnn1s", "发布时间": "2021-03-27 15:21:46", "内容": [{"ctype": "head", "data": "系列文章目录"}, {"ctype": "p", "data": "1.判断回文数之基础篇 2.Pyhton纯手工打造万年历 3.LeetCode第一题：两数之和（twoSum）"}, {"ctype": "p", "data": " 路漫漫其修远兮，吾将上下而求索。 "}, {"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "众所周知： 程序 = 算法 + 数据结构。熟悉常见的算法和数据结构有助于我们优化代码，提高程序的效率、节省时间和内存空间。 本文以LeetCode第125题为例，来记录笔者在学习进阶时的疑惑与成长。"}, {"ctype": "p", "data": "提示：以下是本篇文章正文内容，下面案例可供参考"}, {"ctype": "head", "data": "一、LeetCode——125.验证回文串"}, {"ctype": "head", "data": "1.问题描述"}, {"ctype": "p", "data": "给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。"}, {"ctype": "p", "data": "说明：本题中，我们将空字符串定义为有效的回文串。"}, {"ctype": "head", "data": "2.示例"}, {"ctype": "head", "data": "示例 1:"}, {"ctype": "p", "data": "输入: “A man, a plan, a canal: Panama” 输出: True"}, {"ctype": "head", "data": "示例 1:"}, {"ctype": "p", "data": "输入: “race a car” 输出: False"}, {"ctype": "head", "data": "示例 3:"}, {"ctype": "p", "data": "输入: “!!!” 输出: True"}, {"ctype": "head", "data": "二、解题分析"}, {"ctype": "p", "data": "在排除空格及特殊字符的前提下，且不考虑字母大小写，字符串前后元素一一相同.在字符串为空或只有一个字符时，应该返回True字符串的元素全部是符号是应该返回True"}, {"ctype": "head", "data": "三、解题思路及代码实现"}, {"ctype": "head", "data": "方法一：字符串切片"}, {"ctype": "p", "data": "创建一个空字符串s_new，通过遍历字符串s，将字符串s中的字母和数字，拼接到s_new中，通过比较s_new[::-1] 和s_new得出结论。【字符串为有序的数据结构，可以对其进行切片操作】"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # 创建一个空字符串\n        s_new = ''\n        # 遍历字符串s\n        for i in s:\n        \t# 判断，如果是字母或数字，将其转为小写拼接到字符串中\n            if i.isalnum():\n                s_new += i.lower()\n        # 切片后s_new[::-1]与s_new比较，并将结果返回\n        return s_new[::-1] == s_new\n"}, {"ctype": "head", "data": "方法二：双游标判断"}, {"ctype": "p", "data": "从字符串s两端指定两个游标low，high如果low游标指向了 非字母和数字（即空格和符号）,那么low游标往后移一位； 如果high游标指向了 非字母和数字（即空格和符号）,那么high游标往前移一位；直至low和high都指向了数字或字母，此时进行比较，是否相同。如果比较的结果是True，则low往后移一位，high往前移一位 如果比较的结果是False，则直接返回False重复上述判断，直至low和high重合，此时表示完成了字符串s内前后元素的一一对比判断，返回True即可。"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        low = 0\n        high = len(s) - 1\n        #在字符串为空或只有一个字符时，返回True\n        if len(s) <= 1:\n            return True\n        # 设定low和high对比的条件\n        while low < high:\n        \t# 如果不是字母或数字，low往后移一位【low < high为必须条件，不然会造成索引越界】\n            while not s[low].isalnum() and low < high:\n                low += 1\n            # 如果不是字母或数字，high往前移一位\n            while not s[high].isalnum() and low < high:\n                high -= 1\n             # 判断：如果相同，继续下一次对比；如果不相同，直接返回False\n            if s[low].lower() == s[high].lower():\n                low += 1\n                high -= 1\n            else:\n                return False\n        # low和high重合，即退出循环，表示前后都是一一对应的，返回True\n   \t\treturn True\n"}, {"ctype": "head", "data": "四、总结"}, {"ctype": "p", "data": "以上就是今天的解题，此题目从字符串切片的解题方式来看，考察了我们对字符串常见功能的掌握情况，而双游标的角度来看，主要考察了我们对游标这一工具的灵活运用，相信大家在学习基础算法——快速排序时，会再次遇到双游标，而快速排序可以说是相当于在本文核心代码的基础上再嵌套一层外层循环。"}], "cate": "Python"}
{"题目": "Python(11)---继承与多态", "作者": "叶卡捷琳堡", "发布时间": "2021-03-27 22:09:13", "内容": [{"ctype": "head", "data": "一、继承的语法格式"}, {"ctype": "p", "data": "称为类B继承类A，B类的对象可以使用A类的属性和方法 可以实现代码复用"}, {"ctype": "code", "data": "class 类B(类A):\n\tpass\n"}, {"ctype": "p", "data": "一个最基本的继承和方法调用"}, {"ctype": "code", "data": "# 定义父类Animal\nclass Animal(object):\n    def play(self):\n        print(\"Animal's play method execute!\")\n\n\n# 定义Dog类，继承Animal类\nclass Dog(Animal):\n    pass\n\ndog = Dog()\n# Animal's play method execute!\ndog.play()\n"}, {"ctype": "head", "data": "二、继承的分类"}, {"ctype": "p", "data": "单继承，多继承，多层继承"}, {"ctype": "head", "data": "三、子类重写父类的同名方法"}, {"ctype": "code", "data": "# 定义父类Animal\nclass Animal(object):\n    def play(self):\n        print(\"Animal's play method execute!\")\n\n\n# 定义Dog类，继承Animal类\nclass Dog(Animal):\n    def play(self):\n        print(\"Dog's play method execute!\")\n\nanimal = Animal()\n# Animal's play method execute!\nanimal.play()\ndog = Dog()\n# Dog's play method execute!\ndog.play()\n"}, {"ctype": "head", "data": "四、子类调用父类的同名方法"}, {"ctype": "code", "data": "# 定义父类Animal\nclass Animal(object):\n    def play(self):\n        print(\"Animal's play method execute!\")\n\n\n# 定义Dog类，继承Animal类\nclass Dog(Animal):\n    def play(self):\n        print(\"Dog's play method execute!\")\n    # 在子类中调用父类的play方法\n    def executeAnimalPlay(self):\n        # 方法一：父类.方法名(self,其它参数)\n        # 使用类名.方法名()调用时，系统不会自动传递实参值self，需要手动传值，如果这里没有传入self参数，则会报错\n        Animal.play(self)\n        # 方法二：super(类A，self).方法名(参数)，会调用当前类A父类的方法\n        super(Dog,self).play()\n        # 方法三：方法二的简写，super().方法名(参数)\n        super().play()\n\ndog = Dog()\n# Animal's play method execute!\ndog.executeAnimalPlay()\n"}, {"ctype": "head", "data": "五、继承中的__init__方法"}, {"ctype": "code", "data": "# 继承中的__init__方法\nclass Animal(object):\n    def __init__(self,name):\n        self.name = name\n    def __str__(self):\n        return f\"name={self.name}\"\n\nclass Dog(Animal):\n    # 子类重写了父类的__init__方法，默认不再调用父类的__init__方法，需要手动调用父类的__init__方法\n    # 给对象添加从父类继承的属性\n    def __init__(self,name,age):\n        super().__init__(name)\n        self.age = age\n    def __str__(self):\n        return f\"name={self.name},age={self.age}\"\n\n\ndog = Dog('zhangsan',10)\n# name=zhangsan,age=10\nprint(dog)\n"}, {"ctype": "head", "data": "六、多继承"}, {"ctype": "code", "data": "# 多继承：如果一个类有两个以上父类，就把这种关系称为多继承\nclass A(object):\n    def fun1(self):\n        print(\"A's fun1 execute!\")\n    def Afun(self):\n        print('Afun execute!')\n\nclass B(object):\n    def fun1(self):\n        print(\"B's fun1 execute!\")\n    def Bfun(self):\n        print('Bfun execute!')\n\nclass C(A,B):\n    pass\n\n\nc = C()\n# Afun execute!\nc.Afun()\n# Bfun execute!\nc.Bfun()\n'''\n    两个父类中都有fun1()\n    子类对象调用的是在声明时第一个父类的方法\n    C(A,B)：在声明时第一个父类是A，因此调用A中的fun1方法\n'''\n# A's fun1 execute!\nc.fun1()\n"}, {"ctype": "head", "data": "七、多继承中调用指定父类的方法"}, {"ctype": "code", "data": "# 多继承中调用指定父类的方法\n# 多继承：如果一个类有两个以上父类，就把这种关系称为多继承\nclass A(object):\n    def fun1(self):\n        print(\"A's fun1 execute!\")\n    def Afun(self):\n        print('Afun execute!')\n\nclass B(object):\n    def fun1(self):\n        print(\"B's fun1 execute!\")\n    def Bfun(self):\n        print('Bfun execute!')\n\nclass C(A,B):\n    def fun1(self):\n        print(\"C's fun1 execute!\")\n        # 调用指定父类中的方法\n        # 根据顺序链，调用类A的fun1方法\n        # A's fun1 execute!\n        super(C, self).fun1()\n        # 根据顺序链，调用类B的fun1方法\n        # B's fun1 execute!\n        super(A, self).fun1()\n    pass\n\n\nc = C()\n# Afun execute!\nc.Afun()\n# Bfun execute!\nc.Bfun()\n# C's fun1 execute!\n# A's fun1 execute!\n# B's fun1 execute!\nc.fun1()\n# 类名.__mro__可以查看当前的继承顺序链，也就是同名方法的调用顺序（从左到右）\n# (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)\nprint(C.__mro__)\n"}, {"ctype": "head", "data": "八、私有属性和私有方法"}, {"ctype": "p", "data": "私有属性"}, {"ctype": "code", "data": "# 私有属性和方法\n'''\n    私有属性和方法\n        在属性和方法前加上两个下划线，该属性或方法变为私有\n        私有属性不能在类外访问，只能在类内访问\n        私有属性不能被继承\n'''\nclass People(object):\n    def __init__(self):\n        '''\n            定义__age为私有属性，类外无法访问，不能被继承\n            python中私有的本质是修改属性的名字，在创建属性的时候，会自动修改属性名\n            在属性名前加上\"_类名\"前缀\n            比如这个属性实际上全名是：_People__age\n        '''\n        self.__age = 0\n\n\npeople = People()\n# 代码报错\n# print(people.__age)\n# 通过__dict__可以查看对象具有的属性信息，类型是字典，字典的key是属性名，字典的value是属性值\n# {'_People__age': 0}\nprint(people.__dict__)\n# 注意：这里不是修改私有属性，而是定义了一个新的公有属性\npeople.__age = 100\n# {'_People__age': 0, '__age': 100}\nprint(people.__dict__)\n"}, {"ctype": "p", "data": "私有方法"}, {"ctype": "code", "data": "# 私有方法\n'''\n    私有方法:在方法前加上'__'\n    私有方法,不能在类外访问\n    作用:一般作为类内部的方法使用,不让外部调用的时候去定义\n'''\nclass Dog(object):\n    def fun1(self):\n        print('fun1 execute!')\n        self.__fun2()\n    def __fun2(self):\n        print('fun2 execute!')\n\n\ndog = Dog()\n# fun1 execute!\n# fun2 execute!\ndog.fun1()\n"}, {"ctype": "head", "data": "九、类属性"}, {"ctype": "code", "data": "'''\n    实例对象:通过class关键字定义的类创建的对象,即通过类实例化的\n    实例对象定义的属性被称为实例属性,即通过self定义的属性都称为实例属性\n    类对象:通过class定义的,python解释器在创建类的时候自动创建的\n    类对象的作用:\n        1.可以通过类对象定义实例对象\n        2.类对象可以保存一些属性信息,称为类属性\n    类属性的定义:\n        在类内部,方法外部定义的属性就是类属性\n'''\nclass Dog(object):\n    # 定义类属性\n    className = 'dog'\n    def __init__(self,name,age):\n        # 定义实例属性\n        self.name = name\n        self.age = age\n\ndog = Dog('lisi',1)\n# 打印dog对象具有的属性\n# {'name': 'lisi', 'age': 1}\nprint(dog.__dict__)\n# 类名.__dict__\n# {'__module__': '__main__', 'className': 'dog', '__init__': <function Dog.__init__ at 0x000001C35EA5E5E0>, '__dict__': <attribute '__dict__' of 'Dog' objects>, '__weakref__': <attribute '__weakref__' of 'Dog' objects>, '__doc__': None}\nprint(Dog.__dict__)\n# 访问类属性\n# dog\nprint(Dog.className)\n# 修改类属性\nDog.className = 'Dog class'\n# Dog class\nprint(Dog.className)\n# 注意：如果不存在与实例属性名相同的类属性，则可以使用实例对象访问类属性的值\n# 但如果重名，一定访问类属性\n# Dog class\nprint(dog.className)\n"}, {"ctype": "head", "data": "十、类方法，静态方法"}, {"ctype": "p", "data": "类方法"}, {"ctype": "code", "data": "'''\n实例方法：类中默认的方法就是实例方法\n    实例方法的第一个参数为self，表示实例对象\n\n类方法：使用@classmethod装饰的方法，称为类方法，第一个参数为cls，代表类对象自己\n如果一个方法使用了实例属性，则该方法一定要定义为实例方法\n在不需要使用实例属性的前提下，需要使用类属性，可以将这个方法定义为类方法\n'''\nclass Dog(object):\n    className = 'dog'\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    # 定义类属性\n    @classmethod\n    # cls是类方法的默认形参，在调用的时候，不需要手动传递，python解释器会自动传递\n    def getClassName(cls):\n        return cls.className\n\n\ndog = Dog('lisi',2)\n# dog\nprint(Dog.getClassName())\n"}, {"ctype": "p", "data": "静态方法"}, {"ctype": "code", "data": "'''\n静态方法：\n    使用@staticmethod装饰的方法，称为静态方法，对参数没有特殊要求\n    当不需要使用实例属性，也不需要使用类属性的时候，可以将该方法定义为静态方法\n'''\nclass Dog(object):\n    className = 'dog'\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    # 定义静态方法\n    @staticmethod\n    def show():\n        print(\"the Dog class\")\n\n\ndog = Dog('lisi',2)\n# 静态方法的调用\n# 1.对象.方法名()\n# the Dog class\ndog.show()\n# 2.类名.方法名()\n# the Dog class\nDog.show()\n"}, {"ctype": "head", "data": "十一、多态"}, {"ctype": "code", "data": "'''\n多态：\n    在需要使用父类对象的地方传入子类对象，得到不同的结果\n实现步骤:\n    1.子类继承父类\n    2.子类重写父类的同名方法\n    3.定义一个共同的方法，参数为父类对象，在方法中调用子类和父类同名的方法\n'''\nclass Animal(object):\n    def __init__(self,name):\n        self.name = name\n    def play(self):\n        print(f\"(动物){self.name}在玩\")\nclass Dog(Animal):\n    # 定义play方法\n    def play(self):\n        print(f\"(狗){self.name}在玩\")\n\n# 定义公共方法\ndef doPlay(obj):\n    obj.play()\n\nanimal = Animal('zhangsan')\ndog = Dog('zhangsan')\n# (动物)zhangsan在玩\ndoPlay(animal)\n# (狗)zhangsan在玩\ndoPlay(dog)\n"}], "cate": "Python"}
{"题目": "计算机视觉学习——sift特征检测+匹配地理标记图像", "作者": "Easy-21", "发布时间": "2021-03-27 21:32:20", "内容": [{"ctype": "p", "data": "摘要：python学习计算机视觉，对图像进行sift特征点检测，并采用可视化连接，使用局部描述子将同一地理位置图像进行分类"}, {"ctype": "p", "data": "知识点概念这里就不多说了。。。 "}, {"ctype": "head", "data": "SIFT特征点检测"}, {"ctype": "code", "data": "import sift\nfrom PIL import Image\nfrom pylab import *\nimname = 'test/3.jpg'\nim1 = array(Image.open(imname).convert('L'))\nsift.process_image(imname,'3.sift')\nl1,d1 = sift.read_features_from_file('3.sift')\nfigure()\ngray()\nsift.plot_features(im1,l1,circle=False)\nshow()\n"}, {"ctype": "p", "data": "输入一张图片，使用sift算法进行特征点检测，运行图如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/f4b26270ef607b50d7bf4a6331942496.png#pic_center"}, {"ctype": "head", "data": "SIFT特征匹配"}, {"ctype": "code", "data": "from PIL import Image\nfrom pylab import *\nfrom numpy import *\nimport sift\nfrom pcv.localdescriptors import sift\nim1f = 'test/3.jpg'\nim2f = 'test/4.jpg'\nim1 = array(Image.open(im1f))\nim2 = array(Image.open(im2f))\n\nsift.process_image(im1f,'out_sift_1.txt')\nl1,d1=sift.read_features_from_file('out_sift_1.txt')\nfigure()\ngray()\nsubplot(121)\nsift.plot_features(im1,l1,circle=False)\n\nsift.process_image(im2f,'out_sift_2.txt')\nl2,d2=sift.read_features_from_file('out_sift_2.txt')\nsubplot(122)\nsift.plot_features(im2,l2,circle=False)\n\nmatches = sift.match_twosided(d1,d2)\nprint('{} matches'.format(len(matches.nonzero()[0])))\nfigure()\ngray()\nsift.plot_matches(im1,im1,l1,l2,matches, show_below=True)\nshow()\n"}, {"ctype": "p", "data": "输入两张图片，分别进行特征点检测，将检测数据存储到文本文件中，将二者进行比较使用match_twosided方法匹配相同特征，运行图如下，得到matches=100 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/494eb68640c7e166684773a8b4919e80.png"}, {"ctype": "head", "data": "匹配地理标记图像"}, {"ctype": "code", "data": "import json\nimport os\nimport urllib\nfrom pylab import *\nfrom PIL import Image\nfrom pcv.localdescriptors import sift\nfrom pcv.tools import imtools\nimport pydot\ndownload_path = \"D:/Python/Python39/Scripts/计算机视觉/test\"  #注意使用绝对路径\npath = \"D:/Python/Python39/Scripts/计算机视觉/test\"\n\nimlist = imtools.get_imlist(download_path)\nnbr_images = len(imlist)\n\nfeatlist = [imname[:-3] + 'sift' for imname in imlist]\nfor i, imname in enumerate(imlist):\n    sift.process_image(imname, featlist[i])\n\nmatchscores = zeros((nbr_images, nbr_images))\n\nfor i in range(nbr_images):\n    for j in range(i, nbr_images): #only compute upper triangle\n        print( 'comparing ', imlist[i], imlist[j])\n        l1, d1 = sift.read_features_from_file(featlist[i])\n        l2, d2 = sift.read_features_from_file(featlist[j])\n        matches = sift.match_twosided(d1, d2)\n        nbr_matches = sum(matches>0)\n        print('number of matches = ', nbr_matches)\n        matchscores[i,j] = nbr_matches\n\n# copy values\nfor i in range(nbr_images):\n    for j in range(i + 1, nbr_images): # no need to copy diagonal\n        matchscores[j, i] = matchscores[i, j]\n\n# 可视化\nthreshold = 2 # min number of matches needed to craete link\n\ng = pydot.Dot(graph_type='graph') # don't want the default directed graph\n\nfor i in range(nbr_images):\n    for j in range(i+1, nbr_images):\n        if matchscores[i,j] > threshold:\n            #图像对中的第一幅图像\n            im = Image.open(imlist[i])\n            im.thumbnail((100,100))\n            filename = path + str(i) + '.png'\n            im.save(filename) #需要一定大小的临时文件\n            g.add_node(pydot.Node(str(i), fontcolor='transparent',\n                       shape='rectangle', image=filename))\n\n            #图像对中的第二幅图像\n            im = Image.open(imlist[j])\n            im.thumbnail((100,100))\n            filename = path + str(j) + '.png'\n            im.save(filename) #需要一定大小的临时文件\n            g.add_node(pydot.Node(str(j), fontcolor='transparent',\n                       shape='rectangle', image=filename))\n            g.add_edge(pydot.Edge(str(i), str(j)))\ng.write_png('compare.png')\n"}, {"ctype": "p", "data": "输入一组图片，将所有图片的特征点保存到同名的后缀.sift文件中，通过循环将文件的特征数值两两比较，通过可视化包设置达到最小数值thresold=2，将两张图片进行连线，运行图如下：   1.jpg和2.jpg共有56个匹配点； 3.jpg有964个特征点，和4.jpg共有100个匹配点； 5.jpg有773个特征点，和6.jpg共有12个匹配点，和7共有3个匹配点，和8共有590个匹配点 6.jpg有668个特征点，和7.jpg共有3个匹配点，和8共有8个匹配点 10.jpg有2916个特征点，和9.jpg共有11个匹配点，和11共有15个匹配点； 11.jpg有1896个特征点，和9.jpg共有8个匹配点"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/a111e7f7674cef9c28478b5faceb01aa.png#pic_center"}, {"ctype": "head", "data": "注意问题"}, {"ctype": "p", "data": "图片需要压缩小点否则程序要跑很久，尽量保证图片像素高宽比一致"}, {"ctype": "head", "data": "工具包使用遇到的问题"}, {"ctype": "p", "data": "从网上下载安装pcv包（pip install pcv）调用，然后需要下载降级二进制处理文件vlfeat-0.9.20版本，下载完成后找到\\bin\\win64\\下的sift.exe和vl.dll文件复制到你的项目底下，修改pcv路径(python/lib/pcv/localdescriptors)底下sift.py文件process_image方法底下print后面加括号；"}, {"ctype": "p", "data": "出现了’dot’ not found问题，还需要下载graphviz(安装时授权系统环境变量），找到bin目录底下dot.exe路径，修改python/lib/site-packages/pydot.py中_inif_方法下代码为 self.prog = r’路径\\bin\\dot.exe’"}, {"ctype": "p", "data": "这里给了超链接下载，具体安装方法参考网上教程，具体代码可以参考书本代码《python计算机视觉编程》"}, {"ctype": "p", "data": "https://www.cnblogs.com/Easy-/p/14586997.html"}], "cate": "Python"}
{"题目": "使用Flask和Opencv在多个浏览器上同时获取摄像头监控信息", "作者": "时闻折竹", "发布时间": "2021-03-28 09:53:36", "内容": [{"ctype": "head", "data": "Main部分"}, {"ctype": "p", "data": "该部分主要编写了服务器的路由信息以及视频流的装配信息"}, {"ctype": "code", "data": "#!/usr/bin/env python\nfrom flask import Flask, render_template, Response\nfrom camera_v3 import Camera\nimport cv2\n\napp = Flask(__name__)\n\nvideo_camera = None\nglobal_frame = None\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\ndef gen():\n    global video_camera\n    global global_frame\n    # 如果当前的摄像头为空\n    # 则新建一个类\n    if video_camera is None:\n        video_camera = Camera()\n    while True:\n        frame = video_camera.get_frame()\n        # 如果当前摄像头能够获取到帧\n        # 则正常输出帧，并更新global_frame 的信息\n        # 如果不能正常输出，则输出global_frame的信息\n        if frame is not None:\n            global_frame = frame\n            yield (b'--frame\\r\\n'\n               b'Content-Type: image/jpeg\\r\\n\\r\\n' + frame + b'\\r\\n')\n        else:\n            yield (b'--frame\\r\\n'\n               b'Content-Type: image/jpeg\\r\\n\\r\\n' + global_frame + b'\\r\\n')\n\n\n@app.route('/video_feed')\ndef video_feed():\n    return Response(gen(),\n                    mimetype='multipart/x-mixed-replace; boundary=frame')\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, threaded=True)\n"}, {"ctype": "head", "data": "Camera部分"}, {"ctype": "p", "data": "这部分更简单了，就是使用opencv来读取摄像头的每帧信息，然后转成bytes类型，最后输出的网页端"}, {"ctype": "code", "data": "from time import time\nimport cv2\nimport numpy as np\n\n\nclass Camera(object):\n\n    def __init__(self):\n        self.cap = cv2.VideoCapture(0) \n\n    def __del__(self):\n        self.cap.release()\n    \n    def get_frame(self):\n        success, image = self.cap.read()\n        # 如果成功读取，则正常传输bytes数据\n        # 如读取失败，则返回None，即使用上一帧的数据\n        if success:\n            image = self.cal_flow(image)\n            ret, jpeg = cv2.imencode('.jpg', image)\n            return jpeg.tobytes()\n        else:\n            return None\n"}], "cate": "Python"}
{"题目": "简单计算器 -python", "作者": "影修", "发布时间": "2021-03-28 15:45:48", "内容": [{"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328154247512.png"}, {"ctype": "code", "data": "from tkinter import *\nfrom time import sleep\n\nx = t = y = 0\nbase = Tk()\nbase.title(\"计算器\")\nbase.geometry(\"250x380\")\n\nframe_top = Frame(width = 250, height = 80, bg = '#dddddd')\nframe_top.pack()\n\nsv = StringVar()\nsv.set(\"0.0\")\n\nnum1 = 0\nnum2 = 0\nnum1_1 = 999\nnum2_2 = 999\nop = None  \ndef show_num(num):\n    global num1, num2, op, num1_1, num2_2, t, x, y\n    if not op:\n        if num == num1_1:\n            sv.set(num1_1)\n        else:\n            num1 +=int(num)\n            sv.set(num)\n            num1_1 = num\n    else:\n        if num == num2_2:\n            sv.set(str(num1) + op + str(num))\n        else:\n            num2 += int(num)\n            \"\"\" if t == True:\n                x = num1 +  0.1* int(num)\n                y = int(num)\n                show_del(0)\n                num1 = x\n                print(num1, num2)\n                \n                sv.set(str(num1))\n            else: \"\"\"\n            sv.set(str(int(num1)) + op + str(num2))\n            num2_2 = num\n\ndef show_op(opr):\n    global num1, num2, op, t\n    if opr in ['+', '-', '×', '÷', '%', '.']:\n        op = opr\n        sv.set(str(num1)+ op)\n        if opr == '.':\n            t = True\n    else:\n        if op == '+':\n            nums = num1 + num2\n        if op == '-':\n            nums = num1 - num2\n        if op == '×':\n            nums = num1 * num2\n        if op == '÷':\n            nums = num1 / num2\n        if op == '%':\n            nums = num1 % num2\n        sv.set(nums)\n        show_del(0)\ndef show_yx(num):\n     sv.set(num)\ndef show_del(num):\n    global num1, num2, op, num1_1, num2_2\n    if num == 1:\n        sv.set(\"0.0\")\n    num1 = 0\n    num2 = 0\n    num1_1 = 999\n    num2_2 = 999\n    op = None \n\n   \nlabel_top = Label(frame_top, textvariable = sv, width = 200, height = 2, font = ('黑体', 20, \"bold\"), anchor = 'e', bg = '#cccccc', justify = LEFT)\nlabel_top.pack(padx = 10, pady = 10)\n\nframe_bottom = Frame(width = 400, height = 350, bg = '#cccccc')\n\nbutton_m = Button(frame_bottom, text = \"影\", width = 7, height = 2, command = lambda:show_yx(\"嘤嘤嘤\"))\nbutton_m.grid(row = 0, column = 0)\nbutton_n = Button(frame_bottom, text = \"修\", width = 7, height = 2, command = lambda:show_yx(\"羞羞羞\"))\nbutton_n.grid(row = 0, column = 1)\nbutton_chu = Button(frame_bottom, text = \"%\", width = 7, height = 2, command = lambda:show_op(\"%\"))\nbutton_chu.grid(row = 0, column = 2)\nbutton_c = Button(frame_bottom, text = \"C\", width = 7, height = 2, command = lambda:show_del(1))\nbutton_c.grid(row = 0, column = 3)\n\nbutton_7 = Button(frame_bottom, text = \"7\", width = 7, height = 2, command = lambda:show_num(\"7\"))\nbutton_7.grid(row = 1, column = 0)\nbutton_8 = Button(frame_bottom, text = \"8\", width = 7, height = 2, command = lambda:show_num(\"8\"))\nbutton_8.grid(row = 1, column = 1)\nbutton_9 = Button(frame_bottom, text = \"9\", width = 7, height = 2, command = lambda:show_num(\"9\"))\nbutton_9.grid(row = 1, column = 2)\nbutton_chu = Button(frame_bottom, text = \"/\", width = 7, height = 2, command = lambda:show_op(\"÷\"))\nbutton_chu.grid(row = 1, column = 3)\n\nbutton_4 = Button(frame_bottom, text = \"4\", width = 7, height = 2, command = lambda:show_num(\"4\"))\nbutton_4.grid(row = 2, column = 0)\nbutton_5 = Button(frame_bottom, text = \"5\", width = 7, height = 2, command = lambda:show_num(\"5\"))\nbutton_5.grid(row = 2, column = 1)\nbutton_6 = Button(frame_bottom, text = \"6\", width = 7, height = 2, command = lambda:show_num(\"6\"))\nbutton_6.grid(row = 2, column = 2)\nbutton_cheng = Button(frame_bottom, text = \"*\", width = 7, height = 2, command = lambda:show_op(\"×\"))\nbutton_cheng.grid(row = 2, column = 3)\n\nbutton_1 = Button(frame_bottom, text = \"1\", width = 7, height = 2, command = lambda:show_num(\"1\"))\nbutton_1.grid(row = 3, column = 0)\nbutton_2 = Button(frame_bottom, text = \"2\", width = 7, height = 2, command = lambda:show_num(\"2\"))\nbutton_2.grid(row = 3, column = 1)\nbutton_3 = Button(frame_bottom, text = \"3\", width = 7, height = 2, command = lambda:show_num(\"3\"))\nbutton_3.grid(row = 3, column = 2)\nbutton_jian = Button(frame_bottom, text = \"-\", width = 7, height = 2, command = lambda:show_op(\"-\"))\nbutton_jian.grid(row = 3, column = 3)\n\nbutton_0 = Button(frame_bottom, text = \"0\", width = 7, height = 2, command = lambda:show_num(\"0\"))\nbutton_0.grid(row = 4, column = 0)\nbutton_dian = Button(frame_bottom, text = \".\", width = 7, height = 2, command = lambda:show_op(\".\"))\nbutton_dian.grid(row = 4, column = 1)\nbutton_dengyu = Button(frame_bottom, text = \"=\", width = 7, height = 2, command = lambda:show_op('='))\nbutton_dengyu.grid(row = 4, column = 2)\nbutton_jia = Button(frame_bottom, text = \"+\", width = 7, height = 2, command = lambda:show_op(\"+\"))\nbutton_jia.grid(row = 4, column = 3)\n\nframe_bottom.pack(padx = 10, pady = 10)\n"}, {"ctype": "code", "data": "\n"}], "cate": "Python"}
{"题目": "爬取mm图片", "作者": "一只努力的蜗牛", "发布时间": "2021-03-27 00:34:33", "内容": [{"ctype": "p", "data": "上网址：https://pic.netbian.com/4kmeinv/ 前面几步其实都一样，导入模块，指定url和headers，发起请求，获得请求数据"}, {"ctype": "code", "data": "import requests\nfrom lxml import etree\nimport os\n# if not os.path.exists('./meinv'):\n#     os.mkdir('./meinv')\nurl='https://pic.netbian.com/4kmeinv/'\nheaders={\n    'User-Agent':\n\t'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0'\n}\nresponse=requests.get(url=url,headers=headers)\n# response.encoding='utf-8'\npage_list=response.text\n"}, {"ctype": "p", "data": "然后是xpath的特色 将网页树化根据树化页面找到我们需要的特定的数据"}, {"ctype": "code", "data": "tree=etree.HTML(page_list)\nli_list=tree.xpath('//div[@class=\"slist\"]/ul/li')\n\nfor li in li_list:\n    se_src='https://pic.netbian.com'+li.xpath('./a/img/@src')[0]\n    se_name=li.xpath('./a/img/@alt')[0]+'.jpg' \n    se_name=se_name.encode('iso-8859-1').decode('gbk') \n"}, {"ctype": "p", "data": "最后持久化存储"}, {"ctype": "code", "data": "img_data=requests.get(url=se_src,headers=headers).content\nimg_path='meinv'+se_name\nwith open (img_path,'wb') as fp:\n    fp.write(img_data)\n    print (se_name+' finish')\n"}, {"ctype": "p", "data": "今天遇到的几个问题主要有 树化页面时tree=etree.HTML…我写成了.xpath 这属于**的一个错误 第二个就是 部分代码输错后报错为 IndexError: list index out of range 超出列表范围或者列表不存在，这里很显然是列表不存在 第三个是 出现乱码时的处理方式 response.encoding=‘utf-8’ se_name=se_name.encode(‘iso-8859-1’).decode(‘gbk’) 这两个换着试，不可以一起试"}, {"ctype": "p", "data": "第四个是 持久化存储时 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。"}, {"ctype": "p", "data": "第五个是刚刚发现的 持久还存储时img_path里面文件夹后应该加/否则python把它当作字符串处理"}, {"ctype": "p", "data": "总代码："}, {"ctype": "code", "data": "import requests\nfrom lxml import etree\nimport os\n# if not os.path.exists('./meinv'):\n#     os.mkdir('./meinv')\nurl='https://pic.netbian.com/4kmeinv/'\nheaders={\n    'User-Agent':\n\t'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0'\n}\nresponse=requests.get(url=url,headers=headers)\n# response.encoding='utf-8'\npage_list=response.text\n\ntree=etree.HTML(page_list)\nli_list=tree.xpath('//div[@class=\"slist\"]/ul/li')\n\n# fp=open('./')\nfor li in li_list:\n    se_src='https://pic.netbian.com'+li.xpath('./a/img/@src')[0]\n    se_name=li.xpath('./a/img/@alt')[0]+'.jpg' \n    se_name=se_name.encode('iso-8859-1').decode('gbk') \n    # print(se_name,se_src)\n    \n    img_data=requests.get(url=se_src,headers=headers).content\n    img_path='meinv/'+se_name\n    with open (img_path,'wb') as fp:\n        fp.write(img_data)\n        print (se_name+' finish')\n    \n    \n"}, {"ctype": "p", "data": "最后 附上mm图片 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327003329803.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODY4MDAxMA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "再来一个"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327003414263.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODY4MDAxMA==,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "tensorflow 图像分类 demo", "作者": "jingxindeyi", "发布时间": "2021-03-28 00:42:33", "内容": [{"ctype": "p", "data": "最终的结果 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328004415797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzbG5ndQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "1. 输入准备"}, {"ctype": "p", "data": "首先拿到 0~9 数字的图片，清理成下面这种格式"}, {"ctype": "p", "data": "数字 0 示例 (文件暂时命名为 0.model)"}, {"ctype": "code", "data": "01111110\n01111111\n11100111\n11100011\n11100011\n11000011\n11100011\n11100011\n11100111\n01111110\n01111110\n"}, {"ctype": "p", "data": "因为是 demo 所以简单构造一下输入 将所有数字的图形信息都复制一下"}, {"ctype": "code", "data": "def copy_data():\n    l = [str(i) for i in range(0, 10)]\n    for ll in l:\n        path = \"./tf/\" + str(ll) + \".model\"\n        with open(path, \"r\") as f:\n            cur = f.read()\n            for j in range(0, 15):\n               # s_path ex: 0_1.model 生成15个一样的输入\n                s_path = \"./tf/\" + str(ll) + \"_\" + str(j) + \".model\"\n                with open(s_path, \"w\") as wf:\n                    wf.write(cur)\n"}, {"ctype": "p", "data": "这样一共生成 10 * 14 个图像数据"}, {"ctype": "head", "data": "2. 格式化输入"}, {"ctype": "p", "data": "代码引用的库 & 环境配置"}, {"ctype": "code", "data": "import os\nmodel_path = \"代码根目录\"\nos.chdir(model_path)\nimport cv2\nimport numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom tensorflow import keras\n"}, {"ctype": "p", "data": "将原始内容可视化"}, {"ctype": "code", "data": "trains = []\nlabels=[]\n\ndef get_train(path):\n    with open(path, \"r\") as f:\n        cur = f.read()\n        lines = cur.split(\"\\n\")\n        strs = [list(l) for l in lines]\n        return np.array(strs, dtype='uint8')\n\nfor file in os.listdir(\".\"):\n    if file.find(\"_\") == -1:\n        continue\n    trains.append(get_train(file))\n    labels.append(file.split(\"_\")[0])\n    \nplt.figure(figsize=(10,10))\nfor i in range(10):\n    m = get_train(str(i) + '.model')\n    plt.subplot(5, 5, (i + 1))\n    plt.imshow(m)\n    plt.xticks([])\n    plt.yticks([])\n    plt.xlabel(str(i))\n"}, {"ctype": "p", "data": "结果如下:  获取 训练集合 和 标签集合"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328002340334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzbG5ndQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "for file in os.listdir(\".\"):\n    if file.find(\"_\") == -1:\n        continue\n    trains.append(get_train(file))\n    labels.append(file.split(\"_\")[0])\n"}, {"ctype": "head", "data": "3. 构建 model"}, {"ctype": "code", "data": "# 这些层 & 优化 & 损失函数 是官网源文档的配置\nmodels = keras.Sequential([\n    keras.layers.Flatten(input_shape=(11, 8)),\n    keras.layers.Dense(128, activation=\"relu\"),\n    keras.layers.Dense(10)])\nmodels.compile(\n    optimizer = 'adam',\n    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n    metrics=['accuracy']\n)\n"}, {"ctype": "p", "data": "训练"}, {"ctype": "code", "data": "models.fit(np.array(trains), np.array(labels, dtype=\"uint8\"), epochs=10)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328002752435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzbG5ndQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4. 预测"}, {"ctype": "p", "data": "构建预测的model"}, {"ctype": "code", "data": "#SoftMax 将预测结果转为概率\npredict_model = tf.keras.Sequential([models, tf.keras.layers.Softmax()])\n"}, {"ctype": "p", "data": "预测 可以看到预测为数字0的概率为0.81"}, {"ctype": "code", "data": "get_train(\"0.model\")\npredict_model.predict(np.array([get_train(\"0.model\")]))\n"}, {"ctype": "p", "data": " 再用 9 看一下 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328002917392.png"}, {"ctype": "head", "data": "5. 完整的模型相关代码"}, {"ctype": "code", "data": "import os\nimport cv2\nimport numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom tensorflow import keras\n\nmodel_path = \"./tf\" # 所有的图形信息文件放在代码同目录 tf文件夹下 后缀名为.model\nos.chdir(model_path)\n\n\ntrains = []\nlabels=[]\n\ndef get_train(path):\n    with open(path, \"r\") as f:\n        cur = f.read()\n        lines = cur.split(\"\\n\")\n        strs = [list(l) for l in lines]\n        return np.array(strs, dtype='uint8')\n\nfor file in os.listdir(\".\"):\n    if file.find(\"_\") == -1:\n        continue\n    trains.append(get_train(file))\n    labels.append(file.split(\"_\")[0])\n\nmodels = keras.Sequential([\n    keras.layers.Flatten(input_shape=(11, 8)),\n    keras.layers.Dense(128, activation=\"relu\"),\n    keras.layers.Dense(10)])\n\nmodels.compile(\n    optimizer = 'adam',\n    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n    metrics=['accuracy']\n)\n\nmodels.fit(np.array(trains), np.array(labels, dtype=\"uint8\"), epochs=10)\npredict_model = tf.keras.Sequential([models, tf.keras.layers.Softmax()])\n\nif __name__ == '__main__':\n    tests = []\n    for i in range(10):\n        tests.append(get_train(str(i) + \".model\"))\n\n    rs = predict_model.predict(np.array(tests))\n    for i in range(10):\n        print(\"数字 %s 预测为 %s 的概率为 %s\" % (str(i), str(i), rs[i][i]))\n\n\n"}, {"ctype": "p", "data": "结果: "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032800410051.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzbG5ndQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "神经网络权重不更新与初始化", "作者": "ForeverHaibara", "发布时间": "2021-03-27 23:43:42", "内容": [{"ctype": "head", "data": "神经网络权重不更新与初始化"}, {"ctype": "head", "data": "问题"}, {"ctype": "p", "data": "在手敲神经网络进行训练时，发现神经网络权重w并没有更新。 "}, {"ctype": "head", "data": "代码"}, {"ctype": "p", "data": "主要代码如下（activations.activator 是用来返回激活函数的函数指针的）"}, {"ctype": "code", "data": "import activations\nimport numpy as np\nimport pandas as pd\n\nclass Neuro():\n    def __init__(self,cellnum,learning_rate=0.1,activators=1):\n        self.cellnum = cellnum\n        self.layer_num = len(cellnum)-1\n        self.learning_rate = learning_rate\n        \n        if type(activators) == int :\n            self.activator = [activations.activator(activators)] * self.layer_num\n        else :\n            self.activator = [activations.activator(activator) for activator in activators]\n        \n        self.w , self.b = [] , [] # weights and biases\n        for height, width in zip(cellnum[:-1],cellnum[1:]):\n            self.w.append(np.zeros((height,width)))\n            self.b.append(np.zeros((1,width)))\n\n\n    def fit(self,_x,_y,epochs,batch_size):\n        credit_learning_rate = self.learning_rate / batch_size\n\n        for epoch in range(epochs):\n            index = np.random.permutation(_x.shape[0])\n\n            # activated value, x[layer].shape = ( batch_size , cell[layer] )\n            x = [ np.empty((batch_size,width)) for width in self.cellnum ]\n\n            # pre-activated value , z[layer].shape = ( batch_size , cell[layer+1])\n            z = [ np.empty((batch_size,width)) for width in self.cellnum[1:] ]\n\n            # error[layer].shape = ( batch_size , cell[layer+1] )\n            error = [ np.empty((batch_size,width)) for width in self.cellnum[1:] ]\n\n            for batch_num in range(_x.shape[0],batch_size-1,-batch_size):\n                x[0] = _x[index[batch_num-batch_size : batch_num] , :]\n                y    = _y[index[batch_num-batch_size : batch_num] , :]\n\n                # forward_propagation\n                for layer in range(self.layer_num):\n                    # b[layer] should be broadcast to shape (batch_size,b[layer].width()) \n                    # (automatically broadcast by numpy)\n                    z[layer] = np.dot(x[layer], self.w[layer]) + self.b[layer]\n                    x[layer+1] = self.activator[layer].function()(z[layer])\n                \n                error[-1] = (x[-1] - y) * self.activator[-1].derivative()(z[-1]) # hadmard multiply\n                print(\"loss = \",np.linalg.norm(x[-1]-y))\n\n                # back propagation\n                for layer in range(self.layer_num-2,-1,-1):\n                    error[layer] = self.activator[layer].derivative()(z[layer]) * np.dot(error[layer+1],self.w[layer+1].transpose())\n\n                # update\n                for layer in range(self.layer_num-1,-1,-1):\n                    self.w[layer] -= np.dot(x[layer].transpose() , error[layer]) * credit_learning_rate\n                    self.b[layer] -= np.sum(error[layer],axis=0) * credit_learning_rate\n                    \n"}, {"ctype": "head", "data": "原因分析"}, {"ctype": "head", "data": "1.初始化权重全为0"}, {"ctype": "p", "data": "注意反向传播(back propagation)的部分中，误差项的计算公式： \n     \n      \n       \n        \n         \n          δ\n         \n         \n          l\n         \n        \n        \n         =\n        \n        \n         \n          f\n         \n         \n          ′\n         \n        \n        \n         (\n        \n        \n         \n          z\n         \n         \n          l\n         \n        \n        \n         )\n        \n        \n         ⊙\n        \n        \n         (\n        \n        \n         \n          δ\n         \n         \n          \n           l\n          \n          \n           +\n          \n          \n           1\n          \n         \n        \n        \n         (\n        \n        \n         \n          w\n         \n         \n          \n           l\n          \n          \n           +\n          \n          \n           1\n          \n         \n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         )\n        \n       \n       \n        \\delta^l=f'(z^l)\\odot (\\delta^{l+1}(w^{l+1})^T) \n       \n      \n     δl=f′(zl)⊙(δl+1(wl+1)T) 其中 \n    \n     \n      \n       \n        \n         δ\n        \n        \n         l\n        \n       \n       \n        ,\n       \n       \n        \n         δ\n        \n        \n         \n          l\n         \n         \n          +\n         \n         \n          1\n         \n        \n       \n      \n      \n       \\delta^l,\\delta^{l+1}\n      \n     \n    δl,δl+1为第 \n    \n     \n      \n       \n        l\n       \n       \n        ,\n       \n       \n        l\n       \n       \n        +\n       \n       \n        1\n       \n      \n      \n       l,l+1\n      \n     \n    l,l+1 层误差项，\n    \n     \n      \n       \n        f\n       \n      \n      \n       f\n      \n     \n    f为激活函数，\n    \n     \n      \n       \n        ⊙\n       \n      \n      \n       \\odot\n      \n     \n    ⊙表示哈达玛积（矩阵对应位置元素相乘）。"}, {"ctype": "p", "data": "或见代码中的第52~53行："}, {"ctype": "code", "data": "for layer in range(self.layer_num-2,-1,-1):         \n    error[layer] = self.activator[layer].derivative()(z[layer]) * np.dot(error[layer+1],self.w[layer+1].transpose())\n"}, {"ctype": "p", "data": "如果一开始初始化所有权重\n    \n     \n      \n       \n        w\n       \n      \n      \n       w\n      \n     \n    w为0（零矩阵），那么第一次反向传播的时候在此处权重 \n    \n     \n      \n       \n        w\n       \n      \n      \n       w\n      \n     \n    w 也为0，经过点乘之后，误差项 \n    \n     \n      \n       \n        \n         δ\n        \n        \n         l\n        \n       \n       \n        =\n       \n       \n        e\n       \n       \n        r\n       \n       \n        r\n       \n       \n        o\n       \n       \n        r\n       \n       \n        [\n       \n       \n        l\n       \n       \n        a\n       \n       \n        y\n       \n       \n        e\n       \n       \n        r\n       \n       \n        ]\n       \n      \n      \n       \\delta^l=error[layer]\n      \n     \n    δl=error[layer] 也为零矩阵。"}, {"ctype": "p", "data": "再看最后几行使用误差项计算更新： \n     \n      \n       \n        \n         \n          w\n         \n         \n          l\n         \n        \n        \n         ←\n        \n        \n         \n          w\n         \n         \n          l\n         \n        \n        \n         −\n        \n        \n         η\n        \n        \n         (\n        \n        \n         \n          x\n         \n         \n          l\n         \n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         \n          δ\n         \n         \n          l\n         \n        \n        \n        \n         \n          b\n         \n         \n          l\n         \n        \n        \n         ←\n        \n        \n          \n        \n        \n         \n          b\n         \n         \n          l\n         \n        \n        \n          \n        \n        \n         −\n        \n        \n          \n        \n        \n         η\n        \n        \n         \n          δ\n         \n         \n          l\n         \n        \n        \n               \n        \n       \n       \n        w^l ←w^l- η(x^l)^T\\delta^l \\\\b^l ←\\ b^l\\ -\\ η\\delta^l\\ \\ \\ \\ \\ \\ \n       \n      \n     wl←wl−η(xl)Tδlbl← bl − ηδl       或代码最末："}, {"ctype": "code", "data": "for layer in range(self.layer_num-1,-1,-1):\n    self.w[layer] -= np.dot(x[layer].transpose() , error[layer]) * credit_learning_rate\n    self.b[layer] -= np.sum(error[layer],axis=0) * credit_learning_rate\n"}, {"ctype": "p", "data": "第 \n    \n     \n      \n       \n        l\n       \n      \n      \n       l\n      \n     \n    l 层权重与偏置 \n    \n     \n      \n       \n        \n         w\n        \n        \n         l\n        \n       \n       \n        ,\n       \n       \n        \n         b\n        \n        \n         l\n        \n       \n      \n      \n       w^l,b^l\n      \n     \n    wl,bl 的更新都涉及到了误差项 \n    \n     \n      \n       \n        \n         δ\n        \n        \n         l\n        \n       \n      \n      \n       \\delta^l\n      \n     \n    δl，但由于前面表明误差项为零矩阵，所以权重就不会更新！如此一来，权重矩阵 \n    \n     \n      \n       \n        w\n       \n      \n      \n       w\n      \n     \n    w 仍然是0，再怎么训练依旧为0."}, {"ctype": "head", "data": "2.初始化权重全相等"}, {"ctype": "p", "data": "那么是不是只要不把权重初始化全为0就行了呢？在偷懒的情况下，试图把权重全部初始化为一样的值（比如全变成0.5），这样就解决了吗？  答案是否定的。 假设有一个三层的神经网络：输入层（input layer)、中间层（hidden layer)、输出层（output layer)，假设中间层有神经元 \n    \n     \n      \n       \n        \n         a\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         2\n        \n       \n       \n        ,\n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         n\n        \n       \n      \n      \n       a_1,a_2,...,a_n\n      \n     \n    a1​,a2​,...,an​。  实际上，神经网络训练中的每一步都是矩阵运算，它们对 \n    \n     \n      \n       \n        \n         a\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         2\n        \n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         n\n        \n       \n      \n      \n       a_1,a_2...,a_n\n      \n     \n    a1​,a2​...,an​ 一视同仁。而且由于权重初始化完全一致，也就是说 \n    \n     \n      \n       \n        \n         a\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         2\n        \n       \n       \n        ,\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         n\n        \n       \n      \n      \n       a_1,a_2,..,a_n\n      \n     \n    a1​,a2​,..,an​ 都是等价的。无论怎么训练，输入层对 \n    \n     \n      \n       \n        \n         a\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         2\n        \n       \n       \n        ,\n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         a\n        \n        \n         n\n        \n       \n      \n      \n       a_1,a_2,...,a_n\n      \n     \n    a1​,a2​,...,an​ 的贡献权重一样、它们对输出层的贡献权重一样、输出层计算对每个\n    \n     \n      \n       \n        \n         a\n        \n        \n         i\n        \n       \n      \n      \n       a_i\n      \n     \n    ai​的偏导一样、反向传播的误差项一样、各 \n    \n     \n      \n       \n        \n         a\n        \n        \n         i\n        \n       \n      \n      \n       a_i\n      \n     \n    ai​ （与之相关的权重）的更新也一样……也就是说，这些 \n    \n     \n      \n       \n        \n         a\n        \n        \n         i\n        \n       \n      \n      \n       a_i\n      \n     \n    ai​共进退，相当于中间层只有一个神经元 \n    \n     \n      \n       \n        \n         a\n        \n        \n         1\n        \n       \n      \n      \n       a_1\n      \n     \n    a1​！"}, {"ctype": "head", "data": "解决"}, {"ctype": "p", "data": "初始化的时候用随机数，例如 np.random.normal生成给定均值、方差的正态分布矩阵："}, {"ctype": "code", "data": "self.w , self.b = [] , [] # weights and biases\nfor height, width in zip(cellnum[:-1],cellnum[1:]):\n    self.w.append(np.random.normal(0,1,(height,width)))\n    self.b.append(np.random.normal(0,1,(1,width)))\n"}], "cate": "Python"}
{"题目": "leetcode  1315. Sum of Nodes with Even-Valued Grandparent（python）", "作者": "王大丫丫", "发布时间": "2021-03-27 16:40:23", "内容": [{"ctype": "head", "data": "描述"}, {"ctype": "p", "data": "Given a binary tree, return the sum of values of nodes with even-valued grandparent. (A grandparent of a node is the parent of its parent, if it exists.)"}, {"ctype": "p", "data": "If there are no nodes with an even-valued grandparent, return 0."}, {"ctype": "p", "data": "Example 1:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/a29b7b1e3c784bcc37712aecad131044.png"}, {"ctype": "code", "data": "Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\nOutput: 18\nExplanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.\n"}, {"ctype": "p", "data": "Note:"}, {"ctype": "code", "data": "The number of nodes in the tree is between 1 and 10^4.\nThe value of nodes is between 1 and 100.\n"}, {"ctype": "head", "data": "解析"}, {"ctype": "p", "data": "根据题意，只需要找出该节点有爷爷节点且爷爷节点是偶数，就将该节点的值加入 res 中，使用 DFS 遍历所有节点之后即可得到结果。第一种解法是从下往上，代码比较简洁。第二种解法是从上往下比较好理解，只是代码有些冗余。"}, {"ctype": "head", "data": "解答"}, {"ctype": "code", "data": "class Solution(object):\n   "}], "cate": "Python"}
{"题目": "面试题 05.07. 配对交换", "作者": "pfco", "发布时间": "2021-03-28 21:45:46", "内容": [{"ctype": "p", "data": "本文旨在对于个人知识的梳理以及知识的分享，如果有不足的地方，欢迎大家在评论区指出"}, {"ctype": "head", "data": "题目描述"}, {"ctype": "p", "data": "配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。 示例1:"}, {"ctype": "code", "data": " 输入：num = 2（或者0b10）\n 输出 1 (或者 0b01)\n"}, {"ctype": "p", "data": "示例2:"}, {"ctype": "code", "data": " 输入：num = 3\n 输出：3\n"}, {"ctype": "p", "data": "提示:"}, {"ctype": "head", "data": "题目链接"}, {"ctype": "head", "data": "题目分析"}, {"ctype": "p", "data": "我的思路是先分析题目中数字的范围，最大为32位，所以我只需要枚举每一位，之后两两交换每一位，得到最终的解就好了，偏向于模拟的写法，拿一个数字来举例，例如给定数字6，首先6的二进制表示缩减为0110，之后相应的求解过程如下:"}, {"ctype": "code", "data": "0110\n\n假设res = 0\n首先分析第一组10，此时这里原本的计算为0*2^0+1*2^1\n现在我们只需要将它颠倒，变成1*2^0+0*2^1即可，然后将这个新的计算结果累加到结果集中，\n也就是此时res = 1\n\n之后看第二组01，此时这里原本的计算为1*2^2+0^2^3\n现在我们将它颠倒，变成1*2^3+0*2^2，将这个结果放到结果集中，此时res = 9\n也就求出了我们要的结果\n"}, {"ctype": "p", "data": "那么第二种解法偏向于数学方面，它是利用了0xaaaaaaaa以及0x55555555这两个数字，首先看每一个a和每一个5，发现a的二进制表示为1010，而5为0101，故如果我们让num & 0xaaaaaaaa就可以获得该数字的所有奇数位，而num & 0x55555555就可以获得该数字的所有偶数位，之后我们让偶数位的数字右移一位，奇数位的数字左移一位，这两个数字或起来就是最终的解"}, {"ctype": "head", "data": "解题代码"}, {"ctype": "head", "data": "解法一"}, {"ctype": "p", "data": "Python"}, {"ctype": "code", "data": "class Solution:\n    def exchangeBits(self, num: int) -> int:\n        res = 0\n        for i in range(0, 32, 2):\n            even = num>>i&1\n            odd = (num>>i+1)&1\n            res += even*pow(2, i+1) + odd*pow(2, i)\n        return res\n"}, {"ctype": "p", "data": "Java"}, {"ctype": "code", "data": "class Solution {\n    public int exchangeBits(int num) {\n        int res = 0;\n        for(int i=0; i<32; i+=2){\n            int even = num>>i&1;\n            int odd = (num>>i+1)&1;\n            res += even*Math.pow(2, i+1) + odd*Math.pow(2, i);\n        }\n        return res;\n    }\n}\n"}, {"ctype": "head", "data": "解法二"}, {"ctype": "p", "data": "Python"}, {"ctype": "code", "data": "class Solution:\n    def exchangeBits(self, num: int) -> int:\n        a, b = num&0xaaaaaaaa, num&0x55555555\n        a >>= 1\n        b <<= 1\n        return a | b\n"}, {"ctype": "p", "data": "Java"}, {"ctype": "code", "data": "class Solution {\n    public int exchangeBits(int num) {\n        int a = num & 0xaaaaaaaa;\n        int b = num & 0x55555555;\n        a >>= 1; b <<= 1;\n        return a | b;\n    }\n}\n"}], "cate": "Python"}
{"题目": "字符串的查找、修改、判断", "作者": "weixin_49213878", "发布时间": "2021-03-28 16:40:04", "内容": [{"ctype": "head", "data": "字符串的查找、修改、判断"}, {"ctype": "head", "data": "一、查找"}, {"ctype": "head", "data": "find()"}, {"ctype": "p", "data": ":检测某一个子串是否包含在这个字符串中，如果在返回这个子串的下标，如果不在则返回 -1 语法 字符串序列.find（子串，开始下标，结束下标） 注意开始下标和结束下标可以省略，表示在整个字符串中查找"}, {"ctype": "code", "data": "str=\"0123456789\"\nprint(str.find('10'))\n"}, {"ctype": "p", "data": "结果为 ：-1"}, {"ctype": "code", "data": "a='12345677'\nprint(a.find('14'))\n"}, {"ctype": "p", "data": "结果为 ：-1"}, {"ctype": "code", "data": "str=\"0123456789\"\nprint(str.find('345'))\n"}, {"ctype": "p", "data": "结果为：3"}, {"ctype": "code", "data": "a='isc scjc dhsv jvdvud'\nprint(a.find('dhsv'))\n"}, {"ctype": "p", "data": "结果为9"}, {"ctype": "code", "data": "str=\"0123456789\"\nprint(str.find('8'))\n"}, {"ctype": "p", "data": "结果为 ：8"}, {"ctype": "head", "data": "index（）"}, {"ctype": "p", "data": "检测某一个子串是否包含在这个字符串中：如果在返回这个子串开始下标，否则报错 语法 ：字符串序列.index（子串，开始下标，结束下标）"}, {"ctype": "code", "data": "txt = \"Hello, welcome to my world.\"\n\nx = txt.index(\"welcome\")\n\nprint(x)\n"}, {"ctype": "p", "data": "结果：7"}, {"ctype": "code", "data": "str=\"0123456789\"\nprint(str.index('23456'))\n"}, {"ctype": "p", "data": "结果为：2"}, {"ctype": "code", "data": "str=\"0123456789\"\nprint(str.index('02'))\n"}, {"ctype": "p", "data": "结果报错"}, {"ctype": "p", "data": "查找的必须是单个的或者是连续的一个子串"}, {"ctype": "p", "data": "index() 方法查找指定值的首次出现。 如果找不到该值，index() 方法将引发异常。 index() 方法与 find() 方法几乎相同，唯一的区别是，如果找不到该值，则 find() 方法将返回 -1。"}, {"ctype": "head", "data": "rfind（）和find（）"}, {"ctype": "p", "data": "功能相同但rfind是从右边开始查找"}, {"ctype": "code", "data": "txt = \"China is a great country. I love China.\"\n\nx = txt.rfind(\"China\")\n\nprint(x)\n"}, {"ctype": "p", "data": "结果为33"}, {"ctype": "head", "data": "rindex 和index"}, {"ctype": "p", "data": "功能相同但是查找方向从右边开始"}, {"ctype": "code", "data": "txt = \"Hello, welcome to my world.\"\n\nx = txt.rindex(\"e\")\n\nprint(x)\n"}, {"ctype": "p", "data": "结果为13"}, {"ctype": "head", "data": "count()"}, {"ctype": "p", "data": "返回某一个子串在字符串中出现的次数 语法 ：字符串序列.count（子串，开始下标，结束下标）"}, {"ctype": "code", "data": "txt = \"I love apples, apple are my favorite fruit\"\n\nx = txt.count(\"apple\", 10, 24)\n\nprint(x)\n"}, {"ctype": "p", "data": "结果：1"}, {"ctype": "head", "data": "strip() 方法删除开头和结尾的空白字符"}, {"ctype": "p", "data": "："}, {"ctype": "code", "data": "a = \" Hello, World! \"\nprint(a.strip()) # returns \"Hello, World!\"\n"}, {"ctype": "p", "data": "结果为Hello, World!"}, {"ctype": "head", "data": "lower() 返回小写的字符串："}, {"ctype": "code", "data": "a = \"Hello, World!\"\nprint(a.lower())\n"}, {"ctype": "p", "data": "结果为 hello, world"}, {"ctype": "head", "data": "upper() 方法返回大写的字符串："}, {"ctype": "code", "data": "a = \"Hello, World!\"\nprint(a.upper())\n"}, {"ctype": "p", "data": "结果为 HELLO, WORLD"}, {"ctype": "head", "data": "title() 方法返回一个字符串，其中每个单词的第一个字符均为大写。比如标题。"}, {"ctype": "p", "data": "如果单词包含数字或符号，则其后的第一个字母将转换为大写字母。"}, {"ctype": "code", "data": "txt = \"Welcome to my world\"\n\nx = txt.title()\n\nprint(x)\n"}, {"ctype": "p", "data": "结果为Welcome To My World 请注意，非字母字母之后的第一个字母将转换为大写字母："}, {"ctype": "code", "data": "txt = \"hello d2d2d2 and 5g5g5g\"\n\nx = txt.title()\n\nprint(x)\n"}, {"ctype": "p", "data": "结果为Hello D2D2D2 And 5G5G5G"}], "cate": "Python"}
{"题目": "python自动化-一键作业重命名", "作者": "先剃度再出家", "发布时间": "2021-03-27 18:23:59", "内容": [{"ctype": "head", "data": "前言：写在前面"}, {"ctype": "p", "data": "  作为一个成熟稳重的大学生，我们的必修课可不还是最大限度的偷懒吗？作为班长，每次面对一堆文件，文件命名各式各样，一点都不整整奇奇，想要整齐还得一个个重命名，这又是一件很头大的事情！！！！   科技改变生活，感谢科技！让我产生了用python写代码一键重命名的想法，废话不多说！上源码！！！   "}, {"ctype": "head", "data": "一、源码"}, {"ctype": "head", "data": "1、结果展示"}, {"ctype": "p", "data": "  未重命名之前：    重命名之后： 输入、输出：  结果： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327180652625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg3MzY3Ng==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2、源码"}, {"ctype": "p", "data": "  python源代码如下："}, {"ctype": "code", "data": "import os\nimport pandas as pd\n\ndef suffix(file_list):\n    # 返回对应后缀名\n    lst =['.doc','.docx','.txt','.pdf','.xls','.xlsx']\n    for i in lst:\n        if i in file_list:\n            j = file_list[-len(i):len(file_list)]\n            if i == j:\n                return i\n\n\ndef roster(path_roster):\n    # 获取Excel列，包括学号、姓名\n    Student_name = pd.read_excel(path_roster, usecols=[2],names=None)  # 读取项目名称列,不要列名\n    Student_id = pd.read_excel(path_roster, usecols=[1],names=None)  # 读取项目名称列,不要列名\n\n    # 将列转为list，每个元素均为list\n    name_list = Student_name.values.tolist()\n    id_list = Student_id.values.tolist()\n    # 转化为一个列表\n    result_name = []\n    result_id = []\n    for s1 in name_list:\n        result_name.append(s1[0])\n    for s2 in id_list:\n        result_id.append(s2[0])\n\n    return result_name,result_id\n\ndef rename_my(path_file,path_roster,num):\n    # 获取文件路径\n    file_list = os.listdir(path_file)  # 获取文件路径\n\n    # 获取学生名单(学号，姓名)\n    student_name,student_id = roster(path_roster)\n\n    # 定义OS路径\n    os.chdir(path_file)\n\n    # 重命名\n    for name in range (0,len(student_name)):\n        for named in range(0,len(file_list)):\n            if student_name[name] in file_list[named]:\n                # str_rename为重命名之后的名称，file_list[named]为重命名之前的\n                str_rename = str(student_id[name])+'-'+student_name[name]+'-'+'第'+num+'次作业'+ suffix(file_list[named])\n                os.rename(file_list[named],str_rename)\n    # 返回重命名文件个数\n    return len(file_list)\n\n\n\nif __name__ == '__main__':\n    number = input(\"请输入想要整理第几次作业：\")\n    # 定义作业文件夹路径\n    path_file = 'D:\\Desktop\\操作系统选讲作业\\操作系统选讲第' + number + '次作业'\n\n    # 定义花名册路径\n    path_roster = 'D:\\Desktop\\操作系统选讲作业\\花名册.xlsx'\n\n    total = rename_my(path_file,path_roster,number)\n\n    print('修改完毕，共修改',total,'个文件')\n"}, {"ctype": "head", "data": "二、源码注解"}, {"ctype": "head", "data": "1、所使用依赖包"}, {"ctype": "p", "data": "  所使用到的依赖包共两个，如下所示："}, {"ctype": "code", "data": "# os模块提供了非常丰富的方法用来处理文件和目录\nimport os\n\n# pandas提供了大量能使我们快速便捷地处理数据的函数和方法\nimport pandas as pd\n"}, {"ctype": "p", "data": "  依赖包安装："}, {"ctype": "code", "data": "# 在cmd行输入：\npip install os\npip install pandas\n\n#最后查看是否已安装：\npip list\n"}, {"ctype": "head", "data": "2、调用函数"}, {"ctype": "p", "data": "  所使用自定义函数如下："}, {"ctype": "code", "data": "# 获取后缀名\ndef suffix(file_list):\n \n # 获取学号、姓名\ndef roster(path_roster):\n\n#重命名为：学号-姓名-第几次作业\ndef rename_my(path_file,path_roster,num):\n\n# 函数入口\nif __name__ == '__main__':\n"}, {"ctype": "head", "data": "三、使用方法"}, {"ctype": "p", "data": "  自定义函数无需更改。需要更改如下："}, {"ctype": "code", "data": "#只需要将作业文件夹路径和班级花名册路径更改为本地路径即可。\n\nif __name__ == '__main__':\n    # 定义作业文件夹路径\n    path_file = 'D:\\Desktop\\操作系统选讲作业\\操作系统选讲第一次作业'\n    # 定义花名册路径\n    path_roster = 'D:\\Desktop\\操作系统选讲作业\\花名册.xlsx'\n\n"}, {"ctype": "p", "data": "花名册样式：    既然我们已经成功将所有文件重命名，那是不是还可以一键看看谁没交呢？请点击链接：python自动化-一键查作业学习使用。   配合使用，更加快乐，若没有能力更改源码，请将或名册中的学号用0填够13位，也可以正常使用哦！！！！"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326213627304.png"}], "cate": "Python"}
{"题目": "Python基础学习：函数(def)", "作者": "梁梁呀呀", "发布时间": "2021-03-27 23:13:30", "内容": [{"ctype": "head", "data": "一. 函数的概念："}, {"ctype": "code", "data": "函数是带名字的代码块，用于完成具体的工作。为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数。\n"}, {"ctype": "head", "data": "二. 函数的定义和调用："}, {"ctype": "p", "data": "代码示例1：定义函数"}, {"ctype": "code", "data": "def get_love():  #函数名为：get_love()\n    print(\"佳佳\")\nget_love()\n========================== RESTART: D:/py基础代码/3.27.py ==========================\n佳佳\n"}, {"ctype": "p", "data": "代码示例2：行参(parameter)与实参(argument)"}, {"ctype": "code", "data": "def sum_num(a,b):    #a,b为形参\n    print(a+b)       \nsum_num(3,5))  #3和5为实参\n========================== RESTART: D:/py基础代码/3.27.py ==========================\n8\n"}, {"ctype": "head", "data": "三. 函数的返回值(return):"}, {"ctype": "p", "data": "返回值能够将程序的大部分繁重工作移到函数中去完成，简化主程序。"}, {"ctype": "p", "data": "代码示例1：简单返回值—求圆的面积"}, {"ctype": "code", "data": "def S_yuan(pai,r):    \n    return pai*r*r      #返回函数的一个结果值   \nprint(S_yuan(3,5)) \n========================== RESTART: D:/py基础代码/3.27.py ==========================\n75\n"}, {"ctype": "p", "data": "代码示例2：返回一个字典"}, {"ctype": "code", "data": "def person(pname,psex):\n    person={\n    \"name\":pname,\n    \"sex\":psex\n    }\n    return person\nres=person(\"刘德华\",\"男\")\nprint(res)\n========================== RESTART: D:/py基础代码/3.27.py ==========================\n{'name': '刘德华', 'sex': '男'}\n"}, {"ctype": "p", "data": "代码示例3：函数与判断循环的使用"}, {"ctype": "code", "data": "def person(p_name,p_sex,age):\n#创建一个包含人物信息的字典。\n    person={\n        \"name\":p_name,\n        \"sex\":p_sex\n        }\n    if age:\n        person[\"age\"]=age\n    return person\nwhile True:   #这是一个无限循环\n    res=person(\"刘德华\",\"男\",50)\n    print(res)\n    break     #必须用break结束循环体\n    ========================== RESTART: D:/py基础代码/3.27.py ==========================\n{'name': '刘德华', 'sex': '男', 'age': 50}\n"}, {"ctype": "head", "data": "四. 函数与列表的使用"}, {"ctype": "p", "data": "代码示例1：列表反转字符串"}, {"ctype": "code", "data": "def reverse_str(input_str):\n    ch=list(input_str)\n    lens=len(ch)\n    i=0\n    j=lens-1\n    while i < j:\n        tmp=ch[i]\n        ch[i]=ch[j]\n        ch[j]=tmp\n        i+=1\n        j-=1\n    return ''.join(ch)\nprint(reverse_str('weixiaonan'))\n========================== RESTART: D:/py基础代码/3.27.py ==========================\nnanoaixiew\n"}], "cate": "Python"}
{"题目": "leetcode  1508. Range Sum of Sorted Subarray Sums（python）", "作者": "王大丫丫", "发布时间": "2021-03-27 16:43:41", "内容": [{"ctype": "head", "data": "描述"}, {"ctype": "p", "data": "Given the array nums consisting of n positive integers. You computed the sum of all non-empty continous subarrays from the array and then sort them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers."}, {"ctype": "p", "data": "Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7."}, {"ctype": "p", "data": "Example 1:"}, {"ctype": "code", "data": "Input: nums = [1,2,3,4], n = 4, left = 1, right = 5\nOutput: 13 \nExplanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n"}, {"ctype": "p", "data": "Example 2:"}, {"ctype": "code", "data": "Input: nums = [1,2,3,4], n = 4, left = 3, right = 4\nOutput: 6\nExplanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n"}, {"ctype": "p", "data": "Example 3:"}, {"ctype": "code", "data": "Input: nums = [1,2,3,4], n = 4, left = 1, right = 10\nOutput: 50\n"}, {"ctype": "p", "data": "Note:"}, {"ctype": "code", "data": "1 <= nums.length <= 10^3\nnums.length == n\n1 <= nums[i] <= 100\n1 <= left <= right <= n * (n + 1) / 2\n"}, {"ctype": "head", "data": "解析"}, {"ctype": "p", "data": "根据题意，最暴利的解法就是将 nums 的子数组和都算出来放入 res 中，然后对 res 进行排序，最后将 res[left-1:right] 的子数组求和并对 10**9+7 取模即可，只是这种方法太没技术含量了，鄙视自己的投机取巧。"}, {"ctype": "head", "data": "解答"}, {"ctype": "code", "data": "class Solution(object):\n    def rangeSum(self, nums, n, left, right):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        res = []\n        for i in range(n):\n            for j in range(i+1, n+1):\n                res.append(sum(nums[i:j]))\n        res.sort()\n        return sum(res[left-1:right])%(10**9+7)\n"}, {"ctype": "head", "data": "运行结果"}, {"ctype": "code", "data": "Runtime: 5696 ms, faster than 10.53% of Python online submissions for Range Sum of Sorted Subarray Sums.\nMemory Usage: 33.7 MB, less than 36.84% of Pyt\n"}, {"ctype": "p", "data": "原题链接：https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/"}, {"ctype": "p", "data": "您的支持是我最大的动力"}], "cate": "Python"}
{"题目": "xlwings跨工作簿复制粘贴工作表——小白文章", "作者": "红星闪闪的M", "发布时间": "2021-03-28 00:32:41", "内容": [{"ctype": "code", "data": "import xlwings as xw\nimport time\nfrom time import sleep\n#以上为调用xlwings模块和时间模块\napp = xw.App ( visible=True, add_book=False )\n#选择excel表格可视化操作，并且不新建sheet页\nwb = app.books.open (r'E:/䐁蕳/要复制的工作簿.xlsx')\nsht = wb.sheets['sheet1']\ntime.sleep(2)\nwb1= app.books.open ( r\"C:/Users/Administrator/Desktop/粘贴的工作簿.xlsm\" )\ntime.sleep(3)\n#以上是打开不同的工作簿\nsht1 = wb1.sheets['粘贴的工作表']\nsht1.range(\"a1\").expand(\"table\").clear_contents()\n#以上是清除单元格a1至扩展的部分并保留格式，如果不想要格式，就删掉_contents()\nwb.sheets[\"sheet1\"].range(\"a1\").expand(\"table\").api.Copy(sht1.range('a1').api)\n#以上为复制粘贴代码：意思是从\"要复制的工作簿”的第一个工作表的单元格a1到扩展部分复制给“粘贴的工作簿”的指定的”粘贴的工作表”\n适用于的做法，我想把一个工作簿的一个工作表完全复制到另一个工作簿的指定工作表。\n\n——小白文章，给个辛苦码字的赞——\n"}], "cate": "Python"}
{"题目": "小白如何使用Python获取“豆瓣电影”相关数据，并生成Excel表格", "作者": "Warolitbos", "发布时间": "2021-03-28 00:36:34", "内容": [{"ctype": "head", "data": "使用Python获取“豆瓣电影”相关数据，并生成Excel表格"}, {"ctype": "p", "data": "本文使用了requests和pandas第三方库，对豆瓣电影各相关数据进行爬取，并记录至Excel表格内。但发现存在以下三个问题："}, {"ctype": "p", "data": "生成的Excel表格，第一个sheet页为空数据爬取数据过长无法获取每个标签的具体电影数量，所以我取了一个吉祥的数字520，但请各位大佬指教，若为空，则直接停止，进入下一个标签的爬取"}, {"ctype": "p", "data": "请各位大佬进行指教，并进行优化，小弟在此谢谢！ 注：要是觉得文章写得不错，记得留个赞哦！  因为如果一开始不生成一个sheet页，则无法使用ExcelWriter的方法，小弟的解决方法是使用remove方法进行移除多余的sheet页，代码如下，请各位大佬指教！"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323194026574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpcnVzU2NhbkxvZw==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# 移除创建表格时多余的sheet页\ndef del_excel(self):\n\tbook = load_workbook(self.fileName)\n\tws = book[\"Sheet1\"]\n\tbook.remove(ws)\n\tbook.save(self.fileName)\n"}, {"ctype": "p", "data": "爬取豆瓣电影相关数据的具体代码如下："}, {"ctype": "code", "data": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport requests as re\nfrom openpyxl import load_workbook\nimport pandas as pd\nimport json\n\n\nclass DouBan:\n    def __init__(self):\n\n        self.sr1 = pd.DataFrame(columns=[\"评分\", \"电影名\"], index=None)\n        self.fileName = 'C:/Users/Administrator/Desktop/豆瓣电影评分.xlsx'\n        # sheetName = '豆瓣电影评分'\n\n        # 获取检索标签名\n        self.tag_Movie = {\n            0: \"热门\",\n            1: \"最新\",\n            2: \"经典\",\n            3: \"豆瓣高分\",\n            4: \"冷门佳片\",\n            5: \"华语\",\n            6: \"欧美\",\n            7: \"韩国\",\n            8: \"日本\",\n            9: \"动作\",\n            10: \"喜剧\",\n            11: \"爱情\",\n            12: \"科技\",\n            13: \"悬疑\",\n            14: \"恐怖\",\n            15: \"治愈\"\n        }\n\n    def douban_movie(self):\n\n        # 创建空文件\n        self.sr1.to_excel(self.fileName, index=False, header=True)\n        # 遍历检索标签，获取各标签的数据\n        for tagNumber in range(0, 16):\n            tag_Num = self.tag_Movie[tagNumber]\n            # 将获取的数据暂存在sr3列表内\n            sr3 = []\n            for page_s in range(0, 20, 20):\n\n                for l in self.movie_request(tag_Num, page_s):\n                    movieDetails = self.movie_details(movieID=l['id'])\n                    sr3.append({\n                        '评分': l['rate'],\n                        \"电影名\": l['title'],\n                        \"导演\": json.dumps(movieDetails[\"directors\"], indent=0, separators=('\\n', ': '),\n                                         ensure_ascii=False),\n                        \"主演\": json.dumps(movieDetails[\"actors\"], indent=0, separators=('\\n', ': '), ensure_ascii=False),\n                        \"时长\": movieDetails[\"duration\"]\n                    })\n\n            self.excel_data(sr3, tag_Num)\n\n        self.del_excel()  # 移除多余的sheet1页\n        print(\"====数据获取成功====\")\n\n    # 移除创建表格时多余的sheet页\n    def del_excel(self):\n\n        book = load_workbook(self.fileName)\n        ws = book[\"Sheet1\"]\n        book.remove(ws)\n        book.save(self.fileName)\n\n    # 在新的sheet页添加相应的数据，并保证数据不被覆盖\n    def excel_data(self, sr3, tag_Num):\n        \"\"\"\n        :param sr3:\n        :type tag_Num: object\n        \"\"\"\n        book = load_workbook(self.fileName)\n        writer = pd.ExcelWriter(self.fileName, mode=\"a\", engine=\"openpyxl\")\n        writer.book = book\n        sr1 = pd.DataFrame(sr3, index=None)\n        sr1.to_excel(writer, index=False, header=True, sheet_name=f\"{tag_Num}\")\n        writer.save()  # 这步才生成文件\n        writer.close()\n\n    # 获取豆瓣电影接口数据\n    @staticmethod\n    def movie_request(tag_Num, page_s):\n        \"\"\"\n        :type page_s: object\n        :type tag_Num: object\n        \"\"\"\n        url = \"https://movie.douban.com/j/search_subjects\"\n\n        params = {\n            \"type\": \"movie\",\n            \"tag\": tag_Num,\n            \"sort\": \"recommend\",\n            \"page_limit\": 20,\n            \"page_start\": page_s\n        }\n\n        headers = {\n            \"Authorization\": \"token\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.54\"\n        }\n\n        movies = re.get(url, params=params, headers=headers)\n        js = movies.json()\n        js = js[\"subjects\"]\n        data = json.dumps(js, sort_keys=True, indent=4, separators=(',', ': '), ensure_ascii=False)  # 字符串转化\n        print(data)\n        return js\n\n    # 获取电影详情\n    @staticmethod\n    def movie_details(movieID):\n\n        url = \"https://movie.douban.com/j/subject_abstract?\"\n\n        params = {\n            \"subject_id\": movieID\n        }\n\n        headers = {\n            \"Authorization\": \"token\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.54\"\n        }\n\n        movies = re.get(url, params=params, headers=headers)\n        js = movies.json()\n        js = js[\"subject\"]\n        # data = json.dumps(js, sort_keys=True, indent=4, separators=(',', ': '), ensure_ascii=False)  # 字符串转化\n        # print(data)\n        return js\n\n\nif __name__ == '__main__':\n    DouBan = DouBan()\n    DouBan.douban_movie()\n    \n"}, {"ctype": "p", "data": "生成的Excel表格如下，如果可以生成更漂亮的表格请指教！ "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323194454952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpcnVzU2NhbkxvZw==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "[快速排序]python实现快速排序", "作者": "maets906", "发布时间": "2021-03-28 15:58:07", "内容": [{"ctype": "head", "data": "思考方式"}, {"ctype": "head", "data": "数学家救火法"}, {"ctype": "p", "data": "「数学家救火法」的名字来源于著名的网络段子："}, {"ctype": "p", "data": "一天，数学家觉得自己已受够了数学，于是他跑到消防队去宣布他想当消防员。"}, {"ctype": "p", "data": "消防队长说：「您看上去不错，可是我得先给您一个测试。」"}, {"ctype": "p", "data": "消防队长带数学家到消防队后院小巷，巷子里有一个货栈，一只消防栓和一卷软管。"}, {"ctype": "p", "data": "消防队长问：「假设货栈起火，您怎么办？」"}, {"ctype": "p", "data": "数学家回答：「我把消防栓接到软管上， 打开水龙，把火浇灭。」"}, {"ctype": "p", "data": "消防队长说：「完全正确。最后一个问题：假设您走进小巷，而货栈没有起火，您怎么办？」"}, {"ctype": "p", "data": "数学家疑惑地思索了半天，终于答道：「我就把货栈点着。」"}, {"ctype": "p", "data": "消防队长大叫起来：「什么？太可怕了，您为什么要把货栈点着？」"}, {"ctype": "p", "data": "数学家回答：「这样我就把问题化简为一个我已经解决过的问题了。」"}, {"ctype": "p", "data": "在数学中，这种思考方式被称为化归。"}, {"ctype": "head", "data": "快速排序的原理"}, {"ctype": "p", "data": "首先在一组数中选取一个基准值（pivot）,所有比基准值小的数向左移，比基准值大的数向右移。"}, {"ctype": "p", "data": "3，5，8，1，2，9，4，7，6 待排序的数 3，1，2，4，5，8，9，7，6 选取4为基准值"}, {"ctype": "p", "data": "left为[3,1,2]"}, {"ctype": "p", "data": "right为[5,8,7,6]"}, {"ctype": "p", "data": "我们假设已经知道left和right的排序结果，只需left+[pivot]+right即可得到最终排序的结果。"}, {"ctype": "p", "data": "我们对left和right重复进行上述做法，最终就能得到结果。"}, {"ctype": "head", "data": "代码实现"}, {"ctype": "code", "data": "import random\ndef quick_sort(numbers):\n\t#定义递归出口\n    if len(numbers)==1:\n        return numbers\n    if len(numbers)==0:\n        return []\n    #选取基准值\n    pivot=random.choice(numbers)\n    left=[]\n    right=[]\n    #遍历待排序列表\n    for i in numbers:\n        if i<pivot:\n            left.append(i)\n        elif i==pivot:\n            pass\n        else:\n            right.append(i)\n    Left=[]\n    Right=[]\n    Left.extend(quick_sort(left))\n    Right.extend(quick_sort(right))\n    return Left+[pivot]+Right\n\nnumbers=[3,5,8,1,2,9,4,7,6]\nprint(quick_sort(numbers))\n"}, {"ctype": "p", "data": "结果如下"}, {"ctype": "code", "data": "[1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}, {"ctype": "head", "data": "总结"}, {"ctype": "p", "data": "我们使用了分治的思想，将大问题拆分成小问题，将小问题的解合并起来，就是大问题的答案。"}, {"ctype": "p", "data": "在这个问题中，我们使用了递归的方法，不断调用quick_sort函数处理待排序列表，直到找到递归出口，从而返回上一级递归函数。"}, {"ctype": "p", "data": "OK，That’s it!"}], "cate": "Python"}
{"题目": "python第七章课后习题plus(4)", "作者": "听说不挂科", "发布时间": "2021-03-28 15:36:27", "内容": [{"ctype": "p", "data": "将a,b两个列表改为ndarray类型，并进行连接。维度小的数据在前，维度大的数据在后。将维度小的数组进行调整，使其与维度大的数组的数组的shape相同，然后按维度较大数据的最后一个维度进行连接，返回连接后的ndarray。如果不能连接，返回空数组np.array([]) 提示：np.concatenate"}, {"ctype": "code", "data": "def fun4(a=[3,3,3],b=[[1,2,3],[4,5,6],[7,8,9]]):\n    '''\n    eg.a=[3,3,3],b=[[1,2,3],[4,5,6],[7,8,9]]\n    return a np.array e.g. [[3 3 3 1 2 3]\n       [3 3 3 4 5 6]\n       [3 3 3 7 8 9]]\n    '''\n    a1=np.array(a)\n    b1=np.array(b)\n#之前这里一直错，因为被题目中第二句话带偏了，如果没有这个判断有一个点过不了\n    if a1.ndim>b1.ndim:\n        a1,b1=b1,a1\n#之前都是用if，导致出错，后面听同学意见采用try-except\n    try:\n        a2=a1+np.zeros_like(b1) #利用广播使a1的shape与b1相同\n        return np.concatenate((a2,b1),axis=b1.ndim-1)#拼接的维度按照b1维度-1，因为维度从0开始\n    except:\n        return np.array([])\n"}], "cate": "Python"}
{"题目": "蓝桥杯试题 基础练习 FJ的字符串--Python实现+注释", "作者": "头发还很密", "发布时间": "2021-03-28 13:57:06", "内容": [{"ctype": "head", "data": "试题 基础练习 FJ的字符串"}, {"ctype": "head", "data": "题目"}, {"ctype": "code", "data": "问题描述\n　　FJ在沙盘上写了这样一些字符串：\n　　A1 = “A”\n　　A2 = “ABA”\n　　A3 = “ABACABA”\n　　A4 = “ABACABADABACABA”\n　　… …\n　　你能找出其中的规律并写所有的数列AN吗？\n输入格式\n　　仅有一个数：N ≤ 26。\n输出格式\n　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。\n样例输入\n3\n样例输出\nABACABA\n"}, {"ctype": "head", "data": "python代码"}, {"ctype": "code", "data": "用递归实现的  \nn=int(input())  \nA1='A'\t\t\t#先将n=1的字符串定义出来\ni=65\t\t\t#n=2时候是从A的ASCII往上加的\ndef letter(n):\t#开始递归\n    if n==1:\n        return A1\n    else:\n        return str(letter(n-1))+chr(i+(n-1))+str(letter(n-1))\n        #上一个字符串+上一个字符串的最后一个ASCII码加1+上一个字符串\nprint(letter(n))\n"}, {"ctype": "head", "data": "自学的python然后蓝桥杯报的python。代码可能写的不怎么好，继续努力吧！"}], "cate": "Python"}
{"题目": "Python爬虫学习 - 从零开始 8 (将信息存储为 Excel 文件 - xlwings 库 ）", "作者": "Alice", "发布时间": "2021-03-27 23:03:53", "内容": [{"ctype": "p", "data": "更新日期: 2021.03.27"}, {"ctype": "p", "data": "已经学习的内容："}, {"ctype": "p", "data": "爬取网页：掌握 requests 的常用方法。解析代码：掌握 BeautifulSoup (bs4) 和 re 的常用方法。保存信息：最简单的文件类型 txt。"}, {"ctype": "p", "data": "本节学习内容 ："}, {"ctype": "p", "data": "使用 xlwings 将获取的信息存储为 Excel 文件。"}, {"ctype": "head", "data": "1. 为什么选择 xlwings ？"}, {"ctype": "p", "data": "对于 txt 文件类型，除了使用 Ctrl + F 寻找信息之外，我不知道还可以怎么使用。"}, {"ctype": "p", "data": "因为平时接触比较多的就是Excel 文件，打算学习下怎样将获取的信息存储为Excel 文件。百度了下，发现 Python 中可以操作 Excel 的库很多…看得眼花缭乱…直到看了以下这篇介绍，直接选择了 xlwings ~~"}, {"ctype": "p", "data": "可能是全网最完整的 Python 操作 Excel库总结！ （原创：刘早起）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327212316539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDk1NTgyMQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2. 安装和导入"}, {"ctype": "p", "data": "pip 安装， 使用时 import。"}, {"ctype": "p", "data": "使用方法可以参见以上的总结，或参看官网文档。"}, {"ctype": "head", "data": "3. 创建/打开文件"}, {"ctype": "code", "data": "import xlwings as xw\n\nwb = xw.Book() # 新建一个Excel文件\nwb = xw.Book(\"test.xlsx\") # 打开Excel文件\nwb = xw.Book(r'C:\\Alice\\Crawler_pratice_2021\\test.xlsx') # 打开Excel文件\n"}, {"ctype": "head", "data": "4. 写入数据"}, {"ctype": "code", "data": "import xlwings as xw\nwb = xw.Book(\"test.xlsx\") # 打开Excel文件\nsheet = wb.sheets.active # 获取活动的工作表\n\nsheet.range('A1').value = 'test'\n\nsheet.range('A1').value = [\"a1\", \"b1\", \"c1\"] # 按行横向写入信息\n# 按列纵向写入信息\nsheet.range('A1').options(transpose=True).value = [\"a1_new\", \"a2\", \"a3\"] \n\n# 按照矩阵范围写入信息，2行3列\nsheet.range('A1').options(expand='table').value = [[\"a1_new_2\",2,3], [4,5,6]] \n# 按照矩阵范围写入信息，2列3行\nsheet.range('A1').options(expand='table',transpose=True).value = [[\"a1_new_2\",2,3], [4,5,6]]\n"}, {"ctype": "head", "data": "5. 获取工作表中单元格的值"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327223730319.png"}, {"ctype": "code", "data": "import xlwings as xw\nwb = xw.Book(\"test.xlsx\") # 打开Excel文件\nsheet = wb.sheets.active # 获取活动的工作表\n\nprint(sheet.range(\"a1\").value) # 获取一个单元个的值, a1\nprint(sheet.range(\"A1\").value) # 单元格名称大小写都可以, a1\n\nprint(sheet.range(\"A1:A3\").value) # 获取一列中相邻的一定范围的单元格的值, ['a1', 'a2', 'a3']\nprint(sheet.range(\"A1:A4\").value) # 没有信息的单元格会返回 None, ['a1', 'a2', 'a3', None]\n# print(sheet.range(\"A\").value) # 不能直接取一列的值，会报错\n\nprint(sheet.range(\"A1:B1\").value) # 获取一行中相邻的一定范围的单元格的值['a1', 'b1']\n\nprint(sheet.rangeB(\"A1:B2\").value) # 获取一个矩阵单元格内的值 [['a1', 'b1'], ['a2', 'b2']]\n"}, {"ctype": "head", "data": "6. 保存并关闭文件"}, {"ctype": "code", "data": "wb.save()  # 对于已经命名的文件，直接保存\nwb.save(\"test_2\")  # 对于新建后没有名字的文件，命名并保存\n\nwb.close() # 关闭文件\n"}, {"ctype": "head", "data": "7. 其他功能"}, {"ctype": "p", "data": "xlwings 还有很多其他的功能，比如给表格设置样式，插入图片等，可参见官网文档。"}], "cate": "Python"}
{"题目": "Python_总结列表排重方法", "作者": "weixin_50640351", "发布时间": "2021-03-27 23:53:51", "内容": [{"ctype": "p", "data": "方法1：集合的思想"}, {"ctype": "code", "data": "lis=[1,2,3,1,2,1,1]\n#方法1：set\nlis=[1,2,3,1,2,1,1]\nlist(set(lis))\n"}, {"ctype": "p", "data": "方法2：字典+count函数"}, {"ctype": "code", "data": "aa=[1,2,3,1,2,1,1]\n#方法2：字典+count函数\nd={i:aa.count(i) for i in aa}\n[i for i in d]\n[x for x in {i:aa.count(i) for i in aa}]\n"}, {"ctype": "p", "data": "**方法3：内置函数count + remove **"}, {"ctype": "code", "data": "aa=[1,2,3,1,2,1,1]\nfor i in aa:\n    if aa.count(i)>1: \n        for j in range(aa.count(i)-1):  #控制remove的执行次数=出现次数-1\n            aa.remove(i)\n\nprint(aa) \n"}, {"ctype": "p", "data": "#方法4：普通遍历+切片"}, {"ctype": "code", "data": "aa=[1,2,3,1,2,1,1]\nnew_aa=[]\nfor i in range(len(aa)): \n    if aa[i] not in aa[i+1:]: #当前元素，是否在后面有出现.没有则保留\n        new_aa.append(aa[i])\n\nprint(new_aa)```\n\n"}, {"ctype": "p", "data": "#方法5：更加暴力的遍历"}, {"ctype": "code", "data": "aa=[1,2,3,1,2,1,1]\nnew_aa = []\nfor i in aa:\n    if i not in new_aa:\n        new_aa.append(i)\n\nprint(new_aa)\n"}], "cate": "Python"}
{"题目": "leetcode  1710. Maximum Units on a Truck（python）", "作者": "王大丫丫", "发布时间": "2021-03-27 16:42:40", "内容": [{"ctype": "head", "data": "描述"}, {"ctype": "p", "data": "You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:"}, {"ctype": "p", "data": "You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize."}, {"ctype": "p", "data": "Return the maximum total number of units that can be put on the truck."}, {"ctype": "p", "data": "Example 1:"}, {"ctype": "code", "data": "Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\nOutput: 8\nExplanation: There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of th"}], "cate": "Python"}
{"题目": "Python中Lambda表达式的使用", "作者": "RaspberryＰ！", "发布时间": "2021-03-28 14:02:43", "内容": [{"ctype": "head", "data": "Python中Lambda表达式的使用"}, {"ctype": "head", "data": "一、Lambda表达式是什么？"}, {"ctype": "p", "data": "   lambda表达式，又称匿名函数，是现代各种编程语言争相引入的一种语法，其功能堪比函数，设计却比函数简洁。 其作用是：    创建一个匿名函数对象    同def 类似，但不提供函数名 其格式是：    lambda [参数1，参数2，…]：表达式 注：表达式只可以写一个"}, {"ctype": "head", "data": "二、使用案例"}, {"ctype": "head", "data": "案例一：比大小"}, {"ctype": "p", "data": "代码如下（示例）："}, {"ctype": "code", "data": "def get_Max(num1,num2):\n    if num1 > num2:\n        max = num1\n    else:\n        max = num2\n    return max\nprint(\"def函数的实现：\",get_Max(12,9))\nprint(\"def函数的实现：\",get_Max(5,28))\nprint(\"Lambda的实现\")\nmax = lambda num1,num2: num1 if num1 > num2 else num2\nprint(\"lambda函数的实现：\",max(12,9))\nprint(\"lambda函数的实现：\",max(5,28))\n"}, {"ctype": "p", "data": "实验结果如下图所示： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328135833679.png#pic_center"}, {"ctype": "head", "data": "三、总结"}, {"ctype": "p", "data": "   1. 当lambda表达式调用时，先执行冒号（：）后的表达式，并返回表达式的结果的引用关系。    2. lambda比函数简单，且可以随时创建和销毁，有利于减少程序的偶合度。"}], "cate": "Python"}
{"题目": "Python(12)---异常", "作者": "叶卡捷琳堡", "发布时间": "2021-03-28 15:20:59", "内容": [{"ctype": "head", "data": "一、异常简介"}, {"ctype": "p", "data": "异常的组成： 异常类型：异常具体的描述信息"}, {"ctype": "code", "data": "a = input('请输入数字')\n# 这里可能会出现异常\n# ZeroDivisionError: division by zero\n# ValueError: invalid literal for int() with base 10: 'a'\nresult = 10 / int(a)\nprint(f\"result={result}\")\n"}, {"ctype": "head", "data": "二、捕获单个异常"}, {"ctype": "code", "data": "# 捕获单个异常\n'''\n语法格式：\n    try:\n        可能发生异常的代码\n    except 异常的类型:\n        发生异常执行的代码\n'''\na = input('请输入数字：')\n# 这里可能会出现异常\n# ZeroDivisionError: division by zero\n# ValueError: invalid literal for int() with base 10: 'a'\ntry:\n    result = 10 / int(a)\n    print(f\"result={result}\")\nexcept ZeroDivisionError:\n    print('请不要输入0')\n"}, {"ctype": "head", "data": "三、捕获多个异常"}, {"ctype": "code", "data": "# 捕获多个异常\n'''\n语法格式1：以元组的形式呈现\n    try:\n        可能发生异常的代码\n    except (异常的类型1,异常的类型2...):\n        发生异常执行的代码\n语法格式2：写多个except语句块\n    try:\n        可能发生异常的代码\n    except 异常的类型1:\n        发生异常执行的代码\n    except 异常的类型2:\n        发生异常执行的代码\n    ...\n'''\na = input('请输入数字：')\n# 这里可能会出现异常\n# ZeroDivisionError: division by zero\n# ValueError: invalid literal for int() with base 10: 'a'\ntry:\n    result = 10 / int(a)\n    print(f\"result={result}\")\nexcept (ZeroDivisionError,ValueError):\n    print('您的输入不合法')\n# 第二种方式\ntry:\n    result = 10 / int(a)\n    print(f\"result={result}\")\nexcept ZeroDivisionError:\n    print('请不要输入0')\nexcept ValueError:\n    print('请输入纯数字')\n"}, {"ctype": "head", "data": "四、打印异常信息"}, {"ctype": "code", "data": "# 打印异常信息\n# 捕获多个异常\n'''\n语法格式：使用as关键字\n    try:\n        可能发生异常的代码\n    except (异常的类型1,异常的类型2...) as 变量名:\n        发生异常执行的代码\n        # 这行代码打印异常信息\n        print(变量名)\n'''\na = input('请输入数字：')\n# 这里可能会出现异常\n# ZeroDivisionError: division by zero\n# ValueError: invalid literal for int() with base 10: 'a'\ntry:\n    result = 10 / int(a)\n    print(f\"result={result}\")\nexcept (ZeroDivisionError,ValueError) as e:\n    print('您的输入不合法')\n    # division by zero\n    print(e)\n"}, {"ctype": "head", "data": "五、捕获所有的异常"}, {"ctype": "code", "data": "# 捕获所有的异常\n'''\n语法格式1：缺点：不能获取异常的描述信息\n    try:\n        可能发生异常的代码\n    except:\n        发生异常执行的代码\n语法格式2：Exception是常见异常类的父类\n    try:\n        可能发生异常的代码\n    except Exception as e:\n        发生异常执行的代码\n        print(e)\nException--->BaseException--->object\n'''\na = input('请输入数字：')\ntry:\n    result = 10 / int(a)\n    print(f\"result={result}\")\nexcept Exception as e:\n    print('您的输入不合法')\n    print(e)\n"}, {"ctype": "head", "data": "六、异常的完整结构"}, {"ctype": "code", "data": "# 异常的完整结构\n'''\n语法格式：\n    try:\n        可能发生异常的代码\n    except Exception as e:\n        发生异常执行的代码\n        print(e)\n    else:\n        代码没有发生异常时会执行\n    finally:\n        不管代码有没有发生异常，都会执行\n'''\na = input('请输入数字：')\ntry:\n    result = 10 / int(a)\n    print(f\"result={result}\")\nexcept Exception as e:\n    print('您的输入不合法')\n    print(e)\nelse:\n    print('else execute!')\nfinally:\n    print('finally execute!')\n"}, {"ctype": "head", "data": "七、异常的传递"}, {"ctype": "p", "data": "try嵌套"}, {"ctype": "code", "data": "# 异常的传递\n'''\n异常的传递是python异常处理的底层机制，不需要程序员写代码实现，python已经实现好了\n异常传递：当一行代码发生异常的时候，会想外层传递这个异常，直到被捕获或报错为止\n(1)try嵌套\n(2)函数嵌套\n'''\n# try嵌套\n# 内部发生的异常如果没有捕获，会传递到外层\na = input('请输入数字：')\ntry:\n    try:\n        result = 10 / int(a)\n    except ZeroDivisionError:\n        print('-----0-----')\n    print(f\"result={result}\")\nexcept Exception as e:\n    print('您的输入不合法')\n    print(e)\n"}, {"ctype": "p", "data": "函数嵌套"}, {"ctype": "code", "data": "# 函数嵌套的方法\ndef fun1():\n    print(1)\n    num = 10 / 0\n    print(num)\n    print(2)\ndef fun2():\n    print(3)\n    fun1()\n    print(4)\n\ntry:\n    print(5)\n    fun2()\n    print(6)\nexcept Exception as e:\n    print(7)\n    print(e)\n# 输出结果\n'''\n5\n3\n1\n7\ndivision by zero\n'''\n"}, {"ctype": "head", "data": "八、抛出自定义异常"}, {"ctype": "code", "data": "# 抛出自定义异常\n'''\n1.抛出异常：\n    raise 异常对象\n当程序代码遇到raise的时候，程序就报错了\n2.抛出自定义异常\n    (1)自定义异常类，继承Exception类或BaseException类\n    (2)选择书写__init__()和__str()__以达到效果\n    (3)在合适的时机抛出异常对象即可\n'''\n# 定义异常类\nclass PasswordLengthError(Exception):\n    pass\n\ndef getPassword():\n    password = input('请输入密码，长度大于6位：')\n    if len(password) > 6:\n        print('该密码合法')\n    elif len(password) <= 6:\n        raise PasswordLengthError('密码长度过短')\ntry:\n    getPassword()\nexcept Exception as e:\n    print(e)\n"}], "cate": "Python"}
{"题目": "5-3 python 单元测试框架", "作者": "Alance9", "发布时间": "2021-03-28 19:25:49", "内容": [{"ctype": "head", "data": "Python Unit Test"}, {"ctype": "p", "data": "1. pc.py 新建类 PC 2. 新建单元测试 pc_unit 3. 编写 pc_unit 4. 修改类 PC"}, {"ctype": "head", "data": "1. pc.py 新建类 PC"}, {"ctype": "code", "data": "class PC(object):\n   def add(self,x,y):\n        return x+y\n    def sub(self,x,y):\n        return x-y\n    def mul(self,x,y):\n        return x*y\n    def div(self,x,y):\n      \treturn x/y\n\nif __name__=='__main__':\n    pc=PC()\n    print(pc.add(100,4))\n    print(pc.sub(100, 4))\n    print(pc.mul(100, 4))\n    print(pc.div(100, 4))\n"}, {"ctype": "head", "data": "2. 新建单元测试 pc_unit"}, {"ctype": "p", "data": "Name：pc_unit Kind：Python unit test  自动生成"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328164551705.png"}, {"ctype": "code", "data": "import unittest\n\nclass MyTestCase(unittest.TestCase):\n    def test_something(self):\n        self.assertEqual(True, False)\n\nif __name__ == '__main__':\n    unittest.main()\n"}, {"ctype": "head", "data": "3. 编写 pc_unit"}, {"ctype": "p", "data": "（1）导入包：import unittest"}, {"ctype": "p", "data": "（2）引入 PC 类：from day05.pc import PC"}, {"ctype": "p", "data": "（3）添加函数 setUpClass(cls)、tearDownClass(cls)"}, {"ctype": "code", "data": "1、setUpClass(cls) 和 tearDownClass(cls) 前需加装饰器\n2、setUpClass(cls)：在执行所有用例前，执行一次\n3、tearDownClass(cls)：在执行所有用例后，执行一次\n"}, {"ctype": "p", "data": "（4）添加函数 setUp(self)、tearDown(self)"}, {"ctype": "code", "data": "1、setUp(self)：在执行每个用例前，执行一次\n2、tearDown(self)：在执行每个用例后，执行一次\n"}, {"ctype": "p", "data": "（5）实例化 PC 类"}, {"ctype": "code", "data": "# 在 setUpClass(cls) 方法中，实例化\n@classmethod # 装饰器\n   def setUpClass(cls): # 在所有用例执行之前执行一次\n      print('-- all start --')\n      cls.pc=PC() # 类变量，实例化PC类得到一个该类对象\n"}, {"ctype": "p", "data": "（6）编写测试用例"}, {"ctype": "code", "data": "def test_01(self): #一个用例\n       print('test01')\n       # 调用 pc 的 div 除方法\n       r=self.pc.div(100,20)\n       # 断言相等：assertEqual(期望值，实际值，显示内容)\n       self.assertEqual(5,r,'100÷20=5')\n"}, {"ctype": "table", "data": "assertEqual(a,b,desc)assertEqual(期望值，实际值，提示内容)assertEqual(a,b,desc)相等，判断 a 和 b 是否相等，相等返回 True，不相等则返回提示 descassertNotEqual(a,b,desc)不相等assertTrue(a,desc)为真assertFalse(a,desc)为假assertIs(a,b,desc)同一个对象assertIsNot(a,b,desc)非同一个对象assertIsNone(a,desc)为空assertIsNotNone(a,desc)非空assertIsIn(a,b,desc)a in bassertIsNotIn(a,b,desc)a not in bassertIsIsInstance(a,b,desc)a 是 b 的实例assertIsNotIsInstance(a,b,desc)a 不是 b 的实例assertIsGreater(a,b)a > bassertIsGreaterEqual(a,b)a >= bassertLess(a,b)a < bassertLessEqual(a,b)a <= b"}, {"ctype": "p", "data": "（7）函数执行顺序 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328191516147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTI2MTM5,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "（8）完整代码"}, {"ctype": "code", "data": "import unittest\n\tfrom day05.pc import PC\n\tclass MyTestCase(unittest.TestCase):\n\t    @classmethod # 装饰器\n\t    def setUpClass(cls): # 在所有用例执行之前执行一次\n\t        print('-- all start --')\n\t        cls.pc=PC() # 类变量，实例化PC类得到一个该类对象\n\t        \n\t    @classmethod  # 装饰器\n\t    def tearDownClass(cls): # 在所有用例执行之后执行一次\n\t        print('-- all over --')\n\t        \n\t    def setUp(self): # 在每个用例执行之前执行一次\n\t        print('--any start')\n\t        \n\t    def tearDown(self): # 在每个用例执行之后执行一次\n\t        print('--any over')\n\t\n\t    # 有效等价类：合法的数字相除\n\t    def test_01(self): #一个用例\n\t        print('test01')\n\t        r=self.pc.div(100,20)\n\t        # 断言相等：assertEqual(期望值，实际值，显示内容)\n\t        self.assertEqual(5,r,'100÷20=5')\n\t\n\t    # 无效等价类：除以0\n\t    def test_02(self):  # 一个用例\n\t        print('test02：除零')\n\t        r=self.pc.div(100,0)\n\t        self.assertEqual(None,r,'除数不能为0')\n\t\n\t    # 无效等价类：字符串\n\t    def test_03(self):  # 一个用例\n\t        print('test03：除字符串')\n\t        r = self.pc.div('100', 'abc')\n\t        self.assertEqual(None, r, '不能为字符串')\n\t\n\t    # 无效等价类：数字字符串\n\t    def test_04(self):  # 一个用例\n\t        print('test04：除数字字符串')\n\t        r = self.pc.div('100', '20')\n\t        self.assertEqual(5, r, '不能为字符串')\n\t\n\tif __name__ == '__main__':\n\t    unittest.main()\n"}, {"ctype": "p", "data": "（9）pc_unit 运行结果，除了 test_01 用例，其他都报错  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032818362542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTI2MTM5,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4. 修改类 PC"}, {"ctype": "p", "data": "（1）使 test_02、test_03、test_04 用例能通过 修改 PC 类的 div 除方法："}, {"ctype": "code", "data": "1、除数不能为0\n2、数字型字符串，转换为浮点类型\n3、非数字字符串，返回 None\n"}, {"ctype": "p", "data": "（2）使用 try - except 捕获异常，处理异常"}, {"ctype": "code", "data": "try: # 尝试执行下面代码，若报错，转到 except 执行\n           return float(x) / float(y) # 数字型字符串，转换为浮点类型\n       except:\n           return  None # 非数字字符串，返回 None\n"}, {"ctype": "code", "data": "\ttry:  \n\t# 执行语句\n\t# 捕获异常进入 except 块\n\t# 若无异常进入 else 块\n\texcept error as e:  \n\t# 处理异常\n\t# 一个 except 块可有多个异常\n\t# try 块只有一个，except 块可有多个\n\telse：\n\t# 执行语句\n\tfinally:\n\t# 执行语句，最后都会被执行\n"}, {"ctype": "p", "data": "（3）完整代码："}, {"ctype": "code", "data": "class PC(object):\n   def add(self,x,y):\n       return x+y\n   def sub(self,x,y):\n       return x-y\n   def mul(self,x,y):\n       return x*y\n   def div(self,x,y):\n       try: # 尝试执行下面代码，若报错，转到 except 执行\n           return float(x) / float(y)\n       except:\n           return  None\n\nif __name__=='__main__':\n    pc=PC()\n    print(pc.add(100,2000))\n    print(pc.sub(100, 2000))\n    print(pc.mul(100, 2000))\n    print(pc.div(100, 4))\n"}, {"ctype": "p", "data": "（4）pc_unit 运行结果，所有用例通过 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328185247141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTI2MTM5,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "(更新时间)2021年3月28日 python基础知识(深拷贝和浅拷贝)", "作者": "愚公搬代码", "发布时间": "2021-03-28 16:44:34", "内容": [{"ctype": "head", "data": "1. 浅拷贝"}, {"ctype": "p", "data": "copy函数是浅拷贝，只对可变类型的第一层对象进行拷贝，对拷贝的对象开辟新的内存空间进行存储，不会拷贝对象内部的子对象。"}, {"ctype": "p", "data": "不可变类型的浅拷贝示例代码:"}, {"ctype": "code", "data": "import copy  # 使用浅拷贝需要导入copy模块\n\n# 不可变类型有: 数字、字符串、元组\n\na1 = 123123\nb1 = copy.copy(a1)  # 使用copy模块里的copy()函数就是浅拷贝了\n# 查看内存地址\nprint(id(a1))\nprint(id(b1))\n\nprint(\"-\" * 10)\na2 = \"abc\"\nb2 = copy.copy(a2)\n# 查看内存地址\nprint(id(a2))\nprint(id(b2))\n\nprint(\"-\" * 10)\na3 = (1, 2, [\"hello\", \"world\"])\nb3 = copy.copy(a3)\n# 查看内存地址\nprint(id(a3))\nprint(id(b3))\n"}, {"ctype": "p", "data": "运行结果:"}, {"ctype": "code", "data": "140459558944048\n140459558944048\n----------\n140459558648776\n140459558648776\n----------\n140459558073328\n140459558073328\n"}, {"ctype": "p", "data": "不可变类型的浅拷贝说明:"}, {"ctype": "p", "data": "可变类型的浅拷贝示例代码:"}, {"ctype": "code", "data": "import copy # 使用浅拷贝需要导入copy模块\n\n# 可变类型有: 列表、字典、集合\n\na1 = [1, 2]\nb1 = copy.copy(a1) # 使用copy模块里的copy()函数就是浅拷贝了\n# 查看内存地址\nprint(id(a1))\nprint(id(b1))\nprint(\"-\" * 10)\na2 = {\"name\": \"张三\", \"age\": 20}\nb2 = copy.copy(a2)\n# 查看内存地址\nprint(id(a2))\nprint(id(b2))\nprint(\"-\" * 10)\na3 = {1, 2, \"王五\"}\nb3 = copy.copy(a3)\n# 查看内存地址\nprint(id(a3))\nprint(id(b3))\n\nprint(\"-\" * 10)\na4 = [1, 2, [4, 5]]\n# 注意：浅拷贝只会拷贝父对象，不会对子对象进行拷贝\nb4 = copy.copy(a4) # 使用copy模块里的copy()函数就是浅拷贝了\n# 查看内存地址\nprint(id(a4))\nprint(id(b4))\nprint(\"-\" * 10)\n# 查看内存地址\nprint(id(a4[2]))\nprint(id(b4[2]))\n\n# 修改数据\na4[2][0] = 6\n\n# 子对象的数据会受影响\nprint(a4)\nprint(b4)\n"}, {"ctype": "p", "data": "运行结果:"}, {"ctype": "code", "data": "139882899585608\n139882899585800\n----------\n139882919626432\n139882919626504\n----------\n139882919321672\n139882899616264\n----------\n139882899587016\n139882899586952\n----------\n139882899693640\n139882899693640\n[1, 2, [6, 5]]\n[1, 2, [6, 5]]\n"}, {"ctype": "p", "data": "可变类型的浅拷贝说明:"}, {"ctype": "head", "data": "2. 深拷贝"}, {"ctype": "p", "data": "deepcopy函数是深拷贝, 只要发现对象有可变类型就会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。"}, {"ctype": "p", "data": "不可变类型的深拷贝示例代码:"}, {"ctype": "code", "data": "import copy  # 使用深拷贝需要导入copy模块\n\n# 不可变类型有: 数字、字符串、元组\n\na1 = 1\nb1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了\n# 查看内存地址\nprint(id(a1))\nprint(id(b1))\nprint(\"-\" * 10)\na2 = \"张三\"\nb2 = copy.deepcopy(a2)\n# 查看内存地址\nprint(id(a2))\nprint(id(b2))\nprint(\"-\" * 10)\na3 = (1, 2)\nb3 = copy.deepcopy(a3)\n# 查看内存地址\nprint(id(a3))\nprint(id(b3))\nprint(\"-\" * 10)\n\n# 注意: 元组里面要是有可变类型对象，发现对象有可变类型就会该对象到最后一个可变类型的每一层对象进行拷贝\na4 = (1, [\"李四\"])\nb4 = copy.deepcopy(a4)\n# 查看内存地址\nprint(id(a4))\nprint(id(b4))\n# 元组里面的可变类型子对象也会进行拷贝\nprint(id(a4[1]))\nprint(id(b4[1]))\n"}, {"ctype": "p", "data": "运行结果:"}, {"ctype": "code", "data": "9289120\n9289120\n----------\n140115621848320\n140115621848320\n----------\n140115621859592\n140115621859592\n----------\n140115602480584\n140115621834568\n140115602328136\n140115602436168\n"}, {"ctype": "p", "data": "不可变类型的深拷贝说明:"}, {"ctype": "p", "data": "可变类型的深拷贝示例代码:"}, {"ctype": "code", "data": "import copy  # 使用深拷贝需要导入copy模块\n\n# 可变类型有: 列表、字典、集合\n\na1 = [1, 2]\nb1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了\n# 查看内存地址\nprint(id(a1))\nprint(id(b1))\nprint(\"-\" * 10)\na2 = {\"name\": \"张三\"}\nb2 = copy.deepcopy(a2)\n# 查看内存地址\nprint(id(a2))\nprint(id(b2))\nprint(\"-\" * 10)\na3 = {1, 2}\nb3 = copy.deepcopy(a3)\n# 查看内存地址\nprint(id(a3))\nprint(id(b3))\nprint(\"-\" * 10)\n\na4 = [1, 2, [\"李四\", \"王五\"]]\nb4 = copy.deepcopy(a4)  # 使用copy模块里的deepcopy()函数就是深拷贝了\n# 查看内存地址\nprint(id(a4))\nprint(id(b4))\n\n# 查看内存地址\nprint(id(a4[2]))\nprint(id(b4[2]))\na4[2][0] = \"王五\"\n# 因为列表的内存地址不同，所以数据不会收到影响\nprint(a4)\nprint(b4)\n"}, {"ctype": "p", "data": "运行结果:"}, {"ctype": "code", "data": "140348291721736\n140348291721928\n----------\n140348311762624\n140348311221592\n----------\n140348311457864\n140348291752456\n----------\n140348291723080\n140348291723144\n140348291723208\n140348291723016\n[1, 2, ['王五', '王五']]\n[1, 2, ['李四', '王五']]\n"}, {"ctype": "p", "data": "可变类型的深拷贝说明:"}, {"ctype": "head", "data": "3. 浅拷贝和深拷贝的区别"}, {"ctype": "head", "data": "4. 总结"}], "cate": "Python"}
{"题目": "Python初学，实现对使用input输入的数字进行求和与求平均的计算", "作者": "今天可还行", "发布时间": "2021-03-28 20:05:20", "内容": [{"ctype": "head", "data": "对使用input输入的数字进行求和与求平均的计算"}, {"ctype": "p", "data": "在学习过程中，遇到需要对输入的元素进行计算，在经过资料查阅，了解到可以先将输入的数字存储成元素为字符串的列表，在将字符串转换为float类型（当然也也可以转换为int类型，只是我这里输入的是以成绩为例，成绩会有小数。如果输入的小数，转换的是int类型就会出现报错）。然后为了好看，在对其进行排序，最后使用循环对其进行计算。"}, {"ctype": "code", "data": "Total=0\nAverage=0\nwhile (True):\n    Grade=input(\"Please enter your grade:\")\n    Grade_total=Grade.split(',') #将输入的值以字符串形式保存为列表，每个元素使用逗号隔开\n    Grade_total=[float(Grade_total[x]) for x in range(len(Grade_total))] #从列表中挨个读取元素，将其转换为float类型\n    Grade_total.sort(reverse=True) #对列表进行降序排列\n    print(Grade_total)\n    for x in Grade_total:\n        Total=Total+x #使用for循环挨个取出元素进行相加\n    Average = Total/len(Grade_total) #len读取列表中元素的个数，在使用Total去除\n    print(\"Total=\",Total)\n    print('Average=','%.1f' % Average,)\n    break\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328200119356.png#pic_center"}], "cate": "Python"}
{"题目": "字符串中不同整数的数目", "作者": "s白龙鱼服s", "发布时间": "2021-03-28 20:07:24", "内容": [{"ctype": "p", "data": "原题指路"}, {"ctype": "p", "data": "字符串中不同整数的数目"}, {"ctype": "head", "data": "题目描述"}, {"ctype": "p", "data": "给你一个字符串 word ，该字符串由数字和小写英文字母组成。"}, {"ctype": "p", "data": "请你用空格替换每个不是数字的字符。例如，\"a123bc34d8ef34\" 将会变成 \" 123 34 8 34\" 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：\"123\"、\"34\"、\"8\" 和 \"34\" 。"}, {"ctype": "p", "data": "返回对 word 完成替换后形成的 不同 整数的数目。"}, {"ctype": "p", "data": "只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。"}, {"ctype": "head", "data": "解题思路"}, {"ctype": "p", "data": " python里的切片和字典对这题来说简直就是魔法……不然还得自己弄个哈希表，去除前导0等做一系列麻烦的操作。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/84c05faa2e02ffc5b3e6f9e541374b8c.png"}, {"ctype": "p", "data": "时间复杂度：\n    \n     \n      \n       \n        O\n       \n       \n        (\n       \n       \n        n\n       \n       \n        )\n       \n      \n      \n       O(n)\n      \n     \n    O(n) 空间复杂度：\n    \n     \n      \n       \n        O\n       \n       \n        (\n       \n       \n        n\n       \n       \n        )\n       \n      \n      \n       O(n)\n      \n     \n    O(n)"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "class Solution:\n    def numDifferentIntegers(self, word: str) -> int:\n        temp = []\n        for i, ch in enumerate(word):  # 遍历字符串并把其中非数字的字符全部变为空格\n            if ch >= '0' and ch <= '9':\n                temp.append(ch)\n            else:\n                temp.append(' ')\n        s = \"\".join(temp)\n        num = [int(n) for n in s.split()]  # 借助刚刚生成的空格利用split()新建一个列表\n        return len(list({}.fromkeys(num).keys()))  # 新建字典去重并统计数字个数\n\n"}], "cate": "Python"}
{"题目": "实验三：基础语法练习2", "作者": "菜且迷茫", "发布时间": "2021-03-28 21:51:10", "内容": [{"ctype": "head", "data": "实验3-1"}, {"ctype": "p", "data": "编写程序，输入一个大于2的自然数，输出小于该数字的所有素数组成的集合。 （素数，即质数，指除了1和它本身以外不再有其他因数的自然数。）"}, {"ctype": "code", "data": "import math\nn = int(input())\na = set()\nfor i in range(2, n):\n    flag = 0\n    for j in range(2, int(math.sqrt(i)+1)):\n        if i % j == 0:\n            flag = 1\n            break\n    if flag == 0:\n        a.add(i)\nprint(a)\n"}, {"ctype": "p", "data": "可以使用大括号 { } 或者 set() 函数创建集合。注意k：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。range(2,n)，左闭右开，默认步长为1。判断一个数n是否为素数，只需找因数到√n即可，无需全部遍历。"}, {"ctype": "head", "data": "运行结果"}, {"ctype": "head", "data": "实验3-2"}, {"ctype": "p", "data": "编写程序，输入一个字符串，输出其中出现次数最大的字符及其出现的次数。"}, {"ctype": "code", "data": "s = input()\nresult = []\nmark = {}\nfor i in s:\n    if i not in mark:\n        mark[i] = 1\n    else:\n        mark[i] += 1\nfor key,value in mark.items():\n    if value == max(mark.values()):\n        result.append(key)\nprint('出现次数最多的字符 ：',result)\nprint('出现次数 ：',max(mark.values()))\n"}, {"ctype": "p", "data": "可能存在多个字符出现的最大次数相同，于是用列表result[]存储结果。用字典mark{}记录出现次数，键为字符，值为出现次数。items() 方法以列表返回可遍历的(键, 值) 元组数组。values()方法以列表返回字典中的所有值，keys()方法以列表返回字典中的所有键。"}, {"ctype": "head", "data": "运行结果"}, {"ctype": "head", "data": "实验3-3"}, {"ctype": "p", "data": "制作一个“通讯簿”，其可以存储姓名、电话、邮箱，请编写程序完成这个“通讯簿”的增删改查功能，并且实现文件存储功能。 （仅实现了基础的增删改查功能，未进行输入判断等具体功能）"}, {"ctype": "code", "data": "import json\nimport os\n#用json文件存储字典数据\n#以姓名作为键，列表([电话，邮箱])作为值\nprint('>>>添加-1 删除-2 修改-3 查询-4')\nwhile True:\n    x = input('>>>请输入要进行的操作：')\n    #没有文件则新建\n    if not os.path.exists('phonebook.json'):\n        with open('phonebook.json', 'w', encoding='utf-8') as file:\n            phonebook = {}\n            json.dump(phonebook, file, indent=4, ensure_ascii=False)\n    #将文件中的数据读到字典phonebook中\n    with open('phonebook.json', 'r', encoding='utf-8') as file:\n        phonebook = dict(json.load(file))\n    #添加\n    if x == '1':\n        name = input('姓名:')\n        tel = input('电话:')\n        email = input('邮箱:')\n        phonebook[name] = [tel, email]\n        print('添加成功！')\n    #删除\n    elif x == '2':\n        name = input('请输入要删除的联系人：')\n        if name in phonebook.keys():\n            del phonebook[name]\n            print('删除成功！')\n        else:\n            print('查无此人！')\n    #修改\n    elif x == '3':\n        name = input('请输入要修改的联系人：')\n        if name in phonebook.keys():\n            tel = input('电话:')\n            email = input('邮箱:')\n            phonebook[name] = [tel, email]\n            print('修改成功！')\n        else:\n            print('查无此人！')\n    #查找\n    elif x == '4':\n        name = input('请输入要查找的联系人：')\n        if name in phonebook.keys():\n            print('电话:' + phonebook[name][0])\n            print('邮箱:' + phonebook[name][1])\n        else:\n            print('查无此人！')\n    else:\n        print('命令错误！请重新输入')\n        print('>>>添加-1 删除-2 修改-3 查询-4')\n    #将phonebook中的数据写入文件中\n    with open('phonebook.json', 'w', encoding='utf-8') as file:\n        json.dump(phonebook, file, indent=4, ensure_ascii=False)\n"}, {"ctype": "p", "data": "indent = 4：对json进行数据格式化输出。json.dumps序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False。"}, {"ctype": "head", "data": "运行数据"}, {"ctype": "head", "data": "运行结果"}], "cate": "Python"}
{"题目": "python pyppeteer 破解京东滑块", "作者": "她从小就是校花", "发布时间": "2021-03-27 10:48:38", "内容": [{"ctype": "code", "data": "import asyncio\nimport random\nimport cv2\nfrom pyppeteer import launch\nfrom urllib import request\n\n\n# 滑块的缺口距离识别\nasync def get_distance():\n    img = cv2.imread('image.png', 0)\n    template = cv2.imread('template.png', 0)\n    res = cv2.matchTemplate(img, template, cv2.TM_CCORR_NORMED)\n    value = cv2.minMaxLoc(res)[2][0]\n    distance = value * 278/360\n    return distance\n\n\nasync def main():\n    browser = await launch({\n        'headless': False,# 需要设置一个路径\n        'userDataDir': r'E:\\mj',\n        'args': ['--no-sandbox', '--window-size=1366,768'],\n    })\n    page = await browser.newPage()\n    await page.setViewport({'width': 1366, 'height': 768})\n    await page.goto('https://passport.jd.com/login.aspx')\n    await page.waitFor(1000)\n    await page.click('div.login-tab-r')\n    await page.waitFor(1000)\n\n    # TODO 模拟人工输入用户名、密码    输入自己的账号密码\n    await page.type('#loginname', 'yazhishaw',\n                    {'delay': random.randint(60, 121)})\n    await page.type('#nloginpwd', '123456',\n                    {'delay': random.randint(100, 151)})\n    await page.waitFor(2000)\n    await page.click('div.login-btn')\n    await page.waitFor(3000)\n    # 模拟人工拖动滑块、失败则重试\n    while True:\n        if await page.J('#ttbar-login'):\n            print('登录成功！')\n            await page.waitFor(6000)\n            break\n        else:\n            image_src = await page.Jeval('.JDJRV-bigimg >img', 'el => el.src')\n            request.urlretrieve(image_src, 'image.png')\n            template_src = await page.Jeval('.JDJRV-smallimg >img', 'el => el.src')\n            request.urlretrieve(template_src, 'template.png')\n            await page.waitFor(3000)\n            el = await page.J('div.JDJRV-slide-btn')\n            box = await el.boundingBox()\n            await page.hover('div.JDJRV-slide-btn')\n            distance = await get_distance()\n            await page.mouse.down()\n            await page.mouse.move(box['x'] + distance + random.uniform(30, 33), box['y'], {'steps': 20})\n            await page.waitFor(random.randint(300, 700))\n            await page.mouse.move(box['x'] + distance + 29, box['y'], {'steps': 20})\n            await page.mouse.up()\n            await page.waitFor(3000)\n\n\nasyncio.get_event_loop().run_until_complete(main())"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "第二课.多元高斯分布与其几何特征", "作者": "tzc_fly", "发布时间": "2021-03-27 15:44:56", "内容": [{"ctype": "head", "data": "多元高斯分布"}, {"ctype": "head", "data": "一元高斯与多元高斯"}, {"ctype": "p", "data": "在第一课的一元高斯分布中，处理的是一组样本\n    \n     \n      \n       \n        X\n       \n       \n        =\n       \n       \n        (\n       \n       \n        \n         x\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        \n         x\n        \n        \n         2\n        \n       \n       \n        ,\n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         x\n        \n        \n         N\n        \n       \n       \n        )\n       \n      \n      \n       X=(x_{1},x_{2},...,x_{N})\n      \n     \n    X=(x1​,x2​,...,xN​)，每个样本都是一个随机变量，可以粗略地认为就是随机的\"数值\"；对于多元高斯分布，同样也有一组样本\n    \n     \n      \n       \n        X\n       \n      \n      \n       X\n      \n     \n    X，但每个样本不是单值的随机变量，而是多维的随机向量，假设每个样本有\n    \n     \n      \n       \n        p\n       \n      \n      \n       p\n      \n     \n    p维： \n     \n      \n       \n        \n         x\n        \n        \n         =\n        \n        \n         [\n        \n        \n         \n          x\n         \n         \n          1\n         \n        \n        \n         ,\n        \n        \n         \n          x\n         \n         \n          2\n         \n        \n        \n         ,\n        \n        \n         .\n        \n        \n         .\n        \n        \n         .\n        \n        \n         ,\n        \n        \n         \n          x\n         \n         \n          p\n         \n        \n        \n         \n          ]\n         \n         \n          T\n         \n        \n       \n       \n        x=[x_{1},x_{2},...,x_{p}]^{T}\n       \n      \n     x=[x1​,x2​,...,xp​]T 假设有\n    \n     \n      \n       \n        N\n       \n      \n      \n       N\n      \n     \n    N个样本，则这组样本表示为：  一元高斯分布的样本可以看作多元高斯分布样本在\n    \n     \n      \n       \n        p\n       \n       \n        =\n       \n       \n        1\n       \n      \n      \n       p=1\n      \n     \n    p=1下的情况；"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327132806329.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQzNzYw,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "多元高斯分布的参数"}, {"ctype": "p", "data": "和一元高斯分布类似，多元高斯分布的参数包含两个部分：均值，方差；但注意，描述分布均值的\n    \n     \n      \n       \n        μ\n       \n      \n      \n       \\mu\n      \n     \n    μ不再是一个数值，而是一个\n    \n     \n      \n       \n        p\n       \n      \n      \n       p\n      \n     \n    p维向量： \n     \n      \n       \n        \n         μ\n        \n        \n         =\n        \n        \n         [\n        \n        \n         \n          μ\n         \n         \n          1\n         \n        \n        \n         ,\n        \n        \n         \n          μ\n         \n         \n          2\n         \n        \n        \n         ,\n        \n        \n         .\n        \n        \n         .\n        \n        \n         .\n        \n        \n         ,\n        \n        \n         \n          μ\n         \n         \n          p\n         \n        \n        \n         \n          ]\n         \n         \n          T\n         \n        \n       \n       \n        \\mu=[\\mu_{1},\\mu_{2},...,\\mu_{p}]^{T}\n       \n      \n     μ=[μ1​,μ2​,...,μp​]T 向量\n    \n     \n      \n       \n        μ\n       \n      \n      \n       \\mu\n      \n     \n    μ的每一维\n    \n     \n      \n       \n        \n         μ\n        \n        \n         i\n        \n       \n      \n      \n       \\mu_{i}\n      \n     \n    μi​反映了样本\n    \n     \n      \n       \n        X\n       \n      \n      \n       X\n      \n     \n    X中第\n    \n     \n      \n       \n        i\n       \n      \n      \n       i\n      \n     \n    i个特征的均值；"}, {"ctype": "p", "data": "反映方差的参数同样不再是一个数值，而是协方差矩阵\n    \n     \n      \n       \n        Σ\n       \n      \n      \n       \\Sigma\n      \n     \n    Σ，这是一个\n    \n     \n      \n       \n        p\n       \n       \n        ×\n       \n       \n        p\n       \n      \n      \n       p\\times p\n      \n     \n    p×p的矩阵：  在协方差矩阵中，方阵对角线的值\n    \n     \n      \n       \n        \n         σ\n        \n        \n         \n          i\n         \n         \n          i\n         \n        \n       \n      \n      \n       \\sigma_{ii}\n      \n     \n    σii​表示的是分布中第\n    \n     \n      \n       \n        i\n       \n      \n      \n       i\n      \n     \n    i个特征的方差，非对角线上的值\n    \n     \n      \n       \n        \n         σ\n        \n        \n         \n          i\n         \n         \n          j\n         \n        \n       \n      \n      \n       \\sigma_{ij}\n      \n     \n    σij​表示分布中第\n    \n     \n      \n       \n        i\n       \n      \n      \n       i\n      \n     \n    i个特征和第\n    \n     \n      \n       \n        j\n       \n      \n      \n       j\n      \n     \n    j个特征的协方差，反映两个特征之间的相关性；"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327133651716.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQzNzYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "特别的，当协方差矩阵是一个对角阵，即非对角线上值为0时，代表该分布中，不同特征之间不存在相关性（这也是PCA白化的目标，回顾：算法栈-PCA主成分分析）；"}, {"ctype": "head", "data": "二元高斯分布"}, {"ctype": "p", "data": "以二元高斯分布为例，设置不同的参数，直观感受参数对样本分布的影响："}, {"ctype": "code", "data": "%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nmean_1 = np.array([0, 0])\nconv_1 = np.array([[1, 0],\n                 [0, 1]])\n\nmean_2 = np.array([0, -7])\nconv_2 = np.array([[4, 0],\n                 [0, 0.25]])\n\nmean_3 = np.array([4, 4])\nconv_3 = np.array([[4, -3],\n                 [-3, 0.25]])\n\n# np.random.normal(loc=0.0:\"均值\", scale=1.0:\"标准差\", size=None)用于生成一元高斯分布并采样\n# np.random.multivariate_normal根据指定的均值和协方差生成多元高斯分布并采样,size为样本数量\n# 本例np.random.multivariate_normal(mean=mean_1, cov=conv_1, size=2000)形状为(2000,2),经过转置用于x_1,y_1解包unpack\nx_1, y_1 = np.random.multivariate_normal(mean=mean_1, cov=conv_1, size=2000).T\nx_2, y_2 = np.random.multivariate_normal(mean=mean_2, cov=conv_2, size=2000).T\nx_3, y_3 = np.random.multivariate_normal(mean=mean_3, cov=conv_3, size=2000).T\n\nplt.plot(x_1, y_1, 'ro', alpha=0.05)\nplt.plot(x_2, y_2, 'bo', alpha=0.05)\nplt.plot(x_3, y_3, 'go', alpha=0.05)\n\n# gca()获取当前坐标轴,axes.set_xlim()移动坐标轴到指定范围\nplt.gca().axes.set_xlim(-10, 10)\nplt.gca().axes.set_ylim(-10, 10)\n\nplt.grid()\nplt.show()\n"}, {"ctype": "p", "data": " 以上演示中，分别设置了三组不同的参数： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032714055679.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQzNzYw,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "多元高斯分布的几何特征"}, {"ctype": "head", "data": "几何特征"}, {"ctype": "p", "data": "基于二元高斯分布的可视化，直观感受到整体呈现椭圆形状，假设\n    \n     \n      \n       \n        x\n       \n      \n      \n       x\n      \n     \n    x是一个\n    \n     \n      \n       \n        p\n       \n      \n      \n       p\n      \n     \n    p维随机向量，服从某个\n    \n     \n      \n       \n        p\n       \n      \n      \n       p\n      \n     \n    p维高斯分布\n    \n     \n      \n       \n        θ\n       \n       \n        =\n       \n       \n        (\n       \n       \n        μ\n       \n       \n        ∈\n       \n       \n        \n         R\n        \n        \n         p\n        \n       \n       \n        ,\n       \n       \n        Σ\n       \n       \n        ∈\n       \n       \n        \n         R\n        \n        \n         \n          p\n         \n         \n          ×\n         \n         \n          p\n         \n        \n       \n       \n        )\n       \n      \n      \n       \\theta=(\\mu\\in\\mathbb{R}^{p},\\Sigma\\in\\mathbb{R}^{p\\times p})\n      \n     \n    θ=(μ∈Rp,Σ∈Rp×p)，则有概率密度函数： \n     \n      \n       \n        \n         p\n        \n        \n         (\n        \n        \n         x\n        \n        \n         ∣\n        \n        \n         θ\n        \n        \n         )\n        \n        \n         =\n        \n        \n         \n          1\n         \n         \n          \n           (\n          \n          \n           2\n          \n          \n           π\n          \n          \n           \n            )\n           \n           \n            \n             p\n            \n            \n             2\n            \n           \n          \n          \n           ∣\n          \n          \n           Σ\n          \n          \n           \n            ∣\n           \n           \n            \n             1\n            \n            \n             2\n            \n           \n          \n         \n        \n        \n         e\n        \n        \n         x\n        \n        \n         p\n        \n        \n         (\n        \n        \n         −\n        \n        \n         \n          1\n         \n         \n          2\n         \n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         \n          Σ\n         \n         \n          \n           −\n          \n          \n           1\n          \n         \n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         )\n        \n        \n         )\n        \n       \n       \n        p(x|\\theta)=\\frac{1}{(2\\pi)^{\\frac{p}{2}}|\\Sigma|^{\\frac{1}{2}}}exp(-\\frac{1}{2}(x-\\mu)^{T}\\Sigma^{-1}(x-\\mu))\n       \n      \n     p(x∣θ)=(2π)2p​∣Σ∣21​1​exp(−21​(x−μ)TΣ−1(x−μ)) 协方差矩阵可以分解为\n    \n     \n      \n       \n        Σ\n       \n       \n        =\n       \n       \n        Q\n       \n       \n        Λ\n       \n       \n        \n         Q\n        \n        \n         T\n        \n       \n      \n      \n       \\Sigma=Q\\Lambda Q^{T}\n      \n     \n    Σ=QΛQT，其中，\n    \n     \n      \n       \n        Q\n       \n       \n        \n         Q\n        \n        \n         T\n        \n       \n       \n        =\n       \n       \n        I\n       \n      \n      \n       QQ^{T}=I\n      \n     \n    QQT=I，\n    \n     \n      \n       \n        Q\n       \n       \n        =\n       \n       \n        [\n       \n       \n        \n         q\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         q\n        \n        \n         p\n        \n       \n       \n        ]\n       \n      \n      \n       Q=[q_{1},...,q_{p}]\n      \n     \n    Q=[q1​,...,qp​]，其中\n    \n     \n      \n       \n        Q\n       \n      \n      \n       Q\n      \n     \n    Q为\n    \n     \n      \n       \n        (\n       \n       \n        p\n       \n       \n        ×\n       \n       \n        p\n       \n       \n        )\n       \n      \n      \n       (p\\times p)\n      \n     \n    (p×p)，而\n    \n     \n      \n       \n        Λ\n       \n      \n      \n       \\Lambda\n      \n     \n    Λ为：  因此有：  其中，对角阵\n    \n     \n      \n       \n        \n         Λ\n        \n        \n         \n          −\n         \n         \n          1\n         \n        \n       \n      \n      \n       \\Lambda^{-1}\n      \n     \n    Λ−1为：  因此，\n    \n     \n      \n       \n        \n         Σ\n        \n        \n         \n          −\n         \n         \n          1\n         \n        \n       \n       \n        =\n       \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         p\n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n       \n        \n         1\n        \n        \n         \n          λ\n         \n         \n          i\n         \n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n        \n         T\n        \n       \n      \n      \n       \\Sigma^{-1}=\\sum_{i=1}^{p}q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}\n      \n     \n    Σ−1=∑i=1p​qi​λi​1​qiT​，代入\n    \n     \n      \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        \n         Σ\n        \n        \n         \n          −\n         \n         \n          1\n         \n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        )\n       \n      \n      \n       (x-\\mu)^{T}\\Sigma^{-1}(x-\\mu)\n      \n     \n    (x−μ)TΣ−1(x−μ)得到： \n     \n      \n       \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         \n          Σ\n         \n         \n          \n           −\n          \n          \n           1\n          \n         \n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         )\n        \n        \n         =\n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         [\n        \n        \n         \n          ∑\n         \n         \n          \n           i\n          \n          \n           =\n          \n          \n           1\n          \n         \n         \n          p\n         \n        \n        \n         \n          q\n         \n         \n          i\n         \n        \n        \n         \n          1\n         \n         \n          \n           λ\n          \n          \n           i\n          \n         \n        \n        \n         \n          q\n         \n         \n          i\n         \n         \n          T\n         \n        \n        \n         ]\n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         )\n        \n        \n         =\n        \n        \n         \n          ∑\n         \n         \n          \n           i\n          \n          \n           =\n          \n          \n           1\n          \n         \n         \n          p\n         \n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         [\n        \n        \n         \n          q\n         \n         \n          i\n         \n        \n        \n         \n          1\n         \n         \n          \n           λ\n          \n          \n           i\n          \n         \n        \n        \n         \n          q\n         \n         \n          i\n         \n         \n          T\n         \n        \n        \n         ]\n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         )\n        \n       \n       \n        (x-\\mu)^{T}\\Sigma^{-1}(x-\\mu)=(x-\\mu)^{T}[\\sum_{i=1}^{p}q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)=\\sum_{i=1}^{p}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)\n       \n      \n     (x−μ)TΣ−1(x−μ)=(x−μ)T[i=1∑p​qi​λi​1​qiT​](x−μ)=i=1∑p​(x−μ)T[qi​λi​1​qiT​](x−μ) 进行替换，令\n    \n     \n      \n       \n        \n         y\n        \n        \n         i\n        \n       \n       \n        =\n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n      \n      \n       y_{i}=(x-\\mu)^{T}q_{i}\n      \n     \n    yi​=(x−μ)Tqi​，相当于先平移后投影："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144105668.png"}, {"ctype": "p", "data": "以\n    \n     \n      \n       \n        p\n       \n       \n        =\n       \n       \n        2\n       \n      \n      \n       p=2\n      \n     \n    p=2为例，可以得到： \n     \n      \n       \n        \n         \n          ∑\n         \n         \n          \n           i\n          \n          \n           =\n          \n          \n           1\n          \n         \n         \n          2\n         \n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         \n          )\n         \n         \n          T\n         \n        \n        \n         [\n        \n        \n         \n          q\n         \n         \n          i\n         \n        \n        \n         \n          1\n         \n         \n          \n           λ\n          \n          \n           i\n          \n         \n        \n        \n         \n          q\n         \n         \n          i\n         \n         \n          T\n         \n        \n        \n         ]\n        \n        \n         (\n        \n        \n         x\n        \n        \n         −\n        \n        \n         μ\n        \n        \n         )\n        \n        \n         =\n        \n        \n         \n          y\n         \n         \n          1\n         \n        \n        \n         \n          1\n         \n         \n          \n           λ\n          \n          \n           1\n          \n         \n        \n        \n         \n          y\n         \n         \n          1\n         \n         \n          T\n         \n        \n        \n         +\n        \n        \n         \n          y\n         \n         \n          2\n         \n        \n        \n         \n          1\n         \n         \n          \n           λ\n          \n          \n           2\n          \n         \n        \n        \n         \n          y\n         \n         \n          2\n         \n         \n          T\n         \n        \n        \n         =\n        \n        \n         \n          \n           y\n          \n          \n           1\n          \n          \n           2\n          \n         \n         \n          \n           λ\n          \n          \n           1\n          \n         \n        \n        \n         +\n        \n        \n         \n          \n           y\n          \n          \n           2\n          \n          \n           2\n          \n         \n         \n          \n           λ\n          \n          \n           2\n          \n         \n        \n       \n       \n        \\sum_{i=1}^{2}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)=y_{1}\\frac{1}{\\lambda_{1}}y_{1}^{T}+y_{2}\\frac{1}{\\lambda_{2}}y_{2}^{T}=\\frac{y_{1}^{2}}{\\lambda_{1}}+\\frac{y_{2}^{2}}{\\lambda_{2}}\n       \n      \n     i=1∑2​(x−μ)T[qi​λi​1​qiT​](x−μ)=y1​λ1​1​y1T​+y2​λ2​1​y2T​=λ1​y12​​+λ2​y22​​ 当\n    \n     \n      \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         2\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        [\n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n       \n        \n         1\n        \n        \n         \n          λ\n         \n         \n          i\n         \n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n        \n         T\n        \n       \n       \n        ]\n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        )\n       \n      \n      \n       \\sum_{i=1}^{2}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)\n      \n     \n    ∑i=12​(x−μ)T[qi​λi​1​qiT​](x−μ)固定后，样本对应的二元高斯概率密度就可以得到具体值\n    \n     \n      \n       \n        p\n       \n       \n        (\n       \n       \n        x\n       \n       \n        ∣\n       \n       \n        θ\n       \n       \n        )\n       \n       \n        =\n       \n       \n        v\n       \n       \n        a\n       \n       \n        l\n       \n       \n        u\n       \n       \n        e\n       \n      \n      \n       p(x|\\theta)=value\n      \n     \n    p(x∣θ)=value，即：对于满足\n    \n     \n      \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         2\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        [\n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n       \n        \n         1\n        \n        \n         \n          λ\n         \n         \n          i\n         \n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n        \n         T\n        \n       \n       \n        ]\n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        )\n       \n       \n        =\n       \n       \n        c\n       \n      \n      \n       \\sum_{i=1}^{2}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)=c\n      \n     \n    ∑i=12​(x−μ)T[qi​λi​1​qiT​](x−μ)=c的所有样本，它们出现的概率都一样大；"}, {"ctype": "p", "data": "进一步思考，即对于满足\n    \n     \n      \n       \n        \n         \n          y\n         \n         \n          1\n         \n         \n          2\n         \n        \n        \n         \n          λ\n         \n         \n          1\n         \n        \n       \n       \n        +\n       \n       \n        \n         \n          y\n         \n         \n          2\n         \n         \n          2\n         \n        \n        \n         \n          λ\n         \n         \n          2\n         \n        \n       \n       \n        =\n       \n       \n        c\n       \n      \n      \n       \\frac{y_{1}^{2}}{\\lambda_{1}}+\\frac{y_{2}^{2}}{\\lambda_{2}}=c\n      \n     \n    λ1​y12​​+λ2​y22​​=c时的所有样本，样本出现的概率一样大；注意到\n    \n     \n      \n       \n        \n         \n          y\n         \n         \n          1\n         \n         \n          2\n         \n        \n        \n         \n          λ\n         \n         \n          1\n         \n        \n       \n       \n        +\n       \n       \n        \n         \n          y\n         \n         \n          2\n         \n         \n          2\n         \n        \n        \n         \n          λ\n         \n         \n          2\n         \n        \n       \n       \n        =\n       \n       \n        c\n       \n      \n      \n       \\frac{y_{1}^{2}}{\\lambda_{1}}+\\frac{y_{2}^{2}}{\\lambda_{2}}=c\n      \n     \n    λ1​y12​​+λ2​y22​​=c正好是椭圆的方程；"}, {"ctype": "p", "data": "椭圆方程的长轴短轴不再是经典的\n    \n     \n      \n       \n        x\n       \n      \n      \n       x\n      \n     \n    x轴和\n    \n     \n      \n       \n        y\n       \n      \n      \n       y\n      \n     \n    y轴，变成了向量\n    \n     \n      \n       \n        \n         q\n        \n        \n         1\n        \n       \n      \n      \n       q_{1}\n      \n     \n    q1​和\n    \n     \n      \n       \n        \n         q\n        \n        \n         2\n        \n       \n      \n      \n       q_{2}\n      \n     \n    q2​，椭圆在两个轴上的长度分别为\n    \n     \n      \n       \n        \n         \n          c\n         \n         \n          \n           λ\n          \n          \n           1\n          \n         \n        \n       \n      \n      \n       \\sqrt{c\\lambda_{1}}\n      \n     \n    cλ1​\n\n\n​和\n    \n     \n      \n       \n        \n         \n          c\n         \n         \n          \n           λ\n          \n          \n           2\n          \n         \n        \n       \n      \n      \n       \\sqrt{c\\lambda_{2}}\n      \n     \n    cλ2​\n\n\n​，\n    \n     \n      \n       \n        \n         y\n        \n        \n         1\n        \n       \n      \n      \n       y_{1}\n      \n     \n    y1​和\n    \n     \n      \n       \n        \n         y\n        \n        \n         2\n        \n       \n      \n      \n       y_{2}\n      \n     \n    y2​则是\n    \n     \n      \n       \n        x\n       \n       \n        o\n       \n       \n        y\n       \n      \n      \n       xoy\n      \n     \n    xoy空间下的样本\n    \n     \n      \n       \n        x\n       \n      \n      \n       x\n      \n     \n    x在\n    \n     \n      \n       \n        \n         q\n        \n        \n         1\n        \n       \n      \n      \n       q_{1}\n      \n     \n    q1​和\n    \n     \n      \n       \n        \n         q\n        \n        \n         2\n        \n       \n      \n      \n       q_{2}\n      \n     \n    q2​上的投影长度，即样本\n    \n     \n      \n       \n        x\n       \n      \n      \n       x\n      \n     \n    x以\n    \n     \n      \n       \n        \n         q\n        \n        \n         1\n        \n       \n      \n      \n       q_{1}\n      \n     \n    q1​和\n    \n     \n      \n       \n        \n         q\n        \n        \n         2\n        \n       \n      \n      \n       q_{2}\n      \n     \n    q2​为坐标系的坐标值；"}, {"ctype": "p", "data": "对于\n    \n     \n      \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         2\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        [\n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n       \n        \n         1\n        \n        \n         \n          λ\n         \n         \n          i\n         \n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n        \n         T\n        \n       \n       \n        ]\n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        )\n       \n      \n      \n       \\sum_{i=1}^{2}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)\n      \n     \n    ∑i=12​(x−μ)T[qi​λi​1​qiT​](x−μ)，每次固定常数\n    \n     \n      \n       \n        c\n       \n      \n      \n       c\n      \n     \n    c后，相当于以\n    \n     \n      \n       \n        \n         q\n        \n        \n         1\n        \n       \n      \n      \n       q_{1}\n      \n     \n    q1​和\n    \n     \n      \n       \n        \n         q\n        \n        \n         2\n        \n       \n      \n      \n       q_{2}\n      \n     \n    q2​为轴，\n    \n     \n      \n       \n        \n         \n          c\n         \n         \n          \n           λ\n          \n          \n           1\n          \n         \n        \n       \n      \n      \n       \\sqrt{c\\lambda_{1}}\n      \n     \n    cλ1​\n\n\n​和\n    \n     \n      \n       \n        \n         \n          c\n         \n         \n          \n           λ\n          \n          \n           2\n          \n         \n        \n       \n      \n      \n       \\sqrt{c\\lambda_{2}}\n      \n     \n    cλ2​\n\n\n​为轴长，画一个椭圆，这个椭圆上所有点出现的概率都相等；"}, {"ctype": "p", "data": "设想一下，伴随\n    \n     \n      \n       \n        c\n       \n      \n      \n       c\n      \n     \n    c的改变，\n    \n     \n      \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         2\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        [\n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n       \n        \n         1\n        \n        \n         \n          λ\n         \n         \n          i\n         \n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n        \n         T\n        \n       \n       \n        ]\n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        )\n       \n      \n      \n       \\sum_{i=1}^{2}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)\n      \n     \n    ∑i=12​(x−μ)T[qi​λi​1​qiT​](x−μ)取值也在改变，于是椭圆在缩放，无数椭圆堆叠形成一个实心的\"椭圆\"，而且注意，\n    \n     \n      \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         2\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        \n         )\n        \n        \n         T\n        \n       \n       \n        [\n       \n       \n        \n         q\n        \n        \n         i\n        \n       \n       \n        \n         1\n        \n        \n         \n          λ\n         \n         \n          i\n         \n        \n       \n       \n        \n         q\n        \n        \n         i\n        \n        \n         T\n        \n       \n       \n        ]\n       \n       \n        (\n       \n       \n        x\n       \n       \n        −\n       \n       \n        μ\n       \n       \n        )\n       \n      \n      \n       \\sum_{i=1}^{2}(x-\\mu)^{T}[q_{i}\\frac{1}{\\lambda_{i}}q_{i}^{T}](x-\\mu)\n      \n     \n    ∑i=12​(x−μ)T[qi​λi​1​qiT​](x−μ)越大，即椭圆越大，但\n    \n     \n      \n       \n        p\n       \n       \n        (\n       \n       \n        x\n       \n       \n        ∣\n       \n       \n        θ\n       \n       \n        )\n       \n      \n      \n       p(x|\\theta)\n      \n     \n    p(x∣θ)的取值反而减小，所以越大的椭圆上，点的出现概率越小；"}, {"ctype": "head", "data": "实例演示"}, {"ctype": "p", "data": "以二元高斯为例，设置以下参数进行演示： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327153252350.png"}, {"ctype": "code", "data": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import linalg\n\nmean_1 = np.array([0, 0])\nmean_2 = np.array([20, -20])\n\nconv = np.array([[34, 12],\n              [12, 41]])\n\nx_1, y_1 = np.random.multivariate_normal(mean=mean_1, cov=conv, size=4000).T\nx_2, y_2 = np.random.multivariate_normal(mean=mean_2, cov=conv, size=4000).T\n\nplt.plot(x_1, y_1, 'ro', alpha=0.05)\nplt.plot(x_2, y_2, 'bo', alpha=0.05)\n\nplt.gca().axes.set_xlim(-20, 40)\nplt.gca().axes.set_ylim(-40, 20)\n\nevalue, evector = linalg.eig(conv)\nprint(evalue)\nprint(evector)\n\nplt.grid()\nplt.show()\n"}, {"ctype": "p", "data": " 结果为："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327153611997.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQzNzYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "[25.+0.j 50.+0.j]\n\n[[-0.8 -0.6]\n [ 0.6 -0.8]]\n"}, {"ctype": "p", "data": "蓝色分布为原始的高斯分布，减去均值向量后，整体平移到\n    \n     \n      \n       \n        x\n       \n       \n        o\n       \n       \n        y\n       \n      \n      \n       xoy\n      \n     \n    xoy坐标原点，即红色分布；"}, {"ctype": "p", "data": "对协方差矩阵\n    \n     \n      \n       \n        Σ\n       \n      \n      \n       \\Sigma\n      \n     \n    Σ进行特征值分解得到特征向量\n    \n     \n      \n       \n        \n         q\n        \n        \n         1\n        \n       \n       \n        =\n       \n       \n        [\n       \n       \n        −\n       \n       \n        0.8\n       \n       \n        ,\n       \n       \n        0.6\n       \n       \n        \n         ]\n        \n        \n         T\n        \n       \n      \n      \n       q_{1}=[-0.8,0.6]^{T}\n      \n     \n    q1​=[−0.8,0.6]T和\n    \n     \n      \n       \n        \n         q\n        \n        \n         2\n        \n       \n       \n        =\n       \n       \n        [\n       \n       \n        −\n       \n       \n        0.6\n       \n       \n        ,\n       \n       \n        −\n       \n       \n        0.8\n       \n       \n        \n         ]\n        \n        \n         T\n        \n       \n      \n      \n       q_{2}=[-0.6,-0.8]^{T}\n      \n     \n    q2​=[−0.6,−0.8]T，对应特征值为\n    \n     \n      \n       \n        \n         λ\n        \n        \n         1\n        \n       \n       \n        =\n       \n       \n        25\n       \n      \n      \n       \\lambda_{1}=25\n      \n     \n    λ1​=25和\n    \n     \n      \n       \n        \n         λ\n        \n        \n         2\n        \n       \n       \n        =\n       \n       \n        50\n       \n      \n      \n       \\lambda_{2}=50\n      \n     \n    λ2​=50；即在平移得到的红色分布上，有无数个以\n    \n     \n      \n       \n        [\n       \n       \n        0\n       \n       \n        ,\n       \n       \n        0\n       \n       \n        \n         ]\n        \n        \n         T\n        \n       \n      \n      \n       [0,0]^{T}\n      \n     \n    [0,0]T为中心，\n    \n     \n      \n       \n        \n         q\n        \n        \n         1\n        \n       \n      \n      \n       q_{1}\n      \n     \n    q1​和\n    \n     \n      \n       \n        \n         q\n        \n        \n         2\n        \n       \n      \n      \n       q_{2}\n      \n     \n    q2​为轴的同心椭圆，椭圆的长短轴之比为\n    \n     \n      \n       \n        \n         50\n        \n       \n       \n        /\n       \n       \n        \n         25\n        \n       \n      \n      \n       \\sqrt{50}/\\sqrt{25}\n      \n     \n    50\n\n\n​/25\n\n\n​，对于某个椭圆，其上的点出现概率都相等，而随着椭圆变大，样本出现的概率逐渐降低，即颜色从深变浅。"}], "cate": "Python"}
{"题目": "爬虫 | 用python构建自己的IP代理池，再也不担心IP不够用啦！", "作者": "Python当打之年", "发布时间": "2021-03-27 14:57:20", "内容": [{"ctype": "head", "data": "一、准备工作"}, {"ctype": "p", "data": "常见网站反爬方式主要有以下几种："}, {"ctype": "p", "data": "其实请求头、验证码、动态加载以及数据加密反扒都是在你可以访问网站或者服务器之后的反爬措施，这些都可以使用一些解析方法来破解。"}, {"ctype": "p", "data": "那么试想一下，如果网站直接限制了你的IP，导致根本无法获取想要的数据，即使会N种数据破解方式又有何用呢？所以你懂得。。。"}, {"ctype": "head", "data": "什么是代理IP"}, {"ctype": "p", "data": "代理IP按匿名度可分为三种："}, {"ctype": "head", "data": "二、网页分析"}, {"ctype": "p", "data": "以西拉代理为例：http://www.xiladaili.com/http/"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144026574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE1MjgxMQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "我们可以看到一共有2000页的免费代理IP，足够使用了！不过需要注意代理IP是有存活时间的，从几分钟到几天几个月不等，自行根据需要过滤即可。"}, {"ctype": "p", "data": "这里我们爬取前50页的数据就可以了，当然爬100页，2000页都是可以的。"}, {"ctype": "p", "data": "简单分析一下网页，F12检查网页源码："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144048559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE1MjgxMQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "所有IP信息都在tbody标签中，每一行为一个tr标签。"}, {"ctype": "head", "data": "三、代理IP处理"}, {"ctype": "head", "data": "3.1 配置环境（包）"}, {"ctype": "code", "data": "'''\n爬取国内高匿代理IP\nauthor: Python当打之年\n'''\nimport random\nimport time\nimport requests\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\n"}, {"ctype": "p", "data": "如未安装模块，请使用pip instatll 安装即可"}, {"ctype": "head", "data": "3.2 获取高匿IP信息"}, {"ctype": "code", "data": "def get_ipinfo(url, headers):\n    ipinfo = []\n    # 爬取前50页代理\n    for i in range(1, 50):\n        try:\n            url0 = url.format(i)\n            # 随机延时，避免请求频率过快导致网络瘫痪\n            time.sleep(random.uniform(3.1, 4.2))\n            # 发送网页请求\n            html = requests.get(url0, headers=headers, timeout=10)\n            soup = BeautifulSoup(html.text, 'lxml')\n            # 分析IP列表\n            tr_list = soup.select_one('.fl-table').select_one('tbody').select('tr')\n            # 遍历每一行，获取IP\n            for td_list in tr_list:\n                # 过滤，仅获取高匿、有效期超过1天的IP\n                if '高匿' in td_list.select('td')[2].text and '天' in td_list.select('td')[5].text:\n                    ipport = td_list.select('td')[0].text\n                    ipinfo.append(ipport)\n        except:\n            continue\n        # 返回满足要求IP\n        return ipinfo\n"}, {"ctype": "head", "data": "3.3 验证IP是否有效"}, {"ctype": "p", "data": "既然IP有实效，那么爬取到的IP就可能是失效的IP或者是包装过的IP，这些IP并不能使用，接下来我们需要先检测一下IP是否能正常使用，然后仅保留有效IP，构建IP代理池。"}, {"ctype": "p", "data": "以下几个网站，可以很方便的检验IP是否有效："}, {"ctype": "p", "data": "这里使用站长工具（ip.chinaz.com）检测"}, {"ctype": "code", "data": "def check_ip(ippost_info, headers):\n    # http://icanhazip.com IP测试网址\n    check_url = 'http://icanhazip.com'\n    proxies = {'http': 'http://' + ippost_info, 'https': 'https://' + ippost_info}\n    try:\n        time.sleep(1)\n        # 发送测试请求\n        r = requests.get(check_url, headers=headers, proxies=proxies, timeout=10)\n        if r.status_code == 200:\n            print('有效IP：' + ippost_info)\n            with open('xila_https_list.txt', 'a') as f:\n                f.write(ippost_info)\n                f.write('\\n')\n        else:\n            print('无效IP：' + ippost_info)\n    except:\n        print('无效IP：' + ippost_info)\n"}, {"ctype": "p", "data": "至此，前50页有效IP我们就全部拿到了，作为演示，我把有效IP保存在了xila_https_list.txt文件中，大家也可以存储到MongoDB或者MySQL数据库中。"}, {"ctype": "head", "data": "写在最后"}, {"ctype": "p", "data": "小爬怡情，大爬伤身，强爬。。。（自行脑补）"}, {"ctype": "head", "data": "往期推荐"}, {"ctype": "p", "data": "爬虫 | Python送你王者荣耀官网全套皮肤 基础 | Python函数一文详解 可视化 | Python制作最炫3D可视化地图 可视化 | 动起来的中国大学排名，看看你的母校在哪里 技巧 | Python 字典用法详解（超全） 技巧 | 20个Pycharm最实用最高效的快捷键(动态展示) 技巧 | 5000字超全解析Python三种格式化输出方式【% / format / f-string】"}, {"ctype": "p", "data": "微信公众号 “Python当打之年” ，每天都有python编程技巧推送，希望大家可以喜欢"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322014644931.jpg"}], "cate": "Python"}
{"题目": "面试题 03.04. 化栈为队", "作者": "pfco", "发布时间": "2021-03-27 20:58:13", "内容": [{"ctype": "p", "data": "本文旨在对于个人知识的梳理以及知识的分享，如果有不足的地方，欢迎大家在评论区指出"}, {"ctype": "head", "data": "题目描述"}, {"ctype": "p", "data": "实现一个MyQueue类，该类用两个栈来实现一个队列。 示例:"}, {"ctype": "code", "data": "MyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek();  // 返回 1\nqueue.pop();   // 返回 1\nqueue.empty(); // 返回 false\n"}, {"ctype": "p", "data": "说明:"}, {"ctype": "head", "data": "题目链接"}, {"ctype": "head", "data": "题目分析"}, {"ctype": "p", "data": "这道题要求我们只可以使用栈有关的操作来实现队列，一个比较经典的方式就是使用两个栈，举一个例子，例如给定一个操作序列为[push, push, pop, peek, push], [1, 2, null, null, 3]，两个栈依次为sk1、sk2，则两个栈的变化为:"}, {"ctype": "code", "data": "push 1:\nsk1: [1]     sk2: []\n\npush 2:\nsk1: [1, 2]    sk2: []\n\npop:\nsk1: []   sk2: [2, 1]\n之后pop sk2中的元素=> sk1: []   sk2: [2]\n\npeek:\nsk1: []   sk2: [2]\n返回sk2的栈顶元素即可\n\npush 3:\nsk1: [3]   sk2: [2]\n"}, {"ctype": "p", "data": "由此，思路也就比较清晰了"}, {"ctype": "head", "data": "解题代码"}, {"ctype": "p", "data": "Java"}, {"ctype": "code", "data": "class MyQueue {\n\n    private Stack<Integer> sk1;\n    private Stack<Integer> sk2;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        sk1 = new Stack<Integer>();\n        sk2 = new Stack<Integer>();    \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        sk1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(sk2.size()!=0) return sk2.pop();\n        while(sk1.size()!=0) sk2.push(sk1.pop());\n        return sk2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(sk2.size()!=0) return sk2.peek();\n        while(sk1.size()!=0) sk2.push(sk1.pop());\n        return sk2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return sk1.size()==0 && sk2.size()==0;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n"}, {"ctype": "code", "data": "class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.sk1 = []\n        self.sk2 = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.sk1.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.sk2: \n            return self.sk2.pop()\n        while self.sk1:\n            self.sk2.append(self.sk1.pop())\n        return self.sk2.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.sk2:\n            return self.sk2[-1]\n        while self.sk1:\n            self.sk2.append(self.sk1.pop())\n        return self.sk2[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.sk1)==0 and len(self.sk2)==0\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n"}], "cate": "Python"}
{"题目": "天猫用户重复购买预测之建模优化", "作者": "张先生-您好", "发布时间": "2021-03-28 10:46:33", "内容": [{"ctype": "head", "data": "特征优化"}, {"ctype": "p", "data": "目的：优化数据，接近模型上限"}, {"ctype": "code", "data": "from sklearn.impute import SimpleImputer\nfrom sklearn.metrics import roc_auc_score as AUC\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestClassifier\n"}, {"ctype": "code", "data": "# 是否从本地读取数据\nall_data_test = pd.read_csv(\"./data/all_data_test.csv\")\n"}, {"ctype": "code", "data": "feature_columns = [c for c in all_data_test.columns if c not in [\"label\", \"prob\", \"age_range\", \"gender\"\n                                                               , 'item_path', 'cat_path', 'seller_path'\n                                                                 , 'brand_path', 'time_stamp_path','action_type_path']]\n"}, {"ctype": "code", "data": "train = all_data_test[~all_data_test.label.isna()][:10000]\n"}, {"ctype": "code", "data": "x_train = train[feature_columns]\ny_train = train[\"label\"].values\nx_test = all_data_test[all_data_test.label.isna()][feature_columns]\n"}, {"ctype": "code", "data": "# 缺失数值为类别数据，采用众数填补\nimputer = SimpleImputer(strategy=\"median\")\nimputer = imputer.fit(x_train)\ntrain_imputer = imputer.transform(x_train)\ntest_imputer = imputer.transform(x_test)\n"}, {"ctype": "code", "data": "def select_feature(train, train_sel, target):\n    \n    clf = RandomForestClassifier(max_depth=2\n                                 , random_state=2021\n                                 , n_jobs=-1\n                                )\n    score1 = cross_val_score(clf, train, target, cv=5, scoring=\"roc_auc\")\n    score2 = cross_val_score(clf, train_sel, target, cv=5, scoring=\"roc_auc\")\n    print(\"No Select AUC: %0.3f (+/- %0.3f)\"%(score1.mean(), score1.std()**2))\n    print(\"Feature Select AUC: %0.3f (+/- %0.3f)\"%(score2.mean(), score2.std()**2))\n    print(\"特征选择前特征维度：\", train_imputer.shape)\n    print(\"特征选择后特征维度：\", train_sel.shape)\n"}, {"ctype": "code", "data": "select_feature(x_train, train_imputer, target=y_train)\n"}, {"ctype": "code", "data": "No Select AUC: nan (+/- nan)\nFeature Select AUC: 0.572 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 60)\n"}, {"ctype": "head", "data": "方差分析法"}, {"ctype": "code", "data": "from sklearn.feature_selection import VarianceThreshold\n"}, {"ctype": "code", "data": "threshold_range = np.arange(0, 1, 0.1)\nfor i in threshold_range:\n    print(\"Values is :\", i)\n    sel = VarianceThreshold(threshold=i)\n    train_sel = sel.fit_transform(train_imputer)\n    select_feature(train_imputer, train_sel, y_train)\n"}, {"ctype": "code", "data": "Values is : 0.0\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.576 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 56)\nValues is : 0.1\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 47)\nValues is : 0.2\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.578 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 42)\nValues is : 0.30000000000000004\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.579 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 39)\nValues is : 0.4\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 38)\nValues is : 0.5\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 38)\nValues is : 0.6000000000000001\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 38)\nValues is : 0.7000000000000001\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 38)\nValues is : 0.8\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 38)\nValues is : 0.9\nNo Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.577 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 38)\n"}, {"ctype": "head", "data": "递归功能消除法"}, {"ctype": "code", "data": "from sklearn.feature_selection import RFECV\n\nclf = RandomForestClassifier(max_depth=2\n                             , random_state=2021\n                             , n_jobs=-1\n                            )\n\nselector = RFECV(clf, step=1, cv=2)\nselector = selector.fit(train_imputer, y_train)\n"}, {"ctype": "head", "data": "使用模型选择特征"}, {"ctype": "p", "data": "注意：模型必须coef_或feature_importance属性"}, {"ctype": "code", "data": "from sklearn.feature_selection import SelectFromModel\nfrom sklearn.preprocessing import Normalizer\nfrom sklearn.linear_model import LogisticRegression\n"}, {"ctype": "head", "data": "L1选择"}, {"ctype": "code", "data": "# 数据归一化\nnormalize = Normalizer()\nnormalize = normalize.fit(train_imputer)\ntrain_norm = normalize.transform(train_imputer)\ntest_norm = normalize.transform(test_imputer)\n"}, {"ctype": "code", "data": "LR = LogisticRegression(penalty=\"l1\", C = 5, solver=\"saga\")\nLR = LR.fit(train_norm, y_train)\nmodel = SelectFromModel(LR, prefit=True)\ntrain_sel = model.transform(train_norm)\ntest_sel = model.transform(test_norm)\n"}, {"ctype": "code", "data": "select_feature(train_imputer, train_sel, y_train)\n"}, {"ctype": "code", "data": "No Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.552 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 11)\n"}, {"ctype": "head", "data": "L2选择"}, {"ctype": "code", "data": "LR = LogisticRegression(penalty=\"l2\", C = 5)\nLR = LR.fit(train_norm, y_train)\nmodel = SelectFromModel(LR, prefit=True)\ntrain_sel = model.transform(train_norm)\ntest_sel = model.transform(test_norm)\n"}, {"ctype": "code", "data": "select_feature(train_imputer, train_sel, y_train)\n"}, {"ctype": "code", "data": "No Select AUC: 0.572 (+/- 0.000)\nFeature Select AUC: 0.550 (+/- 0.000)\n特征选择前特征维度： (10000, 60)\n特征选择后特征维度： (10000, 14)\n"}, {"ctype": "head", "data": "建立模型"}, {"ctype": "code", "data": "from sklearn.model_selection import KFold\nfrom scipy import sparse\nimport xgboost\nimport lightgbm as lgb\nfrom sklearn.ensemble import RandomForestClassifier,AdaBoostClassifier,GradientBoostingClassifier\nfrom sklearn.linear_model import LinearRegression,LogisticRegression\nfrom sklearn.ensemble import BaggingClassifier\nfrom sklearn.svm import LinearSVC,SVC\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import log_loss,mean_absolute_error,mean_squared_error\nfrom sklearn.naive_bayes import MultinomialNB,GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import StratifiedKFold\n"}, {"ctype": "head", "data": "数据处理"}, {"ctype": "code", "data": "all_data_test = pd.read_csv(\"./data/all_data_test.csv\")\n"}, {"ctype": "code", "data": "# 有用特征提取\nfeature_columns = [c for c in all_data_test.columns if c not in [\"label\", \"prob\", \"gender\", \"age_range\"\n                                                               , 'item_path', 'cat_path', 'seller_path', 'brand_path', 'time_stamp_path','action_type_path']]\n"}, {"ctype": "code", "data": "x_train = all_data_test[~all_data_test.label.isna()][feature_columns]\ny_train = all_data_test[~all_data_test.label.isna()][\"label\"].values\nx_test = all_data_test[all_data_test.label.isna()][feature_columns]\n"}, {"ctype": "code", "data": "# 缺失值用中位数填补\nimputer = SimpleImputer(strategy=\"median\")\nimputer = imputer.fit(x_train)\nX = imputer.transform(x_train)\nx_test = imputer.transform(x_test)\ny = np.int_(y_train)\n"}, {"ctype": "code", "data": "# # 方差过滤优化特征\n# vart = VarianceThreshold(0.3)\n# vart = vart.fit(X=X)\n# X = vart.transform(X)\n# x_test = vart.transform(x_test)\n"}, {"ctype": "code", "data": "# 分层抽取样本(保证数据划分后的样本数目相同)\n# 构造训练集和测试集\ndef trainData(train_df,label_df):\n    skv = StratifiedKFold(n_splits=5, shuffle=True, random_state=620)\n    trainX = pd.DataFrame()\n    trainY = pd.DataFrame()\n    testX = pd.DataFrame()\n    testY = pd.DataFrame()\n    for train_index, test_index in skv.split(X=train_df, y=label_df):\n        train_x, train_y, test_x, test_y = train_df.iloc[train_index, :], label_df.iloc[train_index], \\\n                                           train_df.iloc[test_index, :], label_df.iloc[test_index]\n        \n        trainX = trainX.append(train_x)\n        trainY = trainY.append(train_y)\n        testX = testX.append(test_x)\n        testY = testY.append(test_y)\n        break\n        \n    return trainX,trainY,testX,testY\n"}, {"ctype": "code", "data": "trainNew, label = pd.DataFrame(X), pd.DataFrame(y)\nX_train, y_train, X_val, y_val = trainData(trainNew,label)\n"}, {"ctype": "head", "data": "RandomForest"}, {"ctype": "code", "data": "# RF =RandomForestClassifier().fit(X_train, y_train)\n"}, {"ctype": "code", "data": "# RF.score(X_test, y_test)\n"}, {"ctype": "head", "data": "LightGBM"}, {"ctype": "code", "data": "# 数据准备\ncv_train = lgb.Dataset(X, y)\ndata_train = lgb.Dataset(X_train, y_train)\ndata_val = lgb.Dataset(X_val, y_val)\n"}, {"ctype": "head", "data": "网格搜索寻找参数范围（粗调）"}, {"ctype": "code", "data": "from sklearn.model_selection import GridSearchCV\nfrom time import time\nimport datetime\nimport sklearn\nimport joblib\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score as AUC\n"}, {"ctype": "code", "data": "class GridSearch:\n    \"\"\"回归模型网格搜索\"\"\"\n    \n    def __init__(self, model):\n        self.model = model\n    \n    def grid_get(self, X, y, param_grid):\n        \"\"\"参数搜索\"\"\"\n        \n        grid_search = GridSearchCV(self.model\n                                   , param_grid =param_grid, scoring=\"roc_auc\"\n                                   , cv = 5\n                                   , n_jobs = -1\n                                  )\n        grid_search.fit(X, y)\n        print(\"Best_params:\", grid_search.best_params_, \"best_score_:\", (grid_search.best_score_))\n        print(pd.DataFrame(grid_search.cv_results_)[[\"params\", \"mean_test_score\", \"std_test_score\"]])\n        \n        return grid_search.best_estimator_\n"}, {"ctype": "code", "data": "# 可用评价指标\n[sklearn.metrics.SCORERS.keys()]\n"}, {"ctype": "code", "data": "[dict_keys(['explained_variance', 'r2', 'max_error', 'neg_median_absolute_error', 'neg_mean_absolute_error', \n'neg_mean_absolute_percentage_error', 'neg_mean_squared_error', 'neg_mean_squared_log_error', \n  'neg_root_mean_squared_error', 'neg_mean_poisson_deviance', 'neg_mean_gamma_deviance', 'accuracy', \n  'top_k_accuracy', 'roc_auc', 'roc_auc_ovr', 'roc_auc_ovo', 'roc_auc_ovr_weighted', 'roc_auc_ovo_weighted', \n  'balanced_accuracy', 'average_precision', 'neg_log_loss', 'neg_brier_score', 'adjusted_rand_score', 'rand_score', \n  'homogeneity_score', 'completeness_score', 'v_measure_score', 'mutual_info_score', 'adjusted_mutual_info_score', \n  'normalized_mutual_info_score', 'fowlkes_mallows_score', 'precision', 'precision_macro', 'precision_micro', \n  'precision_samples', 'precision_weighted', 'recall', 'recall_macro', 'recall_micro', 'recall_samples', 'recall_weighted', 'f1', \n  'f1_macro', 'f1_micro', 'f1_samples', 'f1_weighted', 'jaccard', 'jaccard_macro', 'jaccard_micro', 'jaccard_samples', \n  'jaccard_weighted'])]\n"}, {"ctype": "code", "data": "param_grid = {\n#      \"num_leaves\": np.arange(31, 82, 7)\n#     , \"max_depth\": np.arange(5, 7, 8, 6)\n    , \"learning_rate\": [0.1, 0.01, 0.03]\n    , \"n_estimators\": [1000, 3000, 6000]\n#     , \"subsample\":[0.8, 0.9, 1.0]\n#     , \"colsample_bytree\":[0.8, 0.9, 1.0]\n}\n"}, {"ctype": "code", "data": "t0 = time()\nLGBC = lgb.LGBMClassifier(boosting_type=\"gbdt\"\n                          , device=\"gpu\"\n#                           , learning_rate=0.01\n#                           , num_leaves=41\n#                           , max_depth=6\n                          \n#                           , subsample=0.8\n#                           , colsample_bytree=0.8\n#                           , n_estimators=2000\n                          , metric=\"auc\"\n                          , random_state=0\n                          , silent=True\n                         )\nmodel = GridSearch(LGBC).grid_get(X=X_train,y=y_train, param_grid=param_grid)\nprint(\"处理时间：\",datetime.datetime.fromtimestamp(time()-t0).strftime(\"%M:%S:%f\"))\n"}, {"ctype": "code", "data": "Best_params: {'learning_rate': 0.1} best_score_: 0.6512223331632725\n                   params  mean_test_score  std_test_score\n0  {'learning_rate': 0.1}         0.651222        0.001596\n处理时间： 02:20:432963\n"}, {"ctype": "code", "data": "model.score(X_val, y_val)\n"}, {"ctype": "code", "data": "0.9391387682085357\n"}, {"ctype": "code", "data": "probs = model.predict(X_val) \narea = AUC(y_val, probs)\narea\n"}, {"ctype": "code", "data": "0.5000981728567914\n"}, {"ctype": "head", "data": "默认参数（精调）"}, {"ctype": "code", "data": "# 参数设定为默认状态\nparams1 = {\n      \"boosting_type\": \"gbdt\"\n    , \"objective\": \"binary\" # 二分类任务\n    , \"metric\": {\"binary_logloss\", \"auc\"}\n    \n    , \"nthread\": 16\n    , \"device\": \"gpu\"\n    , \"gpu_device_id\": 1\n    , \"num_gpu\":1\n    , \"verbose\": 0\n\n    , \"learning_rate\": 0.1\n\n    , \"subsample\": 1.0  # 数据采样\n#     , \"subsample_freq\": 5\n    , \"colsample_bytree\": 1.0  # 特征采样\n    \n    , \"max_depth\": 5\n#     , \"min_child_weight\": 1.5\n    , \"num_leaves\": 16  # 由于lightGBM是leaves_wise生长，官方说法是要小于2^max_depth\n    , 'reg_alpha': 0.0  # L1\n    , 'reg_lambda': 0.0  # L2\n    , \"seed\": 2021\n}\n"}, {"ctype": "code", "data": "cv_result1 = lgb.cv(params = params1, train_set = cv_train\n                   , nfold = 5\n                   , stratified = True\n                   , shuffle = True\n                   , num_boost_round = 600\n                   , early_stopping_rounds = 100\n                   , seed = 2021\n                   )\n"}, {"ctype": "head", "data": "参数调整完毕"}, {"ctype": "code", "data": "num_boost_round = 600\nparams2 = {\n      \"boosting_type\": \"gbdt\"\n    , \"objective\": \"binary\" # 二分类任务\n    , \"metric\": {\"binary_logloss\", \"auc\"}\n    \n    , \"nthread\": 16\n    , \"device\": \"gpu\"\n    , \"gpu_device_id\": 1\n    , \"num_gpu\":1\n    , \"verbose\": 0\n\n    , \"learning_rate\": 0.01\n    \n    , \"subsample\": 0.8  # 数据采样\n#     , \"subsample_freq\": 5\n    , \"colsample_bytree\": 0.8  # 特征采样\n    \n    , \"max_depth\": 5\n#     , \"min_child_weight\": 1.5\n    , \"num_leaves\": 15  # 由于lightGBM是leaves_wise生长，官方说法是要小于2^max_depth\n    , 'reg_alpha': 0.0  # L1\n    , 'reg_lambda': 0.0  # L2\n    , \"seed\": 2021\n}\n"}, {"ctype": "code", "data": "cv_result2 = lgb.cv(params = params2, train_set = cv_train\n                   , num_boost_round = num_boost_round\n                   , nfold = 5\n                   , stratified = True\n                   , shuffle = True\n                   , early_stopping_rounds = 100\n                   , seed=2021\n                   )\n"}, {"ctype": "code", "data": "#  选择最佳的estimators\nprint(\"Best_n_estimators: %d\\nBest_cv_score: %.2f\" \n      % (np.array(list(cv_result2.values())).shape[1],\n         max(np.array(list(cv_result2.values()))[0]))\n     ) \n"}, {"ctype": "code", "data": "Best_n_estimators: 600\nBest_cv_score: 0.23\n"}, {"ctype": "head", "data": "调参状态"}, {"ctype": "code", "data": "params3 = {\n      \"boosting_type\": \"gbdt\"\n    , \"objective\": \"binary\" # 二分类任务\n    , \"metric\": {\"binary_logloss\", \"auc\"}\n    \n    , \"nthread\": 16\n    , \"device\": \"gpu\"\n    , \"gpu_device_id\": 1\n    , \"num_gpu\":1\n    , \"verbose\": 0\n\n    , \"learning_rate\": 0.01\n    \n    , \"subsample\": 1  # 数据采样\n#     , \"subsample_freq\": 5\n    , \"colsample_bytree\": 1  # 特征采样\n    \n    , \"max_depth\": 7\n#     , \"min_child_weight\": 1.5\n    , \"num_leaves\":80  # 由于lightGBM是leaves_wise生长，官方说法是要小于2^max_depth\n    , 'reg_alpha': 0.0  # L1\n    , 'reg_lambda': 0.0  # L2\n    , \"seed\": 2021\n}\n"}, {"ctype": "code", "data": "cv_result3 = lgb.cv(params=params3, train_set=cv_train\n                   , num_boost_round=10000\n                   , nfold=5\n                   , stratified=True\n                   , shuffle=True\n                   , early_stopping_rounds=100\n                   , seed=2021\n                  )\n"}, {"ctype": "head", "data": "可视化"}, {"ctype": "code", "data": "def plot_mertics(cv_result1, cv_result2, cv_result3, index1=0, index2=1, save = False):\n    \"\"\"绘制评估曲线\"\"\"\n    \n    fig, ax = plt.subplots(1, 2, figsize = (14,5))\n\n    length1 = np.array(list(cv_result1.values())).shape[1]\n    length2 = np.array(list(cv_result2.values())).shape[1]\n    length3 = np.array(list(cv_result3.values())).shape[1]\n\n    ax[0].plot(range(length1), cv_result1[list(cv_result1.keys())[index1]], label=\"param1\", c=\"red\")\n    ax[1].plot(range(length1), cv_result1[list(cv_result1.keys())[index2]], label=\"param1\", c=\"green\")\n\n    ax[0].plot(range(length2), cv_result2[list(cv_result2.keys())[index1]], label=\"param2\", c=\"magenta\")\n    ax[1].plot(range(length2), cv_result2[list(cv_result2.keys())[index2]], label=\"param2\", c=\"blue\")\n\n    ax[0].plot(range(length3), cv_result3[list(cv_result3.keys())[index1]], label=\"param3\", c=\"yellow\")\n    ax[1].plot(range(length3), cv_result3[list(cv_result3.keys())[index2]], label=\"param3\", c=\"c\")\n\n    ax[0].set_xlabel(\"num_round\", fontsize=12)\n    ax[1].set_xlabel(\"num_round\", fontsize=12)\n    ax[0].set_ylabel(list(cv_result1.keys())[index1], fontsize=12)\n    ax[1].set_ylabel(list(cv_result1.keys())[index2], fontsize=12)\n    ax[0].legend()\n    ax[1].legend()\n    ax[0].grid()\n    ax[1].grid()\n    if save:\n        plt.savefig(\"./imgs/{}.svg\".format(list(cv_result1.keys())[index1].split(\"-\")[0]))\n        \n    plt.show()\n"}, {"ctype": "head", "data": "AUC评估"}, {"ctype": "code", "data": "plot_mertics(cv_result1, cv_result2, cv_result3, index1=2, index2=3, save=True)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032810424751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTE1NDI4MQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "​"}, {"ctype": "head", "data": "Logloss评估"}, {"ctype": "code", "data": "plot_mertics(cv_result1, cv_result2, cv_result3, save=True)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328104238392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTE1NDI4MQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "​"}, {"ctype": "head", "data": "模型评估与保存"}, {"ctype": "code", "data": "\"\"\"\n当使用验证集，并加入早停机制时，可以设置在多少步之内，若评估指标不在下降\n，则提前终止训练模型，多个评估指标使用时，每一个评估指标都可作为终止的条件\n\"\"\"\nlgb_C = lgb.train(params=params2\n                  , train_set=data_train\n                  , valid_sets=data_val\n                  , num_boost_round = 10000\n                  , early_stopping_rounds=200\n                  , valid_names=\"valid\"\n         )\n"}, {"ctype": "code", "data": "# AUC指标\nprobs = lgb_C.predict(X_val, num_iteration=lgb_C.best_iteration) \nFPR, recall, thresholds = roc_curve(y_val, probs, pos_label=1)\narea = AUC(y_val, probs)\narea\n"}, {"ctype": "code", "data": "0.6636913376062848\n"}, {"ctype": "code", "data": "plt.figure(figsize=(9, 5))\nplt.plot(FPR, recall, color=\"red\",\n         label = \"ROC Curve (auc=%0.3f)\" % (area), alpha=0.8)\nplt.plot([0, 1], [0, 1], c=\"black\", linestyle = \"--\")\nplt.xlim([-0.0, 1])\nplt.ylim([-0.0, 1])\nplt.fill_between(FPR, recall, [0.0]*len(recall), alpha=0.6, color=\"pink\")\nplt.xlabel('False Positivate Rate', fontsize=12)\nplt.ylabel('True Positive Rate', fontsize=12)\nplt.legend(loc=\"lower right\")\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328104303649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTE1NDI4MQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "​"}, {"ctype": "code", "data": "# 提交格式\nsubmission = pd.read_csv(\"data/sample_submission.csv\")\nsubmission[\"prob\"] = lgb_C.predict(x_test)\nsubmission.to_csv(\"submission.csv\", index=False)\n"}, {"ctype": "code", "data": "!head -n 5 submission.csv\n"}, {"ctype": "code", "data": "user_id,merchant_id,prob\n163968,4605,0.09104269707689874\n360576,1581,0.06436875895976078\n98688,1964,0.06932283438396855\n98688,3645,0.04079761398133279\n"}, {"ctype": "code", "data": "#　模型保存\nlgb_C.save_model(\"./checkpoint/model.txt\")\n"}, {"ctype": "head", "data": "LightGBM+LR"}, {"ctype": "code", "data": "num_leaves = 15\n\n#  训练集\ny_pred = lgb_C.predict(X_train, num_iteration=lgb_C.best_iteration, pred_leaf=True)\n\nprint('Writing transformed training data')\ntransformed_training_matrix = np.zeros([len(y_pred), len(y_pred[0]) * num_leaves],\n                                       dtype=np.int64)\nfor i in range(0, len(y_pred)):\n    temp = np.arange(len(y_pred[0])) * num_leaves + np.array(y_pred[i])\n    transformed_training_matrix[i][temp] += 1\nprint('X_train leaf', transformed_training_matrix.shape)\n\n#  测试集\ny_pred = lgb_C.predict(X_val, pred_leaf=True, num_iteration=lgb_C.best_iteration)\n\nprint('Writing transformed testing data')\ntransformed_testing_matrix = np.zeros([len(y_pred), len(y_pred[0]) * num_leaves], dtype=np.int64)\nfor i in range(0, len(y_pred)):\n    temp = np.arange(len(y_pred[0])) * num_leaves + np.array(y_pred[i])\n    transformed_testing_matrix[i][temp] += 1\n    if i == 0:\n        break\nprint('testing leaf shape', transformed_testing_matrix.shape)\n"}, {"ctype": "code", "data": "lm = LogisticRegression(penalty='l2',C=0.05) # logestic model construction\nlm.fit(transformed_training_matrix,y_train)  # fitting the data\n"}, {"ctype": "code", "data": "probs = lm.predict(transformed_testing_matrix) \nFPR, recall, thresholds = roc_curve(y_val, probs, pos_label=1)\narea = AUC(y_val, probs)\narea\n"}, {"ctype": "p", "data": "结论：时间复杂高，准确率低。"}, {"ctype": "head", "data": "参考"}, {"ctype": "p", "data": "使用Python Pandas处理亿级数据 LightGBM官方文档"}, {"ctype": "head", "data": "知识点"}, {"ctype": "head", "data": "KFold和StrartifiedFold的区别"}, {"ctype": "code", "data": "from sklearn.model_selection import KFold\nX=np.array([[1,2],[3,4],[5,6],[7,8],[9,10],[11,12]])\ny=np.array([1,2,3,4,5,6])\n\nkf=KFold(n_splits=3, shuffle=True)    # 定义分成几个组\n\n#for循环中的train_index与test_index是索引而并非我们的训练数据\nfor train_index,test_index in kf.split(X):\n    print(\"Train Index:\",train_index,\",Test Index:\",test_index)\n    X_train,X_test=X[train_index],X[test_index]\n    y_train,y_test=y[train_index],y[test_index]\n"}, {"ctype": "code", "data": "Train Index: [0 1 3 4] ,Test Index: [2 5]\nTrain Index: [0 2 3 5] ,Test Index: [1 4]\nTrain Index: [1 2 4 5] ,Test Index: [0 3]\n"}, {"ctype": "code", "data": "from sklearn.model_selection import StratifiedKFold\n\nX=np.array([[1,2],[3,4],[5,6],[7,8],[9,10],[11,12]])\ny=np.array([1,1,1,2,2,2])\n# 类似于分层抽样保证拆分后的数据，正负样本比例保持一致\nskf=StratifiedKFold(n_splits=3, shuffle=True, random_state=2021)\n\n#for循环中的train_index与test_index是索引而并非我们的训练数据\nfor train_index,test_index in skf.split(X,y):\n    \n    print(\"Train Index:\",train_index,\",Test Index:\",test_index)\n    X_train,X_test=X[train_index],X[test_index]\n    y_train,y_test=y[train_index],y[test_index]\n"}, {"ctype": "code", "data": "Train Index: [0 1 3 5] ,Test Index: [2 4]\nTrain Index: [0 2 3 4] ,Test Index: [1 5]\nTrain Index: [1 2 4 5] ,Test Index: [0 3]\n"}], "cate": "Python"}
{"题目": "Flask（一）", "作者": "日渐秃噜的小范", "发布时间": "2021-03-28 13:27:57", "内容": [{"ctype": "head", "data": "一、下载及项目结构"}, {"ctype": "p", "data": "在pycharm创建项目后 1、pip list 里面有东西的原因：   当创建项目的时候已经指定了flask，所以pycharm在创建项目的时候回自动执行：pip intall flask"}, {"ctype": "p", "data": "项目结构 –项目名：   |–static（静态）   |–templates(模板)   |–app.py（运行|启动）"}, {"ctype": "code", "data": "from flask inport Flask\n\napp=Flask(__name__)\n\"\"\"\nWSGI：文本服务器网关接口，是为python语言定义的web服务器和web应用程序\n      框架之间的一种简单而通用的接口\n\"\"\"\n@app.route('/')\ndef hello_world():\n\treturn 'Hello World!'\n\nif __name__ =='__main__':\n\tapp,run(host='0.0.0.0',post='8080',debug=Turn)\n\"\"\"\nrun(host='ip地址',post='端口号',debug=Turn)一个端口号对应一个程序。\ndebug：布尔类型debug=Turn开启debug调试模式只要代码改变服务器就会重新加载\n       最新的代码适用于开发阶段\ndebug=False默认代码发生改变不会自动加载适用于上线模式\n\"\"\"\n"}, {"ctype": "head", "data": "二、路由的命名规范"}, {"ctype": "code", "data": "data= {\n'a':'北京'，'b':'上海','c':'深圳'\n}\n\n@app.route('/index')  #路由\ndef index():  # 视图函数\n\treturn '我是首页'\n@app.route('/getcity/<key>')  # key就是一个变量名，默认是字符串类型的\ndef getcity(key):\n\treturn data.get(key)\n@app.route('/add/<int:mun>')\ndef add(mun):\n\tresult = mun+10\n\treturn str(result)\n"}, {"ctype": "p", "data": "1、路由的变量规则 string   （缺省值）接受任何不包括斜杠的文本 int     接受正整数 float    类似string,但是可以包含斜杠 UUID   接受UUID字符串（唯一标识码）"}, {"ctype": "p", "data": "2、视图  返回值：其实返回值返回都是一个响应对象。"}, {"ctype": "p", "data": "3、重定向  以下两条规则的不同之处在于是否使用尾部的斜杠。:"}, {"ctype": "code", "data": "@app.route('/projects/')\ndef projects():\n    return 'The project page'\n\n@app.route('/projects')\ndef projects1():\n    return 'The about page'\n"}, {"ctype": "p", "data": " 在falsk中路由的运行是自上而下的当在网页中输出的url无论带不带斜杠都会进入到第一个，当输入http:127.0.0.0:5000/projiect 时系统因为找不到这个路由而进行模糊查询从而进入到第一个路由。当把第二个路由放到第一时，再次输入http:127.0.0.0:5000/projiect 就会得到‘The about page’。但是开发中一般不会出现这样的问题。"}, {"ctype": "p", "data": "4、路由与视图函数绑定"}, {"ctype": "code", "data": "@app.route('/')#默认端口\nroute:\n\tdef route(self,rule,**options)\n\t\tdef decorator(f)\n\t\t\tself.add_url_rule(rule,endpoibt,f,**options)\n\t\t\tretuan f\n\t\treturn decorator\n"}, {"ctype": "p", "data": "这个装饰器其实就是将rule字符串更视图函数进行了绑定，通过add_url_rule()实现了绑定"}, {"ctype": "code", "data": "#这个方法与上述方法是等效的\n@app.route('/index')\ndef heool_world():\n\treturn 'hello world'\ndef index():\n\treturn 'welcome everyone'\napp.add_url_rule('/index',view_func=index) \n"}], "cate": "Python"}
{"题目": "Numpy学习记录", "作者": "噬也", "发布时间": "2021-03-28 15:20:32", "内容": [{"ctype": "head", "data": "Numpy实战记录"}, {"ctype": "head", "data": "动机"}, {"ctype": "p", "data": "一直以来，只能看得懂numpy的语法，自己写起来太蹩脚了，动不动就要网上搜索，效率太低。痛定思痛，决定自己好好整理一下，有时间的话抽空来看一看，争取永久性掌握！"}, {"ctype": "code", "data": "import numpy as np\n"}, {"ctype": "head", "data": "Numpy Tips"}, {"ctype": "p", "data": "对于很多函数func()而言，B=np.func(matrixA,...)和B=A.func(...)是等价的生成数组np.array()，生成矩阵np.mat()，全零np.zeros(一个数/元组)【len_of_array / (num_of_row, num_of_col)】，全一np.ones(一个数/元组)【len_of_array / (num_of_row, num_of_col)】"}, {"ctype": "head", "data": "Numpy 常用语法"}, {"ctype": "p", "data": "@, decorator, 相当于矩阵相乘,也即np.dot(matrixA, matrixB)A = np.array([[1,2],\n              [3,4]])    # 2-dim\nA2 = A@A    # same as np.dot(A,A)\n np.concatenate((m1,m2,m3...), axis=0)沿axis的方向拼接多个矩阵AAA = np.concatenate((A,A,A), axis=1)    # num of columns increases\nAAA = np.concatenate((A,A,A), axis=0)    # num of rows increases\n np.transpose()，括号内写转换成轴，若不写则逆序全返A_trans = A.transpose(1,0)    # a combination of 0 to n-1 for n-dim \n np.reshape(matrix, newshape=int或(), order=’C’/’F’/’A’)，简单来说，打碎重组，常用于重建矩阵，计算的时候调整维数，具体的自行百度/google比较清晰A_reshape = np.reshape(A,newshape=(4,1))    # return a (4,1) matrix\n np.nonzero(matrix)，用于寻找matrix中非零元素，返回是多个array表示的地址，例如返回[1,3],[2,0]，说明原矩阵内(1,2)和(3,0)两位置上的数是非零的A_non0 = np.nonzero(A)\n# return: (array([0,0,1,1], dtype=int64), array([0,1,0,1], dtype=int64))\n np.repeat(matrix, repeats=int或[], axis=None/0/1)，用于沿着flatten/0/1轴重复repeats次A_repeat = np.repeat(A, repeats=1)\n# return: [1,2,3,4]\n np.sum(matrix, axis=int或())，用于计算和，axis若是元组则表示要依次在axis的维度加和A_sum = np.sum(A, axis=0)\n# return: [4,6]\n np.argmin(matrix, axis=None/0/1)用于寻找最小值索引，沿着flatten/0/1轴A_amin = np.argmin(A, axis=1)\n# return: [0,0]\n np.array_equal(A, B)用于判断两数组是否相等，在此忽略np.array和python自带list的区别A_is = np.array_equal(A, A.tolist())\n# return: True\n np.argsort(matrix, axis=2/1/0)用于寻找排序后的索引默认最内排序A_asort = np.argsort(A, axis=0)\n# return: [[0 0]\n#\t\t   [1 1]]\n "}, {"ctype": "head", "data": "Numpy 小结"}, {"ctype": "p", "data": "更新中… 以上皆是实战中遇到的，用于自省，希望自己不会在同一个地方翻跟头，望诸君共勉之~"}], "cate": "Python"}
{"题目": "leetcode  1451. Rearrange Words in a Sentence（python）", "作者": "王大丫丫", "发布时间": "2021-03-27 16:44:44", "内容": [{"ctype": "head", "data": "描述"}, {"ctype": "p", "data": "Given a sentence text (A sentence is a string of space-separated words) in the following format:"}, {"ctype": "p", "data": "Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order."}, {"ctype": "p", "data": "Return the new text following the format shown above."}, {"ctype": "p", "data": "Example 1:"}, {"ctype": "code", "data": "Input: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.\t\n"}, {"ctype": "p", "data": "Example 2:"}, {"ctype": "code", "data": "Input: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.\n"}, {"ctype": "p", "data": "Example 3:"}, {"ctype": "code", "data": "Input: text = \"To be or not to be\"\nOutput: \"To be or to be not\"\n"}, {"ctype": "p", "data": "Note:"}, {"ctype": "code", "data": "text begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5\n"}, {"ctype": "head", "data": "解析"}, {"ctype": "p", "data": "根据题意，只需要将 text 按照空格分割成字符串数组，然后按照字符串长度排序（这个过程满足长度一样的情况下按照原字符串的前后顺序排列），最后字符串用空格连起来并将首字母大写即可得到结果"}, {"ctype": "head", "data": "解答"}, {"ctype": "code", "data": "class Solution(object):\n    def arrangeWords(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: str\n        \"\"\"\n        words = text.split(\" \")\n        words.sort(key = lambda x:len(x))\n        res = \" \".join(words).capitalize()\n        return res\n"}, {"ctype": "head", "data": "运行结果"}, {"ctype": "code", "data": "Runtime: 36 ms, faster than 65.63% of Python online submissions for Rearrange Words in a Sentence.\nMemory Usage: 16.4 MB, less than 92.97% of Python online submissions for Rearrange Words in a Sentence.\n"}, {"ctype": "p", "data": "原题链接：https://leetcode.com/problems/rearrange-words-in-a-sentence"}, {"ctype": "p", "data": "您的支持是我最大的动力"}], "cate": "Python"}
{"题目": "python之闭包函数", "作者": "小儿小儿朗", "发布时间": "2021-03-28 15:58:27", "内容": [{"ctype": "p", "data": "一、大前提 闭包函数 = 名称空间与作用域+函数嵌套+函数对象 核心点：名字的查找关系是以函数定义阶段为准"}, {"ctype": "p", "data": "二、什么是闭包函数 ‘闭’函数指的是该函数是内嵌函数 ‘包’函数指的是该函数包含对外层作用域名称的引用（不是对全局作用域）"}, {"ctype": "p", "data": "闭包函数之名称空间与作用域的应用+函数嵌套"}, {"ctype": "code", "data": "def f1():\n\tdef f2():\n\t\tpass\n"}, {"ctype": "code", "data": "\t#闭包函数之名称空间与作用域的应用+函数嵌套\ndef f1():\n\tx = 3333\n\tdef f2():\n\t\tprint(x)\n\tf2()\n\nx = 111\ndef bar():\n\tx = 4444\n\tf1()\n\ndef foo():\n\tx = 2222\n\tbar()\n\nfoo()  # 结果为3333，名称空间！！要一眼看出答案\n#该函数仅做到了‘闭’\n"}, {"ctype": "p", "data": "闭包函数之函数对象"}, {"ctype": "code", "data": "def f1():\n\tx = 333\n\tdef f2():\n\t\tprint('函数f2',x)\n\treturn f2\n\nf = f1()\nprint(f)\nf()\n\ndef foo():\n\tx = 555\n\tf()\n\nfoo()\n"}, {"ctype": "p", "data": "三、闭包函数的应用场景 两种为函数体传参的方式 方式一：直接把函数体需要的参数定义成形参"}, {"ctype": "code", "data": "def f2(x):\n\tprint(x)\n\nf2(1)\nf2(2)\nf2(3)\n"}, {"ctype": "p", "data": "方式二："}, {"ctype": "code", "data": "def f1(x):\n\t#x = 3\n\tdef f2():\n\t\tprint(x)\n\t\n\treturn f2\nx = f1(1)\nprint(x)\nx()\n"}], "cate": "Python"}
{"题目": "python第七章课后习题plus(7)", "作者": "听说不挂科", "发布时间": "2021-03-28 15:39:41", "内容": [{"ctype": "p", "data": "完成函数fun7,参数v是一个n*m的矩阵(二维列表，每个数是0-10的整数)，求出每一行中最大值与最小值差的绝对值，返回类型为Numpy数组，并返回最大的一个绝对值所在行的索引。"}, {"ctype": "code", "data": "def fun7(v):\n    '''\n    Arg\n    v: a 3*3 matrix ; return the difference between the maximum and minimum of each row and number of rows with maximum difference\n    eg\n    [[3, 2, 7],\n    [2, 8, 4],\n    [9, 6, 1]]\n    return  (array([5 6 8]), 2)\n    '''\n    #因为每个数都是0-10，所以这里不需要abs函数\n    diff=np.max(v,axis=1)-np.min(v,axis=1)\n    return (diff,int(np.where(diff==np.max(diff))[0]))\n"}], "cate": "Python"}
{"题目": "四种姿势爬取豆瓣电影Top250信息", "作者": "叶庭云", "发布时间": "2021-03-28 16:41:02", "内容": [{"ctype": "head", "data": "一、分析网页"}, {"ctype": "p", "data": " 电影信息在 ol class 为 grid_view 下的 li 标签里，获取到所有li标签的内容，然后遍历，从中提取出每一条电影的信息。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210204220013767.gif#pic_center"}, {"ctype": "p", "data": "翻页查看url变化规律："}, {"ctype": "code", "data": "第1页：https://movie.douban.com/top250?start=0&filter=\n第2页：https://movie.douban.com/top250?start=25&filter=\n第3页：https://movie.douban.com/top250?start=50&filter=\n第10页：https://movie.douban.com/top250?start=225&filter=\n"}, {"ctype": "p", "data": "start参数控制翻页，start=25 * (page - 1)"}, {"ctype": "p", "data": " 本文分别用正则表达式、BeautifulSoup、PyQuery、Xpath来解析提取数据，将豆瓣电影Top250信息保存到本地。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210205081357647.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5ZnVnb3lmYQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "二、正则表达式"}, {"ctype": "p", "data": "正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配，常用于数据清洗，也可以顺便用于爬虫，从网页源代码文本中匹配出我们想要的数据。"}, {"ctype": "p", "data": "re.findall"}, {"ctype": "p", "data": "示例如下："}, {"ctype": "code", "data": "import re\ntext = \"\"\"\n<div class=\"box picblock col3\" style=\"width:186px;height:264px\">\n<img src2=\"http://pic2.sc.chinaz.com/Files/pic/pic9/202007/apic26584_s.jpg\" 123nfsjgnalt=\"山水风景摄影图片\">\n<a target=\"_blank\" href=\"http://sc.chinaz.com/tupian/200509002684.htm\"\n<img src2=\"http://pic2.sc.chinaz.com/Files/pic/pic9/202007/apic26518_s.jpg\" enrberonbialt=\"山脉湖泊山水风景图片\">\n<a target=\"_blank\" href=\"http://sc.chinaz.com/tupian/200509002684.htm\"\n<img src2=\"http://pic2.sc.chinaz.com/Files/pic/pic9/202006/apic26029_s.jpg\" woenigoigniefnirneialt=\"旅游景点山水风景图片\">\n<a target=\"_blank\" href=\"http://sc.chinaz.com/tupian/200509002684.htm\"\n\"\"\"\n\npattern = re.compile(r'\\d+')  # 查找所有数字\nresult1 = pattern.findall('me 123 rich 456 money 1000000000000')\nprint(result1)\nimg_info = re.findall('<img src2=\"(.*?)\" .*alt=\"(.*?)\">', text)  # 匹配src2 alt里的内容\n\nfor src, alt in img_info:\n    print(src, alt)\n \n['123', '456', '1000000000000']\nhttp://pic2.sc.chinaz.com/Files/pic/pic9/202007/apic26584_s.jpg 山水风景摄影图片\nhttp://pic2.sc.chinaz.com/Files/pic/pic9/202007/apic26518_s.jpg 山脉湖泊山水风景图片\nhttp://pic2.sc.chinaz.com/Files/pic/pic9/202006/apic26029_s.jpg 旅游景点山水风景图片\n"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "# -*- coding: UTF-8 -*-\n\"\"\"\n@Author  ：叶庭云\n@公众号  ：修炼Python\n@CSDN    ：https://yetingyun.blog.csdn.net/\n\"\"\"\nimport requests\nimport re\nfrom pandas import DataFrame\nfrom fake_useragent import UserAgent\nimport logging\n\n# 日志输出的基本配置\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s')\n# 随机产生请求头\nua = UserAgent(verify_ssl=False, path='fake_useragent.json')\n\n\ndef random_ua():\n    headers = {\n        \"Accept-Encoding\": \"gzip\",\n        \"Connection\": \"keep-alive\",\n        \"User-Agent\": ua.random\n    }\n    return headers\n\n\ndef scrape_html(url):\n    resp = requests.get(url, headers=random_ua())\n    # print(resp.status_code, type(resp.status_code))\n    if resp.status_code == 200:\n        return resp.text\n    else:\n        logging.info('请求网页失败')\n\n\ndef get_data(page):\n    url = f\"https://movie.douban.com/top250?start={25 * page}&filter=\"\n    html_text = scrape_html(url)\n    # 电影名称  导演 主演\n    name = re.findall('<img width=\"100\" alt=\"(.*?)\" src=\".*\"', html_text)\n    director_actor = re.findall('(.*?)<br>', html_text)\n    director_actor = [item.strip() for item in director_actor]\n    # 上映时间  上映地区  电影类型信息   去除两端多余空格\n    info = re.findall('(.*)&nbsp;/&nbsp;(.*)&nbsp;/&nbsp;(.*)', html_text)\n    time_ = [x[0].strip() for x in info]\n    area = [x[1].strip() for x in info]\n    genres = [x[2].strip() for x in info]\n    # 评分  评分人数\n    rating_score = re.findall('<span class=\"rating_num\" property=\"v:average\">(.*)</span>', html_text)\n    rating_num = re.findall('<span>(.*?)人评价</span>', html_text)\n    # 一句话引言\n    quote = re.findall('<span class=\"inq\">(.*)</span>', html_text)\n    data = {'电影名': name, '导演和主演': director_actor,\n            '上映时间': time_, '上映地区': area, '电影类型': genres,\n            '评分': rating_score, '评价人数': rating_num, '引言': quote}\n    df = DataFrame(data)\n    if page == 0:\n        df.to_csv('movie_data2.csv', mode='a+', header=True, index=False)\n\n    else:\n        df.to_csv('movie_data2.csv', mode='a+', header=False, index=False)\n    logging.info(f'已爬取第{page + 1}页数据')\n\n\nif __name__ == '__main__':\n    for i in range(10):\n        get_data(i)\n\n"}, {"ctype": "p", "data": "结果如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210205083130691.gif#pic_center"}, {"ctype": "head", "data": "三、BeautifulSoup"}, {"ctype": "p", "data": "find() 与 find_all() 是 BeautifulSoup 对象的两个方法，它们可以匹配 html 的标签和属性，把 BeautifulSoup 对象里符合要求的数据都提取出来： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210205083259538.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5ZnVnb3lmYQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# -*- coding: UTF-8 -*-\n\"\"\"\n@Author  ：叶庭云\n@公众号  ：修炼Python\n@CSDN    ：https://yetingyun.blog.csdn.net/\n\"\"\"\nimport requests\nfrom bs4 import BeautifulSoup\nimport openpyxl\nfrom fake_useragent import UserAgent\nimport logging\n\n# 日志输出的基本配置\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s')\n# 随机产生请求头\nua = UserAgent(verify_ssl=False, path='fake_useragent.json')\nwb = openpyxl.Workbook()    # 创建工作簿对象\nsheet = wb.active           # 获取工作簿的活动表\nsheet.title = \"movie\"       # 工作簿重命名\nsheet.append([\"排名\", \"电影名\", \"导演和主演\", \"上映时间\", \"上映地区\", \"电影类型\", \"评分\", \"评价人数\", \"引言\"])\n\n\ndef random_ua():\n    headers = {\n        \"Accept-Encoding\": \"gzip\",\n        \"Connection\": \"keep-alive\",\n        \"User-Agent\": ua.random\n    }\n    return headers\n\n\ndef scrape_html(url):\n    resp = requests.get(url, headers=random_ua())\n    # print(resp.status_code, type(resp.status_code))\n    if resp.status_code == 200:\n        return resp.text\n    else:\n        logging.info('请求网页失败')\n\n\ndef get_data(page):\n    global rank\n    url = f\"https://movie.douban.com/top250?start={25 * page}&filter=\"\n    html_text = scrape_html(url)\n    soup = BeautifulSoup(html_text, 'html.parser')\n    lis = soup.find_all('div', class_='item')\n    for li in lis:\n        name = li.find('div', class_='hd').a.span.text\n        temp = li.find('div', class_='bd').p.text.strip().split('\\n')\n        director_actor = temp[0]\n        temp1 = temp[1].rsplit('/', 2)\n        time_, area, genres = [item.strip() for item in temp1]\n        quote = li.find('p', class_='quote')\n        # 有些电影信息没有一句话引言\n        if quote:\n            quote = quote.span.text\n        else:\n            quote = None\n        rating_score = li.find('span', class_='rating_num').text\n        rating_num = li.find('div', class_='star').find_all('span')[-1].text\n        sheet.append([rank, name, director_actor, time_, area, genres, rating_score, rating_num, quote])\n        logging.info([rank, name, director_actor, time_, area, genres, rating_score, rating_num, quote])\n        rank += 1\n\n\nif __name__ == '__main__':\n    rank = 1\n    for i in range(10):\n        get_data(i)\n    wb.save(filename='movie_info4.xlsx')\n"}, {"ctype": "p", "data": "结果如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210205083726534.gif#pic_center"}, {"ctype": "head", "data": "四、PyQuery"}, {"ctype": "p", "data": "在解析 HTML 文本的时候，首先需要将其初始化为一个 pyquery 对象。它的初始化方式有多种，比如直接传入字符串、传入 URL、传入文件名等等。"}, {"ctype": "code", "data": "from pyquery import PyQuery as pq\n\nhtml = '''\n<div>\n    <ul class=\"clearfix\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li><img src=\"http://pic.netbian.com/uploads/allimg/210107/215736-1610027856f6ef.jpg\"></li>\n        <li><img src=\"http://pic.netbian.com//uploads/allimg/190902/152344-1567409024af8c.jpg\"></li> \n    </ul>\n</div>\n'''\n\ndoc = pq(html)\nprint(doc('li'))\n"}, {"ctype": "p", "data": "结果如下："}, {"ctype": "code", "data": "<li class=\"item-0\">first item</li>\n<li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n<li><img src=\"http://pic.netbian.com/uploads/allimg/210107/215736-1610027856f6ef.jpg\"/></li>\n<li><img src=\"http://pic.netbian.com//uploads/allimg/190902/152344-1567409024af8c.jpg\"/></li>  \n"}, {"ctype": "p", "data": "首先引入 pyquery 这个对象，取别名为 pq，然后定义了一个长 HTML 字符串，并将其当作参数传递给 pyquery 类，这样就成功完成了初始化。接下来，将初始化的对象传入 CSS 选择器。在这个实例中，我们传入 li 节点，这样就可以选择所有的 li 节点。"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "# -*- coding: UTF-8 -*-\n\"\"\"\n@Author  ：叶庭云\n@公众号  ：修炼Python\n@CSDN    ：https://yetingyun.blog.csdn.net/\n\"\"\"\nimport requests\nfrom pyquery import PyQuery as pq\nimport openpyxl\nfrom fake_useragent import UserAgent\nimport logging\n\n# 日志输出的基本配置\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s')\n# 随机产生请求头\nua = UserAgent(verify_ssl=False, path='fake_useragent.json')\nwb = openpyxl.Workbook()    # 创建工作簿对象\nsheet = wb.active           # 获取工作簿的活动表\nsheet.title = \"movie\"       # 工作簿重命名\nsheet.append([\"排名\", \"电影名\", \"导演和主演\", \"上映时间\", \"上映地区\", \"电影类型\", \"评分\", \"评价人数\", \"引言\"])\n\n\ndef random_ua():\n    headers = {\n        \"Accept-Encoding\": \"gzip\",\n        \"Connection\": \"keep-alive\",\n        \"User-Agent\": ua.random\n    }\n    return headers\n\n\ndef scrape_html(url):\n    resp = requests.get(url, headers=random_ua())\n    # print(resp.status_code, type(resp.status_code))\n    if resp.status_code == 200:\n        return resp.text\n    else:\n        logging.info('请求网页失败')\n\n\ndef get_data(page):\n    global rank\n    url = f\"https://movie.douban.com/top250?start={25 * page}&filter=\"\n    html_text = scrape_html(url)\n    doc = pq(html_text)\n    lis = doc('.grid_view li')\n    for li in lis.items():\n        name = li('.hd a span:first-child').text()\n        temp = li('.bd p:first-child').text().split('\\n')\n        director_actor = temp[0]\n        temp1 = temp[1].rsplit('/', 2)\n        time_, area, genres = [item.strip() for item in temp1]\n        quote = li('.quote span').text()\n        rating_score = li('.star .rating_num').text()\n        rating_num = li('.star span:last-child').text()\n        sheet.append([rank, name, director_actor, time_, area, genres, rating_score, rating_num, quote])\n        logging.info([rank, name, director_actor, time_, area, genres, rating_score, rating_num, quote])\n        rank += 1\n\n\nif __name__ == '__main__':\n    rank = 1\n    for i in range(10):\n        get_data(i)\n    wb.save(filename='movie_info3.xlsx')\n\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210205084125638.gif#pic_center"}, {"ctype": "head", "data": "五、Xpath"}, {"ctype": "p", "data": "Xpath 是一个非常好用的解析方法，同时也作为爬虫学习的基础，在后面的 selenium 以及 scrapy 框架中都会涉及到这部分知识。"}, {"ctype": "p", "data": "首先我们使用 lxml 的 etree 库，然后利用 etree.HTML 初始化，然后我们将其打印出来。 其中，这里体现了 lxml 的一个非常实用的功能就是自动修正 html 代码，大家应该注意到了，最后一个 li 标签，其实我把尾标签删掉了，是不闭合的。不过，lxml 因为继承了 libxml2 的特性，具有自动修正 HTML 代码的功能，通过 xpath 表达式可以提取标签里的内容，如下所示："}, {"ctype": "code", "data": "from lxml import etree\ntext = '''\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n     </ul>\n </div>\n'''\nhtml = etree.HTML(text)\nresult = etree.tostring(html)\nresult1 = html.xpath('//li/@class')   # xpath表达式\nprint(result1)\nprint(result)\n"}, {"ctype": "code", "data": "['item-0', 'item-1', 'item-inactive', 'item-1', 'item-0']\n<html><body>\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n</div>\n</body></html>\n"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "# -*- coding: UTF-8 -*-\n\"\"\"\n@Author  ：叶庭云\n@公众号  ：修炼Python\n@CSDN    ：https://yetingyun.blog.csdn.net/\n\"\"\"\nimport requests\nfrom lxml import etree\nimport openpyxl\nfrom fake_useragent import UserAgent\nimport logging\n\n# 日志输出的基本配置\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s')\n# 随机产生请求头\nua = UserAgent(verify_ssl=False, path='fake_useragent.json')\nwb = openpyxl.Workbook()    # 创建工作簿对象\nsheet = wb.active           # 获取工作簿的活动表\nsheet.title = \"movie\"       # 工作簿重命名\nsheet.append([\"排名\", \"电影名\", \"导演和主演\", \"上映时间\", \"上映地区\", \"电影类型\", \"评分\", \"评价人数\", \"引言\"])\n\n\ndef random_ua():\n    headers = {\n        \"Accept-Encoding\": \"gzip\",\n        \"Connection\": \"keep-alive\",\n        \"User-Agent\": ua.random\n    }\n    return headers\n\n\ndef scrape_html(url):\n    resp = requests.get(url, headers=random_ua())\n    # print(resp.status_code, type(resp.status_code))\n    if resp.status_code == 200:\n        return resp.text\n    else:\n        logging.info('请求网页失败')\n\n\ndef get_data(page):\n    global rank\n    url = f\"https://movie.douban.com/top250?start={25 * page}&filter=\"\n    html = etree.HTML(scrape_html(url))\n    lis = html.xpath('//ol[@class=\"grid_view\"]/li')\n    # 每个li标签里有每部电影的基本信息\n    for li in lis:\n        name = li.xpath('.//div[@class=\"hd\"]/a/span[1]/text()')[0]\n        director_actor = li.xpath('.//div[@class=\"bd\"]/p/text()')[0].strip()\n        info = li.xpath('.//div[@class=\"bd\"]/p/text()')[1].strip()\n        # 按\"/\"切割成列表\n        _info = info.split(\"/\")\n        # 得到 上映时间  上映地区  电影类型信息   去除两端多余空格\n        time_, area, genres = _info[0].strip(), _info[1].strip(), _info[2].strip()\n        # print(time, area, genres)\n        rating_score = li.xpath('.//div[@class=\"star\"]/span[2]/text()')[0]\n        rating_num = li.xpath('.//div[@class=\"star\"]/span[4]/text()')[0]\n        quote = li.xpath('.//p[@class=\"quote\"]/span/text()')\n        # 有些电影信息没有一句话引言  加条件判断  防止报错\n        if len(quote) == 0:\n            quote = None\n        else:\n            quote = quote[0]\n        sheet.append([rank, name, director_actor, time_, area, genres, rating_score, rating_num, quote])\n        logging.info([rank, name, director_actor, time_, area, genres, rating_score, rating_num, quote])\n        rank += 1\n\n\nif __name__ == '__main__':\n    rank = 1\n    for i in range(10):\n        get_data(i)\n    wb.save(filename='movie_info1.xlsx')\n\n"}, {"ctype": "p", "data": "结果如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210205090621566.gif#pic_center"}, {"ctype": "head", "data": "六、总结"}, {"ctype": "p", "data": "对于爬取网页结构简单的 Web 页面，有些代码是可以通用的，如下所示："}, {"ctype": "code", "data": "from fake_useragent import UserAgent\n\n# 随机产生请求头\nua = UserAgent(verify_ssl=False, path='fake_useragent.json')\n\ndef random_ua():\n    headers = {\n        \"Accept-Encoding\": \"gzip\",\n        \"User-Agent\": ua.random\n    }\n    return headers\n"}, {"ctype": "p", "data": "伪装请求头，并可以随机切换，封装为函数，便于复用。"}, {"ctype": "code", "data": "def scrape_html(url):\n    resp = requests.get(url, headers=random_ua())\n    # print(resp.status_code, type(resp.status_code))\n    # print(resp.text)\n    if resp.status_code == 200:\n        return resp.text\n    else:\n        logging.info('请求网页失败')\n"}, {"ctype": "p", "data": "请求网页，状态码为 200 说明正常请求，返回网页源代码文本。"}], "cate": "Python"}
{"题目": "Tensorflow LSTM选择Relu激活函数与权重初始化、梯度修剪解决梯度爆炸问题实践", "作者": "肖永威", "发布时间": "2021-03-27 16:14:31", "内容": [{"ctype": "head", "data": "1. 梯度爆炸问题"}, {"ctype": "p", "data": "我最近研究多层LSTM在时序业务场景中的应用，如果基于Keras框架实现的时候，激活函数使用Relu，训练速度比较快而且效果也好，但是基于Tensorflow框架实现的时候，如果把激活函数由默认tanh换成Relu时，训练过程中出现了如下问题：  深度学习模型训练中途出现cost突然变大，或许几经周折降下来，不过大多数还是暴涨，出现了“nan”。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326213321629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW95dw==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "cost:  0.00532\n......\ncost:  1097.2125\ncost:  nan\ncost:  nan\n"}, {"ctype": "p", "data": "其中，激活函数设置如下："}, {"ctype": "code", "data": "        #更换默认tanh激活函数\n        cell_list = tf.contrib.rnn.BasicLSTMCell(self.cell_size, \n                                                 forget_bias=1.0, \n                                                 state_is_tuple=True, \n                                                 activation=tf.nn.relu) \n"}, {"ctype": "p", "data": "模型初始化权重："}, {"ctype": "code", "data": "    def _weight_variable(self, shape, name='weights'):\n        initializer = tf.random_normal_initializer(mean=0., stddev=1.0,)\n        return tf.get_variable(shape=shape, initializer=initializer, name=name)\n\n    def _bias_variable(self, shape, name='biases'):\n        initializer = tf.constant_initializer(0.1)\n        return tf.get_variable(name=name, shape=shape, initializer=initializer)\n"}, {"ctype": "p", "data": "其实，出现这种问题是深度学习训练中常见的典型梯度爆炸问题。"}, {"ctype": "head", "data": "2. 解决方案"}, {"ctype": "head", "data": "2.1. 换回tanh激活函数？"}, {"ctype": "p", "data": "本实践案例中，目标是采用的激活函数是Relu。"}, {"ctype": "p", "data": "\n     \n      \n       \n        \n         r\n        \n        \n         e\n        \n        \n         l\n        \n        \n         u\n        \n        \n         (\n        \n        \n         x\n        \n        \n         )\n        \n        \n         =\n        \n        \n         m\n        \n        \n         a\n        \n        \n         x\n        \n        \n         (\n        \n        \n         x\n        \n        \n         ,\n        \n        \n         0\n        \n        \n         )\n        \n        \n         =\n        \n        \n         \n          {\n         \n         \n          \n           \n            \n             \n              \n               x\n              \n              \n               ,\n              \n             \n            \n           \n           \n            \n             \n              \n               x\n              \n              \n               ⩾\n              \n              \n               0\n              \n             \n            \n           \n          \n          \n           \n            \n             \n              0\n             \n            \n           \n           \n            \n             \n              \n               x\n              \n              \n               <\n              \n              \n               0\n              \n             \n            \n           \n          \n         \n        \n       \n       \n        relu(x)=max(x,0)= \\left\\{\\begin{matrix} x, & x\\geqslant 0\\\\ 0 & x<0 \\end{matrix}\\right.\n       \n      \n     relu(x)=max(x,0)={x,0​x⩾0x<0​"}, {"ctype": "p", "data": "其图形效果如下所示。  使用Relu函数有什么优势？"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210321143538593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW95dw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "Relu的缺点："}, {"ctype": "p", "data": "在神经网络中，隐含层的激活函数，最好选择ReLU。而在LSTM中，默认激活函数Tanh，如果解决不了梯度爆炸问题，只能换回tanh激活函数。"}, {"ctype": "p", "data": "\n     \n      \n       \n        \n         t\n        \n        \n         a\n        \n        \n         n\n        \n        \n         h\n        \n        \n         (\n        \n        \n         x\n        \n        \n         )\n        \n        \n         =\n        \n        \n         \n          2\n         \n         \n          \n           1\n          \n          \n           +\n          \n          \n           \n            e\n           \n           \n            \n             −\n            \n            \n             2\n            \n            \n             x\n            \n           \n          \n         \n        \n        \n         −\n        \n        \n         1\n        \n       \n       \n        tanh(x) = \\frac{2} {1+e^{-2x}}-1\n       \n      \n     tanh(x)=1+e−2x2​−1"}, {"ctype": "p", "data": "其图形效果如下图所示。  sigmoid和tanh："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210321135054941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW95dw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "relu时比tanh收敛更快，且准确率更高"}, {"ctype": "head", "data": "2.2. 优化初始化权重"}, {"ctype": "p", "data": "我们知道神经网络基本构成可以描述为由线性函数\n    \n     \n      \n       \n        f\n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        =\n       \n       \n        w\n       \n       \n        x\n       \n       \n        +\n       \n       \n        b\n       \n      \n      \n       f(x)=wx+b\n      \n     \n    f(x)=wx+b构成，在累加\n    \n     \n      \n       \n        \n         ∑\n        \n        \n         i\n        \n        \n         m\n        \n       \n       \n        \n         w\n        \n        \n         i\n        \n       \n       \n        \n         x\n        \n        \n         i\n        \n       \n       \n        +\n       \n       \n        b\n       \n      \n      \n       \\sum_{i}^{m}w_{i}x_{i} + b\n      \n     \n    ∑im​wi​xi​+b过程中，如果权重’weights’过大，可能影响loss过大，进而引起梯度爆炸的问题。"}, {"ctype": "p", "data": "根据输入、输出的特点（本案例归一化输入为0~1之间），设置参数如下所示："}, {"ctype": "code", "data": "    def _weight_variable(self, shape, name='weights'):\n        initializer = tf.random_normal_initializer(mean=0., stddev=0.1,)\n        return tf.get_variable(shape=shape, initializer=initializer, name=name)\n\n    def _bias_variable(self, shape, name='biases'):\n        initializer = tf.constant_initializer(0.01)\n        return tf.get_variable(name=name, shape=shape, initializer=initializer)\n"}, {"ctype": "p", "data": "通过设置小些的标准差和偏置，梯度爆炸发生减少，但是不能杜绝。"}, {"ctype": "p", "data": "一个较小的标准差，代表这些数值较接近平均值，一般来说标准差较小为好，这样代表比较稳定。下面模拟标准差对神经元计算的影响。"}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nimport math\nimport numpy as np\n\ndef testInitWeight():\n    x = np.random.uniform(0,1,30*25)\n    t = 10000\n    z_lst = np.empty(t)\n    mu = [0,0,0]\n    sigma = [1.0,0.1,0.01]    \n    for j in range(3):\n        for i in range(t):\n            w = np.random.normal(mu[j], sigma[j], 30*25)         \n            b = 0\n            # z为加权和\n            z = np.sum(x * w) + b           \n            z_lst[i] = z                            \n            \n        print ('z 均值：', np.mean(z_lst))\n        print ('z 方差：', np.var(z_lst))   \n        plt.subplot(1,3,(j+1))\n        plt.grid()   \n        \n        plt.hist(z_lst, bins=10)  \n    \n    plt.show()            \n\nif __name__ == '__main__':\n    testInitWeight()\n"}, {"ctype": "p", "data": "通过实践，标准差设置小些，如上所示“stddev=0.1”，训练过程中较稳定，减少了梯度爆炸的发生。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322132027995.png"}, {"ctype": "head", "data": "2.3. 梯度修剪"}, {"ctype": "p", "data": "不过本文的重点在于在tensorflow中解决梯度爆炸问题，原理很简单就是梯度修剪。把大于1的导数修剪为1。"}, {"ctype": "p", "data": "Tensorflow梯度修剪函数为tf.clip_by_value(A, min, max)： 输入一个张量A，把A中的每一个元素的值都压缩在min和max之间。小于min的让它等于min，大于max的元素的值等于max。"}, {"ctype": "code", "data": "    def compute_cost(self):\n        losses = tf.contrib.legacy_seq2seq.sequence_loss_by_example(\n            [tf.reshape(self.pred, [-1], name='reshape_pred')], \n            [tf.reshape(self.ys, [-1], name='reshape_target')],       \n            [tf.ones([self.batch_size * self.n_steps*self.output_size], dtype=tf.float32)], \n            average_across_timesteps=True,\n            softmax_loss_function=self.ms_error,\n            name='losses'\n        )\n        \n        with tf.name_scope('average_cost'):\n            self.cost = tf.div(\n                tf.reduce_sum(losses, name='losses_sum'),\n                self.batch_size_,\n                name='average_cost')\n            tf.summary.scalar('cost', self.cost)\n    \n    def train_optimizer(self):   \n        # 使用Adam梯度下降\n        optimizer = tf.train.AdamOptimizer(LR)     \n        # 裁剪一下Gradient输出，最后的gradient都在[-1, 1]的范围内\n        # 计算导数，cost为损失函数\n        gradients = optimizer.compute_gradients(self.cost)\n        # 限定导数值域-1到1\n        capped_gradients = [(tf.clip_by_value(grad, -1., 1.), var) for grad, var in gradients if grad is not None]\n        # 将处理后的导数继续应用到LSTM算法中\n        self.train_op = optimizer.apply_gradients(capped_gradients)\n"}, {"ctype": "p", "data": "默认值为 clipnorm=1.0 、clipvalue=0.5。"}, {"ctype": "head", "data": "3. 原理说明"}, {"ctype": "head", "data": "3.1. 什么是梯度爆炸"}, {"ctype": "p", "data": "梯度爆炸指神经网络训练过程中大的误差梯度不断累积，导致模型权重出现重大更新。会造成模型不稳定，无法利用训练数据学习。"}, {"ctype": "p", "data": "误差梯度是神经网络训练过程中计算的方向和量的大小，用于以正确的方向和以合适的量更新网络权重。 在深度网络或RNN中，更新过程中可能会累积误差梯度，并最终累积成非常大的梯度。这会导致网络权重的大幅更新，从而导致网络不稳定。在极端情况下，权重的值可能会大到溢出导致出现NaN值。"}, {"ctype": "p", "data": "网络层之间的梯度（值大于 1.0）重复相乘导致的指数级增长会产生梯度爆炸。 梯度爆炸引发的问题 在深度多层感知机网络中，梯度爆炸会引起网络不稳定，最好的结果是无法从训练数据中学习，而最坏的结果是出现无法再更新的 NaN 权重值。"}, {"ctype": "p", "data": "如何确定是否出现梯度爆炸？"}, {"ctype": "p", "data": "本质是梯度传递的链式法则所导致的矩阵高次幂（反向传播会逐层对函数求偏导相乘）。"}, {"ctype": "p", "data": "RNN结果出现nan值？梯度爆炸，导致结果不收敛。都是梯度太大惹的祸，所以可以通过减小学习率（梯度变化直接变小）、减小batch size（累积梯度更小）、 features规格化（避免突然来一个大的输入）。"}, {"ctype": "head", "data": "3.2. 链式法则"}, {"ctype": "p", "data": "链式法则应用广泛，神经网络中的反向传播算法就是链式法则为基础。微积分中的链式法则(为了不与概率中的链式法则相混) 用于计算复合函数的导数。反向传播是一种计算链式法则的算法，使用高效的特定运算顺序。"}, {"ctype": "p", "data": "设\n    \n     \n      \n       \n        x\n       \n      \n      \n       x\n      \n     \n    x是实数，\n    \n     \n      \n       \n        f\n       \n      \n      \n       f\n      \n     \n    f和\n    \n     \n      \n       \n        g\n       \n      \n      \n       g\n      \n     \n    g是从实数映射到实数的函数。假设\n    \n     \n      \n       \n        y\n       \n       \n        =\n       \n       \n        g\n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n      \n      \n       y=g(x)\n      \n     \n    y=g(x)，并且\n    \n     \n      \n       \n        z\n       \n       \n        =\n       \n       \n        f\n       \n       \n        (\n       \n       \n        g\n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        )\n       \n       \n        =\n       \n       \n        f\n       \n       \n        (\n       \n       \n        y\n       \n       \n        )\n       \n      \n      \n       z=f(g(x))=f(y)\n      \n     \n    z=f(g(x))=f(y)。那么链式法则是说："}, {"ctype": "p", "data": "\n    \n     \n      \n       \n        \n         \n          d\n         \n         \n          z\n         \n        \n        \n         \n          d\n         \n         \n          x\n         \n        \n       \n       \n        =\n       \n       \n        \n         \n          d\n         \n         \n          z\n         \n        \n        \n         \n          d\n         \n         \n          y\n         \n        \n       \n       \n        \n         \n          d\n         \n         \n          y\n         \n        \n        \n         \n          d\n         \n         \n          x\n         \n        \n       \n      \n      \n       \\frac {dz}{dx}=\\frac {dz}{dy}\\frac {dy}{dx}\n      \n     \n    dxdz​=dydz​dxdy​"}, {"ctype": "p", "data": "或另种形式："}, {"ctype": "p", "data": "\n    \n     \n      \n       \n        \n         \n          d\n         \n         \n          z\n         \n        \n        \n         \n          d\n         \n         \n          x\n         \n        \n       \n       \n        =\n       \n       \n        \n         f\n        \n        \n         ′\n        \n       \n       \n        (\n       \n       \n        g\n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        )\n       \n       \n        \n         g\n        \n        \n         ′\n        \n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n      \n      \n       \\frac {dz}{dx}=f'(g(x))g'(x)\n      \n     \n    dxdz​=f′(g(x))g′(x)"}, {"ctype": "p", "data": "链式法则就是\n    \n     \n      \n       \n        f\n       \n      \n      \n       f\n      \n     \n    f和\n    \n     \n      \n       \n        g\n       \n      \n      \n       g\n      \n     \n    g两个函数组合起来的复合函数，导数等于里面函数代入外函数值的导乘以里面函数之导数。"}, {"ctype": "p", "data": "Hinton在它的IRNN论文里面（arxiv：[1504.00941] A Simple Way to Initialize Recurrent Networks of Rectified Linear Units）是很明确的提到的:"}, {"ctype": "p", "data": "也就是说在RNN中直接把激活函数换成ReLU会导致非常大的输出值。"}, {"ctype": "p", "data": "首先，由于前向传播时计算的结果会变成多个W连乘："}, {"ctype": "p", "data": "假设采用ReLU替代传统RNN中的激活函数，并且假设ReLU函数一直处于激活区域（即输入大于0），"}, {"ctype": "p", "data": "则有： \n    \n     \n      \n       \n        f\n       \n       \n        (\n       \n       \n        x\n       \n       \n        )\n       \n       \n        =\n       \n       \n        x\n       \n      \n      \n       f(x)=x\n      \n     \n    f(x)=x； \n    \n     \n      \n       \n        n\n       \n       \n        e\n       \n       \n        \n         t\n        \n        \n         t\n        \n       \n       \n        =\n       \n       \n        U\n       \n       \n        \n         x\n        \n        \n         t\n        \n       \n       \n        +\n       \n       \n        W\n       \n       \n        (\n       \n       \n        U\n       \n       \n        \n         x\n        \n        \n         \n          t\n         \n         \n          −\n         \n         \n          1\n         \n        \n       \n       \n        +\n       \n       \n        W\n       \n       \n        \n         h\n        \n        \n         \n          t\n         \n         \n          −\n         \n         \n          2\n         \n        \n       \n       \n        )\n       \n      \n      \n       net_{t} = Ux_{t} + W(Ux_{t-1}+Wh_{t-2})\n      \n     \n    nett​=Uxt​+W(Uxt−1​+Wht−2​)"}, {"ctype": "p", "data": "将其继续展开，\n    \n     \n      \n       \n        n\n       \n       \n        e\n       \n       \n        \n         t\n        \n        \n         t\n        \n       \n      \n      \n       net_{t}\n      \n     \n    nett​中最终将包含t个W连成。如果W不是单位举证，\n    \n     \n      \n       \n        n\n       \n       \n        e\n       \n       \n        \n         t\n        \n        \n         t\n        \n       \n      \n      \n       net_{t}\n      \n     \n    nett​则的结果最终将趋于0或者无穷大，引发严重的数值问题。"}, {"ctype": "p", "data": "同时，假设采用ReLU激活函数，且一开始所有的神经元都处于激活状态，在梯度传递了n层之后，有："}, {"ctype": "p", "data": "\n    \n     \n      \n       \n        \n         \n          n\n         \n         \n          e\n         \n         \n          \n           t\n          \n          \n           t\n          \n         \n        \n        \n         \n          n\n         \n         \n          e\n         \n         \n          \n           t\n          \n          \n           \n            t\n           \n           \n            1\n           \n          \n         \n        \n       \n       \n        =\n       \n       \n        \n         W\n        \n        \n         n\n        \n       \n      \n      \n       \\frac{net_{t}}{net_{t1}}=W^{n}\n      \n     \n    nett1​nett​​=Wn"}, {"ctype": "p", "data": "可以看到，只要W不是单位矩阵，梯度还是会出现消失或者爆炸的问题。"}, {"ctype": "p", "data": "综上所述，当采用ReLU作为激活函数时，只有当W的取值在单位矩阵附近的时候，才能取得比较好的效果。"}, {"ctype": "head", "data": "3.3. 梯度修剪原理"}, {"ctype": "p", "data": "基于梯度修剪原理解决梯度爆炸的方法，是在一个只有一个隐藏节点的网络中，损失函数和权值w偏置b构成error surface，就好比其中有一堵墙，如下所示。  损失函数每次迭代都是每次一小步，但是当遇到这堵墙时，在墙上的某点计算梯度，梯度会瞬间增大，指向某处不理想的位置。如果我们使用缩放，可以把误导控制在可接受范围内，如虚线箭头所示。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327103317453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW95dw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.4. 权重正则化"}, {"ctype": "p", "data": "目标函数 = 损失函数 + 正则化项。通过目标函数中的正则化项，“惩罚”过大的权重，从而使权重不会过大，进而缓解梯度爆炸的问题。"}, {"ctype": "p", "data": "什么是正则化(regularization)"}, {"ctype": "p", "data": "​ 如果用一句话解释：正则化就是通过增加权重惩罚(penalty)项到损失函数，让网络倾向于学习小一点的权重，从而达到抑制过拟合，增加模型泛化能力的效果。常见的正则化方法有\n    \n     \n      \n       \n        L\n       \n       \n        1\n       \n      \n      \n       L1\n      \n     \n    L1正则化，\n    \n     \n      \n       \n        L\n       \n       \n        2\n       \n      \n      \n       L2\n      \n     \n    L2正则化和Dropout正则化等。其中，\n    \n     \n      \n       \n        L\n       \n       \n        2\n       \n      \n      \n       L2\n      \n     \n    L2正则化的公式："}, {"ctype": "p", "data": "\n    \n     \n      \n       \n        L\n       \n       \n        =\n       \n       \n        \n         L\n        \n        \n         0\n        \n       \n       \n        +\n       \n       \n        \n         λ\n        \n        \n         2\n        \n       \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         n\n        \n       \n       \n        (\n       \n       \n        \n         w\n        \n        \n         2\n        \n       \n       \n        )\n       \n      \n      \n       L = L_{0} + \\frac{ \\lambda}{2} \\sum_{i=1}^{n}(w^{2})\n      \n     \n    L=L0​+2λ​∑i=1n​(w2) ​ 式中\n    \n     \n      \n       \n        \n         L\n        \n        \n         0\n        \n       \n      \n      \n       L_{0}\n      \n     \n    L0​是原始代价损失函数，\n    \n     \n      \n       \n        \n         λ\n        \n        \n         2\n        \n       \n       \n        \n         ∑\n        \n        \n         \n          i\n         \n         \n          =\n         \n         \n          1\n         \n        \n        \n         n\n        \n       \n       \n        (\n       \n       \n        \n         w\n        \n        \n         2\n        \n       \n       \n        )\n       \n      \n      \n       \\frac{ \\lambda}{2} \\sum_{i=1}^{n}(w^{2})\n      \n     \n    2λ​∑i=1n​(w2)是\n    \n     \n      \n       \n        L\n       \n       \n        2\n       \n      \n      \n       L2\n      \n     \n    L2正则化损失函数， 其中\n    \n     \n      \n       \n        λ\n       \n      \n      \n       \\lambda\n      \n     \n    λ是权重因子，\n    \n     \n      \n       \n        w\n       \n      \n      \n       w\n      \n     \n    w为权重。"}, {"ctype": "p", "data": "在tensorflow 中，计算图(graph)通过集合(collection)来管理包括张量(tensor)、变量(variable)、资源："}, {"ctype": "head", "data": "4. 小结"}, {"ctype": "p", "data": "通常在使用LSTM组成的神经网络层数比较少的时候，一般默认用其tanh函数作为激活函数，比Relu要好很多。"}, {"ctype": "p", "data": "近些年来，在卷机神经网络中使用了Relu函数，发现解决了深度神经网络梯度消失的问题，在LSTM中，随着LSTM组成的网络加深，再继续使用tanh函数，就存在了梯度消失的的风险，导致一直徘徊在一个点无法搜索最优解，这种情况下，可以采用Relu函数进行调整，注意学习率需要变地更小一点防止进入死神经元。"}, {"ctype": "p", "data": "为了解决基于Tensorflow多层LSTM模型中激活函数采用Relu出现梯度爆炸的问题，采用梯度修剪为核心的解决方案，并在神经网络及输入数据的参数权重设置为正态分布，std=0.1，减缓梯度爆炸发生。  在训练方法也很重要，选取合适的batch、学习率也是解决梯度爆炸问题的入手点。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327160716315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW95dw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "参考： 《深度学习–解决梯度爆炸方法（含TensorFlow代码）》 CSDN博客， 超屌的温jay ，2018年6月 《激活函数 sigmoid、tanh、relu》 简书 ， SpikeKing ，2019年1月 《Tensorflow LSTM实现多维输入输出预测实践详解》 CSDN博客 ，肖永威 ，2021年3月 《基于tensorflow的正则化实现》 简书 ， AlexChung16 ，2020年5月"}], "cate": "Python"}
{"题目": "那些年我与Anaconda的相爱相杀", "作者": "时空摆渡者", "发布时间": "2021-03-28 20:09:07", "内容": [{"ctype": "head", "data": "1.配置环境变量"}, {"ctype": "p", "data": "一定要手动配置环境变量，不要自动配置 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322212013884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMTQyNDU2MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.启动Anaconda Navigator"}, {"ctype": "p", "data": "在开始-Anaconda-Anaconda Navigator。打不开找了一堆资料后，尝试后也没打开，也正常，对于这种集成度很高的软件安装肯定不会很顺利。同样的一个问题发生可能是由不同的细微原因引起的，有的很简单，有的很复杂。所以我们一定要去发现自己的错误原因。那么去cmd去运行试试吧 首先找到anaconda-navigator.exe 位于F:\\Anaconda\\pkgs\\anaconda-navigator-1.10.0-py38_0\\Scripts> 当然盘符要换成你自己的。这里推荐Everything这款搜索工具，速度很快。 cmd运行时错误如下"}, {"ctype": "code", "data": "F:\\Anaconda\\pkgs\\anaconda-navigator-1.10.0-py38_0\\Scripts>anaconda-navigator.exeUnable to create process using 'F:\\Anaconda\\pkgs\\anaconda-navigator-1.10.0-py38_0\\python.exe F:\\Anaconda\\pkgs\\anaconda-navigator-1.10.0-py38_0\\Scripts\\anaconda-navigator-script.py\n"}, {"ctype": "p", "data": "阅读后发现，开启的实质应该是要用python去运行一个py脚本从而创建一个进程，但我发现我的F:\\Anaconda\\pkgs\\anaconda-navigator-1.10.0-py38_0\\下没有python.exe。这个是在安装根目录下有的。"}, {"ctype": "head", "data": "解决方法"}, {"ctype": "p", "data": "1.使用自己原有的python运行启动脚本"}, {"ctype": "code", "data": "python F:\\Anaconda\\pkgs\\anaconda-navigator-1.10.0-py38_0\\Scripts\\anaconda-navigator-script.py\n"}, {"ctype": "p", "data": "成功开启了！！！ 2. 将anaconda目录下的python(anaconda会自带一个python)复制到anaconda-navigator-script.py的上级目录，运行继续报新错误 This application failed to start because it could not find or load the Qt platform plugin “windows” "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328193957238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMTQyNDU2MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "起因思考"}, {"ctype": "p", "data": "这个报错是程序反馈的，说明程序默认在此目录下寻找，但确实目录下没有"}, {"ctype": "p", "data": "安装Anaconda时漏选或错选了某个功能已有python时，安装时不会在该目录下安装，转到其他目录安装，比如安装的根目录（我现在就是）玄学"}, {"ctype": "head", "data": "3.增加Anaconda中国镜像"}, {"ctype": "p", "data": "在Anaconda prompt中操作："}, {"ctype": "code", "data": "conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\n"}, {"ctype": "p", "data": "最后一条指令是，设置搜索时显示通道地址 查看通道"}, {"ctype": "code", "data": "conda config --show channels  \n- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  \n- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  \n- defaults\n"}, {"ctype": "p", "data": "增加镜像应该是为了下载新资源包的速度更快（虽然anaconda的集成度已经很高了）"}, {"ctype": "head", "data": "安装新环境"}, {"ctype": "p", "data": "conda create --name python3.8.5 python=3.8.5 激活 conda activate python3.8.5 删除 conda deactivate 最后，我们可以通过conda info -e命令查看已有的环境。 通过conda remove -n env_name --all来删除指定的环境（如果不添–all参数，而是指明某个库名，则是删除该库）。"}, {"ctype": "head", "data": "4.启动jupyter notebook"}, {"ctype": "p", "data": "今天最主要的目的就是使用振峰哥哥推荐的 jupyter notebook 在新环境中输入jupyter notebook 或者在开始菜单直接点击Jupyter notebook  当然会报错 找度娘——然后在命令行输入以下命令"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328194339775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMTQyNDU2MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "pip uninstall jupyter \npip install jupyter \npip install --force-reinstall --upgrade pyzmq`\n"}, {"ctype": "p", "data": "再次运行 jupyter notebook，成功开启（真实过程是，第一次打开后发现不能运行，一直有Kernel Error） 尝试更新conda"}, {"ctype": "code", "data": "conda update conda\n"}, {"ctype": "head", "data": "DLL load failed while importing win32api: %1 不是有效的 Win32 应用程序"}, {"ctype": "p", "data": "解决方案："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328194855784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMTQyNDU2MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "随后又一直报找不到‘云云’错误，没办法；ctrl +c 再见了。之后我又尝试了一下直接打开jupyter nootbook，奇迹发生了，打开了，也不报Kernel Error错误了（之前打开要不是闪退没反应就是打开后不能运行代码，一直报错）（中间还经历了若干次删除重新安装换镜像重新安装，最后应该是用的清华镜像站的anaconda） 解决jupyter nootbook打不开的问题"}, {"ctype": "head", "data": "指定端口启动"}, {"ctype": "p", "data": "如果你想自定义端口号来启动"}, {"ctype": "p", "data": "Jupyter Notebook，可以在终端中输入以下命令："}, {"ctype": "code", "data": "jupyter notebook --port <port_number>\n"}, {"ctype": "p", "data": "如果你同时启动了多个Jupyter Notebook，由于默认端口“8888”被占用，因此地址栏中的数字将从“8888”起，每多启动一个Jupyter Notebook数字就加1，如“8889”、“8890”……"}, {"ctype": "p", "data": "如果你只是想启动Jupyter Notebook的服务器但不打算立刻进入到主页面，那么就无需立刻启动浏览器。在终端中输入："}, {"ctype": "code", "data": "jupyter notebook --no-browser\n"}, {"ctype": "head", "data": "更换notebook启动目录"}, {"ctype": "p", "data": "Windows下jupyter notebook默认的启动路径就是当前cmd启动jupyter 的路径：这个路径一般是c盘下。"}, {"ctype": "p", "data": "更换步骤"}, {"ctype": "p", "data": "在Anaconda PowerShell Prompt或cmd的Anaconda的安装目录下输入"}, {"ctype": "code", "data": " jupyter notebook --generate-config\n"}, {"ctype": "p", "data": " 进入该目录下，打开 jupyter_notebook_config.py 文件，找到"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328200118216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMTQyNDU2MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": " ## The directory to use for notebooks and kernels.\n #c.NotebookApp.notebook_dir = ''\n"}, {"ctype": "p", "data": "在c.NotebookApp.notebook_dir = 填自己想要作为启动路径的路径"}, {"ctype": "head", "data": "库操作"}, {"ctype": "p", "data": "以下命令均在Anaconda Prompt环境中使用"}, {"ctype": "p", "data": "查询已有库 conda list安装新库 conda install 库名 例如 conda install pandas更新指定的库 conda update 库名升级所有的库 conda update --all如果相关软件、插件的版本过低，可以利用下面方法进行升级，即 升级conda插件：conda update conda 升级anaconda：conda update anaconda"}, {"ctype": "p", "data": "参考博客"}], "cate": "Python"}
{"题目": "数据分析  第七讲 pandas练习 数据的合并、分组聚合、时间序列、pandas绘图", "作者": "yangyusir", "发布时间": "2021-03-27 15:20:11", "内容": [{"ctype": "head", "data": "数据分析 第七讲 pandas练习 数据的合并和分组聚合"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323213307607.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "一、pandas-DataFrame"}, {"ctype": "head", "data": "练习1"}, {"ctype": "head", "data": "对于这一组电影数据，如果我们想runtime(电影时长)的分布情况，应该如何呈现数据？"}, {"ctype": "p", "data": "数据分析"}, {"ctype": "code", "data": "# 对于这一组电影数据，如果我们想runtime(电影时长)的分布情况，应该如何呈现数据？\n\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport matplotlib\nfont = {\n'family':'SimHei',\n'weight':'bold',\n'size':12\n}\nmatplotlib.rc(\"font\", **font)\nfile_path = './IMDB-Movie-Data.csv'\ndf = pd.read_csv(file_path)\n# print(df.info())\n'''\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1000 entries, 0 to 999\nData columns (total 12 columns):\n #   Column              Non-Null Count  Dtype  \n---  ------              --------------  -----  \n 0   Rank                1000 non-null   int64  \n 1   Title               1000 non-null   object \n 2   Genre               1000 non-null   object \n 3   Description         1000 non-null   object \n 4   Director            1000 non-null   object \n 5   Actors              1000 non-null   object \n 6   Year                1000 non-null   int64  \n 7   Runtime (Minutes)   1000 non-null   int64  \n 8   Rating              1000 non-null   float64\n 9   Votes               1000 non-null   int64  \n 10  Revenue (Millions)  872 non-null    float64\n 11  Metascore           936 non-null    float64\ndtypes: float64(3), int64(4), object(5)\nmemory usage: 93.9+ KB\nNone\n'''\n# print(df.head(3))\n# runtime_data = df.loc[:,'Runtime (Minutes)']  # 也可以直接取runtime_data = df['Runtime (Minutes)']\n# print(type(runtime_data))  # <class 'pandas.core.series.Series'>\nruntime_data = df['Runtime (Minutes)']\nprint(type(runtime_data))  # <class 'pandas.core.series.Series'>\nprint(max(runtime_data))  # 191\nprint(min(runtime_data))  # 66\n# print(runtime_data)\n'''\n0      121\n1      124\n2      117\n3      108\n4      123\n      ... \n995    111\n996     94\n997     98\n998     93\n999     87\nName: Runtime (Minutes), Length: 1000, dtype: int64\n'''\nruntime_data = df['Runtime (Minutes)'].values  # 变成列表的形式\nprint(type(runtime_data))  # <class 'numpy.ndarray'>\nprint(max(runtime_data))  # 191\nprint(min(runtime_data))  # 66\n# print(runtime_data)\n'''\n[121 124 117 108 123 103 128  89 141 116 133 127 133 107 109  87 139 123\n 118 116 120 137 108  92 120  83 159  99 100 115 111 116 144 108 107 147\n 169 115 132 113  89 111  73 115  99 136 132  91 122 130 136  91 118 101\n 152 161  88 106 117  96 151  86 112 125 130 129 133 120 106 107 133 124\n 108  97 108 169 143 153 151 116 148 118 180 149 137 124 129 162 187 128\n 153 123 146 114 141 116 106  90 105 151 132 115 144 106 116 102 120 110\n 105 108  89 134 118 117 130 105 118 161 104  97 127 139  98  86 164 106\n 165  96 108 156 139 125  86 107 130 140 122 143 138 148 127  94 130 118\n 165 144 104 162 113 121 117 142  88 121  91  94 131 118 112 121 106  90\n 132 118 144 122 129 109 144 148 118 101  84 126 102 130 130 107 134 117\n 118  92 105 112 124 135 113 119 100 125 133  94 128  92 140 124  95 148\n 114 107 113 146 134 126 120 132  99 118 125 111 114  94 144 104 112 126\n 136 104 100 117  96 117 100 158 110 163 119 107  97 102 118  95 139 131\n 114 102 100  85  99 125 134  95  90 126 118 158 109 119 119 112  92  94\n 147 142 112 100 131 105  81 118 119 108 108 117 112  99 102 172 107  85\n 143 169 110 106  89 124 112 157 117 130 115 128 113 119  98 110 105 127\n  95  99 118 112  92 107 143 111  94 109 127 158 132 121  95  97 104 148\n 113 110 104 110 129 180  93 144 138 126 112  81  94 131 104  84 114 109\n 120 106 110 103  95 133  87 133 117 150 123  97 122  88 126 117 107 119\n 131 102 139 110 127 138 102  94  89 124 119  96 119 102 118 123 107 123\n  98 100 132  88 106 120 115 117 136 123  89 113 113 110 111  99 123 133\n  97 126  86 124  81 142 100 121 105 140 126 132 100 115 122  98 101 112\n 112 113  85 110  91  91  92  95 118 100 157 100 137  99  93 115 104 130\n  98 102 108 123 146 101 111  88 108 102  99 166 102 115 104 109 170 102\n 116 132 102  97 123 114 103  88 130 117 100 112  81 125  95 101 102 100\n 124 101 108 119 109 115 108 100 117 119 125  97 109  97 103 129 100  91\n 112 107 157 123 158 153 120 106 137  94  96 113 111  97 115  97  97  94\n 117 115 105 111  98 118  85 114 108 101 106 112 109  96 131 118 109 124\n 141 110 131  95  94  91  94 124  91 132 115  92 150 120 161 111 120 117\n 133 112 106 103 109 100 123 135 117  92 126  89 125 132 130 108  92 108\n 128 105 107 126 103 112  92 108  98 100 106 123 100 104 106  91 108  92\n 122  84 103  91 110 101 127 111 154  96  98  98 109 107 121 101 117 106\n 117 125 146 101  90 103  94 110 133 114 137 110 107  93 152 112 106 105\n  96 116 110  83  97  95 113  88 129  95 110  95 100  98 139 120 124 162\n 135 160  90  92 101 139  95 114 103  88 108  97 109 118 104  88  93  98\n 112 112 120  85  98 129  93 116  83 113 117 122 119 113  85 116 101 133\n 101 104 116 101 103  87  83 140 165 101 100  96 111  95 114 117 102 129\n 106 115 129 143 114 137 131 114  98 126 115 102 101 140 123 112  90 130\n 123 118  96  88 103 122  96 151 104 105 127  93 100 106 128  94 111 106\n 111 165  98  87 106  88 141  96 150  80  95 131 116 108 104  86 138  97\n 123 115 102  89 140 113 109 110 117 100 119 104 100 149 104 126  93 128\n 118 112  99 111 129 110  96 116  86 127  99 106 113 104 107 103 106 111\n  92  87 113 116 114 114 102 118  85 153 114 122 109 119 106  95  98 110\n  96 106 102  90  90 108 113 117 120  82  95 134 108  92  89  92 118 111\n 101  66 102 108 120  98 114 109  88 110 115 105 104 111 116  95 111 128\n  93 100 123 112  87 129  95  94  99  73 107 123 118 119  90  88  91 108\n 191  87 102  94 120 112  83 108 128 113 102 115 108 125 135  97  98 138\n  94 131 108 128 123 104 116  96  92 111 115 123 107 141 113 129  81  85\n 108 120 110 122  99 126 116  85  93 107 114 100  98  98 110  99 120 125\n 119  96 101 143 139 101  88 100 104 134 127 145  92 105 123 117  96  89\n 101 105  98 102 117 110  95 122  95 106 133  87  96  89 122 156 103  91\n 147 113  97  93 102 103 154 117 110 110  86 144 113 107  97  97 120 108\n  92  96 108 109  98 124  86 106 119  99 132  91 100  80 105 115 146  95\n 105  94 100 109 117 110 101 101 115 108 104 180 122 123  83 150  92 105\n 123 111 124  94 113  92  97 120 109 118 133 104 111 102  92 104  99 128\n  92 165  97  97  88 111  94  98  93  87]'''\nmax_runtime = max(runtime_data)\nmin_runtime = min(runtime_data)\n\n# 直方图\n# 组数 = (最大值-最小值)/组距  (191-66)//5 = 25\nnum_bins = (max_runtime - min_runtime) // 5\n# print(num_bins)  # 25\n\nplt.figure(figsize=(15,8),dpi=80)\nplt.hist(runtime_data,num_bins)\nplt.xticks(range(min_runtime,max_runtime+5,5))\nplt.title('电影时长分布图')\nplt.grid()\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210324095623194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "练习2"}, {"ctype": "head", "data": "全球食品数据分析"}, {"ctype": "p", "data": "步骤分析 1.数据清洗 2.获取国家列表 3.对各个国家进行统计 4.保存统计结果"}, {"ctype": "code", "data": "import pandas as pd\n\n# df = pd.read_csv('FoodFacts.csv')\n# print(df.info())\n'''\nsys:1: DtypeWarning: Columns (0,3,5,27,36) have mixed types.Specify dtype option on import or set low_memory=False.\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 65503 entries, 0 to 65502\nColumns: 159 entries, code to nutrition_score_uk_100g\ndtypes: float64(103), object(56)\nmemory usage: 79.5+ MB\nNone'''\n\n\ndef get_countries(countries_data):\n    '''获取国家数据'''\n    low_countries_data = countries_data.str.lower()  # 改为小写\n    # print(low_countries_data.head(30))\n    # 很多行包含两个国家france,united kingdom\n    # contains 模糊查询  ~ 非\n    low_countries_data = low_countries_data[~low_countries_data.str.contains(',')]\n    countries = low_countries_data.unique()  # 返回列的所有唯一值\n    # print(countries)\n    '''\n    ['united kingdom' 'france' 'spain' 'germany' 'united states' 'belgium'\n     'australia' 'netherlands' 'cuba' 'canada' 'switzerland' 'austria'\n     'sweden' 'united arab emirates' 'saint pierre and miquelon' 'fr:quebec'\n     'italy' 'czech republic' 'china' 'cambodia' 'réunion' 'hong kong'\n     'brazil' 'japan' 'mexico' 'lebanon' 'philippines' 'guadeloupe' 'ireland'\n     'senegal' \"côte d'ivoire\" 'togo' 'poland' 'india' 'south korea' 'turkey'\n     'french guiana' 'portugal' 'south africa' 'romania' 'denmark' 'greece'\n     'luxembourg' 'new caledonia' 'russia' 'french polynesia' 'tunisia'\n     'martinique' 'mayotte' 'hungary' 'bulgaria' 'slovenia' 'finland'\n     'republique-de-chine' 'taiwan' 'lithuania' 'belarus' 'cyprus' 'irlande'\n     'albania' 'malta' 'iceland' 'polska' 'kenya' 'mauritius' 'algeria' 'iran'\n     'qatar' 'thailand' 'colombia' 'norway' 'israel' 'venezuela' 'argentina'\n     'chile' 'new zealand' 'andorra' 'serbia' 'other-turquie' 'iraq'\n     'nederland' 'singapore' 'indonesia' 'burkina faso']'''\n    # print(\"一共有%s个国家\"%len(countries))  # 一共有84个国家\n    return countries\n\n\ndef get_additives_count(countries, data):\n    count_list = []\n    for country in countries:\n        f_data = data[data['countries_en'].str.contains(country, case=False)]  # 模糊查找，不区分大小写\n        # print(f_data.head(10))\n        # exit()\n        '''\n                             countries_en  additives_n\n        5          United Kingdom          0.0\n        10         United Kingdom          5.0\n        11         United Kingdom          5.0\n        14         United Kingdom          0.0\n        17         United Kingdom          0.0\n        18         United Kingdom          0.0\n        46  France,United Kingdom          1.0\n        60         United Kingdom          0.0\n        84         United Kingdom          0.0\n        97         United Kingdom          0.0\n        '''\n        count = f_data['additives_n'].mean()  # 计算平均值\n        count_list.append(count)\n    # print(count_list)\n    '''\n    [1.259009009009009, 1.93042170523602, 0.930323846908734, 0.7779232111692844, 2.1806083650190113, 1.8857142857142857, 0.5796847635726795, 1.5714285714285714, 1.8333333333333333, 1.847457627118644, 1.7183673469387755, 0.6185567010309279, 0.18181818181818182, 1.7142857142857142, 2.4324324324324325, 1.1724137931034482, 0.9190751445086706, 1.2666666666666666, 1.2, 0.2222222222222222, 2.0625, 1.375, 0.898876404494382, 0.8666666666666667, 1.75, 0.6, 0.8, 1.6748466257668713, 0.7142857142857143, 1.9166666666666667, 0.0, 8.0, 2.310810810810811, 2.0, 2.0, 0.3, 1.7954545454545454, 1.8299492385786802, 1.7272727272727273, 1.7692307692307692, 1.5912408759124088, 1.1111111111111112, 2.1923076923076925, 1.3333333333333333, 0.125, 2.0, 2.246153846153846, 1.5454545454545454, 0.0, 0.5384615384615384, 1.25, 0.25, 0.4166666666666667, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.2857142857142857, 1.3333333333333333, 0.6666666666666666, 0.0, 1.5, 2.1666666666666665, 2.857142857142857, 0.0, 4.4, 0.6896551724137931, 0.5, 1.5714285714285714, 1.0, 0.0, 1.9090909090909092, 3.5, 2.6607142857142856, 0.2, 2.0, 0.0, 1.5, 0.0, 1.0, 2.125, 1.6666666666666667]\n    '''\n    # print(len(count_list))  # 84\n    result_df = pd.DataFrame()\n    result_df['country'] = countries\n    result_df['count'] = count_list\n    return result_df\n\n\ndef main():\n    '''主函数'''\n    # 读取数据\n    df1 = pd.read_csv('FoodFacts.csv', usecols=['countries_en', 'additives_n'])\n    # print(df1.info())\n    '''\n    <class 'pandas.core.frame.DataFrame'>\n    RangeIndex: 65503 entries, 0 to 65502\n    Data columns (total 2 columns):\n     #   Column        Non-Null Count  Dtype  \n    ---  ------        --------------  -----  \n     0   countries_en  65292 non-null  object \n     1   additives_n   43664 non-null  float64\n    dtypes: float64(1), object(1)\n    memory usage: 1023.6+ KB\n    None'''\n    # 数据清洗  删除缺失数据\n    data = df1.dropna()\n    # print(data.info())\n    '''<class 'pandas.core.frame.DataFrame'>\n    Int64Index: 43616 entries, 5 to 65501\n    Data columns (total 2 columns):\n     #   Column        Non-Null Count  Dtype  \n    ---  ------        --------------  -----  \n     0   countries_en  43616 non-null  object \n     1   additives_n   43616 non-null  float64\n    dtypes: float64(1), object(1)\n    memory usage: 1022.2+ KB\n    None'''\n    # print(data.head())\n    '''      countries_en  additives_n\n    5   United Kingdom          0.0\n    6           France          0.0\n    8           France          0.0\n    10  United Kingdom          5.0\n    11  United Kingdom          5.0'''\n\n    countries = get_countries(data['countries_en'])\n    # print(countries)\n    # 获取每个国家添加剂的数量\n    additives = get_additives_count(countries, data)\n    additives.to_csv('result.csv', index=False)  # 保存，不加索引\n\n\nif __name__ == \"__main__\":\n    main()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210324141312228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "二、数据的合并和分组聚合"}, {"ctype": "head", "data": "1.字符串离散化"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210324141818531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# 字符串离散化的案例\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport matplotlib\n\nfont = {\n    'family': 'SimHei',\n    'weight': 'bold',\n    'size': 12\n}\nmatplotlib.rc(\"font\", **font)\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', 5)  # 只看5行\npd.set_option('max_colwidth', 200)\n\nfile_path = './IMDB-Movie-Data.csv'\n\ndf = pd.read_csv(file_path)\n# print(df)\n# print(df.info())\n# print(df.head(3))\ng_list = df.loc[:, 'Genre']  # 获取分类列\n# print(g_list)\n'''\n0       Action,Adventure,Sci-Fi\n1      Adventure,Mystery,Sci-Fi\n                 ...           \n998            Adventure,Comedy\n999       Comedy,Family,Fantasy\nName: Genre, Length: 1000, dtype: object'''\ng_list = df[\"Genre\"].str.split(\",\").tolist()  # [[],...,[]]\n# print(g_list)\n# temp_list = []\n# for i in g_list:\n#     for j in i:\n#         # print(j)\n#         temp_list.append(j)\n# print(set(temp_list))\ngenre_list = list(set([j for i in g_list for j in i]))  # 电影分类类名\n# print(genre_list)\n'''['Action', 'Crime', 'Biography', 'Adventure', 'Thriller', 'Music', 'Romance', 'Sport', 'Family', 'Horror', 'Western', 'War', 'Animation', 'Mystery', 'Sci-Fi', 'History', 'Drama', 'Musical', 'Fantasy', 'Comedy']'''\n\n# 构造全为0的数组\nzeros_data = pd.DataFrame(np.zeros((df.shape[0], len(genre_list))), columns=genre_list)\n# print(zeros_data)\n'''\n     Action  Horror  Family  Thriller  Animation  History  Romance  Fantasy  \\\n0       0.0     0.0     0.0       0.0        0.0      0.0      0.0      0.0   \n1       0.0     0.0     0.0       0.0        0.0      0.0      0.0      0.0   \n..      ...     ...     ...       ...        ...      ...      ...      ...   \n998     0.0     0.0     0.0       0.0        0.0      0.0      0.0      0.0   \n999     0.0     0.0     0.0       0.0        0.0      0.0      0.0      0.0   \n\n     Biography  Western  Drama  Comedy  Sci-Fi  Crime  War  Sport  Mystery  \\\n0          0.0      0.0    0.0     0.0     0.0    0.0  0.0    0.0      0.0   \n1          0.0      0.0    0.0     0.0     0.0    0.0  0.0    0.0      0.0   \n..         ...      ...    ...     ...     ...    ...  ...    ...      ...   \n998        0.0      0.0    0.0     0.0     0.0    0.0  0.0    0.0      0.0   \n999        0.0      0.0    0.0     0.0     0.0    0.0  0.0    0.0      0.0   \n\n     Musical  Music  Adventure  \n0        0.0    0.0        0.0  \n1        0.0    0.0        0.0  \n..       ...    ...        ...  \n998      0.0    0.0        0.0  \n999      0.0    0.0        0.0  \n\n[1000 rows x 20 columns]'''\n\n# 给每个电影出现的位置赋值1\n# print(df)  # [1000 rows x 12 columns]\nfor i in range(df.shape[0]):\n    # zeros_data[0,[Action,Musical]] = 1\n    zeros_data.loc[i, g_list[i]] = 1\n# print(zeros_data.head(3))\n'''\n   Music  Sport  Mystery  Adventure  Musical  Comedy  Horror  Fantasy  Action  \\\n0    0.0    0.0      0.0        1.0      0.0     0.0     0.0      0.0     1.0   \n1    0.0    0.0      1.0        1.0      0.0     0.0     0.0      0.0     0.0   \n2    0.0    0.0      0.0        0.0      0.0     0.0     1.0      0.0     0.0   \n\n   Biography  Family  Sci-Fi  War  Thriller  Romance  Drama  Crime  Animation  \\\n0        0.0     0.0     1.0  0.0       0.0      0.0    0.0    0.0        0.0   \n1        0.0     0.0     1.0  0.0       0.0      0.0    0.0    0.0        0.0   \n2        0.0     0.0     0.0  0.0       1.0      0.0    0.0    0.0        0.0   \n\n   Western  History  \n0      0.0      0.0  \n1      0.0      0.0  \n2      0.0      0.0  \n'''\ngenre_count = zeros_data.sum(axis=0)  # 对0轴进行求和\n# print(genre_count)\n'''\nThriller     195.0\nBiography     81.0\n             ...  \nAction       303.0\nSci-Fi       120.0\nLength: 20, dtype: float64'''\n\nx = genre_count.index\ny = genre_count.values\n\nplt.figure(figsize=(15, 8), dpi=80)\nplt.bar(x, y)\nplt.xticks(range(len(x)), x, rotation=45)\nplt.title(\"电影分类图\")\nplt.grid()\nplt.show()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210324161047765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.数据合并"}, {"ctype": "code", "data": "# 数据合并\nimport numpy as np\nimport pandas as pd\n\nt1 = pd.DataFrame(np.arange(12).reshape(3,4),index=list('ABC'),columns=list('DEFG'))\nt2 = pd.DataFrame(np.arange(10).reshape(2,5),index=list('AB'),columns=list('VWXYZ'))\nprint(t1)\n'''\n   D  E   F   G\nA  0  1   2   3\nB  4  5   6   7\nC  8  9  10  11'''\nprint(t2)\n'''\n   V  W  X  Y  Z\nA  0  1  2  3  4\nB  5  6  7  8  9'''\nprint(t1 + t2)\n'''\n    D   E   F   G   V   W   X   Y   Z\nA NaN NaN NaN NaN NaN NaN NaN NaN NaN\nB NaN NaN NaN NaN NaN NaN NaN NaN NaN\nC NaN NaN NaN NaN NaN NaN NaN NaN NaN'''\n\nprint(t1.join(t2))  # join:以t1为基础，默认情况下它是把行索引相同的数据合并到一起\n'''\n   D  E   F   G    V    W    X    Y    Z\nA  0  1   2   3  0.0  1.0  2.0  3.0  4.0\nB  4  5   6   7  5.0  6.0  7.0  8.0  9.0\nC  8  9  10  11  NaN  NaN  NaN  NaN  NaN'''\nprint(t2.join(t1))  # join:以t2为基础，默认情况下它是把行索引相同的数据合并到一起\n'''\n   V  W  X  Y  Z  D  E  F  G\nA  0  1  2  3  4  0  1  2  3\nB  5  6  7  8  9  4  5  6  7'''\nt3 = pd.DataFrame(np.arange(12).reshape(3,4),index=list('ABC'),columns=list('DEFG'))\nt4 = pd.DataFrame(np.arange(10).reshape(2,5),index=list('AC'),columns=list('VWXYZ'))\nprint(t3)\n'''\n   D  E   F   G\nA  0  1   2   3\nB  4  5   6   7\nC  8  9  10  11'''\nprint(t4)\n'''\n   V  W  X  Y  Z\nA  0  1  2  3  4\nC  5  6  7  8  9'''\nprint(t3.join(t4))  # join:以t3为基础，默认情况下它是把行索引相同的数据合并到一起\n'''\n   D  E   F   G    V    W    X    Y    Z\nA  0  1   2   3  0.0  1.0  2.0  3.0  4.0\nB  4  5   6   7  NaN  NaN  NaN  NaN  NaN\nC  8  9  10  11  5.0  6.0  7.0  8.0  9.0'''\nprint(t4.join(t3))  # join:以t4为基础，默认情况下它是把行索引相同的数据合并到一起\n'''\n   V  W  X  Y  Z  D  E   F   G\nA  0  1  2  3  4  0  1   2   3\nC  5  6  7  8  9  8  9  10  11'''\nt5 = pd.DataFrame(np.arange(12).reshape(3,4),index=list('ABC'),columns=list('DEFG'))\nt6 = pd.DataFrame(np.arange(10).reshape(2,5),index=list('DE'),columns=list('VWXYZ'))\nprint(t5.join(t6))  # join:以t5为基础，没有相同的索引，后面拼接的都为NaN\n'''\n   D  E   F   G   V   W   X   Y   Z\nA  0  1   2   3 NaN NaN NaN NaN NaN\nB  4  5   6   7 NaN NaN NaN NaN NaN\nC  8  9  10  11 NaN NaN NaN NaN NaN'''\nprint(t6.join(t5))  # join:以t6为基础，没有相同的索引，后面拼接的都为NaN\n'''\n   V  W  X  Y  Z   D   E   F   G\nD  0  1  2  3  4 NaN NaN NaN NaN\nE  5  6  7  8  9 NaN NaN NaN NaN'''\n"}, {"ctype": "code", "data": "# 数据合并\nimport numpy as np\nimport pandas as pd\n\nt1 = pd.DataFrame(np.arange(12).reshape(3, 4), index=list('ABC'), columns=list('DEFG'))\nt2 = pd.DataFrame(np.arange(10).reshape(2, 5), index=list('AB'), columns=list('DWXYZ'))\nprint(t1)\n'''\n   D  E   F   G\nA  0  1   2   3\nB  4  5   6   7\nC  8  9  10  11'''\nprint(t2)\n'''\n   D  W  X  Y  Z\nA  0  1  2  3  4\nB  5  6  7  8  9'''\nprint(t1 + t2)\n'''\n     D   E   F   G   W   X   Y   Z\nA  0.0 NaN NaN NaN NaN NaN NaN NaN\nB  9.0 NaN NaN NaN NaN NaN NaN NaN\nC  NaN NaN NaN NaN NaN NaN NaN NaN'''\nprint(t1.merge(t2))  # merge:至少要有一个相同的列索引，相同的列下有相同的元素，就把该元素所在的行（去除相同的元素）合并到一行\n'''\n   D  E  F  G  W  X  Y  Z\n0  0  1  2  3  1  2  3  4'''\nt1.iloc[2, 0] = 5\nprint(t1)\n'''\n   D  E   F   G\nA  0  1   2   3\nB  4  5   6   7\nC  5  9  10  11'''\nprint(t2)\n'''\n   D  W  X  Y  Z\nA  0  1  2  3  4\nB  5  6  7  8  9'''\nprint(t1.merge(t2))  # 以t1为主，merge:至少要有一个相同的列索引，相同的列下有相同的元素，就把该元素所在的行（去除相同的元素）合并到一行，合并后的数据行索引从0开始\n'''\n   D  E   F   G  W  X  Y  Z\n0  0  1   2   3  1  2  3  4\n1  5  9  10  11  6  7  8  9'''\nprint(t2.merge(t1))  # 以t2为主，merge:至少要有一个相同的列索引，相同的列下有相同的元素，就把该元素所在的行（去除相同的元素）合并到一行，合并后的数据行索引从0开始\n'''\n   D  W  X  Y  Z  E   F   G\n0  0  1  2  3  4  1   2   3\n1  5  6  7  8  9  9  10  11'''\nt1.iloc[[0, 1, 2], 0] = 1\nprint(t1)\n'''\n   D  E   F   G\nA  1  1   2   3\nB  1  5   6   7\nC  1  9  10  11'''\nprint(t2)\n'''\n   D  W  X  Y  Z\nA  0  1  2  3  4\nB  5  6  7  8  9'''\nprint(t2.merge(t1))  # 以t2为主，merge:至少要有一个相同的列索引，相同的列下没有相同的元素，Empty DataFrame\n'''\nEmpty DataFrame\nColumns: [D, W, X, Y, Z, E, F, G]\nIndex: []'''\nt1.iloc[[0, 1, 2], 0] = 0\nprint(t1)\n'''\n   D  E   F   G\nA  0  1   2   3\nB  0  5   6   7\nC  0  9  10  11'''\nprint(t2)\n'''\n   D  W  X  Y  Z\nA  0  1  2  3  4\nB  5  6  7  8  9'''\nprint(t2.merge(t1))  # 以t2为主，merge:至少要有一个相同的列索引，相同的列下有相同的元素，就把该元素所在的行（去除相同的元素）合并到一行，合并后的数据行索引从0开始\n'''\n   D  W  X  Y  Z  E   F   G\n0  0  1  2  3  4  1   2   3\n1  0  1  2  3  4  5   6   7\n2  0  1  2  3  4  9  10  11'''\nprint(t2.merge(t1,\n               how='left'))  # 以t2为主，merge:至少要有一个相同的列索引，相同的列下有相同的元素，就把该元素所在的行（去除相同的元素）合并到一行，合并后的数据行索引从0开始 how='left'保留t2的原数据，后面用NaN填充\n'''\n   D  W  X  Y  Z    E     F     G\n0  0  1  2  3  4  1.0   2.0   3.0\n1  0  1  2  3  4  5.0   6.0   7.0\n2  0  1  2  3  4  9.0  10.0  11.0\n3  5  6  7  8  9  NaN   NaN   NaN'''\nprint(t2.merge(t1, on='D', how='outer'))\n'''\n   D  W  X  Y  Z    E     F     G\n0  0  1  2  3  4  1.0   2.0   3.0\n1  0  1  2  3  4  5.0   6.0   7.0\n2  0  1  2  3  4  9.0  10.0  11.0\n3  5  6  7  8  9  NaN   NaN   NaN'''\n\nt3 = pd.DataFrame(np.arange(12).reshape(3, 4), index=list('abc'), columns=list('MNOP'))\nt4 = pd.DataFrame(np.arange(10).reshape(2, 5), index=list('de'), columns=list('MWXYZ'))\nprint(t3)\n'''\n   M  N   O   P\na  0  1   2   3\nb  4  5   6   7\nc  8  9  10  11'''\nprint(t4)\n'''\n   M  W  X  Y  Z\nd  0  1  2  3  4\ne  5  6  7  8  9\n'''\nprint(t3.merge(t4,left_on='N',right_on='Z'))\n'''\n   M_x  N   O   P  M_y  W  X  Y  Z\n0    8  9  10  11    5  6  7  8  9'''\n\n"}, {"ctype": "head", "data": "3.数据的分组聚合"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326092955903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "df.groupby(by=“columns_name”)"}, {"ctype": "p", "data": "dict_obj = { ‘key1’ : [‘a’, ‘b’, ‘a’, ‘b’,‘a’, ‘b’, ‘a’, ‘a’], ‘key2’ : [‘one’, ‘one’, ‘two’, ‘three’,‘two’, ‘two’, ‘one’, ‘three’], ‘data1’: np.arange(8), ‘data2’: np.arange(8) }"}, {"ctype": "code", "data": "# 分组聚合\nimport pandas as pd\nimport numpy as np\n\n\ndict_obj = {\n    'key1': ['a', 'b', 'a', 'b', 'a', 'b', 'a', 'a'],\n    'key2': ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],\n    'data1': np.arange(8),\n    'data2': np.arange(8)\n}\ndf = pd.DataFrame(dict_obj)\nprint(df)\n'''\n  key1   key2  data1  data2\n0    a    one      0      0\n1    b    one      1      1\n2    a    two      2      2\n3    b  three      3      3\n4    a    two      4      4\n5    b    two      5      5\n6    a    one      6      6\n7    a  three      7      7\n'''\n# 分组 groupby\ndf.groupby(by=\"key1\")\nprint(df.groupby(by=\"key1\"))  # <pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000000002CB9208>\nfor i in df.groupby(by=\"key1\"):\n    print(i)\n'''\n('a',   key1   key2  data1  data2\n0    a    one      0      0\n2    a    two      2      2\n4    a    two      4      4\n6    a    one      6      6\n7    a  three      7      7)\n('b',   key1   key2  data1  data2\n1    b    one      1      1\n3    b  three      3      3\n5    b    two      5      5)\n'''\nprint(df.groupby(by=\"key1\").mean())  # 求平均值,key2不是数字类型直接忽略掉\n'''\n      data1  data2\nkey1              \na       3.8    3.8\nb       3.0    3.0'''\nprint(df.groupby(by=\"key1\").sum())  # 求和,key2不是数字类型直接忽略掉\n'''\n      data1  data2\nkey1              \na        19     19\nb         9      9'''\nprint(df.groupby(by=\"key1\").count())  # 记录个数\n'''\n      key2  data1  data2\nkey1                    \na        5      5      5\nb        3      3      3'''\n\n"}, {"ctype": "code", "data": "# 现在我们有一组关于全球星巴克店铺的统计数据，如果我想知道美国的星巴克数量和\n# 中国的哪个多，或者我想知道中国每个省份星巴克的数量的情况，那么应该怎么办？\n# 思路：根据国家分组，统计每个国家的总数进行对比，取出中国的数据，按省份分组统计每个省份的总数进行对比\nimport numpy as np\nimport pandas as pd\n\nfile_path = './starbucks_store_worldwide.csv'\ndf = pd.read_csv(file_path)\nprint(df.info())\n'''\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 25600 entries, 0 to 25599\nData columns (total 13 columns):\n #   Column          Non-Null Count  Dtype  \n---  ------          --------------  -----  \n 0   Brand           25600 non-null  object \n 1   Store Number    25600 non-null  object \n 2   Store Name      25600 non-null  object \n 3   Ownership Type  25600 non-null  object \n 4   Street Address  25598 non-null  object \n 5   City            25585 non-null  object \n 6   State/Province  25600 non-null  object \n 7   Country         25600 non-null  object \n 8   Postcode        24078 non-null  object \n 9   Phone Number    18739 non-null  object \n 10  Timezone        25600 non-null  object \n 11  Longitude       25599 non-null  float64\n 12  Latitude        25599 non-null  float64\ndtypes: float64(2), object(11)\nmemory usage: 2.5+ MB\nNone'''\nprint(df.head())\n'''\n       Brand  Store Number  ... Longitude Latitude\n0  Starbucks  47370-257954  ...      1.53    42.51\n1  Starbucks  22331-212325  ...     55.47    25.42\n2  Starbucks  47089-256771  ...     55.47    25.39\n3  Starbucks  22126-218024  ...     54.38    24.48\n4  Starbucks  17127-178586  ...     54.54    24.51\n'''\npd.set_option('display.max_rows', 10)\npd.set_option('display.max_columns', 13)\nprint(df)\n'''\n                        City State/Province Country Postcode  Phone Number  \\\n0           Andorra la Vella              7      AD    AD500     376818720   \n1                      Ajman             AJ      AE      NaN           NaN   \n2                      Ajman             AJ      AE      NaN           NaN   \n3                  Abu Dhabi             AZ      AE      NaN           NaN   \n4                  Abu Dhabi             AZ      AE      NaN           NaN   \n...                      ...            ...     ...      ...           ...   \n25595  Thành Phố Hồ Chí Minh             SG      VN    70000  08 3824 4668   \n25596  Thành Phố Hồ Chí Minh             SG      VN    70000  08 5413 8292   \n25597           Johannesburg             GT      ZA     2194   27873500159   \n25598                 Menlyn             GT      ZA      181           NaN   \n25599                Midrand             GT      ZA     1682   27873500215   \n\n                             Timezone  Longitude  Latitude  \n0             GMT+1:00 Europe/Andorra       1.53     42.51  \n1                GMT+04:00 Asia/Dubai      55.47     25.42  \n2                GMT+04:00 Asia/Dubai      55.47     25.39  \n3                GMT+04:00 Asia/Dubai      54.38     24.48  \n4                GMT+04:00 Asia/Dubai      54.54     24.51  \n...                               ...        ...       ...  \n25595          GMT+000000 Asia/Saigon     106.70     10.78  \n25596          GMT+000000 Asia/Saigon     106.71     10.72  \n25597  GMT+000000 Africa/Johannesburg      28.04    -26.15  \n25598  GMT+000000 Africa/Johannesburg      28.28    -25.79  \n25599  GMT+000000 Africa/Johannesburg      28.11    -26.02  \n\n[25600 rows x 13 columns]\n'''\ngrouped = df.groupby(by='Country').count()['Brand']\nprint(type(grouped))  # <class 'pandas.core.series.Series'>\nprint(grouped)\n'''\nAD        1\nAE      144\nAR      108\nAT       18\nAU       22\n      ...  \nTT        3\nTW      394\nUS    13608\nVN       25\nZA        3\nName: Brand, Length: 73, dtype: int64'''\nus_count = grouped['US']  # us_count = grouped.loc['US']也可以\nprint(us_count)  # 13608\ncn_count = grouped['CN']  # cn_count = grouped.loc['CN']也可以\nprint(cn_count)  # 2734\nprint(\"美国的星巴克总数位%s,中国的星巴克为%s\" % (us_count, cn_count))\n'''美国的星巴克总数位13608,中国的星巴克为2734'''\n\n# 布尔索引\nchina_data = df[df['Country'] == 'CN']\nprint(china_data)\n'''\n          Brand  Store Number           Store Name Ownership Type  \\\n2091  Starbucks  22901-225145            北京西站第一咖啡店  Company Owned   \n2092  Starbucks  32320-116537              北京华宇时尚店  Company Owned   \n2093  Starbucks  32447-132306           北京蓝色港湾圣拉娜店  Company Owned   \n2094  Starbucks  17477-161286           北京太阳宫凯德嘉茂店  Company Owned   \n2095  Starbucks  24520-237564              北京东三环北店  Company Owned   \n...         ...           ...                  ...            ...   \n4820  Starbucks  17872-186929                Sands       Licensed   \n4821  Starbucks  24126-235784              Wynn II       Licensed   \n4822  Starbucks  28490-242269      Wynn Palace BOH       Licensed   \n4823  Starbucks  22210-218665  Sands Cotai Central       Licensed   \n4824  Starbucks  17108-179449          One Central       Licensed   \n\n                                         Street Address   City State/Province  \\\n2091                          丰台区, 北京西站通廊7-1号, 中关村南大街2号    北京市             11   \n2092          海淀区, 数码大厦B座华宇时尚购物中心内, 蓝色港湾国际商区1座C1-3单元首层、    北京市             11   \n2093                朝阳区朝阳公园路6号, 二层C1-3单元及二层阳台, 太阳宫中路12号    北京市             11   \n2094                  朝阳区, 太阳宫凯德嘉茂一层01-44/45号, 东三环北路27号    北京市             11   \n2095                      朝阳区, 嘉铭中心大厦A座B1层024商铺, 金融大街7号    北京市             11   \n...                                                 ...    ...            ...   \n4820  Portion of Shop 04, Ground Floor, Sands, Largo...  Macau             92   \n4821             Wynn Macau, Rua Cidada de Sintra, NAPE  Macau             92   \n4822       Employee Entrance Outlet, Wynn Cotai, Resort  Macau             92   \n4823  Shop K201 & K202, Level 02, Parcela 5&6, Estra...  Macau             92   \n4824                       Promenade Rd, Open Area, 2/F  Macau             92   \n\n     Country Postcode   Phone Number                Timezone  Longitude  \\\n2091      CN   100073            NaN  GMT+08:00 Asia/Beijing     116.32   \n2092      CN   100086   010-51626616  GMT+08:00 Asia/Beijing     116.32   \n2093      CN   100020   010-59056343  GMT+08:00 Asia/Beijing     116.47   \n2094      CN   100028   010-84150945  GMT+08:00 Asia/Beijing     116.45   \n2095      CN      NaN            NaN  GMT+08:00 Asia/Beijing     116.46   \n...      ...      ...            ...                     ...        ...   \n4820      CN      NaN  (853)28782773  GMT+08:00 Asia/Beijing     113.55   \n4821      CN      NaN    85328723516  GMT+08:00 Asia/Beijing     113.55   \n4822      CN      NaN            NaN  GMT+08:00 Asia/Beijing     113.54   \n4823      CN      NaN    85328853439  GMT+08:00 Asia/Beijing     113.56   \n4824      CN      NaN            NaN  GMT+08:00 Asia/Beijing     113.55   \n\n      Latitude  \n2091     39.90  \n2092     39.97  \n2093     39.95  \n2094     39.97  \n2095     39.93  \n...        ...  \n4820     22.19  \n4821     22.19  \n4822     22.20  \n4823     22.15  \n4824     22.19  \n\n[2734 rows x 13 columns]\n'''\nchina_province_data = china_data.groupby(by='State/Province').count()\nprint(china_province_data['Brand'])\n'''\nState/Province\n11    236\n12     58\n13     24\n14      8\n15      8\n     ... \n62      3\n63      3\n64      2\n91    162\n92     13\nName: Brand, Length: 31, dtype: int64'''\n"}, {"ctype": "head", "data": "4.索引和复合索引"}, {"ctype": "code", "data": "# 索引和复合索引\nimport numpy as np\nimport pandas as pd\n\nt1 = pd.DataFrame(np.arange(12).reshape(3, 4), index=list('ABC'), columns=list('WXYZ'))\nprint(t1)\n'''\n   W  X   Y   Z\nA  0  1   2   3\nB  4  5   6   7\nC  8  9  10  11'''\nprint(t1.index)  # Index(['A', 'B', 'C'], dtype='object')\n# 重置索引\nprint(t1.reindex(['a','e']))\n'''\n    W   X   Y   Z\na NaN NaN NaN NaN\ne NaN NaN NaN NaN'''\nprint(t1.reindex(['A','e']))\n'''\n     W    X    Y    Z\nA  0.0  1.0  2.0  3.0\ne  NaN  NaN  NaN  NaN'''\n# 指定某一列作为索引\nprint(t1.set_index('W'))  # 默认删除W列，以W作为行索引\n'''\n   X   Y   Z\nW           \n0  1   2   3\n4  5   6   7\n8  9  10  11'''\nprint(t1.set_index('W',drop=False))  # 不删除W列，以W作为行索引\n'''\n   W  X   Y   Z\nW              \n0  0  1   2   3\n4  4  5   6   7\n8  8  9  10  11'''\n# 返回index的唯一值: t.set_index(\"M\").index.unique()\nprint(t1.set_index('W').index)\n'''Int64Index([0, 4, 8], dtype='int64', name='W')'''\nprint(t1.set_index('W').index.unique())\n'''Int64Index([0, 4, 8], dtype='int64', name='W')'''\nt1.loc['B','W'] = 8\nprint(t1)\n'''\n   W  X   Y   Z\nA  0  1   2   3\nB  8  5   6   7\nC  8  9  10  11'''\nprint(t1.set_index('W').index.unique())\n'''Int64Index([0, 8], dtype='int64', name='W')'''\n# 设置两个索引  复合索引\nt2 = pd.DataFrame(np.arange(12).reshape(3, 4), index=list('ABC'), columns=list('WXYZ'))\nprint(t2)\n'''\n   W  X   Y   Z\nA  0  1   2   3\nB  4  5   6   7\nC  8  9  10  11'''\nprint(t2.set_index(['W','X']))\n'''\n      Y   Z\nW X        \n0 1   2   3\n4 5   6   7\n8 9  10  11'''\nprint(type(t2.set_index(['W','X'])))  # <class 'pandas.core.frame.DataFrame'>\n"}, {"ctype": "head", "data": "Series复合索引"}, {"ctype": "p", "data": "a = pd.DataFrame({‘a’: range(7),‘b’: range(7, 0, -1),‘c’: [‘one’,‘one’,‘one’,‘two’,‘two’,‘two’, ‘two’],‘d’: list(“hjklmno”)})"}, {"ctype": "p", "data": "设置c,d为索引"}, {"ctype": "code", "data": "# 索引和复合索引\nimport numpy as np\nimport pandas as pd\n\na = pd.DataFrame({'a': range(7), 'b': range(7, 0, -1), 'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'], 'd':\n    list(\"hjklmno\")})\nprint(type(a))  # <class 'pandas.core.frame.DataFrame'>\nprint(a)\n'''\n   a  b    c  d\n0  0  7  one  h\n1  1  6  one  j\n2  2  5  one  k\n3  3  4  two  l\n4  4  3  two  m\n5  5  2  two  n\n6  6  1  two  o'''\nb = a.set_index(['c','d'])\nprint(b)\n'''\n       a  b\nc   d      \none h  0  7\n    j  1  6\n    k  2  5\ntwo l  3  4\n    m  4  3\n    n  5  2\n    o  6  1\n'''\nprint(b.loc['one'])\n'''\n   a  b\nd      \nh  0  7\nj  1  6\nk  2  5'''\nprint(b.loc['one'].loc['j'])\n'''\na    1\nb    6\nName: j, dtype: int64'''\nprint(b.loc['one'].loc['j']['a'])  # 1\nc = b['a']\nprint(type(c))  # <class 'pandas.core.series.Series'>\nprint(c)\n'''\nc    d\none  h    0\n     j    1\n     k    2\ntwo  l    3\n     m    4\n     n    5\n     o    6\nName: a, dtype: int64'''\nprint(c['one']['j'])  # 1\nprint(c['one','j'])  # 1\n"}, {"ctype": "p", "data": "设置d,c为索引"}, {"ctype": "code", "data": "# 索引和复合索引\nimport numpy as np\nimport pandas as pd\n\na = pd.DataFrame({'a': range(7), 'b': range(7, 0, -1), 'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'], 'd':\n    list(\"hjklmno\")})\nprint(type(a))  # <class 'pandas.core.frame.DataFrame'>\nprint(a)\n'''\n   a  b    c  d\n0  0  7  one  h\n1  1  6  one  j\n2  2  5  one  k\n3  3  4  two  l\n4  4  3  two  m\n5  5  2  two  n\n6  6  1  two  o'''\nb = a.set_index(['d','c'])\nprint(b)\n'''\n       a  b\nd c        \nh one  0  7\nj one  1  6\nk one  2  5\nl two  3  4\nm two  4  3\nn two  5  2\no two  6  1 \n'''\nprint(b.loc['j'])\n'''\n     a  b\nc        \none  1  6'''\nprint(b.loc['j'].loc['one'])\n'''\na    1\nb    6\nName: one, dtype: int64'''\nprint(b.loc['j'].loc['one']['a'])  # 1\nprint(b.loc['j'].loc['one','a'])  # 1\n# 复合索引交换\nprint(b.swaplevel())\n'''\n       a  b\nc   d      \none h  0  7\n    j  1  6\n    k  2  5\ntwo l  3  4\n    m  4  3\n    n  5  2\n    o  6  1'''\n\n"}, {"ctype": "head", "data": "DateFrame复合索引"}, {"ctype": "code", "data": "# 索引和复合索引\nimport numpy as np\nimport pandas as pd\n\na = pd.DataFrame({'a': range(7), 'b': range(7, 0, -1), 'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'], 'd':\n    list(\"hjklmno\")})\nprint(type(a))  # <class 'pandas.core.frame.DataFrame'>\nprint(a)\n'''\n   a  b    c  d\n0  0  7  one  h\n1  1  6  one  j\n2  2  5  one  k\n3  3  4  two  l\n4  4  3  two  m\n5  5  2  two  n\n6  6  1  two  o'''\nb = a.set_index(['c','d'])\nprint(b)\n'''\n       a  b\nc   d      \none h  0  7\n    j  1  6\n    k  2  5\ntwo l  3  4\n    m  4  3\n    n  5  2\n    o  6  1\n'''\n# 从外层开始取值\nprint(b.loc['one'].loc['j','b'])  # 6\n# 从内层开始取值\nprint(b.swaplevel().loc['j'].loc['one','b'])  # 6\n"}, {"ctype": "head", "data": "5.练习"}, {"ctype": "head", "data": "1.使用matplotlib呈现出店铺总数排名前10的国家"}, {"ctype": "code", "data": "# # 1.使用matplotlib呈现出店铺总数排名前10的国家  # sort_values  groupby\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfile_path = './starbucks_store_worldwide.csv'\ndf = pd.read_csv(file_path)\nprint(df.info())\n'''\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 25600 entries, 0 to 25599\nData columns (total 13 columns):\n #   Column          Non-Null Count  Dtype  \n---  ------          --------------  -----  \n 0   Brand           25600 non-null  object \n 1   Store Number    25600 non-null  object \n 2   Store Name      25600 non-null  object \n 3   Ownership Type  25600 non-null  object \n 4   Street Address  25598 non-null  object \n 5   City            25585 non-null  object \n 6   State/Province  25600 non-null  object \n 7   Country         25600 non-null  object \n 8   Postcode        24078 non-null  object \n 9   Phone Number    18739 non-null  object \n 10  Timezone        25600 non-null  object \n 11  Longitude       25599 non-null  float64\n 12  Latitude        25599 non-null  float64\ndtypes: float64(2), object(11)\nmemory usage: 2.5+ MB\nNone'''\ndata = df.groupby(by='Country').count()\nprint(data.head(3))\n'''\n         Brand  Store Number  Store Name  ...  Timezone  Longitude  Latitude\nCountry                                   ...                               \nAD           1             1           1  ...         1          1         1\nAE         144           144         144  ...       144        144       144\nAR         108           108         108  ...       108        108       108\n\n[3 rows x 12 columns]'''\ndata_sort = data.sort_values(by='Brand', ascending=False)[0:10]  # 倒序\nprint(data_sort['Brand'])\n# data = df.groupby(by='Country').count()['Brand'].sort_values(ascending=False)[0:10]\n# print(data)  # 这样写也可以\n'''\nCountry\nUS    13608\nCN     2734\nCA     1468\nJP     1237\nKR      993\nGB      901\nMX      579\nTW      394\nTR      326\nPH      298\nName: Brand, dtype: int64'''\nx = data_sort['Brand'].index\ny = data_sort['Brand'].values\n\n# 设置图片大小\nplt.figure(figsize=(15, 8), dpi=80)\n# 直方图\nplt.bar(x, y)\nplt.show()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326114301281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.使用matplotlib呈现出中国每个城市的店铺数量"}, {"ctype": "code", "data": "# 2.使用matplotlib呈现出中国每个城市的店铺数量\n\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport matplotlib\n\nfont = {\n    'family': 'SimHei',\n    'weight': 'bold',\n    'size': 12\n}\nmatplotlib.rc(\"font\", **font)\n\nfile_path = './starbucks_store_worldwide.csv'\ndf = pd.read_csv(file_path)\n# print(df.info())\n'''\n #   Column          Non-Null Count  Dtype  \n---  ------          --------------  -----  \n 0   Brand           25600 non-null  object \n 1   Store Number    25600 non-null  object \n 2   Store Name      25600 non-null  object \n 3   Ownership Type  25600 non-null  object \n 4   Street Address  25598 non-null  object \n 5   City            25585 non-null  object \n 6   State/Province  25600 non-null  object \n 7   Country         25600 non-null  object \n 8   Postcode        24078 non-null  object \n 9   Phone Number    18739 non-null  object \n 10  Timezone        25600 non-null  object \n 11  Longitude       25599 non-null  float64\n 12  Latitude        25599 non-null  float64\ndtypes: float64(2), object(11)\nmemory usage: 2.5+ MB\nNone'''\ndf = df[df['Country'] == 'CN']\n# print(df.head(3))\n'''\n          Brand  Store Number  ... Longitude Latitude\n2091  Starbucks  22901-225145  ...    116.32    39.90\n2092  Starbucks  32320-116537  ...    116.32    39.97\n2093  Starbucks  32447-132306  ...    116.47    39.95\n\n[3 rows x 13 columns]'''\ndata = df.groupby(by='City').count()['Brand'].sort_values(ascending=False)[0:30]\nx = data.index\ny = data.values\n\n# 设置图片大小\nplt.figure(figsize=(15, 8), dpi=80)\n# 直方图\nplt.bar(x, y)\n# 设置x轴刻度\nplt.xticks(rotation=45)\nplt.show()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032612011634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "三、pandas中的时间序列"}, {"ctype": "head", "data": "1.时间范围"}, {"ctype": "p", "data": "时间范围 pd.date_range(start=None, end=None, periods=None, freq=‘D’) periods       时间范围的个数 freq       频率,以天为单位还是以月为单位 关于频率的更多缩写 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326120349583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# 时间序列\nimport pandas as pd\n\nd = pd.date_range(start='20210101', end='20210201')\nprint(d)  # freq='D' 频率默认是天\n'''DatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',\n               '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08',\n               '2021-01-09', '2021-01-10', '2021-01-11', '2021-01-12',\n               '2021-01-13', '2021-01-14', '2021-01-15', '2021-01-16',\n               '2021-01-17', '2021-01-18', '2021-01-19', '2021-01-20',\n               '2021-01-21', '2021-01-22', '2021-01-23', '2021-01-24',\n               '2021-01-25', '2021-01-26', '2021-01-27', '2021-01-28',\n               '2021-01-29', '2021-01-30', '2021-01-31', '2021-02-01'],\n              dtype='datetime64[ns]', freq='D')'''\nm = pd.date_range(start='20210101', end='20211231',freq='M')  # 频率是1月\nprint(m)\n'''\nDatetimeIndex(['2021-01-31', '2021-02-28', '2021-03-31', '2021-04-30',\n               '2021-05-31', '2021-06-30', '2021-07-31', '2021-08-31',\n               '2021-09-30', '2021-10-31', '2021-11-30', '2021-12-31'],\n              dtype='datetime64[ns]', freq='M')'''\nd10 = pd.date_range(start='20210101', end='20210201',freq='10D')\nprint(d10)  # freq='10D' 频率是10天\n'''\nDatetimeIndex(['2021-01-01', '2021-01-11', '2021-01-21', '2021-01-31'], dtype='datetime64[ns]', freq='10D')'''\nd3 = pd.date_range(start='20210101', end='20210201',freq='3D')\nprint(d3)  # freq='10D' 频率是3天\n'''\nDatetimeIndex(['2021-01-01', '2021-01-04', '2021-01-07', '2021-01-10',\n               '2021-01-13', '2021-01-16', '2021-01-19', '2021-01-22',\n               '2021-01-25', '2021-01-28', '2021-01-31'],\n              dtype='datetime64[ns]', freq='3D')'''\nd3 = pd.date_range(start='20210101', periods=5, freq='3D')\nprint(d3)  # freq='10D' 频率是3天  periods和end不要同时用\n'''\nDatetimeIndex(['2021-01-01', '2021-01-04', '2021-01-07', '2021-01-10',\n               '2021-01-13'],\n              dtype='datetime64[ns]', freq='3D')'''\n"}, {"ctype": "head", "data": "2.DataFrame中使用时间序列"}, {"ctype": "p", "data": "index=pd.date_range(“20190101”,periods=10) df = pd.DataFrame(np.arange(10),index=index) 作为行索引 df = pd.DataFrame(np.arange(10).reshape(1,10),columns=index) 作为列索引"}, {"ctype": "code", "data": "# 使用时间序列\nimport pandas as pd\nimport numpy as np\n\n# 时间序列当行索引\ndindex = pd.date_range(start='20210101', periods=10)\ndf = pd.DataFrame(np.arange(10),index=dindex)\nprint(df)\n'''\n            0\n2021-01-01  0\n2021-01-02  1\n2021-01-03  2\n2021-01-04  3\n2021-01-05  4\n2021-01-06  5\n2021-01-07  6\n2021-01-08  7\n2021-01-09  8\n2021-01-10  9\n'''\n# 时间序列当列索引\nd_index = pd.date_range(start='20210101', periods=10)\ndf1 = pd.DataFrame(np.arange(10).reshape(1,10),columns=d_index)\nprint(df1)\n'''\n   2021-01-01  2021-01-02  2021-01-03  ...  2021-01-08  2021-01-09  2021-01-10\n0           0           1           2  ...           7           8           9\n\n[1 rows x 10 columns]'''\n"}, {"ctype": "head", "data": "3.pandas重采样"}, {"ctype": "code", "data": "# 使用时间序列\nimport pandas as pd\nimport numpy as np\n\ndindex = pd.date_range(start='2021-01-01',end='2021-02-24')\nt = pd.DataFrame(np.arange(55).reshape(55,1),index=dindex)\nprint(t)\n'''\n             0\n2021-01-01   0\n2021-01-02   1\n2021-01-03   2\n2021-01-04   3\n2021-01-05   4\n2021-01-06   5\n2021-01-07   6\n2021-01-08   7\n2021-01-09   8\n2021-01-10   9\n2021-01-11  10\n2021-01-12  11\n2021-01-13  12\n2021-01-14  13\n2021-01-15  14\n2021-01-16  15\n2021-01-17  16\n2021-01-18  17\n2021-01-19  18\n2021-01-20  19\n2021-01-21  20\n2021-01-22  21\n2021-01-23  22\n2021-01-24  23\n2021-01-25  24\n2021-01-26  25\n2021-01-27  26\n2021-01-28  27\n2021-01-29  28\n2021-01-30  29\n2021-01-31  30\n2021-02-01  31\n2021-02-02  32\n2021-02-03  33\n2021-02-04  34\n2021-02-05  35\n2021-02-06  36\n2021-02-07  37\n2021-02-08  38\n2021-02-09  39\n2021-02-10  40\n2021-02-11  41\n2021-02-12  42\n2021-02-13  43\n2021-02-14  44\n2021-02-15  45\n2021-02-16  46\n2021-02-17  47\n2021-02-18  48\n2021-02-19  49\n2021-02-20  50\n2021-02-21  51\n2021-02-22  52\n2021-02-23  53\n2021-02-24  54\n'''\nprint(t.resample('M').mean())\n'''\n               0\n2021-01-31  15.0\n2021-02-28  42.5'''\nprint(t.resample('10D').mean())\n'''\n               0\n2021-01-01   4.5\n2021-01-11  14.5\n2021-01-21  24.5\n2021-01-31  34.5\n2021-02-10  44.5\n2021-02-20  52.0'''\n"}, {"ctype": "head", "data": "4.练习"}, {"ctype": "head", "data": "练习1：统计出911数据中不同月份的电话次数"}, {"ctype": "code", "data": "# 练习1：统计出911数据中不同月份的电话次数\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfile_path = './911.csv'\ndf = pd.read_csv(file_path)\npd.set_option('display.max_rows', 30)\npd.set_option('display.max_columns', 9)\n# print(df.info())\n'''\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 249737 entries, 0 to 249736\nData columns (total 9 columns):\n #   Column     Non-Null Count   Dtype  \n---  ------     --------------   -----  \n 0   lat        249737 non-null  float64\n 1   lng        249737 non-null  float64\n 2   desc       249737 non-null  object \n 3   zip        219391 non-null  float64\n 4   title      249737 non-null  object \n 5   timeStamp  249737 non-null  object \n 6   twp        249644 non-null  object \n 7   addr       249737 non-null  object \n 8   e          249737 non-null  int64  \ndtypes: float64(3), int64(1), object(5)\nmemory usage: 17.1+ MB\nNone\n'''\n# print(df['timeStamp'])\n'''0         2015-12-10 17:10:52\n                 ...         \n249736    2017-09-20 19:42:29\nName: timeStamp, Length: 249737, dtype: object'''\ndf['timeStamp'] = pd.to_datetime(df['timeStamp'])  # 把时间字符串转为索引\n# print(df['timeStamp'])\n'''\n0        2015-12-10 17:10:52\n                 ...        \n249736   2017-09-20 19:42:29\nName: timeStamp, Length: 249737, dtype: datetime64[ns]'''\ndf.set_index('timeStamp', inplace=True)\n# print(df)\n'''\n                           lat        lng  \\\ntimeStamp                                   \n2015-12-10 17:10:52  40.297876 -75.581294   \n...                        ...        ...   \n2017-09-20 19:42:29  40.095206 -75.410735   \n\n                                                                  desc  \\\ntimeStamp                                                                \n2015-12-10 17:10:52  REINDEER CT & DEAD END;  NEW HANOVER; Station ...   \n...                                                                ...   \n2017-09-20 19:42:29  1ST AVE & MOORE RD; UPPER MERION; 2017-09-20 @...   \n\n                         zip                        title           twp  \\\ntimeStamp                                                                 \n2015-12-10 17:10:52  19525.0       EMS: BACK PAINS/INJURY   NEW HANOVER   \n...                      ...                          ...           ...   \n2017-09-20 19:42:29  19406.0  Traffic: VEHICLE ACCIDENT -  UPPER MERION   \n\n                                       addr  e  \ntimeStamp                                       \n2015-12-10 17:10:52  REINDEER CT & DEAD END  1  \n...                                     ... ..  \n2017-09-20 19:42:29      1ST AVE & MOORE RD  1  \n\n[249737 rows x 8 columns]\n'''\ncount_by_month = df.resample('M').count()['lat']\nprint(count_by_month)\n'''\ntimeStamp\n2015-12-31     7916\n2016-01-31    13096\n2016-02-29    11396\n2016-03-31    11059\n2016-04-30    11287\n2016-05-31    11374\n2016-06-30    11732\n2016-07-31    12088\n2016-08-31    11904\n2016-09-30    11669\n2016-10-31    12502\n2016-11-30    12091\n2016-12-31    12162\n2017-01-31    11605\n2017-02-28    10267\n2017-03-31    11684\n2017-04-30    11056\n2017-05-31    11719\n2017-06-30    12333\n2017-07-31    11768\n2017-08-31    11753\n2017-09-30     7276\nFreq: M, Name: lat, dtype: int64\n'''\n# 绘制折线图分析变化趋势\nx = count_by_month.index\ny = count_by_month.values\nx = [i.strftime(\"%Y%m%d\") for i in x]  # 转化为时间日期格式。\nplt.figure(figsize=(15, 8), dpi=80)\nplt.plot(range(len(x)), y)\nplt.xticks(range(len(x)), x, rotation=45)\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326144929215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "https://www.kaggle.com/uciml/pm25-data-for-five-chinese-cities"}, {"ctype": "head", "data": "练习2现在我们有北上广、深圳、和沈阳5个城市空气质量数据，请绘制出5个城市的PM2.5随时间的变化情况"}, {"ctype": "p", "data": "数据来源：https://www.kaggle.com/uciml/pm25-data-for-five-chinese-cities 观察这组数据中的时间结构，并不是字符串，这个时候我们应该怎么办？"}, {"ctype": "p", "data": "之前所学习的DatetimeIndex可以理解为时间戳 那么现在我们要学习的PeriodIndex可以理解为时间段 periods = pd.PeriodIndex(year=df[“year”],month=df[“month”],day=df[“day”],hour=df[“hour”],freq=“H”) 那么如果给这个时间段降采样呢？ data = df.set_index(periods).resample(“10D”).mean()"}, {"ctype": "code", "data": "# 现在我们有北上广、深圳、和沈阳5个城市空气质量数据，请绘制出5个城市的PM2.5随时间的变化情况\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\ndf = pd.read_csv('./PM2.5/BeijingPM20100101_20151231.csv')\n# print(df.info())\n'''\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 52584 entries, 0 to 52583\nData columns (total 18 columns):\n #   Column           Non-Null Count  Dtype  \n---  ------           --------------  -----  \n 0   No               52584 non-null  int64  \n 1   year             52584 non-null  int64  \n 2   month            52584 non-null  int64  \n 3   day              52584 non-null  int64  \n 4   hour             52584 non-null  int64  \n 5   season           52584 non-null  int64  \n 6   PM_Dongsi        25052 non-null  float64\n 7   PM_Dongsihuan    20508 non-null  float64\n 8   PM_Nongzhanguan  24931 non-null  float64\n 9   PM_US Post       50387 non-null  float64\n 10  DEWP             52579 non-null  float64\n 11  HUMI             52245 non-null  float64\n 12  PRES             52245 non-null  float64\n 13  TEMP             52579 non-null  float64\n 14  cbwd             52579 non-null  object \n 15  Iws              52579 non-null  float64\n 16  precipitation    52100 non-null  float64\n 17  Iprec            52100 non-null  float64\ndtypes: float64(11), int64(6), object(1)\nmemory usage: 7.2+ MB\nNone'''\npd.set_option('display.max_rows', 30)\npd.set_option('display.max_columns', 18)\n# print(df.head())\n'''\n   No  year  month  day  hour  season  PM_Dongsi  PM_Dongsihuan  \\\n0   1  2010      1    1     0       4        NaN            NaN   \n1   2  2010      1    1     1       4        NaN            NaN   \n2   3  2010      1    1     2       4        NaN            NaN   \n3   4  2010      1    1     3       4        NaN            NaN   \n4   5  2010      1    1     4       4        NaN            NaN   \n\n   PM_Nongzhanguan  PM_US Post  DEWP  HUMI    PRES  TEMP cbwd    Iws  \\\n0              NaN         NaN -21.0  43.0  1021.0 -11.0   NW   1.79   \n1              NaN         NaN -21.0  47.0  1020.0 -12.0   NW   4.92   \n2              NaN         NaN -21.0  43.0  1019.0 -11.0   NW   6.71   \n3              NaN         NaN -21.0  55.0  1019.0 -14.0   NW   9.84   \n4              NaN         NaN -20.0  51.0  1018.0 -12.0   NW  12.97   \n\n   precipitation  Iprec  \n0            0.0    0.0  \n1            0.0    0.0  \n2            0.0    0.0  \n3            0.0    0.0  \n4            0.0    0.0  \n'''\n# pd.PeriodIndex 把分开的时间字符串通过PeriodIndex的方法转换为pandas的时间类型\nperiods = pd.PeriodIndex(year=df[\"year\"], month=df[\"month\"], day=df[\"day\"], hour=df[\"hour\"], freq=\"H\")\n# print(periods)\n'''\nPeriodIndex(['2010-01-01 00:00', '2010-01-01 01:00', '2010-01-01 02:00',\n             '2010-01-01 03:00', '2010-01-01 04:00', '2010-01-01 05:00',\n             '2010-01-01 06:00', '2010-01-01 07:00', '2010-01-01 08:00',\n             '2010-01-01 09:00',\n             ...\n             '2015-12-31 14:00', '2015-12-31 15:00', '2015-12-31 16:00',\n             '2015-12-31 17:00', '2015-12-31 18:00', '2015-12-31 19:00',\n             '2015-12-31 20:00', '2015-12-31 21:00', '2015-12-31 22:00',\n             '2015-12-31 23:00'],\n            dtype='period[H]', length=52584, freq='H')\n'''\ndf['datetime'] = periods\ndf.set_index('datetime',inplace=True)\n# print(df.head())\n'''\n                  No  year  month  day  hour  season  PM_Dongsi  \\\ndatetime                                                          \n2010-01-01 00:00   1  2010      1    1     0       4        NaN   \n2010-01-01 01:00   2  2010      1    1     1       4        NaN   \n2010-01-01 02:00   3  2010      1    1     2       4        NaN   \n2010-01-01 03:00   4  2010      1    1     3       4        NaN   \n2010-01-01 04:00   5  2010      1    1     4       4        NaN   \n\n                  PM_Dongsihuan  PM_Nongzhanguan  PM_US Post  DEWP  HUMI  \\\ndatetime                                                                   \n2010-01-01 00:00            NaN              NaN         NaN -21.0  43.0   \n2010-01-01 01:00            NaN              NaN         NaN -21.0  47.0   \n2010-01-01 02:00            NaN              NaN         NaN -21.0  43.0   \n2010-01-01 03:00            NaN              NaN         NaN -21.0  55.0   \n2010-01-01 04:00            NaN              NaN         NaN -20.0  51.0   \n\n                    PRES  TEMP cbwd    Iws  precipitation  Iprec  \ndatetime                                                          \n2010-01-01 00:00  1021.0 -11.0   NW   1.79            0.0    0.0  \n2010-01-01 01:00  1020.0 -12.0   NW   4.92            0.0    0.0  \n2010-01-01 02:00  1019.0 -11.0   NW   6.71            0.0    0.0  \n2010-01-01 03:00  1019.0 -14.0   NW   9.84            0.0    0.0  \n2010-01-01 04:00  1018.0 -12.0   NW  12.97            0.0    0.0  \n'''\n# 进行降采样\ndf = df.resample('10D').mean()\n# 处理缺失数据\ndata = df['PM_US Post'].dropna()\n# print(data)\n'''\ndatetime\n2010-01-01 23:00    129.0\n2010-01-02 00:00    148.0\n2010-01-02 01:00    159.0\n2010-01-02 02:00    181.0\n2010-01-02 03:00    138.0\n                    ...  \n2015-12-31 19:00    133.0\n2015-12-31 20:00    169.0\n2015-12-31 21:00    203.0\n2015-12-31 22:00    212.0\n2015-12-31 23:00    235.0\nFreq: H, Name: PM_US Post, Length: 50387, dtype: float64\n'''\nx = data.index\ny = data.values\nplt.figure(figsize=(15,8),dpi=80)\nplt.plot(range(len(x)),y)\nplt.xticks(range(0,len(x),10),list(x)[::10],rotation=45)\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327151121639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "四、pandas画图"}, {"ctype": "head", "data": "1.折线图"}, {"ctype": "code", "data": "# pandas绘图\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\niris_data = pd.read_csv('iris.csv')\n# print(iris_data.info())\n'''\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 150 entries, 0 to 149\nData columns (total 5 columns):\n #   Column       Non-Null Count  Dtype  \n---  ------       --------------  -----  \n 0   SepalLength  150 non-null    float64\n 1   SepalWidth   150 non-null    float64\n 2   PetalLength  150 non-null    float64\n 3   PetalWidth   150 non-null    float64\n 4   Name         150 non-null    object \ndtypes: float64(4), object(1)\nmemory usage: 6.0+ KB\nNone\n'''\n# 折线图\niris_data.plot()\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327201648441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.分组柱状图"}, {"ctype": "code", "data": "# pandas绘图\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\niris_data = pd.read_csv('iris.csv')\n# print(iris_data.info())\n\n# 分组柱状图\niris_data.groupby('Name').mean().plot(kind='bar')\nplt.show()\n\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327202041378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.饼图"}, {"ctype": "code", "data": "# pandas绘图\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\niris_data = pd.read_csv('iris.csv')\n# print(iris_data.info())\n\n# 饼图\niris_data.groupby('Name').size().plot(kind='pie',autopct='%.2f%%')\nplt.show()\n\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327202459913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd5dXNpcg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python之无参装饰器", "作者": "小儿小儿朗", "发布时间": "2021-03-28 17:36:28", "内容": [{"ctype": "p", "data": "在讲装饰器之前，要知道以下知识点 一、储备知识点 1.*args，**kwargs"}, {"ctype": "code", "data": "def index(x,y):\n\tprint(x,y)\n\ndef wrapper(*args,**kwargs):\n\tindex(*args,**kwargs) #index(y = 222,x = 111)\nwrapper(y = 222, x = 111)\n"}, {"ctype": "p", "data": "2.名称空间与作用域：名称空间的‘嵌套’关系是在函数定义阶段，即检测语法的时候确定的。"}, {"ctype": "p", "data": "3.函数对象 可以把函数当做参数传入 可以把行数当做返回值返回"}, {"ctype": "code", "data": "def index():\n\tpass\ndef foo(func):\n\treturn func\nfoo(index)\n#不要加括号，加括号是先运行了inndex了，不要加括号！不加括号代表的是传的是函数\n"}, {"ctype": "p", "data": "4.函数的嵌套定义"}, {"ctype": "code", "data": "def outter(func):\n\tdef wrapper():\n\t\tpass\n\treturn wrapper\n"}, {"ctype": "p", "data": "闭包函数"}, {"ctype": "code", "data": "def outter():\n\tx = 111\n\tdef wrapper():\n\t\tx\n\treturn wrapper #重新回到全局\n\nf =outter()\n"}, {"ctype": "p", "data": "传参的方式一：通过参数的形式为函数体传值"}, {"ctype": "code", "data": "def wrapper():\n\tprint(1)\n\tprint(2)\n\tprint(3)\n\tx\n"}, {"ctype": "p", "data": "传参的方式二：通过闭包的函数体传值"}, {"ctype": "code", "data": "1.\ndef outter(x):\n\t#x=1\n\tdef wrapper():\n\t\tprint(1)\n\t\tprint(2)\n\t\tprint(3)\n\t\tx\n\treturn wrapper\n\t#return outter内的wrapper那个函数的内存地址\n\nf1 = outter(1)\nf2 = outter(2)\nf3 = outter(3)\n\nwrapper = outter(1)\n\n2.\ndef outter(x):\n\t#x=11\n\tdef wrapper():\n\t\tx\n\treturn wrapper\n\nwrapper = outter(1)\n"}, {"ctype": "p", "data": "二、装饰器 1.什么是装饰器？ 器指的是工具，可以定义成函数 装饰指的是为其他事物添加额外的东西点缀 合在一起： 装饰器指的是定义一个函数，该函数是用来为其他函数添加额外的功能"}, {"ctype": "p", "data": "2.为什么要用装饰器？ 开放封闭原则 开放：指的是对拓展功能是开放的 封闭：指的是对修改源代码是封闭的 装饰器就是在不修改被装饰器对象源代码以及调用方式的前提下为被装饰对象添加新功能"}, {"ctype": "p", "data": "3.如何用？"}, {"ctype": "p", "data": "需求：在不修改index函数的源代码以及调用方式的前提下为其添加统计运行时间的功能"}, {"ctype": "code", "data": "def index(x,y):\n\tprint('index %s %s'%(x,y))\n\nindex(111,222,)\nindex(x=111,y=222)\n"}, {"ctype": "p", "data": "方案一：失败 问题：没有修改被装饰对象的调用方式，但是修改了其源代码"}, {"ctype": "code", "data": "import time\ndef index(x,y):\n\tstart = time.time()\n\ttime.sleep(3)\n\tprint('index %s %s' %(x,y))\n\tstop = time.time()\n\tprint(stop - start)\n\nindex(111,222)\n"}, {"ctype": "p", "data": "方案二： 问题：没有修改被装饰对象的调用方式，也没有修改其源代码，并且加上了新功能，但是代码冗余。"}, {"ctype": "code", "data": "import time\ndef index(x,y):\n\ttime.sleep(3)\n\tprint('index %s %s' %(x,y))\n\nstart = time.time()\nindex(111,222)\nstop = time.time()\nprint(stop-start)\n#多次使用造成的代码冗余\nstart = time.time()\nindex(111,222)\nstop = time.time()\nprint(stop-start)\n\nstart = time.time()\nindex(111,222)\nstop = time.time()\nprint(stop-start)\n\nstart = time.time()\nindex(111,222)\nstop = time.time()\nprint(stop-start)\n"}, {"ctype": "p", "data": "方案三： 问题：解决了方案二代码冗余的问题，但是带来了一个新问题，函数的调用方式改变了"}, {"ctype": "code", "data": "import time\ndef index(x,y):\n\ttime.sleep(3)\n\tprint('index %s %s' %(x,y))\n\ndef wrapper():\n\tstart = time.time()\n\tindex(111,222)\n\tstop = time.time()\n\tprint(stop - start)\n\nwrapper()\n"}, {"ctype": "p", "data": "方案三的优化一：将index的参数写活了"}, {"ctype": "code", "data": "import time\ndef index(x,y,z):\n\ttime.sleep(3)\n\tprint('index %s %s %s' %(x,y,z))\n\ndef wrapper(*args,**kwargs):\n\tstart = time.time()\n\tindex(*args,**kwargs)\n\tstop = time.time()\n\tprint(stop - start)\n\nwrapper(111,222,333)\nwrapper(333,y = 444,z=555)\n"}, {"ctype": "p", "data": "方案三的优化二：在优化一的基础上把被装饰对象写活了，原来只能装饰index"}, {"ctype": "code", "data": "import time\ndef index(x,y,z):\n\ttime.sleep(3)\n\tprint('index %s %s %s' %(x,y,z))\n\ndef home(name):\n\ttime.sleep(2)\n\tprint('welcome %s to home page' % name)\n\ndef outter(func): #func = index的内存地址\n\t#func=index的内存地址\n\tdef wrapper(*args,**kwargs):\n\t\tstart = time.time()\n\t\tfunc(*args,**kwargs) #index的内存地址（）\n\t\tstop = time.time()\n\t\tprint(stop - start)\n\treturn wrapper\nindex = outter(index) #f = outter(index的内存地址）\n#index = 当初那个wrapper函数的内存地址\nindex(x = 1, y= 2, z= 3)\n"}, {"ctype": "p", "data": "方案三的优化三：将wrapper做的跟被装饰对象一模一样，以假乱真"}, {"ctype": "code", "data": "import time\ndef index(x,y,z):\n\ttime.sleep(3)\n\tprint('index %s %s %s' %(x,y,z))\ndef home(name):\n\ttime.sleep(2)\n\tprint('welcome %s to home page' % name)\n\treturn 123\ndef outter(func): \n\tdef wrapper(*args,**kwargs):\n\t\tstart = time.time()\n\t\tres = func(*args,**kwargs) \n\t\tstop = time.time()\n\t\tprint(stop - start)\n\t\treturn res\n\treturn wrapper\n#偷梁换柱:home这个名字指向的wrapper函数的内存地址\nhome = outter(home)\nres = home('egon')\nprint('返回值-->',res)\n"}, {"ctype": "p", "data": "语法糖：让你开心的糖"}, {"ctype": "code", "data": "import time\n##装饰器\ndef timmer(func):\n\tdef wrapper(*args,**kwargs):\n\t\tstart = time.time()\n\t\tres = func(*args,**kwargs) \n\t\tstop = time.time()\n\t\tprint(stop - start)\n\t\treturn res\n\treturn wrapper\n\t\n##在被装饰对象正上方单独的以行写@装饰器名字及\n@timmer  #index = timmer(index)\ndef home(name):\n\ttime.sleep(2)\n\tprint('welcome %s to home page' % name)\n\treturn 123\n\n #偷梁换柱：home这个名字指向的wrapper函数的内存地址\n#\n index (x = 1, y = 2, z = 3)\n home('egon')\n"}], "cate": "Python"}
{"题目": "爬虫的第一个入门小例子 —— 爬取作者主页的文章标题", "作者": "养猪去", "发布时间": "2021-03-28 01:30:16", "内容": [{"ctype": "p", "data": "作者的官网：传送门"}, {"ctype": "p", "data": "必须安装三个拓展的包：requests、BeautifulSoup、lxml"}, {"ctype": "head", "data": "案例一"}, {"ctype": "p", "data": "工具方法，返回一个随机的请求头（防止被服务器封掉）。"}, {"ctype": "code", "data": "import random\n\nuser_agent = [\n    \"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50\",\n    \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50\",\n    \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0\",\n    \"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; InfoPath.3; rv:11.0) like Gecko\",\n    \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)\",\n    \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\",\n    \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\",\n    \"Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\",\n    \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11\",\n    \"Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\",\n    \"Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\",\n    \"Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\",\n    \"Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\",\n    \"Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\",\n    \"MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\",\n    \"Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10\",\n    \"Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13\",\n    \"Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+\",\n    \"Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0\",\n    \"Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124\",\n    \"Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)\",\n    \"UCWEB7.0.2.37/28/999\",\n    \"NOKIA5700/ UCWEB7.0.2.37/28/999\",\n    \"Openwave/ UCWEB7.0.2.37/28/999\",\n    \"Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999\",\n    # iPhone 6：\n\t\"Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25\",\n\n]\n\n# 随机获取一个请求头\ndef getHeader():\n    return {'User-Agent': random.choice(user_agent)}\n"}, {"ctype": "code", "data": "import requests\nfrom util.randomHeaders import getHeader\nfrom bs4 import BeautifulSoup\nlink = \"http://www.santostang.com/\"\nheaders = getHeader()\nr = requests.get(link,headers = headers)\nsoup = BeautifulSoup(r.text,\"lxml\")\ntitle_list = []\n\n# 下面的信息可以从html代码里看到，chrome检查元素即可。\n# 提取页面中所有的 class为 post-title 的 h1标签\nh1_list = soup.find_all(\"h1\",class_=\"post-title\")\nfor div in h1_list:\n    # h1 标签下有个 a 标签\n    title_list.append(div.a.text.strip())\nfor title in title_list:\n    print(title)\n"}], "cate": "Python"}
{"题目": "在Anaconda上给sklearn一个家(环境部署,赶紧把机器学习给我支棱起来！)", "作者": "钧桐", "发布时间": "2021-03-27 15:02:38", "内容": [{"ctype": "head", "data": "我们为什么要使用sklearn"}, {"ctype": "p", "data": "scikit-learn 是基于 Python 语言的机器学习工具"}, {"ctype": "head", "data": "我们为什么选择anaconda"}, {"ctype": "p", "data": "Anaconda的优点总结起来就八个字：省时省心、分析利器。"}, {"ctype": "p", "data": "anaconda的下载网上很多，大家自行解决！"}, {"ctype": "head", "data": "创建一个sklearn的虚拟环境"}, {"ctype": "p", "data": "那我们现在就开始在sklearn上面创建一个sklearn的虚拟环境吧！"}, {"ctype": "head", "data": "在conda上新建一个虚拟环境"}, {"ctype": "p", "data": "condacreate-n 环境名 python=版本号 如：我们创建的这个环境叫做machine-learning，python版本是3.6；"}, {"ctype": "code", "data": "conda create -n machine-learning python=3.6\n"}, {"ctype": "head", "data": "查看虚拟环境的包list"}, {"ctype": "p", "data": "首先，我们要激活环境"}, {"ctype": "code", "data": "conda activate 环境名\n"}, {"ctype": "p", "data": "然后我们可以调用list"}, {"ctype": "code", "data": "conda list\n"}, {"ctype": "p", "data": " 这是初始环境的包"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327145755261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTM2ODMy,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "下载对应所需的包"}, {"ctype": "p", "data": "我们需要下载的包有 numpy scipy scikit-learn"}, {"ctype": "code", "data": "pip install numpy\npip install scipy\npip3 install -U scikit-learn # 这是3.+版本的安装命令\n"}, {"ctype": "p", "data": " 安装后，我们查看list的结果 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032714582125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTM2ODMy,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "这样我们就在anaconda上创建了一个可以使用sklearn的虚拟环境了！"}, {"ctype": "head", "data": "如何在notebook运行sklearn请看这里"}, {"ctype": "p", "data": "在Jupyter-notebook上给sklearn办理入住手续"}], "cate": "Python"}
{"题目": "C语言运算符（算术，关系，逻辑，赋值，自增运算符， 三目运算符，逗号表达式）", "作者": "留白(●—●)", "发布时间": "2021-03-28 13:11:07", "内容": [{"ctype": "head", "data": "（1）算术运算符"}, {"ctype": "p", "data": "＋(加), －(减) , *(乘) , /(除) , %(求余)"}, {"ctype": "head", "data": "除法运算的注意事项"}, {"ctype": "p", "data": "被除数和除数都是int类型，则商一定是整数（原因：如果商是小数，结果会自动舍去小数点后面的数字） 例如： 16 / 4 = 4 16 / 5 = 3被除数和除数只要有一个是float类型，则商也是小数（原因：如果商是小数，结果也会保留小数点后面的数字） 例如: 16 / 4.0 = 4.0 16.0 / 4 = 4.0 16.0 / 5 = 3.2 16 / 5.0 = 3.2"}, {"ctype": "p", "data": "典型例题：求s = 1 + 1/2 + 1/3 + …+1/100的值"}, {"ctype": "head", "data": "求余运算的注意事项"}, {"ctype": "p", "data": "验证的小例子:"}, {"ctype": "code", "data": "#include <stdio.h>\nint main (void)\n{\n\tprintf (\"%d\", 13%3);//结果：1 \n\tprintf (\"%d\", -13%3);//结果：-1 \n\tprintf (\"%d\", 13%-3);//结果：1 \n } \n"}, {"ctype": "head", "data": "（2）关系运算符"}, {"ctype": "p", "data": "<(小于)， >(大于)， ==（等于）， !=(不等于)， ＜=(小于等于) ， >=(大于等于)"}, {"ctype": "p", "data": "\"=“与”==\"的区别： \"=\"的意思是将右边的东西赋值给左边"}, {"ctype": "p", "data": "而\"==\"的意思就是数学意义上的等于"}, {"ctype": "head", "data": "（3）逻辑运算符"}, {"ctype": "p", "data": "||(或) , &&(且), !（非）"}, {"ctype": "p", "data": "该逻辑运算符与数学的或且非符号对真假的判定方法一致"}, {"ctype": "p", "data": "C语言对真假的处理:"}, {"ctype": "p", "data": "（1）验证的小例子:"}, {"ctype": "code", "data": "#include <stdio.h>\nint main (void)\n{\n\tif (1)\n\tprintf (\"哈哈\");\n\tif (-5)\n\tprintf (\"嘻嘻\");\n\tif (0)\n\tprintf (\"呵呵\"); \n } \n //结果:哈哈嘻嘻 \n  \n"}, {"ctype": "p", "data": "（2）验证的小例子："}, {"ctype": "code", "data": "#include <stdio.h>\nint main (void)\n{\n\tint a,b;\n\ta = (3>2) && (5<4);//整体为假\n\tb = (3>2) || (5<4);//整体为真\n\tprintf (\"a=%d\", a);//结果：a=0 \n\tprintf (\"b=%d\", b);//结果：b=1 \n } \n \n"}, {"ctype": "head", "data": "（4）赋值运算符"}, {"ctype": "p", "data": "＝ , ＋＝ , －＝ , *＝, /＝"}, {"ctype": "p", "data": "对于a ＋= 3；它等价于 a = a＋3； 对于a *= 3；它等价于 a = a * 3；"}, {"ctype": "p", "data": "优先级别：算术>关系>逻辑>赋值"}, {"ctype": "head", "data": "（5）自增运算符"}, {"ctype": "head", "data": "前自增和后自增的相同点及不同点"}, {"ctype": "p", "data": "前自增 ++i ，后自增 i++ 相同点：都使i的值加1 不同点： 前自增使表达式的值为i+1之后的值 后自增使表达式的值为i+1之前的值 验证的小例子："}, {"ctype": "code", "data": "#include <stdio.h>\nint main (void)\n{\n\tint a, b, c;\n\ta = 5;\n\tb = a++;\n\tc = ++a;\n\tprintf (\"a=%d\", a);//结果：a=7（前自增和后自增使a加了两次1） \n\tprintf (\"b=%d\", b);//结果：b=5 (后自增使b的值为a+1之前的值)\n\tprintf (\"c=%d\", c);//结果：c=7 （前自增使c的值为a+1之后的值）\n } \n \n"}, {"ctype": "head", "data": "使用该运算符的注意事项"}, {"ctype": "p", "data": "该运算符应单独使用，不要将它作为表达式的一部分 使用时应屏蔽掉前自增和后自增的差别"}, {"ctype": "head", "data": "使用该运算符的好处"}, {"ctype": "p", "data": "使代码更简练 该运算符的运算速度更快"}, {"ctype": "head", "data": "（6）三目运算符"}, {"ctype": "p", "data": "格式：（A ? B : C） 等价于 if （A） B； else C； 即如果式子A成立，则执行B；如果不成立，则执行C"}, {"ctype": "p", "data": "验证的小例子："}, {"ctype": "code", "data": "#include <stdio.h>\nint main (void)\n{\n\tint a = 1;\n\tint b = -1;\n\t(a>0 ? a++ : a--) ;\n\t(b>0 ? b++ : b--);\n\tprintf (\"a=%d\", a);//结果：a=2 \n\tprintf (\"b=%d\", b);//结果：b=-2 \n } \n"}, {"ctype": "head", "data": "（7）逗号表达式"}, {"ctype": "p", "data": "格式：（A，B，C，D） 功能：从左到右执行 最终表达式的值为最后一个式子的值 验证小例子："}, {"ctype": "code", "data": "#include <stdio.h>\nint main (void)\n{\n\tint i, j;\n\ti = 2;\n\tj = (i++, i+3, i++, i-1);\n\tprintf (\"j=%d\", j);//结果：j=3 \n } \n"}], "cate": "Python"}
{"题目": "python学习笔记（四）——流程控制", "作者": "别呀", "发布时间": "2021-03-27 22:47:02", "内容": [{"ctype": "head", "data": "条件语句"}, {"ctype": "p", "data": "Python 条件语句跟其他语言基本一致的，都是通过一条或多条语句的执行结果（ True 或者 False ）来决定执行的代码块。"}, {"ctype": "p", "data": "Python 程序语言指定任何非 0 和非空（null）值为 True，0 或者 null 为 False。"}, {"ctype": "head", "data": "if语句的基本形式"}, {"ctype": "p", "data": "Python 中，if 语句的基本形式如下："}, {"ctype": "code", "data": "if 判断条件：\n    执行语句……\nelse：\n    执行语句……\n"}, {"ctype": "p", "data": "Python 语言有着严格的缩进要求，因此这里也需要注意缩进，也不要少写了冒号 :"}, {"ctype": "p", "data": "if 语句的判断条件可以用>（大于）、<(小于)、==（等于）、>=（大于等于）、<=（小于等于）来表示其关系。 示例："}, {"ctype": "code", "data": "results=59\nif results>=60:\n    print ('及格')\nelse :\n    print ('不及格')\n \n 运行结果：\n 不及格\n"}, {"ctype": "p", "data": "上面也说到，非零数值、非空字符串、非空 list 等，判断为 True，否则为 False。因此也可以这样写："}, {"ctype": "code", "data": "num = 6\nif num:\n    print('Hello Python')\n    \n运行结果：\nHello Python\n"}, {"ctype": "p", "data": "那如果我们把 num 改为空字符串呢？"}, {"ctype": "code", "data": "if '':\n    print('hello python')\n"}, {"ctype": "p", "data": "很明显，空字符串是为 False 的，不符合条件语句，因此不会执行到 print('Hello Python') 这段代码。"}, {"ctype": "p", "data": "注意：在条件判断代码中的冒号 : 后、下一行内容是一定要缩进的。不缩进是会报错的。冒号和缩进是一种语法。它会帮助 Python 区分代码之间的层次，理解条件执行的逻辑及先后顺序。"}, {"ctype": "head", "data": "if语句多个判断条件的形式"}, {"ctype": "p", "data": "有些时候，我们的判断语句不可能只有两个，有些时候需要多个，比如上面的例子中大于 60 的为及格，那我们还要判断大于 90 的为优秀，在 80 到 90 之间的良好呢？"}, {"ctype": "p", "data": "这时候需要用到 if 语句多个判断条件，"}, {"ctype": "p", "data": "语法格式："}, {"ctype": "code", "data": "if 判断条件1:\n    执行语句1……\nelif 判断条件2:\n    执行语句2……\nelif 判断条件3:\n    执行语句3……\nelse:\n    执行语句4……\n"}, {"ctype": "p", "data": "实例："}, {"ctype": "code", "data": "results = 89\n\nif results > 90:\n    print('优秀')\nelif results > 80:\n    print('良好')\nelif results > 60:\n    print ('及格')\nelse :\n    print ('不及格')\n运行结果：\n良好\n"}, {"ctype": "head", "data": "if语句多个条件同时判断"}, {"ctype": "p", "data": "有时候我们会遇到多个条件的时候该怎么操作呢？"}, {"ctype": "p", "data": "比如说要求 java 和 python 的考试成绩要大于 80 分的时候才算优秀，这时候该怎么做？"}, {"ctype": "p", "data": "这时候我们可以结合 or 和 and 来使用。"}, {"ctype": "p", "data": "or （或）表示两个条件有一个成立时判断条件成功"}, {"ctype": "p", "data": "and （与）表示只有两个条件同时成立的情况下，判断条件才成功。"}, {"ctype": "p", "data": "例如："}, {"ctype": "code", "data": "java = 86\npython = 68\n\nif java > 80 and  python > 80:\n    print('优秀')\nelse :\n    print('不优秀')\n\nif ( java >= 80  and java < 90 )  or ( python >= 80 and python < 90):\n    print('良好')\n    \n输出结果：\n不优秀\n良好\n"}, {"ctype": "p", "data": "注意：if 有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于 >（大于）、<（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。"}, {"ctype": "head", "data": "if嵌套"}, {"ctype": "p", "data": "if 嵌套是指什么呢？"}, {"ctype": "p", "data": "就跟字面意思差不多，指 if 语句中可以嵌套 if 语句。"}, {"ctype": "p", "data": "比如上面说到的例子，也可以用 if 嵌套来写。"}, {"ctype": "p", "data": "示例："}, {"ctype": "code", "data": "a = 81\nb = 20\n\nif a > 80:\n    if b > 90:\n        print('优秀')\n    else:\n        print('及格')\nelse:\n    print('差')\n\n输出结果：\n及格\n"}, {"ctype": "p", "data": "当然这只是为了说明 if 条件语句是可以嵌套的。如果是这个需求，还是不太建议这样使用 if 嵌套的，因为这样代码量多了，而且嵌套太多，也不方便阅读代码。"}, {"ctype": "p", "data": "默认从上向下执行，先整体扫描一下，没有语法错误才会执行。"}, {"ctype": "p", "data": "代码示例："}, {"ctype": "code", "data": "a=int(input('请输入您的身高(cm)：'))\nif a>=179:\n    print('男神身高')\nelif a == 178:\n\tprint('标准身高')\nelif 160 < a < 178:\n\tprint('中等身高')\nelse:\n\tprint('身高不可说')\n\n运行示例：\n请输入您的身高(cm)：181\n男神身高\n"}, {"ctype": "head", "data": "三目运算（语法糖）"}, {"ctype": "p", "data": "语法糖：糖衣语法 英国计算机科学家彼得·约翰·兰达，通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。"}, {"ctype": "p", "data": "语法格式：值1 if 判断语句 else 值2 （解释：语句成立 执行值1 不成立 执行值2）"}, {"ctype": "code", "data": "a = 4\nif a > 5:\n    print(True)\nelse:\n    print(False)\n    \n# 三目运算符 \nprint(True) if a>5 else print(False)\nb = True if a > 5 else False\n\n执行结果：\nFalse\nFalse\n\n# 糖->节省代码格式\n# 装饰器\n"}, {"ctype": "head", "data": "循环语句"}, {"ctype": "p", "data": "一般编程语言都有循环语句，为什么呢？ 那就问一下自己，我们弄程序是为了干什么？ 那肯定是为了方便我们工作，优化我们的工作效率啊。而计算机和人类不同，计算机不怕苦也不怕累，也不需要休息，可以一直做。你要知道，计算机最擅长就是做重复的事情。所以这时候需要用到循环语句，循环语句允许我们执行一个语句或语句组多次。"}, {"ctype": "p", "data": "在 Python 提供了 for 循环和 while 循环。 这里又有一个问题了，如果我想让他运行了一百次之后停止，那该怎么做呢？ 这时候需要用到一些控制循环的语句："}, {"ctype": "table", "data": "循环控制语句描述break终止循环，并且跳出整个循环continue终止当前循环，跳出该次循环，执行下一次循环passpass 是空语句，是为了保持程序结构的完整性"}, {"ctype": "p", "data": "这些控制语句是为了让我们告诉程序什么时候停止，什么时候不运行这次循环。"}, {"ctype": "head", "data": "while循环"}, {"ctype": "p", "data": "While 循环和 for 循环的作用是一样的。"}, {"ctype": "p", "data": "我们先来看看 While 循环语句的样子。"}, {"ctype": "code", "data": "# 计算1-100 的和。高斯求和\ncount = 1\nsum1 = 0\nwhile count<=100:\n    sum1 = sum1+ count\n    count = count + 1\nprint(sum1)\n\n执行结果：\n5050\n"}, {"ctype": "p", "data": "while 循环嵌套语法"}, {"ctype": "code", "data": "while expression:\n   while expression:\n      statement(s)\n   statement(s)\n"}, {"ctype": "p", "data": "有时候，我们只想统计 1 到 100 之间的奇数和，那么也就是说当 count 是偶数，也就是双数的时候，我们需要跳出当次的循环，不想加，这时候可以用到 break，例如："}, {"ctype": "code", "data": "count = 1\nsum = 0\nwhile (count <= 100):\n    if ( count % 2 == 0):  # 双数时跳过输出\n        count = count + 1\n        continue\n    sum = sum + count\n    count = count + 1\nprint(sum)\n\n执行结果：\n2500\n"}, {"ctype": "head", "data": "for迭代循环"}, {"ctype": "p", "data": "基本的语法格式："}, {"ctype": "code", "data": "for iterating_var in sequence:\n   statements(s)\n#sequence:可迭代对象\n"}, {"ctype": "p", "data": "那么我们根据这个基本语法格式，随便写个例子测试一下："}, {"ctype": "code", "data": "for i in 'hello':\n    print(i)\n\n执行结果：\nh\ne\nl\nl\no\n"}, {"ctype": "p", "data": "从打印结果来看，它就是把字符串 hello 一个一个字符的打印出来。"}, {"ctype": "p", "data": "那如果我们把字符串换为字典 dict 呢？"}, {"ctype": "code", "data": "dict1 = {'name':'李四','age':'18','from':'福建'}\nfor i in dict1:# i 是key\n    print(i+':',dict1[i])\n\n执行结果：\nname: 李四\nage: 18\nfrom: 福建\n"}, {"ctype": "p", "data": "for遍历列表去双元素实例："}, {"ctype": "code", "data": "#取列表值——遍历列表\n#双元素\nl = [(1, 2), (3, 4), (5, 6)]\nfor x, y in l:\n    print(x, y)\n\nl = [(1, 2), (3, 4), (5, 6)]\nfor x, y in enumerate(l):\n    print(x, y)\n\n执行结果：\n1 2\n3 4\n5 6\n0 (1, 2)\n1 (3, 4)\n2 (5, 6)\n"}, {"ctype": "p", "data": "for 循环嵌套语法"}, {"ctype": "p", "data": "实例："}, {"ctype": "code", "data": "for num in range(10,15):  # 迭代 10 到 20 之间的数字\n   for i in range(2,num): # 根据因子迭代\n      if num%i == 0:      # 确定第一个因子\n         j=num/i          # 计算第二个因子\n         print ('%d 是一个合数' % num)\n         break            # 跳出当前循环\n   else:                  # 循环的 else 部分\n      print ('%d 是一个质数' % num)\n\n执行结果：\n10 是一个合数\n11 是一个质数\n12 是一个合数\n13 是一个质数\n14 是一个合数\n"}, {"ctype": "p", "data": "当然，这里还用到了 for … else 语句。"}, {"ctype": "p", "data": "其实 for 循环中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 通过 break终止循环，就不会执行else中的语句）的情况下执行。"}, {"ctype": "p", "data": "当然有 for … else ，也会有 while … else 。他们的意思都是一样的。"}, {"ctype": "head", "data": "range()函数"}, {"ctype": "p", "data": "or 循环还常常和 range() 函数搭配使用的。"}, {"ctype": "p", "data": "如果不知道 range() 函数 , 我们直接通过一段程序来理解。"}, {"ctype": "code", "data": "for i in range(3):\n    print(i)\n\n执行结果：\n0\n1\n2\n"}, {"ctype": "p", "data": "使用 range(x) 函数，就可以生成一个从 0 到 x-1 的整数序列。"}, {"ctype": "p", "data": "如果是 range(a,b) 函数，你可以生成了一个左闭右开的整数序列。"}, {"ctype": "p", "data": "其实例子中的 range(3) 可以写成 range(0,3), 结果是一样的。"}, {"ctype": "p", "data": "其实使用 range() 函数，我们更多是为了把一段代码重复运行 n 次。"}, {"ctype": "p", "data": "这里提个问题，你仔细观察 range() 函数，上面说到的不管是 1 个参数的，还是 2 个参数的都有什么共同的特点？"}, {"ctype": "p", "data": "不知道你们有没有发现，他都是每次递增 1 的。"}, {"ctype": "p", "data": "range(3) 就是 0 ，1，2 ，每次递增 1 。"}, {"ctype": "p", "data": "range(3,6) 就是 3 ，4 ，5 ，也是每次递增 1 的。"}, {"ctype": "p", "data": "那能不能每次不递增 1 呢？"}, {"ctype": "p", "data": "比如我想递增 2 呢？"}, {"ctype": "p", "data": "在程序的编写中，肯定会遇到这样的需求的。而 python 发展至今，range 函数肯定也会有这种功能。"}, {"ctype": "p", "data": "所以 range 函数还有一个三个参数的。"}, {"ctype": "p", "data": "比如 range(0,10,2) , 它的意思是：从 0 数到 10（不取 10 ），每次间隔为 2 。"}, {"ctype": "head", "data": "for循环和while循环的区别"}, {"ctype": "p", "data": "之前也提到过了，如果一种语法能表示一个功能，那没必要弄两种语法来表示。"}, {"ctype": "p", "data": "既然都是循环，for 循环和 while 循环肯定有他们的区别的。"}, {"ctype": "p", "data": "那什么时候才使用 for 循环和 while 循环呢？"}, {"ctype": "p", "data": "for和while可以互用实例："}, {"ctype": "code", "data": "for i in range(0, 10):\n    print(i)\n\n\ni = 0\nwhile i < 10:\n    print(i)\n    i = i + 1\n"}, {"ctype": "head", "data": "案例"}, {"ctype": "p", "data": "1、打印九九乘法表"}, {"ctype": "code", "data": "# 打印九九乘法表\nfor i in range(1, 10):\n        for j in range(1, i+1):\n            # 打印语句中，大括号及其里面的字符 (称作格式化字段) 将会被 .format() 中的参数替换,注意有个点的\n            print('{}x{}={}\\t'.format(i, j, i*j), end='')  \n        print() #这里有换行的意思\n"}, {"ctype": "p", "data": "执行结果："}, {"ctype": "code", "data": "1x1=1\t\n2x1=2\t2x2=4\t\n3x1=3\t3x2=6\t3x3=9\t\n4x1=4\t4x2=8\t4x3=12\t4x4=16\t\n5x1=5\t5x2=10\t5x3=15\t5x4=20\t5x5=25\t\n6x1=6\t6x2=12\t6x3=18\t6x4=24\t6x5=30\t6x6=36\t\n7x1=7\t7x2=14\t7x3=21\t7x4=28\t7x5=35\t7x6=42\t7x7=49\t\n8x1=8\t8x2=16\t8x3=24\t8x4=32\t8x5=40\t8x6=48\t8x7=56\t8x8=64\t\n9x1=9\t9x2=18\t9x3=27\t9x4=36\t9x5=45\t9x6=54\t9x7=63\t9x8=72\t9x9=81\t\n"}, {"ctype": "p", "data": "2、判断是否是闰年"}, {"ctype": "code", "data": "# 判断是否是闰年\nyear = int(input(\"请输入一个年份: \"))\nif (year % 4) == 0 and (year % 100) != 0 or (year % 400) == 0:\n    print('{0} 是闰年' .format(year))\nelse:\n     print('{0} 不是闰年' .format(year))\n"}, {"ctype": "p", "data": "执行示例结果："}, {"ctype": "code", "data": "请输入一个年份: 2020\n2020 是闰年\n"}], "cate": "Python"}
{"题目": "python    random 模块", "作者": "weixin_49213878", "发布时间": "2021-03-27 20:47:09", "内容": [{"ctype": "p", "data": "随机数 Python 没有 random() 函数来创建随机数，但 Python 有一个名为 random 的内置模块，可用于生成随机数："}, {"ctype": "p", "data": "实例 导入 random 模块，并显示 1 到 9 之间的随机数："}, {"ctype": "code", "data": "import random\n\nprint(random.randrange(1,10))\n"}, {"ctype": "p", "data": "Python 有一个可用于制作随机数的内建模块。"}, {"ctype": "p", "data": "random 模块有一组如下的方法："}, {"ctype": "p", "data": "方法 描述 seed() 初始化随机数生成器。 getstate() 返回随机数生成器的当前内部状态。 setstate() 恢复随机数生成器的内部状态。 getrandbits() 返回表示随机位的数字。 randrange() 返回给定范围之间的随机数。 randint() 返回给定范围之间的随机数。 choice() 返回给定序列中的随机元素。 choices() 返回一个列表，其中包含给定序列中的随机选择。 shuffle() 接受一个序列，并以随机顺序返回此序列。 sample() 返回序列的给定样本。 random() 返回 0 与 1 之间的浮点数。 uniform() 返回两个给定参数之间的随机浮点数。 triangular() 返回两个给定参数之间的随机浮点数，您还可以设置模式参数以指定其他两个参数之间的中点。 betavariate() 基于 Beta 分布（用于统计学）返回 0 到 1 之间的随机浮点数。 expovariate() 基于指数分布（用于统计学），返回 0 到 1 之间的随机浮点数，如果参数为负，则返回 0 到 -1 之间的随机浮点数。 gammavariate() 基于 Gamma 分布（用于统计学）返回 0 到 1 之间的随机浮点数。 gauss() 基于高斯分布（用于概率论）返回 0 到 1 之间的随机浮点数。 lognormvariate() 基于对数正态分布（用于概率论）返回 0 到 1 之间的随机浮点数。 normalvariate() 基于正态分布（用于概率论）返回 0 到 1 之间的随机浮点数。 vonmisesvariate() 基于 von Mises 分布（用于定向统计学）返回 0 到 1 之间的随机浮点数。 paretovariate() 基于 Pareto 分布（用于概率论）返回 0 到 1 之间的随机浮点数。 weibullvariate() 基于 Weibull 分布（用于统计学）返回 0 到 1 之间的随机浮点数。"}], "cate": "Python"}
{"题目": "selenium の demo", "作者": "Sunny_Future", "发布时间": "2021-03-28 19:47:48", "内容": [{"ctype": "head", "data": "1、selenium 概述"}, {"ctype": "p", "data": "Selenium 是web自动化测试工具集，包括IDE、Grid、RC（selenium 1.0）、WebDriver（selenium 2.0）等。"}, {"ctype": "head", "data": "2、环境部署 （Chrome）"}, {"ctype": "code", "data": "pip install selenium\n"}, {"ctype": "head", "data": "2.1 查看 浏览器版本"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328193537374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bm55X0Z1dHVyZQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.2 下载驱动"}, {"ctype": "p", "data": "链接如下："}, {"ctype": "head", "data": "2.3 win：python36\\Scripts"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328194354953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bm55X0Z1dHVyZQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.4 mac or linux：bin/"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328194458754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bm55X0Z1dHVyZQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3、demo：模拟 百度搜索 关键字"}, {"ctype": "code", "data": "import time\nfrom selenium import webdriver\n\n\nbrowser = webdriver.Chrome()\n\nbrowser.get(\"http://www.baidu.com\")\nbrowser.find_element_by_id(\"kw\").send_keys(\"selenium\")\nbrowser.find_element_by_id(\"su\").click()\nprint(browser.title)\ntime.sleep(5)\nbrowser.quit()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328194717275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bm55X0Z1dHVyZQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4、文档"}], "cate": "Python"}
{"题目": "python对文档的操作 异常处理，os读取选定文件夹目录内容。", "作者": "普普通通研究生学代码", "发布时间": "2021-03-28 22:59:24", "内容": [{"ctype": "head", "data": "python对文档的操作 异常处理，os读取选定文件夹目录内容。"}, {"ctype": "code", "data": "def read_file_name():\n    file_path=r'D:\\Program Files\\untitled3'\n    file_name=[]\n    for i in os.listdir(file_path):\n\n        file_name.append(i)\n    \n    return file_name\n\n\n"}, {"ctype": "p", "data": "file_name 返回当前文件夹的内部文件形成list列表。"}, {"ctype": "p", "data": "工程中读取文件夹许多文件会出现编码不一致，可以用："}, {"ctype": "code", "data": "    ##i 循环得到list中每一个表名字然后循环读取进行操作，error_bad_lines=False可以处理\n    for i in file_name:\n          path='D:/Program Files/untitled3/'+i\n\n          try:\n              content = pd.read_csv(path, encoding='utf-8',error_bad_lines=False)\n\n          except:\n              content = pd.read_csv(path, encoding='gbk',error_bad_lines=False)\n"}], "cate": "Python"}
{"题目": "Python：虚拟环境", "作者": "weixin_42161670", "发布时间": "2021-03-27 16:10:23", "内容": [{"ctype": "head", "data": "一.为什么要安装虚拟环境"}, {"ctype": "p", "data": "我在虚拟机家目录下创建了两个文件夹，分别是projects下的pa和pb(ls ～/projects)，代表着pa和pb两个项目 假设pa这个项目需要requests框架，pb项目需要flask框架，那么进行框架的安装后（pip3 install requests , pip3 install flask） requests框架和flask框架会安装到统一的路径（/usr/local/lib/python3.6/site-packages），那么这样就无法对pa，pb两个项目进行分开管理，所以需要安装虚拟环境，实现pa项目和pb项目分别管理自己的框架，二者互不干扰，互不影响"}, {"ctype": "p", "data": "如果还是觉得懵逼的话，看下面图解便一目了然啦："}, {"ctype": "p", "data": "创建虚拟环境前  创建虚拟环境后 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032711304374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE2MTY3MA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "二.配置虚拟环境"}, {"ctype": "p", "data": "安装虚拟环境virtualenv pip3 install virtualenv安装管理虚拟环境的virtualenvwrapper pip3 install virtualenvwrapper配置virtualenvwrapper vim ~/.bashrc,添加以下三行代码 export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.6 # 指定新虚拟环境默认的Python版本 export WORKON_HOME=~/.envs #v指定创建新的虚拟环境保存在哪个文件夹下 source /usr/local/bin/virtualenvwrapper.sh  # 执行virtualenvwrapper.sh脚本创建虚拟环境 cd ～/projects/pa virtualenv pa  # pa为自定义名称激活虚拟环境 source ~/projects/pa/pa/bin/activate  # pa为第2步里自定义的虚拟环境名称退出虚拟环境 deactive切换虚拟环境 workon pa导出freee文件 cd ~/projects/pa pip freeze > requirements.txt"}, {"ctype": "p", "data": "⚠️以后实际进行项目交付时，不会将框架一同交付，而是只给框架名称和.py文件，到时让人家自己通过[pip3 install 框架名]的方式自行安装 框架名称我们是通过pip freeze > requirements.txt获取到的"}, {"ctype": "head", "data": "三.实验"}, {"ctype": "p", "data": "创建pa，pb文件夹 mkdir projects cd projects mkdir pa mkdir pb安装框架 cd pa pip3 install requests cd pb pip3 install flask 安装成功后的画面示例如下： 查看requests，flask库统一安装到如下路径： /usr/local/lib/python3.6/site-packages 删除该路径下安装的requests和flask框架，我们看看安装虚拟环境后是什么样的效果安装虚拟环境 1）pip3 install virtualenv 2）pip3 install virtualenvwrapper 3）vim ~/.bashrc # 添加以下三行代码 … … … … … … … … … … … … … … … … … export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.6 export WORKON_HOME=~/.envs source /usr/local/bin/virtualenvwrapper.sh … … … … … … … … … … … … … … … … … 4）cd ～/projects/pa # cd到pa下 virtualenv pa # 创建虚拟环境pa source ~/projects/pa/bin/activate # 激活虚拟环境 5）cd ～/projects/pb # cd到pb下 virtualenv pb # 创建虚拟环境pb source ~/projects/pb/bin/activate # 激活虚拟环境 6）workon pa # 切换到虚拟环境pa 7）pip3 install requests # 在虚拟环境pa下安装框架requests 8）workpb # 切换到虚拟环境pb 9）pip3 install flask # 在虚拟环境pb下安装框架flask ⚠️ 我的电脑无需第3）步也成功了，可以先跳过此步骤，进行不下去了再回来配置也可 》〉》〉》〉》〉》〉》〉》〉》〉》〉》〉》〉》最终效果 pa项目下安装的requests框架安装到pa管理的目录下，pb项目下安装的flask框架安装到pb管理的目录下，实现了框架的分别管理，互补干扰，互不影响  "}, {"ctype": "p", "data": "参考 https://blog.csdn.net/qq_38627475/article/details/89735995"}], "cate": "Python"}
{"题目": "迭代器与生成器", "作者": "Zhangyakang_", "发布时间": "2021-03-27 10:57:13", "内容": [{"ctype": "head", "data": "迭代器"}, {"ctype": "p", "data": "其中__iter__()返回对象本身__next__()返回容器中的下一个元素"}, {"ctype": "p", "data": "自定义迭代器对象"}, {"ctype": "code", "data": "class MyRange(object):\n\tdef __init__(self, n):\n\t\tself.idx = 0\n\t\tself.n = n\n\t\t\n\tdef __iter__(self):\n\t\treturn self\n\t\t\n\tdef __next__(self):\n\t\tif self.idx < self.n:\n\t\t\tval = self.idx\n\t\t\tself.idx += 1\n\t\t\treturn val\n\t\telse:\n\t\t\traise StopIteration()"}, {"ctype": "p", "data": "输出结果"}, {"ctype": "code", "data": ">>> for i in MyRange(3):\n...     print(i)\n...\n0\n1\n2"}, {"ctype": "p", "data": "解决迭代器对象没有办法多次迭代的问题"}, {"ctype": "code", "data": "class Frange(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\t\n\tdef __iter__(self):\n\t\treturn SubRange(self.n)\n\t\t\nclass SubRange(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.id = 0\n\t\t\n\tdef __iter__(self):\n\t\treturn self\n\t\t\n\tdef __next__(self):\n\t\tif self.id < self.n:\n\t\t\tval = self.id\n\t\t\tself.id += 1\n\t\t\treturn val\n\t\telse:\n\t\t\traise StopIteration()"}, {"ctype": "p", "data": "输出结果如下"}, {"ctype": "code", "data": ">>> for i in Frange(3):\n...     print(i)\n...\n0\n1\n2\n>>> for i in Frange(3):\n...     print(i)\n...\n0\n1\n2"}, {"ctype": "head", "data": "生成器"}, {"ctype": "p", "data": "弄明白生成器动作原理"}, {"ctype": "code", "data": "def zrange(n):\n\tprint(\"生成器函数开始工作\")\n\ti = 0\n\twhile i < n:\n\t\tprint(\"yield 执行之前\", i)\n\t\tyield i\n\t\ti += 1\n\t\tprint(\"yield 执行之后\",i)\n\tprint(\"生成器函数执行完毕\")"}, {"ctype": "p", "data": "输出如下"}, {"ctype": "code", "data": ">>> zranged = zrange(3)\n>>> for i in zranged:\n...     print(i)\n...\n生成器函数开始工作\nyield 执行之前 0\n0\nyield 执行之后 1\nyield 执行之前 1\n1\nyield 执行之后 2\nyield 执行之前 2\n2\nyield 执行之后 3\n生成器函数执行完毕"}, {"ctype": "head", "data": "生成器表达式"}, {"ctype": "code", "data": ">>> make_reg = (x for x in range(10))# 此处就是生成器表达式，语法规则和列表推导式特别相似\n>>> for i in make_reg:\n...     print(i)\n...\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n>>> for i in make_reg:\n...     print(i)\n..."}, {"ctype": "head", "data": "递归生成器"}, {"ctype": "code", "data": "def permutations(li):\n    if len(li) == 0:\n        yield li [012] \n    else:\n        for i in range(len(li)):\n            li[0], li[i] = li[i], li[0]\n            for item in permutations(li[1:]):\n                yield [li[0]] + item\n    \nfor item in permutations(range(3)):\n    print(item)"}, {"ctype": "head", "data": "生成器的send()和close()"}, {"ctype": "p", "data": "使用send 需注意地方，在第一次调用生成器的时候需要先调用__next__()或者__send__(None),因为在第一次调用时假如send传递非None参数此时没有yield参数来接收参数，也就是说send传递非空参数时生成器必须处于挂起状态。"}, {"ctype": "code", "data": "def zrange(n):\n\ti = 0\n\twhile i < n:\n\t\tval = yield i\n\t\tprint(\"val is \",val)\n\t\ti += 1"}, {"ctype": "code", "data": ">>> zr = zrange(5)\n>>> print(zr.send())# 第一次调用send()此时会报错\n##############结果报错如下\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: send() takes exactly one argument (0 given)\n#############可见send必须传入一个参数而且不能是空的\n\n\n>>> print(zr.send(8))#此时传入一个非空参数\n############执行结果\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't send non-None value to a just-started generator\n############\n\n\n>>> print(zr.__next__())\n0\n>>> print(zr.send(9))\nval is  9\n1"}, {"ctype": "head", "data": "生成器迭代器总结"}, {"ctype": "p", "data": "通过实现迭代器协议对应的__iter__()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素像列表这种序列类型的对象，可迭代对象和迭代器对象是相互独立存在的，在迭代的过程中各个迭代器相互独立；但是，有的可迭代对象本身又是迭代器对象，那么迭代器就没法独立使用。itertools模块提供了一系列迭代器，能够帮助用户轻松地使用排列、组合、笛卡尔积或其他组合结构生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义__iter__()和next()方法生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果"}], "cate": "Python"}
{"题目": "Fairseq的wav2vec2的踩坑之旅4：如何手动将一个Fairseq的wav2vec2模型转换为transformers的模型", "作者": "starinline", "发布时间": "2021-03-27 15:44:31", "内容": [{"ctype": "head", "data": "摘要："}, {"ctype": "p", "data": "本文尝试将用中文拼音预训练的Fairseq的wav2vec2模型转换为transformers模型（以下简写trms），因为汉语拼音的label数量与英文不同，所以本文需要进行模型转换函数的修改。"}, {"ctype": "p", "data": "自己预训练和finetune的模型没有稳定输出，但是应该是label转换的问题 本文可能对“复现党”有一定的参考价值"}, {"ctype": "head", "data": "1.分析transofrmers模型的结构"}, {"ctype": "p", "data": "huggingface下载的模型默认保存在~/.cache/huggingface下面，如果需要离线使用，则需要将其保存到一个常见可见的目录，方便手动管理。"}, {"ctype": "p", "data": "在模型目录下一般包括如下的文件："}, {"ctype": "p", "data": "使用fairseq.checkpoint_utils.load_model_ensemble_and_task([fname])尝试导入pytorch_model.bin，报错，分析是从huggingface下载的模型是没有fairseq的task/args/cfg等信息。"}, {"ctype": "code", "data": "    with open(local_path, \"rb\") as f:\n        state = torch.load(f, map_location=torch.device(\"cpu\"))\n        \n    #分析类型state是<class 'collections.OrderedDict'>\n"}, {"ctype": "p", "data": "Tips: 这里有一个方便的下载各个模型的小工具，下载模型到具体目录保存。"}, {"ctype": "code", "data": "from transformers import Wav2Vec2Tokenizer, Wav2Vec2ForCTC\nimport argparse\nimport os\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model_name\", type=str, default=\"facebook/wav2vec2-base-100h\", help=\"pretrained model name\")\n    parser.add_argument(\"--save_dir\", type=str, default=\"openai-gpt\", help=\"pretrained model name\")\n    args = parser.parse_args()\n    print(args)    \n    #save model\n    save_dir = os.path.expanduser(args.save_dir)    \n    # load model and tokenizer\n    tokenizer = Wav2Vec2Tokenizer.from_pretrained(args.model_name) \n    tokenizer.save_pretrained(save_dir)\n    model = Wav2Vec2ForCTC.from_pretrained(args.model_name)\n    model.save_pretrained(save_dir)\n    \nif __name__==\"__main__\":\n    \"\"\"\n    $prj=~/Documents/projects/transformers/facebook/wav2vec2-base-100h\n    python ～/Documents/workspace/fairseq2trms/downloadModel.py --model_name=\"facebook/wav2vec2-base-100h\"  --save_dir=$prj\n    \"\"\"\n    main()\n"}, {"ctype": "head", "data": "2.使用transformers的工具进行导入"}, {"ctype": "p", "data": "**说明：**为什么不直接Fairseq，而是要用transformers呢？"}, {"ctype": "p", "data": "fairseq存在比较严重的过渡封装问题，接口复杂，omgaconf传参工具不容易迁移，不适合作生产环境部署fairseq做评估和ASR应用需要flashlight，由于防火墙的存在，基本上是无法按照官方教程安装的（vcpkg和编译都不容易）trms的接口比较直接明确，工具链比较简单"}, {"ctype": "head", "data": "2.1 导入工具参数说明"}, {"ctype": "p", "data": "trms本身提供了从fairseq导入wav2vec2模型的工具：transformers/models/wav2vec2/convert_wav2vec2_original_pytorch_checkpoint_to_pytorch.py"}, {"ctype": "p", "data": "使用如下脚本可以从自己训练的模型转换trms用的模型："}, {"ctype": "code", "data": "python -m  transformers.models.wav2vec2.convert_wav2vec2_original_pytorch_checkpoint_to_pytorch  --pytorch_dump_folder_path \"~/Documents/projects/transformers/bostenai/960h-zh_CN\" --checkpoint_path \"~/Documents/projects/Fairseq/ModelSerial/CTC-softlink-slr18_bst-0310/ctc_d1/outputs/checkpoints2/checkpoint_best.pt\" --dict_path \"~/Documents/projects/transformers/bostenai/960h-zh_CN/dict.ltr.txt\" \n"}, {"ctype": "code", "data": "#具体参数含义如下\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--pytorch_dump_folder_path\", default=None, type=str, help=\"transformers模型导出到该目录.\")\nparser.add_argument(\"--checkpoint_path\", default=None, type=str, help=\"需要转换的fairseq的wav2vec2模型文件\")\nparser.add_argument(\"--dict_path\", default=None, type=str, help=\"Path to dict of fine-tuned model，但是从代码看，这就是填充data字段防止fairseq无法加载的占为参数，随便给一个就好，也就是为什么不用fairseq的原因，代码质量太差！\")\n#在内部如果指定了config将直接使用，因此不能指定config的path\n#dict_path 貌似是有歧义的参数名，只是使用用来替换data字段的，不传会错误，传递了也没啥用\nparser.add_argument(\"--config_path\", default=None, type=str, help=\"转换后的配置文件，因为是转换所以留空不传，传了出错！\")\nparser.add_argument(\n    \"--not_finetuned\", action=\"store_true\", help=\"Whether the model to convert is a fine-tuned model or not\"\n)\n"}, {"ctype": "p", "data": "Error1: 缩略~导致的问题"}, {"ctype": "p", "data": "trms并没有对路径参数调用os.path.expanduser()，导致无法推倒含的路径。但是处于个人隐私考虑，全文还是使用代替传递参数中的绝对路径，请自行替换，下同。"}, {"ctype": "code", "data": "requests.exceptions.HTTPError: 404 Client Error: Not Found for url: https://huggingface.co/~/Documents/projects/transformers/bostenai/960h-zh_CN//resolve/main/config.json\nDuring handling of the above exception, another exception occurred:\n- '~/Documents/projects/transformers/bostenai/960h-zh_CN/' is a correct model identifier listed on 'https://huggingface.co/models'\n- or '~/Documents/projects/transformers/bostenai/960h-zh_CN/' is the correct path to a directory containing a config.json file\n"}, {"ctype": "p", "data": "Error2: config.json"}, {"ctype": "p", "data": "如果指定了config.json参数，而该文件不能自行生成，将导致如下错误，直接留空不传"}, {"ctype": "code", "data": "OSError: file /home/xxx/Documents/projects/transformers/bostenai/960h-zh_CN/config.json not found\nDuring handling of the above exception, another exception occurred:\n\n"}, {"ctype": "p", "data": "Error3: Exception “omegaconf.errors.ValidationError”"}, {"ctype": "p", "data": "这是Fairseq的Bug和功能缺陷，Omgaconf实在太复杂，当不传递–dict_path时导致：data等参数无法填充"}, {"ctype": "code", "data": "Exception \"omegaconf.errors.ValidationError\"\nNon optional field cannot be assigned None\n\tfull_key: data\n\treference_type=Optional[AudioPretrainingConfig]\n\tobject_type=AudioPretrainingConfig\nFile: ~/.conda/envs/lSrv39/lib/python3.9/site-packages/omegaconf/_utils.py, Line: 610\n"}, {"ctype": "p", "data": "#在内部如果指定了config将直接使用，因此不能指定config的path #dict_path 貌似是有歧义的参数名，只是使用用来替换data字段的，不传会错误，传递了也没啥用"}, {"ctype": "p", "data": "Error4：finetune层的维度不一致的问题"}, {"ctype": "p", "data": "注意：因为我们是zh_CN识别的模型，而官方是英文，一个vocab是26而中文是222,因次原始的加载函数需要魔改"}, {"ctype": "p", "data": "为了能够正确加载模型，我们需要将trms提供的加载函数略作修改"}, {"ctype": "code", "data": "#transformers/src/transformers/models/wav2vec2/convert_wav2vec2_original_pytorch_checkpoint_to_pytorch.py\n#对下面的函数进行修改，首先 加载fairseq模型，读取ctc层的配置，最后再创建trms模型进行复制\n\n@torch.no_grad()\ndef convert_wav2vec2_checkpoint(\n    checkpoint_path, pytorch_dump_folder_path, config_path=None, dict_path=None, is_finetuned=True\n):\n    \"\"\"\n    Copy/paste/tweak model's weights to transformers design.\n    \"\"\"\n    #首先加载需要转换的模型\n    if is_finetuned:\n        model, saved_cfg, task= fairseq.checkpoint_utils.load_model_ensemble_and_task(\n            [checkpoint_path], arg_overrides={\"data\": dict_path}\n        )\n        #注意这里的dict_path是随便赋值的，因为没啥实际作用，仅仅是让fairseq不要出错。在fairseq加载时有大量莫名其妙的参数检查和以来，omgaconf的实现质量十分的差\n    else:\n        model, saved_cfg, task = fairseq.checkpoint_utils.load_model_ensemble_and_task([checkpoint_path])\n    model = model[0].eval()\n    \n    #创建默认的值\n    if  config_path is not None:\n        config = Wav2Vec2Config.from_pretrained(config_path)\n    else:\n        config = Wav2Vec2Config()    \n    \n    if is_finetuned:\n        #修改config的值,这里直接使用了最后一层的值，因为其他地方得不到\n        config.vocab_size = list(model.modules())[-1].out_features\n        hf_wav2vec = Wav2Vec2ForCTC(config)\n    else:\n        hf_wav2vec = Wav2Vec2Model(config)\n\n    recursively_load_weights(model, hf_wav2vec, is_finetuned)\n    hf_wav2vec.save_pretrained(pytorch_dump_folder_path)\n"}, {"ctype": "head", "data": "2.2 创建对应的tokenizer需要的文件"}, {"ctype": "p", "data": "我认为fairseq训练的时候使用了默认的配置，那么special_tokens_map.json tokenizer_config.json preprocessor_config.json都可以复制，只需要修改vocab.json"}, {"ctype": "p", "data": "创建vocab.json需要从fairseq的dict.ltr.txt转换，转换脚本如下："}, {"ctype": "code", "data": "# coding=utf-8\n\"\"\"\n创建汉语拼音使用的字典\n\"\"\"\nimport argparse\nimport os\nimport json\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--dict\", type=str, default=\"dict.ltr.txt\", help=\"finetune时的字典文件\")\n    parser.add_argument(\"--vocab\", type=str, default=\"vocab.json\", help=\"输出的字典json\")\n    args = parser.parse_args()\n    print(args)\n    #vocab 系统自带和默认的几个key\n    oVocab ={\"<pad>\": 0, \"<s>\": 1, \"</s>\": 2, \"<unk>\": 3}    \n    #加载fairseq的dict.ltr.txt文件\n    dictF  = os.path.expanduser(args.dict)\n    vocabF = os.path.expanduser(args.vocab)\n    with open(dictF, 'r') as df:\n        text = df.readlines()\n        tLen = len(oVocab)\n        #转换为trms的字典\n        for it in text:\n            key, p = it.strip().split()\n            oVocab[key] = tLen\n            tLen = tLen+1\n    #写出到vocab.json\n    with open(vocabF, 'w+', encoding=\"utf-8\") as cf:\n        json.dump(oVocab, cf, sort_keys=True, indent=4, separators=(',', ': '), ensure_ascii=False )\n\n    \nif __name__==\"__main__\":\n    \"\"\"\n    $prj=~/Documents/projects/transformers/bostenai/960h-zh_CN\n    python ~/Documents/workspace/fairseq2trms/create_vocab.py --dict=$prj/dict.ltr.txt  --vocab=$prj/vocab.json\n    \"\"\"\n    main()\n\n"}, {"ctype": "p", "data": "脚本将创建一个自定义的汉语拼音的vocab文件"}, {"ctype": "p", "data": "到此模型转换的过程基本完成"}, {"ctype": "head", "data": "3.测试转换后的trms模型的效果"}, {"ctype": "p", "data": "使用官方模型进行测试，这里使用local_files_only=True来加载我们下载或者本地封装的模型"}, {"ctype": "code", "data": "#模拟Fairseq官方提供的例子写的一个Demo\nfrom transformers import  Wav2Vec2ForCTC, Wav2Vec2Processor\nimport argparse\nimport os\n#from pypinyin import  lazy_pinyin, Style\nimport soundfile as sf\nimport torch\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model_path\", type=str, default=\"~/Documents/Projects/transformers/bostenai/100h-zh_CN\", help=\"pretrained model path\")\n    parser.add_argument(\"--local_files_only\", action=\"store_true\", help=\"是否使用本地模式\")\n    parser.add_argument(\"wav\", type=str,  help=\"待分析的音频文件\")\n    args = parser.parse_args()\n    print(args)    \n    #save model\n    model_path = os.path.expanduser(args.model_path)    \n    # load model and tokenizer\n    tokenizer = Wav2Vec2Processor.from_pretrained(model_path, local_files_only=args.local_files_only)\n    model = Wav2Vec2ForCTC.from_pretrained(model_path, local_files_only=args.local_files_only)\n    \n    #read in sound file    \n    #tStr =\"我爱北京天安门\"\n    #tList = lazy_pinyin(tStr, style=Style.TONE )     \n    #print(\"|\".join(tList))\n    #tAudio = \"/home/linger/Downloads/temp/1.wav\"    \n    tAudio = os.path.expanduser(args.wav)\n    audio_input, sr = sf.read(tAudio)    \n    # transcribe\n    input_values = tokenizer(audio_input, return_tensors=\"pt\", sampling_rate=sr).input_values\n    logits = model(input_values).logits\n    predicted_ids = torch.argmax(logits, dim=-1)\n    transcription = tokenizer.batch_decode(predicted_ids)[0]\n    print(transcription)\n    \nif __name__==\"__main__\":\n    \"\"\"\n    python /home/linger/Documents/workspace/fairseq2trms/test_trms.py  --model_path ~/Documents/Projects/transformers/bostenai/100h-zh_CN --local_files_only /home/linger/Downloads/temp/1.wav\n    \"\"\"\n    main()\n\n"}, {"ctype": "p", "data": "如果测试官方模型可能会得到这样的结果："}, {"ctype": "code", "data": "$ python /home/linger/Documents/workspace/fairseq2trms/test_trms.py  --model_path facebook/wav2vec2-base-960h  --local_files_only /home/linger/Downloads/temp/1.wav\nNamespace(model_path='facebook/wav2vec2-base-960h', local_files_only=True, wav='/home/linger/Downloads/temp/1.wav')\nSome weights of Wav2Vec2ForCTC were not initialized from the model checkpoint at facebook/wav2vec2-base-960h and are newly initialized: ['wav2vec2.masked_spec_embed']\nYou should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.\nWA I BA GING KAN IMON\n"}, {"ctype": "p", "data": "看到英语直接拼音汉语是不是很好玩. 哈哈：WA I BA GING KAN IMON"}, {"ctype": "head", "data": "4.使用Transformers对汉语拼音进行finetune"}, {"ctype": "p", "data": "好尴尬!! 前期预训练的汉语拼音的wav2vec2没有没有输出我想要的结果："}, {"ctype": "code", "data": "$    python /home/linger/Documents/workspace/fairseq2trms/test_trms.py  --model_path ~/Documents/Projects/transformers/bostenai/100h-zh_CN --local_files_only /home/linger/Downloads/temp/1.wav\nNamespace(model_path='/home/linger/Documents/Projects/transformers/bostenai/100h-zh_CN', local_files_only=True, wav='/home/linger/Downloads/temp/1.wav')\n\nw<unk><unk><unk><unk><unk><unk>\n"}, {"ctype": "p", "data": "那么尝试在我的小本上试试finetune吧"}, {"ctype": "p", "data": "未完待续"}], "cate": "Python"}
{"题目": "python+selenium+BeautifulSoup爬取酒店评论", "作者": "keaideciel", "发布时间": "2021-03-28 17:13:55", "内容": [{"ctype": "head", "data": "环境与配置"}, {"ctype": "p", "data": "本文使用的Python版本是 Anaconda Python 3.8.5 安装selenium 打开命令行cmd，输入下面的命令"}, {"ctype": "code", "data": "pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple some-package\n"}, {"ctype": "p", "data": "下载驱动 火狐浏览器要下载火狐驱动geckodriver 网盘链接: 提取码：1234 添加环境变量 建议直接将geckodriver.exe放到python.exe的相同路径下，方便 其他 关于Selenium的安装与配置可以参考 python selenium firefox使用详解:"}, {"ctype": "head", "data": "准备代码"}, {"ctype": "p", "data": "假设我们的目标是爬取携程上某一酒店的4千多条评论 我们的目标酒店 链接: 代码部分一："}, {"ctype": "code", "data": "from selenium import webdriver\nfrom bs4 import BeautifulSoup\nimport time\n\n# 选定火狐浏览器\nbrowser = webdriver.Firefox()\n# 通过网页地址打开网页，此时会弹出浏览器，并加载相应的网页\nbrowser.get('https://hotels.ctrip.com/hotels/346754.html')\n# 隐式等待，程序会一直等待整个页面加载完成，才能执行后续操作\n# 最长等待10秒\nbrowser.implicitly_wait(10)\n\n"}, {"ctype": "p", "data": "更多的等待方式可以参考 Selenium的三种等待方式:"}, {"ctype": "head", "data": "爬取代码"}, {"ctype": "p", "data": "代码部分二："}, {"ctype": "code", "data": "# 设置爬取的评论页数\npagenum = 360\n\nfor n in range(pagenum):  \n    # 解析网页，第二个参数为解析器\n    soup = BeautifulSoup(browser.page_source, \"lxml\")\n    # 获取所有class属性为comment的div标签\n    review = soup.find_all(\"div\", attrs={'class': 'comment'})\n    # 创建一个评论列表\n    reviewlist = []\n    # 获取所有class属性为p的标签，并加入reviewlist里\n    for r in review:\n        rvw = r.find_all(\"p\")\n        reviewlist.append(rvw[0])\n    # 将爬到的评论写入a.txt文件\n    with open('a.txt', mode='a', encoding='gb18030', errors='ignore') as f:\n        for i in range(len(reviewlist)):\n            f.write(\"****************************************************************\\n\")\n            f.write(str(reviewlist[i]))\n            f.write('\\n')\n    # 输出一下爬了几次了\n    print(n,\" time\\n\")\n    # 由于需要使用Selenium模拟点击标签，进行评论的翻页\n    # 此处获取一个class属性为\"u-icon-arrowRight\"的i标签，并点击\n    browser.find_element_by_xpath('//i[@class=\"u-icon u-icon-arrowRight\"]').click()\n    # 隐式等待方式，10秒\n    browser.implicitly_wait(10)\n    #强制等待0.1秒，保险起见\n    time.sleep(0.1)\n\n"}, {"ctype": "head", "data": "最后"}], "cate": "Python"}
{"题目": "python print（）函数控制输出格式", "作者": "一个小芋圆呀", "发布时间": "2021-03-28 14:12:47", "内容": [{"ctype": "p", "data": "在这里总结一些python使用print()函数输出时控制格式的一些方法。"}, {"ctype": "head", "data": "【函数介绍】"}, {"ctype": "head", "data": "【print()函数】"}, {"ctype": "p", "data": "参考了菜鸟教程对print()函数的介绍：https://www.runoob.com/python3/python-func-print.html"}, {"ctype": "p", "data": "功能：用于打印输出参数："}, {"ctype": "table", "data": "参数名含义flush输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。objects复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。end用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符串。sep用来间隔多个对象，默认值是一个空格。file要写入的文件对象。"}, {"ctype": "p", "data": "实例："}, {"ctype": "code", "data": ">>>print(1)  \n1  \n>>> print(\"Hello World\")  \nHello World  \n \n>>> a = 1\n>>> b = 'runoob'\n>>> print(a,b)\n1 runoob\n \n>>> print(\"aaa\"\"bbb\")\naaabbb\n>>> print(\"aaa\",\"bbb\")\naaa bbb\n>>> \n \n>>> print(\"www\",\"runoob\",\"com\",sep=\".\")  # 设置间隔符\nwww.runoob.com\n"}, {"ctype": "head", "data": "【format()函数】"}, {"ctype": "p", "data": "参考了菜鸟教程对format()函数的介绍：https://www.runoob.com/python/att-string-format.html"}, {"ctype": "p", "data": "str.format()是一种一种格式化字符串的函数，它增强了字符串格式化的功能。 基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序。 实例："}, {"ctype": "code", "data": ">>>\"{} {}\".format(\"hello\", \"world\")    # 不设置指定位置，按默认顺序\n'hello world'\n \n>>> \"{0} {1}\".format(\"hello\", \"world\")  # 设置指定位置\n'hello world'\n \n>>> \"{1} {0} {1}\".format(\"hello\", \"world\")  # 设置指定位置\n'world hello world'\n"}, {"ctype": "p", "data": "它也可以设置参数，实例:"}, {"ctype": "code", "data": "#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \nprint(\"网站名：{name}, 地址 {url}\".format(name=\"菜鸟教程\", url=\"www.runoob.com\"))\n \n# 通过字典设置参数\nsite = {\"name\": \"菜鸟教程\", \"url\": \"www.runoob.com\"}\nprint(\"网站名：{name}, 地址 {url}\".format(**site))\n \n# 通过列表索引设置参数\nmy_list = ['菜鸟教程', 'www.runoob.com']\nprint(\"网站名：{0[0]}, 地址 {0[1]}\".format(my_list))  # \"0\" 是必须的\n"}, {"ctype": "p", "data": "输出结果为："}, {"ctype": "p", "data": "数字格式化 下表展示了 str.format() 格式化数字的多种方法："}, {"ctype": "code", "data": ">>> print(\"{:.2f}\".format(3.1415926))\n3.14\n"}, {"ctype": "table", "data": "数字格式输出描述3.1415926{:.2f}3.14保留小数点后两位3.1415926{:+.2f}+3.14带符号保留小数点后两位-1{:+.2f}-1.00带符号保留小数点后两位2.71828{:.0f}3不带小数5{:0>2d}05数字补零 (填充左边, 宽度为2)5{:x<4d}5xxx数字补x (填充右边, 宽度为4)10{:x<4d}10xx数字补x (填充右边, 宽度为4)1000000{:,}1,000,000以逗号分隔的数字格式0.25{:.2%}25.00%百分比格式1000000000{:.2e}1.00e+09指数记法13{:>10d}13右对齐 (默认, 宽度为10)13{:<10d}13左对齐 (宽度为10)13{:^10d}13中间对齐 (宽度为10)11‘{:b}’.format(11)1011二进制11‘{:d}’.format(11)11十进制11‘{: o}’.format(11)13八进制11‘{:x}’.format(11)b十六进制11‘{:#x}’.format(11)0xb十六进制11‘{:#X}’.format(11)0XB十六进制"}, {"ctype": "p", "data": "此外我们可以使用大括号 {} 来转义大括号，如下实例："}, {"ctype": "p", "data": "实例"}, {"ctype": "code", "data": "#!/usr/bin/python\n# -*- coding: UTF-8 -*-\nprint (\"{} 对应的位置是 {{0}}\".format(\"runoob\"))\n"}, {"ctype": "p", "data": "输出结果为："}, {"ctype": "head", "data": "【格式化输出实例】"}, {"ctype": "code", "data": "a=10\nb=12345.42394294\ns=\"I love python\"\n#下面这两条语句的输出效果是一样的\n# %是占位符，后面的字母控制输出格式，%d:十进制整数，%f:浮点数，%s:字符串\nprint(\"a=%d,b=%.2f,s=%s\"%(a,b,s))\nprint(\"a={:d},b={:.2f},s={}\".format(a,b,s))\n#百分数的输出\nc=0.9\nprint(\"c=%.2f%%\"%(c*100))#要输出%这个符号，需要连续使用两个%\nprint(\"c={:.2%}\".format(c))\n"}, {"ctype": "p", "data": "输出："}], "cate": "Python"}
{"题目": "C语言文件读取结束判断正确方式", "作者": "hunte5299", "发布时间": "2021-03-27 10:28:13", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "对于在文件操作时，怎么样判断文件是否结束，以feof来判断文件读取结束是否正确？"}, {"ctype": "head", "data": "一、MSDN对feof的介绍？"}, {"ctype": "p", "data": " 对与返回值的描述是： feof函数在第一次读取操作后返回一个非零值，该操作试图读取文件的末尾。如果当前位置不是文件结尾，则返回0。没有错误返回。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327095542479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1bnRlNTI5OQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "仔细读最后一句话，我们得到的信息是，如果当函数对文件流的操作失败时，它是不能正确抛出错误的，它仅仅只能判断文件是否结束。 即在文件读取过程中，避免用feof函数的返回值来判断文件读取是否结束，而是应用于当前文件读取结束时，判断时读取结束还是遇到文件尾结束"}, {"ctype": "head", "data": "1.如何正确判断文件是否结束"}, {"ctype": "p", "data": "对于任意的流操作函数，都有对应的返回值来 如以下代码"}, {"ctype": "code", "data": "\t\tend = fscanf(fp,\"%d %s %s\", &(t->p.id), &(t->p.name), &(t->p.telnum)); \n\t\tif (end == EOF){\n\t\t\tbreak;\n\t\t}\n\t\tend = fgets\n\t\tif(end == NULL){\n\t\t\tbreak;\n\t\t}\n"}, {"ctype": "p", "data": "在判断对文件操作结束的时候，要以对应操作函数的返回值来进行判断 即 Ⅰ. 文本文件读取是否结束，应该判断："}, {"ctype": "table", "data": "对应函数的返回值"}, {"ctype": "code", "data": "fgets是否为NULL；\nfgetc是否为EOF；\nfscanf是否为EOF；\n"}, {"ctype": "p", "data": "Ⅱ. 二进制文件的读取是否结束，应该判断： | fread：返回值是否小于实际要读取的个数"}, {"ctype": "p", "data": "然后在读取结束后再总的判断是因何而结束： Ⅲ."}, {"ctype": "code", "data": "\tif(ferror(pf)){\n\t\tprintf(\"读取错误而失败结束\");\n\t}\n\n\telse if(feof(fp)){\n\t\tprintf(\"遇到文件末尾而结束\");\n\t}\n"}, {"ctype": "p", "data": "ferror：若流上无错误发生，返回0，否则返回非零值"}, {"ctype": "head", "data": "2.总结"}, {"ctype": "p", "data": "用对应流操作函数的返回值来判断文件是否结束"}], "cate": "Python"}
{"题目": "python多任务编程", "作者": "般若时光", "发布时间": "2021-03-27 16:47:24", "内容": [{"ctype": "p", "data": "python进程与线程"}, {"ctype": "head", "data": "线程的注意事项"}, {"ctype": "head", "data": "1、线程之间执行是无序的"}, {"ctype": "code", "data": "import threading\nimport time\n\ndef task():\n    print(threading.current_thread().name)\n    time.sleep(0.5)\n\nif __name__ == '__main__':\n    # 循环创建多个线程\n    for i in range(10):\n        sub_thread = threading.Thread(target=task)\n        sub_thread.start()\n\n"}, {"ctype": "head", "data": "2、主线程会等待所有的子线程执行结束再结束"}, {"ctype": "code", "data": "import threading\nimport time\n\ndef task():\n    for i in range(10):\n        print('任务中-----')\n        time.sleep(0.2)\n\nif __name__ == '__main__':\n      \n    sub_thread = threading.Thread(target=task)\n      sub_thread.start()\n\n    time.sleep(1)\n    print('主线程')\n"}, {"ctype": "p", "data": "我们可以设置子线程守护主线程，主线程退出，子线程直接销毁。 有两种方法：详情看下方代码"}, {"ctype": "code", "data": "import threading\nimport time\n\ndef task():\n    for i in range(10):\n        print('任务中-----')\n        time.sleep(0.2)\n\nif __name__ == '__main__':\n    # 方式一:daemon=True\n    # sub_thread = threading.Thread(target=task, daemon=True)\n    # sub_thread.start()\n\n    # 方式二:\n    sub_thread = threading.Thread(target=task)\n    sub_thread.setDaemon(True)\n    sub_thread.start()\n\n    time.sleep(1)\n    print('主线程')\n\n"}, {"ctype": "head", "data": "3、线程之间共享全局变量"}, {"ctype": "code", "data": "import threading\nimport time\n\ng_list = []\n\n\ndef add_data():\n    for i in range(3):\n        # 将i追加到全局变量内\n        g_list.append(i)\n        time.sleep(0.2)\n\n    print(g_list)\n\n\ndef read_data():\n    print('read_data:', g_list)\n\n\nif __name__ == '__main__':\n    # 创建添加数据的子线程\n    add_thread = threading.Thread(target=add_data)\n\n    # 创建读取数据的子线程\n    read_thread = threading.Thread(target=read_data)\n\n    add_thread.start()\n\n    # 让当前线程(主线程)等待添加数据的线程执行完成后代码在继续执行\n    add_thread.join()\n    read_thread.start()\n    \n\t先导入线程模块，创建两个子线程\n"}, {"ctype": "p", "data": "这点线程与进程不同，进程之间不共享全局变量。"}, {"ctype": "head", "data": "4、线程之间共享全局变量数据出现错误问题。"}, {"ctype": "p", "data": "线程在共享全局变量时，数据会出现出错的问题"}, {"ctype": "code", "data": "import threading\n\n# 定义一个全局变量\ng_num = 0\n\n\ndef first_data():\n    for i in range(1000000):\n        # 声明全局变量\n        global g_num\n        g_num += 1\n\n    print('第一个:', g_num)\n\n\ndef second_data():\n    for i in range(1000000):\n        # 声明全局变量\n        global g_num\n        g_num += 1\n\n    print('第二个:', g_num)\n\n\nif __name__ == '__main__':\n    # 创建第一个子线程\n    first_thread = threading.Thread(target=first_data)\n\n    # 创建第二个子线程\n    second_thread = threading.Thread(target=second_data)\n\n    first_thread.start()\n\n    # 让当前线程(主线程)等待添加数据的线程执行完成后代码在继续执行\n    # first_thread.join()  # 若没有这一步数据出错 例: \"第二个: 1145315; 第一个: 1204873\"\n\n    second_thread.start()\n"}, {"ctype": "p", "data": "如有错误请斧正！！！ 全局变量数据出错有两种解决办法。详情点击链接: https://blog.csdn.net/xbc3970/article/details/115268459。"}], "cate": "Python"}
{"题目": "利用Python批量将csv文件转化成xml文件", "作者": "叶庭云", "发布时间": "2021-03-28 16:42:59", "内容": [{"ctype": "head", "data": "一、前言"}, {"ctype": "p", "data": "将 csv 格式转换成xml格式有许多方法，可以用数据库的方式，也有许多软件可以将 csv 转换成xml。但是比较麻烦，本文利用 Python 一键批量将 csv 文件转化成 xml 文件。"}, {"ctype": "p", "data": "逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列，通常都是纯文本文件。"}, {"ctype": "p", "data": "可扩展标记语言，标准通用标记语言的子集，简称XML。是一种用于标记电子文件使其具有结构性的标记语言。在电子计算机中，标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种的信息比如文章等。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。"}, {"ctype": "head", "data": "二、Python代码实现"}, {"ctype": "p", "data": "导入用到的库"}, {"ctype": "code", "data": "from xml.etree.ElementTree import Element, ElementTree\nimport csv\nfrom pathlib import Path\nimport os\n"}, {"ctype": "p", "data": "创建一个文件夹，用来保存转换后的xml文件"}, {"ctype": "code", "data": "# 创建一个文件夹  用来保存转换后的xml文件\npath = os.path.join('xml_file')\nif not os.path.exists(path):\n    os.mkdir(path)\n"}, {"ctype": "p", "data": "获取所有待转换的csv文件"}, {"ctype": "code", "data": "# 获取所有待转换的csv文件  返回列表\ndef list_csv():\n    file_path = input('请输入你存放csv文件的路径：')\n    p = Path(file_path)\n    csv_files = p.glob('**/*.csv')\n    csv_files = [str(csv_file) for csv_file in csv_files]\n    return csv_files\n"}, {"ctype": "p", "data": "将 csv 文件转换为 xml 文件"}, {"ctype": "code", "data": "# 将csv文件转换为xml\ndef csv_to_xml(file_name):\n    print(file_name)\n    with open(file_name, 'r', encoding='utf-8') as f:   # 读取csv文件\n        reader = csv.reader(f)\n        header = next(reader)   # 跳过表头\n        root = Element('Datas')\n        print('root', len(root))\n        # 处理转换\n        for row in reader:\n            erow = Element('row')\n            root.append(erow)\n            for tag, text in zip(header, row):\n                e = Element(tag)\n                e.text = text\n                erow.append(e)\n    beatau(root)\n    return ElementTree(root)\n\n\ndef beatau(e, level=0):\n    if len(e) > 0:\n        e.text = '\\n' + '\\t' * (level + 1)\n        child = None\n        for child in e:\n            beatau(child, level + 1)\n        child.tail = child.tail[:-1]\n    e.tail = '\\n' + '\\t' * level\n"}, {"ctype": "p", "data": "主函数调用"}, {"ctype": "code", "data": "if __name__ == '__main__':\n    csv_list = list_csv()\n    print(csv_list)\n    for index_, item in enumerate(csv_list, start=1):\n        print(index_, item)\n        et = csv_to_xml(item)\n        et.write(path + '/' + 'test_{}.xml'.format(index_), encoding='utf-8')\n"}, {"ctype": "p", "data": "结果如下："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210208134637402.gif#pic_center"}, {"ctype": "p", "data": "用编辑器打开可以看到 xml 文件的内容（我用的Sublime Text），如下所示 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210208134720838.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5ZnVnb3lmYQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "2021/3/26第十二次python课(面向对象上)", "作者": "笔记本IT", "发布时间": "2021-03-27 11:37:31", "内容": [{"ctype": "head", "data": "一、面向对象简介"}, {"ctype": "p", "data": "• Python是一门面向对象的编程语言 • 所谓面向对象的语言，简单理解就是语言中的所有操作都是通过对象来进行的 • 面向过程 [主要指函数，一个函数一般实现一个功能]  • 面向过程指将我们的程序分解为一个一个步骤，通过对每个步骤的抽象来完成程序  • 这种编写方式往往只适用于一个功能，如果要实现别的功能，往往复用性比较低  • 这种编程方式符号人类的思维，编写起来比较容易   • 1.妈妈穿衣服穿鞋出门   • 2.妈妈骑上电动车   • 3.妈妈到超市门口放好电动车   • 4.妈妈买西瓜   • 5.妈妈结账   • 6.妈妈骑电动车回家   • 7.到家孩子吃西瓜 • 面向对象的编程语言，关注的是对象，而不注重过程，对于面向对象一切皆对象 [针对python] • 以上方式可以用 孩子妈妈给孩子买瓜来解决 • 面向对象的编程思想，将所有功能统一保存到对应的对象(类对象）中，要使用某个功能，直接找到对应的方法即可 • 这种编码方式比较容易阅读，并且易于维护，容易复用。但是编写的过程中不太符合常规的思维，编写相对麻烦 总结：面向对象：难编写，易读（不关注过程，关注结果）指挥者 面向过程：易编写，难读（关注过程，不关注结果） 执行者"}, {"ctype": "head", "data": "二、类（class）"}, {"ctype": "p", "data": "• 我们目前学习的都是Python的内置对象，但是内置对象并不都能满足我们的需求，所以我们在开发中经常要自定义一些对象 • 类简单理解它就是相当于一个图纸，在程序汇总我们需要根据类来创建对象。 • 如果多个对象是通过一个类创建的，我们称这些对象是一类对象"}, {"ctype": "code", "data": "class Person():  # 类里面有的东西实例里面一定会有\n    name = '李华'  # 属性\n\n    def speak(self):  # 方法 类中的函数不叫做函数了，叫做方法\n        print('你好,%s'%self.name)\n\n\np1 = Person()\np1.name = '小明'\n\nprint(p1.name)  # 实例.属性  就可以获取到这个属性值  属性的访问\np1.speak()   #方法的调用\n\np2 = Person()\nprint(p2.name)\n"}, {"ctype": "p", "data": "• 类也是一个对象，类就是用来创建对象的对象 • 可以向实例对象中添加或改变变量，对象中的变量称之为属性 语法：对象.属性名 = 属性值 形象的类比，更好的理解类 自定义类对象（图纸）―通过图纸创建出来的汽车―汽车就是通过图纸创建出来的实例对象"}, {"ctype": "p", "data": "类可以创建多个实例，每个实例各不相同，这一些实例我们称呼为一类实例 isinstance(）：用来检测这个实例是否是这个类创建出来的"}, {"ctype": "head", "data": "三、类的定义"}, {"ctype": "p", "data": "• 类和对象都是对现实生活中事物的抽象 • 事物包含两部分  • 1. 数据(属性)  • 2. 行为(方法) • 调用方法 对象.方法名() • 方法调用和函数调用的区别：如果是函数调用，调用时有几个形参，就会传递几个实参。如果是方法调用，默认传递一个参数，所以方法中至少得有一个形参 • 在类代码块中，我们可以定义变量和函数   • 变量会成为该类实例的公共属性，所有的该实例都可以通过 对象.属性名的形式访问   • 函数会成为该类实例的公共方法，所有该类实例都可以通过 对象.方法名（）的形式访问"}, {"ctype": "head", "data": "四、属性和方法"}, {"ctype": "p", "data": "• 类中定义的属性和方法都是公共的，任何该类实例都可以访问 • 属性和方法的查找流程  • 当我们调用一个对象的属性时，解析器会现在当前的对象中寻找是否还有该属性，如果有，则直接返回当前的对象的属性值。如果没有，则去当前对象的类对象中去寻找，如果有则返回类对象的属性值。如果没有就报错 • 类对象和实例对象中都可以保存属性(方法)  • 如果这个属性(方法)是所有的实例共享的，则应该将其保存到类对象中  • 如果这个属性(方法)是某个实例独有的。则应该保存到实例对象中  • 一般情况下，属性保存到实例对象中 而方法需要保存到类对象中"}, {"ctype": "head", "data": "五、self"}, {"ctype": "p", "data": "self在定义时需要定义，但是在调用时会自动传入。 self的名字并不是规定死的，但是最好还是按照约定是用self self总是指调用时的类的实例"}, {"ctype": "p", "data": "哪个对象调用我这个speak方法，那么self就是这个对象 self是调用我这个方法的实例对象本身（结合上方代码）"}, {"ctype": "head", "data": "六、特殊方法"}, {"ctype": "p", "data": "在类中可以定义一些特殊方法也称为魔术方法 特殊方法都是形如 xxx()这种形式 特殊方法不需要我们调用，特殊方法会在特定时候自动调用"}, {"ctype": "p", "data": "问题: 1.容易忘记要添加的参数，查看代码需要哪些参数比较麻烦2．没有提示，会导致后面代码运行出错 def _init _ (self，name，age):#实例创建的时候，init方法就会被调用（初始化方法）  self.name = name  self.age = age"}, {"ctype": "p", "data": "注：需要关注的点：类与实例的关系，以及类与实例的属性与方法"}], "cate": "Python"}
{"题目": "DCPose CVPR2021 充分利用帧间信息的多人姿态估计", "作者": "xz1203", "发布时间": "2021-03-27 19:58:18", "内容": [{"ctype": "p", "data": "最近看到一篇有关人体姿态估计的文章：Deep Dual Consecutive Network for Human Pose Estimation，是cvpr2021上的，在github上有代码实现。链接：https://github.com/Pose-Group/DCPose"}, {"ctype": "p", "data": "如下图所示，看起来效果还不错。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032719381077.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h6MTIwMw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "从git上下下来后，要配置环境："}, {"ctype": "p", "data": "首先创建conda虚拟环境并激活，一定是3.6的，我尝试过python3.7的，后面在安装模块的时候失败"}, {"ctype": "code", "data": "conda create -n DCPose python=3.6.12\nsource activate DCPose"}, {"ctype": "p", "data": "然后，pip依赖包"}, {"ctype": "code", "data": "pip install -r DCPose_requirement.txt"}, {"ctype": "p", "data": "接着，安装DCN模块，若上面是3.7，则此处可能失败，Windows也没成功"}, {"ctype": "code", "data": "cd thirdparty/deform_conv\npython setup.py develop"}, {"ctype": "p", "data": "最后，把模型文件下下来，放在对应的位置，模型文件给的是谷歌网盘，可以在这里下载，直接放在DCPose目录下就行。"}, {"ctype": "p", "data": "在demo文件夹下面给了一段示例代码，大致的逻辑是，将视频分解成图片并保存，然后读取本地图片，先由yolov3框出人，然后根据帧间信息进行姿态估计。"}, {"ctype": "p", "data": "将视频放入demo/input文件夹下，运行video.py即可"}, {"ctype": "code", "data": "cd demo/                   \nmkdir input/\npython video.py"}, {"ctype": "p", "data": "用了一段郭达斯坦森舞步的视频做测试，效果还不错，跳成这样也基本也都跟上了。显卡是960m，一帧都用了600ms左右，属实拉跨，yolov3大概是300ms，姿态估计也是300ms左右"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327195441452.gif"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "python基础知识整理 第六节：面向对象封装练习", "作者": "Upupup6", "发布时间": "2021-03-27 14:47:45", "内容": [{"ctype": "p", "data": "PS：在python3中，object是所有类的基类。也就是说只要我们定义了一个类，这个类最终的基类都是object类。（Object是python3中所有类的祖宗类）"}, {"ctype": "p", "data": "所以在以后定义类时，如果没有父类建议统一继承自object。"}, {"ctype": "code", "data": "class 类名(object):\n     pass"}, {"ctype": "p", "data": "面向对象开发的3大特性：封装、继承、多态。"}, {"ctype": "p", "data": "1、针对Person类"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326102759109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "2、针对于户型添加家具（哪一个类要被使用到就应该先开发那个类）"}, {"ctype": "code", "data": "class HouseItem:\n    def __init__(self,name,area):\n        self.Name=name\n        self.Area=area\n    def __str__(self):\n        return \"家具 %s 占地面积%.2f\"%(self.Name,self.Area) \nbed=HouseItem(\"席梦思\",130)\nchest=HouseItem(\"衣柜\",2)\ntable=HouseItem(\"餐桌\",1.5)\nprint(bed)\nprint(chest)\nprint(table)\n\nclass House:\n    def __init__(self,house_type,area):#户型和总面积应该由外界传递\n        self.House_type=house_type\n        self.Area=area\n        self.free_area=area#一个新房没有任何家具，所以剩余面积就等于总面积（剩余面积不需要由外界传递）\n        self.item_list=[]#新房子没有家具初始的时候只是一个空列表，所以在定义形参的时候只需要为户型和总面积传递两个形参就可以\n    def __str__(self):\n        return (\"该房子户型%s，总面积%.2f，添加了%s家具，[该房子剩余面积]%.2f\"\n                %(self.House_type,self.Area,\n                  self.item_list,self.free_area))  \n    def add_item(self,item):\n        #判断家具面积\n        if item.Area>self.free_area:\n            print(\"%s该家具放不下\"%item.Name)\n            return#只要return执行下方的代码就不会执行\n        #将家具的名称添加到列表中\n        self.item_list.append(item.Name)\n        #计算剩余面积\n        self.free_area-=item.Area\n\nmy_home=House(\"3室\",120)   \nmy_home.add_item(bed)\nmy_home.add_item(chest)\nmy_home.add_item(table)\nprint(my_home)"}, {"ctype": "p", "data": "结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326102601516.png"}, {"ctype": "p", "data": "3、（重点：一个对象的属性可以是另外一个类创建的对象）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326103330286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "class Gun:\n    def __init__(self,model):\n        self.Model=model\n        self.bullet_count=0\n    def add_bullet(self,count):\n        self.bullet_count+=count\n    def shoot(self):\n        #判断子弹数量\n        if self.bullet_count<=0:\n            print(\"%s没有子弹了\"%self.Model)\n            return\n        #发射子弹（-1）\n        self.bullet_count-=1\n        #提示发射子弹数量\n        print(\"[%s]剩余子弹[%d]\"%(self.Model,self.bullet_count))\n\n\nclass Soldier:\n    def __init__(self,name):\n        self.Name=name\n        #因为新兵没有枪\n        self.Gun=None#(使用None即定义属性又不设置具体的抢对象)\n        \"\"\"\n        在初始化方法中定义这个属性，避免了在给属性添加对象时，不要在外界添加这个属性，而应该在\n        初始化方法内部先把这个属性添加好，如果想要修改这个属性的值，我们再在外部使用赋值语句给这个属性\n        设置一个新对象就可以\n        \n        \"\"\"      \n    def fire(self):\n        #判断自己是否有枪\n        #if self.Gun==None:#==是比较变量的值是否相等的\n        if self.Gun is None:#身份运算符是用来比较内存的地址的\n            print(\"[%s]还没有枪\"%self.Name)\n            return\n        #枪装子弹\n        self.Gun.add_bullet(10)\n        #发射子弹\n        self.Gun.shoot()\n\n#创建枪对象\nAK47=Gun(\"AK47\")\n#AK47.add_bullet(10)#枪自己并不能装填子弹\n#AK47.shoot()#枪自己并不能发射，需要士兵完成\n\n\n#创建许三多士兵对象\nxusanduo=Soldier(\"许三多\")\n#在主程序中使用赋值语句给xusanduo赋值枪\nxusanduo.Gun=AK47\nxusanduo.fire()\nprint(xusanduo.Gun)"}, {"ctype": "p", "data": "结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326132611936.png"}, {"ctype": "p", "data": "4、私有属性和私有方法"}, {"ctype": "p", "data": "在定义属性和方法时，在属性名或者方法名前增加两个下划线，定义的就是私有属性和方法。"}, {"ctype": "p", "data": "私有属性和方法的应用场景就是：在实际开发中对象的某些属性和方法可能只希望在对象的内部被使用，而不希望在外部被访问到。"}, {"ctype": "p", "data": "PS：私有属性只是禁止在外界访问，而在对象的方法内部仍然正常访问。"}, {"ctype": "p", "data": "在对象的方法内部是可以访问属性以及自己的私有属性的。在外界不能调用对象的私有属性或者私有方法。"}, {"ctype": "p", "data": "虽然子类对象不能在自己的方法内部，直接访问父类的私有属性和私有方法；但是子类对象可以通过父类的公有方法间接访问到私有属性或者私有方法。"}, {"ctype": "code", "data": "class Women:\n    def __init__(self,name,age):\n        self.Name=name\n        self.__Age=age\n    #在对象的方法内部，是可以访问对象的私有属性的\n    def secret(self):\n        print(\"%s的年龄是%d\"%(self.Name,self.__Age))\nxiaofang=Women(\"小芳\",18)\n#私有属性，在外界不能够被直接访问\n#print(xiaofang.__Age)#报错：'Women' object has no attribute '__Age'\nxiaofang.secret()#输出：小芳的年龄是18(在对象的方法内部，是可以访问对象的私有属性的)"}, {"ctype": "p", "data": "5、继承：子类拥有父类的所有方法和属性"}, {"ctype": "p", "data": "继承的语法："}, {"ctype": "code", "data": "class 类名(父类名):\n     pass"}, {"ctype": "p", "data": "子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发。"}, {"ctype": "p", "data": "子类中应该根据职责，封装子类特有的属性和方法。"}, {"ctype": "p", "data": "PS：父类私有的属性和方法，是属于父类的；子类是无法访问到的。但是子类对象可以通过父类的公有方法间接访问到私有属性或者私有方法。"}, {"ctype": "p", "data": "5.1覆盖父类的方法"}, {"ctype": "p", "data": "5.2对父类的方法进行扩展"}, {"ctype": "p", "data": "如果在开发中，子类的方法实现中，包含父类的方法实现。（也就是说父类原本封装的方法实现是子类方法的一部分，但是父类的方法只能满足子类方法所需的一部分功能，这个时候就需要使用扩展的方式，在子类中对父类的方法进行一个扩展补充）"}, {"ctype": "p", "data": "扩展的方式：（在子类中对父类的方法进行扩展，但是仍然保留了父类中的方法，没有完全覆盖）"}, {"ctype": "p", "data": "在子类中重写父类的方法。在这个方法中，在需要的位置使用super().父类方法来调用父类方法的执行。代码其他的位置针对子类的需求，编写子类特有的代码实现。"}, {"ctype": "p", "data": "关于super："}, {"ctype": "code", "data": "class Animal:\n    def eat(self):\n        print(\"动物会吃\")\n    def drink(self):\n        print(\"动物会喝\")\n    def bark(self):\n        print(\"动物会叫\")\nclass Dog(Animal):\n    def swim(self):\n        print(\"狗会游泳\")\n    def bark(self):\n        print(\"狗会汪汪叫\")\nclass XiaoTianQuan(Dog):\n    def fly(self):\n        print(\"哮天犬会飞\")\n    def bark(self):\n        #1、针对子类特有的需求编写代码\n        print(\"我是哮天犬，比一般的狗叫的更大声\")\n        #2、使用super().调用原来在父类中封装的方法\n        super().bark()#如果把super方法注释掉，就不会调用到父类的方法了\n        \"\"\"\n        如果在子类中需要用到父类的方法，那么我们就在子类中使用super()\n        这个特殊的对象来调用父类方法的实现;而在其他的位置我们就可以根据子类特有的需求来\n        编写特有的代码就可以\n        \"\"\"\n         #3、增加其他子类的代码\n        print(\"我是神狗\")\nxtq=XiaoTianQuan()\nxtq.bark()"}, {"ctype": "p", "data": "结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326145425898.png"}, {"ctype": "p", "data": "6、多继承"}, {"ctype": "p", "data": "上述定义子类的小括号内只有一个父类，我们叫做单继承。而在python中，子类是可以拥有多个父类的，并且具有所有父类的属性和方法。"}, {"ctype": "p", "data": "语法："}, {"ctype": "code", "data": "class 子类（父类1，父类2...）:\n       pass"}, {"ctype": "p", "data": "Q：如果不同的父类中，存在同名的方法，子类对象在调用方法时，会调用哪一个父类的方法？"}, {"ctype": "p", "data": "A：首先在开发时应该尽量避免这种混淆的情况；如果父类之间存在同名的属性和方法，应该尽量避免使用多继承。（如果非要一样的话，那么是根据先后的继承顺序来执行的，小括号内的父类哪个在前调用哪个）"}, {"ctype": "p", "data": "7、多态"}, {"ctype": "p", "data": "一个是调用子类的方法，一个是调用父类中的方法。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326171300304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "8、类中的术语："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114039934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "PS：假如我们使用class关键字定义了一个类，程序在运行时这个类会不会被加载到内存呢？应该会的。假设我们在定义一个类之后，在程序运行时是不是可以使用这个类来创建出很多很多个对象，在对象的内存空间中保存的是什么内容呢？在对象的内存空间中保存的是不同对象各自不同的属性，而对象的实例方法是保存在类所在的内存空间的，当我们让某一个对象调用实例方法时，这个对象会把自己的引用当做参数传递给这个方法，因此对象的实例方法是保存在类所在的内存空间的，类在运行的时候同样也会被加载到内存。、"}, {"ctype": "p", "data": "除了可以封装实例的属性和方法之外，也可以访问类的属性或者调用类的方法。（因为类是一个特殊的对象，可以拥有自己的属性和方法，即类属性、类方；所以可以通过类名.的方式访问类的属性或者调用类的方法）（还有一种访问类属性的方式但是不推荐使用，对象.类属性）"}, {"ctype": "p", "data": "1、可以使用赋值语句定义类属性。"}, {"ctype": "p", "data": "定义类属性。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032712163424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "2、定义类方法"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327140125435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "3、静态方法"}, {"ctype": "p", "data": "通过类名.调用静态方法，不需要创建对象。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327140344457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "9、综合示例演示"}, {"ctype": "code", "data": "class Game(object):\n    top_score=100#类属性\n    @staticmethod\n    def show_help():\n        print(\"帮助信息\")\n    @classmethod\n    def show_top_score(cls):\n        print(\"这个游戏的历史最高分是%d\"%cls.top_score)\n        \n    def __init__(self,name):\n        self.player_name=name#实例属性\n    def start_game(self):\n        print(\"%s可以开始游戏了\"%self.player_name)\n#查看游戏的帮助信息\nGame.show_help()\n#查看历史最高分\nGame.show_top_score()\n#穿件游戏对象\nchiji=Game(\"小明\")\nchiji.start_game()\n"}, {"ctype": "p", "data": "结果："}, {"ctype": "p", "data": "  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144157974.png"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "Gurobi优化器下载安装以及如何部署在pycharm中", "作者": "总裁余(余登武)", "发布时间": "2021-03-27 16:38:17", "内容": [{"ctype": "p", "data": "Gurobi是著名的优化器。 最近在看一本书，里面的优化算法基本全部是用这个优化器写的，所以今天先讲解下如何安装."}, {"ctype": "p", "data": "第一步 注册网站 官网地址 https://www.gurobi.com/resources/prescriptive-analytics/"}, {"ctype": "p", "data": "点击login注册 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327155603806.png#pic_center"}], "cate": "Python"}
{"题目": "Python 数据结构", "作者": "我有两颗糖", "发布时间": "2021-03-27 17:19:29", "内容": [{"ctype": "head", "data": "1. List"}, {"ctype": "head", "data": "1.1 列表特性"}, {"ctype": "p", "data": "列表支持迭代，按索引访问："}, {"ctype": "code", "data": "myList = [1, 2, 3, 4]\nfor elem in myList:\n    print(elem)\n"}, {"ctype": "p", "data": "引用类型：列表名是列表的引用，删除列表名后列表仍然存在："}, {"ctype": "code", "data": "a = [1, 2, 3, 4]\nb = a\n\ndel a\nprint(b)\t# [1, 2, 3, 4]\n"}, {"ctype": "p", "data": "要删除列表本身，可以使用 del a[:] ："}, {"ctype": "code", "data": "a = [1, 2, 3, 4]\ndel a[:]\nprint(a)\t# []\n"}, {"ctype": "head", "data": "1.2 创建列表"}, {"ctype": "p", "data": "创建 1 维列表和 2 维列表："}, {"ctype": "code", "data": "a = [0, 1, 2, 3]\nb = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n"}, {"ctype": "p", "data": "使用 列表推导式"}, {"ctype": "code", "data": "squeres = [x**2 for x in range(0, 5)]\ncombination = [(x, y) for x in [1, 2, 3] for y in [1, 3] if x != y]\n"}, {"ctype": "p", "data": "如通过列表推导式将列表转置："}, {"ctype": "code", "data": "a = [[1, 2, 3],\t[4, 5, 6], [7, 8, 9]]\na = [[row[i] for row in a] for i in range(0, len(a[0]))]\nprint(a)\n"}, {"ctype": "head", "data": "1.3 常用方法："}, {"ctype": "code", "data": "list.append(x)\t# 在 list 尾部添加元素 x\nlist.extend(L)\t# 在 list 尾部添加列表 L\nlist.insert(i, x)\t# 在位置 i 处插入元素 x\nlist.remove(x)\t# 删除第一个值为 x 的元素，不存在则报错\nlist.pop([i])\t# 删除位置 i 处的元素并返回\nlist.clear()\t# 清空列表，相当与 del list[:]\nlist.count(x)\t# 返回元素 x 出现的次数\nlist.sort()\t\t# 就地排序\nlist.reverse()\t# 就地逆序\n"}, {"ctype": "p", "data": "list 可以用作栈或队列："}, {"ctype": "code", "data": "# stack\na = [1, 2, 3]\na.append(4)\nwhile a:\n\ta.pop()\n"}, {"ctype": "code", "data": "# queue\na = [1, 2, 3]\na.append()\na.pop(0)\n"}, {"ctype": "head", "data": "1.4 遍历"}, {"ctype": "p", "data": "使用下标 / in 遍历："}, {"ctype": "code", "data": "a = [1, 5, 7, 3, 4, 9]\nfor i in range(0, len(a)):\n\tprint(a[i])\n    \nfor i in a:\n\tprint(i)\n"}, {"ctype": "p", "data": "可以使用 zip() 将两个列表合并遍历："}, {"ctype": "code", "data": "names = ['Tom', 'Carry', 'Dom']\nspecies = ['cat', 'dog', 'squerra']\nfor name, species in zip(names, species):\n\tprint(name, species)\n"}, {"ctype": "head", "data": "2. Set"}, {"ctype": "p", "data": "set 是一个无序、元素不重复的集合"}, {"ctype": "p", "data": "可以对 set 做与、或、想减等运算："}, {"ctype": "code", "data": "a = set([1, 8, 3, 2])\nb = set([1, 5, 8])\nprint(a)\t\t# {8, 1, 2, 3}\nprint(a & b)\t# {8, 1}\nprint(a | b)\t# {1, 2, 3, 5, 8}\nprint(a - b)\t# {2, 3}\n"}, {"ctype": "head", "data": "3. dict"}, {"ctype": "head", "data": "3.1 创建字典"}, {"ctype": "code", "data": "pets = {\n\t'cat': 'Tom',\n\t'mouse': 'Jerry',\n\t'dog': 'Dofphy'\n}\n"}, {"ctype": "p", "data": "dict 可以直接从 key-value 中创建字典："}, {"ctype": "code", "data": "d = dict([('a', 1), ('b', 2), ('c', 3)])\n"}, {"ctype": "p", "data": "也可以使用推导式创建："}, {"ctype": "code", "data": "squares = {x: x**2 for x in range(0, 5)}\n"}, {"ctype": "head", "data": "3.2 访问键值对"}, {"ctype": "p", "data": "可以直接使用类似列表的索引："}, {"ctype": "code", "data": "pets = {\n\t'cat': 'Tom',\n\t'mouse': 'Jerry',\n\t'dog': 'Dofphy'\n}\nprint(type(pets['cat']))\t# str\n"}, {"ctype": "p", "data": "可以使用 dict.items(), dict.kes() 和 dict.values() 遍历："}, {"ctype": "code", "data": "for species, name in pets.items():\n\tprint(species, name)\n\nfor species in pets.keys():\n\tprint(species)\n\nfor name in pets.values():\n\tprint(name)\n"}, {"ctype": "p", "data": "End …"}], "cate": "Python"}
{"题目": "011_wz_ledr_pytorch深度学习实战_第十二讲——循环神经网络（RNN）基础篇", "作者": "王泽的随笔", "发布时间": "2021-03-27 21:30:16", "内容": [{"ctype": "head", "data": "一、目的"}, {"ctype": "p", "data": "搭建简单的RNN，实现seq2seq的转换"}, {"ctype": "head", "data": "二、编程"}, {"ctype": "p", "data": "先大概了解一下RNN  RNN 其实也是一个普通的神经网络，只不过多了一个 hidden_state 来保存历史信息。跟一般网络不同的是，RNN 网络的输入数据的维度通常是\n    \n     \n      \n       \n        [\n       \n       \n        b\n       \n       \n        a\n       \n       \n        t\n       \n       \n        c\n       \n       \n        h\n       \n       \n        _\n       \n       \n        s\n       \n       \n        i\n       \n       \n        z\n       \n       \n        e\n       \n       \n        ∗\n       \n       \n        s\n       \n       \n        e\n       \n       \n        q\n       \n       \n        l\n       \n       \n        e\n       \n       \n        n\n       \n       \n        ∗\n       \n       \n        i\n       \n       \n        n\n       \n       \n        p\n       \n       \n        u\n       \n       \n        t\n       \n       \n        _\n       \n       \n        s\n       \n       \n        i\n       \n       \n        z\n       \n       \n        e\n       \n       \n        ]\n       \n      \n      \n       [batch\\_size*seqlen*input\\_size]\n      \n     \n    [batch_size∗seqlen∗input_size]，它多了一个序列长度\n    \n     \n      \n       \n        s\n       \n       \n        e\n       \n       \n        q\n       \n       \n        l\n       \n       \n        e\n       \n       \n        n\n       \n      \n      \n       seqlen\n      \n     \n    seqlen。在前向过程中，我们会把样本\n    \n     \n      \n       \n        t\n       \n      \n      \n       t\n      \n     \n    t个时间序列\n    \n     \n      \n       \n        \n         x\n        \n        \n         1\n        \n       \n       \n        ,\n       \n       \n        \n         x\n        \n        \n         2\n        \n       \n       \n        ,\n       \n       \n        .\n       \n       \n        .\n       \n       \n        .\n       \n       \n        ,\n       \n       \n        \n         x\n        \n        \n         t\n        \n       \n      \n      \n       x_1,x_2,...,x_t\n      \n     \n    x1​,x2​,...,xt​的信息不断输入同一个网络 ，因为是重复地使用同一个网络，所以称为循环神经网络。  关于 RNN，你只需要记住一个公式：\n     \n      \n       \n        \n         \n          h\n         \n         \n          t\n         \n        \n        \n         =\n        \n        \n         t\n        \n        \n         a\n        \n        \n         n\n        \n        \n         h\n        \n        \n         (\n        \n        \n         \n          w\n         \n         \n          \n           i\n          \n          \n           h\n          \n         \n        \n        \n         \n          x\n         \n         \n          t\n         \n        \n        \n         +\n        \n        \n         \n          b\n         \n         \n          \n           i\n          \n          \n           h\n          \n         \n        \n        \n         +\n        \n        \n         \n          w\n         \n         \n          \n           h\n          \n          \n           h\n          \n         \n        \n        \n         \n          h\n         \n         \n          \n           t\n          \n          \n           −\n          \n          \n           1\n          \n         \n        \n        \n         +\n        \n        \n         \n          b\n         \n         \n          \n           h\n          \n          \n           h\n          \n         \n        \n        \n         )\n        \n       \n       \n        h_t=tanh(w_{ih}x_t+b_{ih}+w_{hh}h_{t-1}+b_{hh})\n       \n      \n     ht​=tanh(wih​xt​+bih​+whh​ht−1​+bhh​)这也是 pytorch 官方文档中给出的最原始的 RNN 公式，其中\n    \n     \n      \n       \n        w\n       \n      \n      \n       w\n      \n     \n    w表示 weight，\n    \n     \n      \n       \n        b\n       \n      \n      \n       b\n      \n     \n    b表示 bias，\n    \n     \n      \n       \n        \n         x\n        \n        \n         t\n        \n       \n      \n      \n       x_t\n      \n     \n    xt​是输入，\n    \n     \n      \n       \n        \n         h\n        \n        \n         t\n        \n       \n      \n      \n       h_t\n      \n     \n    ht​是隐藏状态。回忆一下，普通的神经网络只有\n    \n     \n      \n       \n        \n         w\n        \n        \n         \n          i\n         \n         \n          h\n         \n        \n       \n       \n        \n         x\n        \n        \n         t\n        \n       \n       \n        +\n       \n       \n        \n         b\n        \n        \n         \n          i\n         \n         \n          h\n         \n        \n       \n      \n      \n       w_{ih}x_t+b_{ih}\n      \n     \n    wih​xt​+bih​这一部分，而 RNN 无非就是多加了一个隐藏状态的信息\n    \n     \n      \n       \n        \n         w\n        \n        \n         \n          h\n         \n         \n          h\n         \n        \n       \n       \n        \n         h\n        \n        \n         \n          t\n         \n         \n          −\n         \n         \n          1\n         \n        \n       \n       \n        +\n       \n       \n        \n         b\n        \n        \n         \n          h\n         \n         \n          h\n         \n        \n       \n      \n      \n       w_{hh}h_{t-1}+b_{hh}\n      \n     \n    whh​ht−1​+bhh​而已。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327182013698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODY5NzEx,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "普通网络都是一次前向传播就得到结果，而 RNN 因为多了 sequence 这个维度，所以需要跑 n 次前向。"}, {"ctype": "p", "data": "编程实现分为两种一种是使用RNNCell，另一种是直接使用RNN RNNCell："}, {"ctype": "code", "data": "import torch\n\n# 输入样本特征数\ninput_size = 4\n# 隐藏层样本特征数（分类数）\nhidden_size = 4\n# batch大小\nbatch_size = 1\n\nidx2char = ['e', 'h', 'l', 'o']\n# hello\nx_data = [1, 0, 2, 2, 3]\n# ohlol\ny_data = [3, 1, 2, 3, 2]\n\n# 将x_data转换为one_hot表示\n'''\ntorch.eye()\n参数：\nn (int ) – 行数\nm (int, optional) – 列数.如果为None,则默认为n\nout (Tensor, optinal) - Output tensor\n'''\nx_one_hot = torch.eye(n=4)[x_data, :]\ny_one_hot = torch.eye(n=4)[y_data, :]\n\n# x_data转换维度为(seqlen, batch_size, input_size),此维度为RNN的输入\ninputs = x_one_hot.view(-1, batch_size, input_size)\n# y_data转换维度为(seqlen，1)\nlabels = torch.LongTensor(y_data).view(-1, 1)\n\n# 构建神经网络模型\nclass Model(torch.nn.Module):\n    def __init__(self):\n        super(Model, self).__init__()\n        self.input_size = input_size\n        self.batch_size = batch_size\n        self.hidden_size = hidden_size\n        # 对于RNNCell输入为(batch_size, input_size)，隐层为(batch_size, hidden_size)\n        self.rnncell = torch.nn.RNNCell(input_size=self.input_size, hidden_size=self.hidden_size)\n\n    def forward(self, input, hidden):\n        # h_t=Cell(x_t, h_t-1)\n        hidden = self.rnncell(input, hidden)\n        return hidden\n\n    # 初始化隐层h_0\n    def init_hidden(self):\n        return torch.zeros(self.batch_size, self.hidden_size)\n\n\nmodel = Model()\n\n# 构建损失函数和优化器\ncriterion = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01)\n\n# 训练\nfor epoch in range(60):\n    loss = 0\n    optimizer.zero_grad()\n    # h_0\n    hidden = model.init_hidden()\n    print('Predicted string:', end='')\n    for input, label in zip(inputs, labels):\n        hidden = model(input, hidden)\n        loss += criterion(hidden, label)\n        _, idx = hidden.max(dim=1)\n        print(idx2char[idx.item()], end='')\n    loss.backward()\n    optimizer.step()\n    print(', epoch[%d/60] loss=%.4f' % (epoch+1, loss.item()))\n"}, {"ctype": "p", "data": "预测结果："}, {"ctype": "code", "data": "Predicted string:llllo, epoch[1/60] loss=6.3004\nPredicted string:lllll, epoch[2/60] loss=6.1191\n\n...\nPredicted string:ohlol, epoch[59/60] loss=3.0500\nPredicted string:ohlol, epoch[60/60] loss=3.0195\n"}, {"ctype": "p", "data": "RNN："}, {"ctype": "code", "data": "import torch\n\n# 输入样本特征数\ninput_size = 4\n# 隐藏层样本特征数（分类数）\nhidden_size = 4\n# batch大小\nbatch_size = 1\n# RNN的层数\nnum_layers = 1\n\nidx2char = ['e', 'h', 'l', 'o']\n# hello\nx_data = [1, 0, 2, 2, 3]\n# ohlol\ny_data = [3, 1, 2, 3, 2]\n\n# 将x_data转换为one_hot表示\n'''\ntorch.eye()\n参数：\nn (int ) – 行数\nm (int, optional) – 列数.如果为None,则默认为n\nout (Tensor, optinal) - Output tensor\n'''\nx_one_hot = torch.eye(n=4)[x_data, :]\ny_one_hot = torch.eye(n=4)[y_data, :]\n\n# x_data转换维度为(seqlen, batch_size, input_size),此维度为RNN的输入\ninputs = x_one_hot.view(-1, batch_size, input_size)\n# y_data转换维度为(seqlen*batch_size，1)\nlabels = torch.LongTensor(y_data)\n\n# 构建神经网络模型\nclass Model(torch.nn.Module):\n    def __init__(self):\n        super(Model, self).__init__()\n        self.input_size = input_size\n        self.batch_size = batch_size\n        self.hidden_size = hidden_size\n        self.num_layers = num_layers\n        # 对于RNN输入为(seqlen, batch_size, input_size)\n        self.rnn = torch.nn.RNN(input_size=self.input_size, hidden_size=self.hidden_size, num_layers=self.num_layers)\n\n    def forward(self, input):\n        hidden = torch.zeros(self.num_layers, self.batch_size, self.hidden_size)\n        # h_t=Cell(x_t, h_t-1)\n        out, _ = self.rnn(input, hidden)\n        out = out.view(-1, self.hidden_size)\n        return out\n\n\nmodel = Model()\n\n# 构建损失函数和优化器\ncriterion = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n# 训练\nfor epoch in range(60):\n    optimizer.zero_grad()\n    outputs = model(inputs)\n    loss = criterion(outputs, labels)\n    loss.backward()\n    optimizer.step()\n\n    _, idx = outputs.max(dim=1)\n    idx = idx.data.numpy()\n    print(\"Predicted:\", ''.join([idx2char[x]for x in idx]), end='')\n    print(\",epoch[%d/60] loss=%.4f\" % (epoch+1, loss.item()))\n"}, {"ctype": "p", "data": "预测结果："}, {"ctype": "code", "data": "Predicted: hhhhh,epoch[1/60] loss=1.4128\nPredicted: oholl,epoch[2/60] loss=1.1269\n...\nPredicted: ohlol,epoch[59/60] loss=0.4408\nPredicted: ohlol,epoch[60/60] loss=0.4407\n"}, {"ctype": "head", "data": "三、参考"}, {"ctype": "p", "data": "pytorch深度学习实践 Pytorch实现RNN"}, {"ctype": "head", "data": "注：【PyTorch】深度学习实践 b站 第12讲RNN基础篇非常不错的一篇文章"}], "cate": "Python"}
{"题目": "2-PyQt快速开发项目采用nuitka打包案例", "作者": "阿飞哥666", "发布时间": "2021-03-27 19:50:41", "内容": [{"ctype": "head", "data": "系列文章目录"}, {"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "提示：本案例是“2-一文讲清楚：nuitka用于python打包（应用于PyQt5编程打包）”、3.nuitka只打一次包多次版本发布应用。 本文未完结… "}, {"ctype": "p", "data": "提示：以下是本篇文章正文内容，下面案例可供参考"}, {"ctype": "head", "data": "一、项目代码目录层级"}, {"ctype": "p", "data": "项目目录结构："}, {"ctype": "code", "data": " 入口程序.py\n client # 项目目录入口\n      callMain.py\n      view 目录\n           页面py文件\n       dbase目录\n res # 资源目录，用于存储图片等\n"}, {"ctype": "p", "data": "原来是采用callMain.py转换为pyd文件之后，放入clien目录下，用于阻断nuitka打包view、dbase目录下的py文件。当前最新nuitka版本（0.6.13）有一个功能可以不打包client目录（可能以前版本也有类似的没有细究）。"}, {"ctype": "head", "data": "二、打包环境维护"}, {"ctype": "p", "data": "在入口程序加入以下代码，方便模块引用："}, {"ctype": "code", "data": "import os\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(BASE_DIR)\nsys.path.append(os.path.join(BASE_DIR, 'client'))\n"}, {"ctype": "p", "data": "在client下的某个程序需要应用client要调用dbase下的函数时就可以使用以下方法： from dbase import xxxx 否则就需要使用 from …dbase import xxxx方式才行，如果层级再深一级就要4个点。"}, {"ctype": "p", "data": "资源相关文件使用如下代码处理："}, {"ctype": "code", "data": "def resourcePath(relative_path):\n\tbase_path = os.path.abspath(\".\")\n\tr = os.path.join(base_path, relative_path)\n\treturn r\n"}, {"ctype": "code", "data": "#代码示例\ndef doSomeThing():\n\tif os.path.isfile('res/dts/aaa.png'):\n\t\tprint('存在')\n\tif os.path.isfile(resourcePath('res/dts/aaa.png')):\n\t\tprint('存在')\n"}, {"ctype": "p", "data": "注：经过测试，nuitka解决resourcepath这个函数想要解决的问题。这个函数留着这里，建议大家还是按照这种方式进行处理比较保险。"}, {"ctype": "head", "data": "三、打包命令"}, {"ctype": "code", "data": "Nuitka-0.6.8.4\nnuitka --mingw64 --windows-disable-console --standalone --show-progress --show-memory --plugin-enable=qt-plugins --plugin-enable=pylint-warnings --recurse-all --recurse-not-to=numpy,jinja2,matplotlib,scipy,sqlalchemy,pandas,pygal,pyzbar,pubunit,qtunit,dataunit --windows-icon=D:\\proAll\\DataTools\\trunk\\src\\res\\dts\\desico.ico --output-dir=D:\\打包结果\\数据处理工具 testDtsRun.py\nNuitka-0.6.13\npython -m nuitka --mingw64 --standalone --show-progress --show-memory --plugin-enable=qt-plugins --plugin-enable=pylint-warnings --nofollow-import-to=numpy,jinja2,matplotlib,scipy,sqlalchemy,pandas,pygal,pyzbar,pubunit,qtunit,dataunit,client --windows-icon-from-ico=D:\\proAll\\DataTools\\src\\res\\dts\\img\\desico.ico  --output-dir=D:\\打包结果\\数据处理工具 testDtsRun.py\n"}, {"ctype": "p", "data": "注1： nuitka 0.6.8.4 打包前提，先把callMain.py编译出一个pyd文件存放在callMain.py同级目录下（调用优先读取pyd文件）。"}, {"ctype": "p", "data": "注2： nuitka 0.6.13 版本在排除模块参数后面加入了client表示不处理client，由打包用户自己维护"}, {"ctype": "p", "data": "**注3：**正式版本打包加入："}, {"ctype": "code", "data": "--windows-disable-console --windows-icon-from-ico=exe图标文件路径.ico\n"}, {"ctype": "head", "data": "五、依赖发布"}, {"ctype": "p", "data": "把以下三点准备好存放到一个准备的目录下，以备下次打包使用："}, {"ctype": "code", "data": "1. 源码编译\n2. 资源准备\n3. 三方依赖包\n"}, {"ctype": "head", "data": "1.源码编译"}, {"ctype": "p", "data": "采用cython进行编译py，之后按源码目录保存到打包目录下。资源目录存放在exe同级之下。"}, {"ctype": "head", "data": "2.三方依赖包"}, {"ctype": "p", "data": "由于采用阻断打包方式、并排除一些导入模块这种方式，需要在程序运行之前，找到这些依赖包拷贝到运行exe同级目录下。 采用调试模式打包，打开cmd窗口，切换到打包目录下，执行exe文件，根据cmd 界面提示****模块找不到，到："}, {"ctype": "code", "data": "C:\\Users\\lch\\AppData\\Local\\Programs\\Python\\Python38\\Lib\\site-packages\n"}, {"ctype": "p", "data": "类似目录下找到对应模块，拷贝到exe同级目录下，同时备份一份到打包准备目录下"}, {"ctype": "p", "data": "每个页面、每个按钮都点击一下，以保证找到所有依赖。"}, {"ctype": "head", "data": "六、360报毒处理"}, {"ctype": "p", "data": "代码中用到了“system、exce”等，打包到exe中，必然会被360等杀毒软件报毒。 解决办法：把这段代码打包到pyd中，不包含到exe即可"}], "cate": "Python"}
{"题目": "2.机器学习，k-近邻算法", "作者": "攀爬←蜗牛", "发布时间": "2021-03-27 20:25:00", "内容": [{"ctype": "head", "data": "1.概述"}, {"ctype": "p", "data": "采用测量不同特征值之间距离的方法进行分类的方法 1.已知样本数据集及其对应的标签（类别）"}, {"ctype": "p", "data": "2.把新数据的各个特征与样本集中数据的对应特征作比较"}, {"ctype": "p", "data": "3.然后提取样本集中前k项样本特征最相似的数据的标签作为新数据的分类依据（算法处理）"}, {"ctype": "head", "data": "2.Python写算法"}, {"ctype": "head", "data": "2.1创建名为KNN.py的Python模块"}, {"ctype": "p", "data": "添加代码（详细看代码注释）："}, {"ctype": "code", "data": "from numpy import*      #导入科学计算包numpy（线性运算）\nimport operator         #导入运算符模块  （排序等）\ndef createDataSet():    #定义函数createDataSet(),gruop和labels分别为数据和标签\n      group = array([[1.1,1.1],[1.0,1.0],[0,0],[0,0.1]])  #每一个数据都是一个数列，每一个数代表一个特征\n      labels = ['A','A','B','B']\n      return group,labels\n\n"}, {"ctype": "head", "data": "2.2KNN分类算法"}, {"ctype": "p", "data": "1.计算已知数据中的点与当前点之间的举例；2.按照距离持续递增排序；3.选取与当前点距离最小的K个点；4.确定前k个点所在标签出现的频率；5.返回前k个点出现频率最高的标签作为新数据的预测分类；"}, {"ctype": "p", "data": "近邻算法程序："}, {"ctype": "code", "data": "def classify0(inX,dataSet,labels,k):                           #说明1见代码段下\n      dataSetSize = dataSet.shape[0]                         #2\n      diffMat = tile(inX,(dataSetSize,1)) - dataSet     #3\n      sqDiffMat = diffMat**2\n      sqDistances = sqDiffMat.sum(axis=1)                   #4\n      distances = sqDistances**0.5\n      sortedDistIndicies = distances.argsort()   #将数组中的数据在整体中的大小排名按按照从小到大排序\n      classCount = {}           #定义一个字典\n      for i in range(k):           #分别给i赋值0~k，不包括k\n            voteIlabel = labels[sortedDistIndicies[i]]\n            classCount[voteIlabel] = classCount.get(voteIlabel,0)+1\n      sortedClassCount = sorted(classCount.items(),key = operator.itemgetter(1),reverse = True)\n      return sortedClassCount[0][0]\n"}, {"ctype": "p", "data": "说明： 1.定义了classify0函数，参数：inX需要分类的数据；dataSet：样本数据；Labels：样本数据标签；k：取前K个最接近的标签作为分类依据。 2.shape函数的功能是读取数组维度和长度的函数，shape[0]是读取矩阵第一维度的长度。shape[[5,7,9],[1,2,3]]返回值为（2，3）代表第一维度[],[]长度（元素个数）为2，第二维度长度为3。也可以理解为返回值为行数和列数。 3.tile函数，重复复制inX，行复制dataSetSize次，列数不便。 4.将矩阵的每一行向量相加（有axis=1这个参数时）"}, {"ctype": "head", "data": "2.3.处理得到需要分析的数据"}, {"ctype": "code", "data": "def file2matrix(filename):   #定义文本处理函数\n      fr = open(filename)    #打开一个文本记录\n      arrayOfLines = fr.readlines()   #.readlines函数，读取文本文件的所有行\n      numberOfLines = len(arrayOfLines)  #读取行数\n      returnMat = zeros((numberOfLines,3))  \n      classLabelVector = []\n      index = 0\n      for line in arrayOfLines:\n            line = line.strip()   #strip（*）函数，移除字符串头尾指定的字符*（默认为空格或换行符）或字符序列\n            listFromLine = line.split('\\t') #制表符\n            returnMat[index,:] = listFromLine[0:3]  #读取前三个数据\n            classLabelVector.append(int(listFromLine[-1]))  #读取最后一行数据\n            index += 1\n      return returnMat,classLabelVector\n"}, {"ctype": "head", "data": "2.3.创建散点图Matplotlib"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": "import matplotlib\nimport matplotlib.pyplot as plt\ndef Drawing(Matrix):\n      fig = plt.figure()\n      ax = fig.add_subplot(111)  #1\n      ax.scatter(Matrix[:,1],Matrix[:,2])  #2\n      plt.show()\n"}, {"ctype": "p", "data": "说明： 1.add_subplot(111)函数，例：add_subplot(223)将图纸分为2*2的4块区域，指定在第三块作图 2.scatter函数：请点击连接参考：点这里学习scatter！！！！！！"}, {"ctype": "head", "data": "2.4.归一化操作"}, {"ctype": "p", "data": "某些特征的数值相对于其他值特别大，会影响分类的准确性，归一化数值可以将数值控制在0~1区间，得到更加准确的分类结果。"}, {"ctype": "code", "data": "def autoNorm(dataSet):\n      minVals = dataSet.min(0)   #得到每一列最小的值\n      maxVals = dataSet.max(0)    #得到每一列最大的值 \n      ranges = maxVals - minVals  \n      normDataSet = zeros(shape(dataSet))\n      m = dataSet.shape(0)\n      normDataSet = dataSet - tile(minVals,(m,1))\n      normDataSet = normDataSet/tile(ranges,(m,1))\n      return normDataSet,ranges,minVals\n"}, {"ctype": "head", "data": "2.5.主代码"}, {"ctype": "code", "data": "def datingClassTest():\n      hoRatio = 0.10\n      datingDataMat,datingLabels = file2matrix('datingTestSet.txt')\n      normMat,ranges,minVals = autoNorm(datingDataMat)\n      m = normMat.shape[0]\n      numTestVecs = int(m*hoRatio)\n      errorCount = 0.0\n      for i in range(numTestVecs):\n            classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],3)\n     str = \"the classifier come back with: %d, the real answer is : %d ||%d\"% (classifierResult,datingLabels[i],index)\n            print(str)\n            index +=1\n            if (classifierResult != datingLabels[i]):errorCount += 1.0\n      str = \"the total error rate is : %f\" % (errorCount/float(numTestVecs))\n      print (str)      \n"}, {"ctype": "head", "data": "2.6.输出结果"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210316003137162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NDY0MzQ5,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.总代码"}, {"ctype": "code", "data": "from numpy import*\nimport operator\n#打开文档，提取整理样本数据\ndef file2matrix(filename):\n      fr = open(filename)\n      arrayOfLines = fr.readlines()\n      numberOfLines = len(arrayOfLines)\n      returnMat = zeros((numberOfLines,3))\n      classLabelVector = []\n      index = 0\n      for line in arrayOfLines:\n            line = line.strip()\n            listFromLine = line.split('\\t')\n            returnMat[index,:] = listFromLine[0:3]\n            classLabelVector.append(int(listFromLine[-1]))\n            index += 1\n      return returnMat,classLabelVector\n\n#K-近邻法 分类\ndef classify0(inX,dataSet,labels,k):\n      dataSetSize = dataSet.shape[0]\n      diffMat = tile(inX,(dataSetSize,1)) - dataSet\n      sqDiffMat = diffMat**2\n      sqDistances = sqDiffMat.sum(axis=1)                   #将矩阵的每一行向量相加（有axis=1这个参数时）\n      distances = sqDistances**0.5\n      sortedDistIndicies = distances.argsort()              #将数组中的数据在整体中的大小排名按按照从小到大排序\n      classCount = {}                                       #定义一个字典\n      for i in range(k):                                    #分别给i赋值0~k，不包括k\n            voteIlabel = labels[sortedDistIndicies[i]]\n            classCount[voteIlabel] = classCount.get(voteIlabel,0)+1\n      sortedClassCount = sorted(classCount.items(),key = operator.itemgetter(1),reverse = True)\n      return sortedClassCount[0][0]\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef Drawing(Matrix):\n      fig = plt.figure()\n      ax = fig.add_subplot(111)\n      ax.scatter(Matrix[:,1],Matrix[:,2])\n      plt.show()\n#数值归一化\ndef autoNorm(dataSet):\n      minVals = dataSet.min(0)\n      maxVals = dataSet.max(0)\n      ranges = maxVals - minVals\n      normDataSet = zeros(shape(dataSet))\n      m = dataSet.shape[0]\n      normDataSet = dataSet - tile(minVals,(m,1))\n      normDataSet = normDataSet/tile(ranges,(m,1))\n      return normDataSet,ranges,minVals\n#主代码\ndef datingClassTest():\n      hoRatio = 0.1\n      datingDataMat,datingLabels = file2matrix('F:\\桌面\\py工作\\约会\\约会分类训练数据.txt')\n      normMat,ranges,minVals = autoNorm(datingDataMat)\n      m = normMat.shape[0]\n      numTestVecs = int(m*hoRatio)\n      errorCount = 0.0\n      index = 1\n      for i in range(numTestVecs):\n            classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],3)\n            str = \"the classifier come back with: %d, the real answer is : %d ||%d\"% (classifierResult,datingLabels[i],index)\n            print(str)\n            index +=1\n            if (classifierResult != datingLabels[i]):errorCount += 1.0\n      str = \"the total error rate is : %f\" % (errorCount/float(numTestVecs))\n      print (str)\n      \n"}, {"ctype": "head", "data": "3.1.附件：样本数据"}, {"ctype": "p", "data": "数据点这里！"}], "cate": "Python"}
{"题目": "使用MTCNN进行人脸检测", "作者": "Mithrandir_74", "发布时间": "2021-03-27 10:24:00", "内容": [{"ctype": "head", "data": "github地址"}, {"ctype": "p", "data": "https://github.com/ipazc/mtcnn"}, {"ctype": "head", "data": "本机环境"}, {"ctype": "code", "data": "python 3.7\nKeras 2.2.0\nopencv-python 4.5.1.48\ntensorflow 1.13.1\n"}, {"ctype": "head", "data": "检测函数及实例"}, {"ctype": "code", "data": "import cv2\nfrom mtcnn import MTCNN\n\ndetector = MTCNN()\n\ndef detec_face(imgFileName):\n    image = cv2.cvtColor(cv2.imread(imgFileName), cv2.COLOR_BGR2RGB)\n    result = detector.detect_faces(image)\n\n    if len(result) == 0:\n        print(\"图片 \"+imgFileName+\" 没有检测到人脸。\")\n        print(\"---------------------------\")\n    else:\n        count = len(result)\n        for item in result:\n            bounding_box = item[\"box\"]\n            cv2.rectangle(image,\n                          (bounding_box[0], bounding_box[1]),\n                          (bounding_box[0] + bounding_box[2], bounding_box[1] + bounding_box[3]),\n                          (0, 155, 255),\n                          2)\n            cv2.imwrite(imgFileName.split(\".\")[0]+\"_result.\"+imgFileName.split(\".\")[1], cv2.cvtColor(image, cv2.COLOR_RGB2BGR))\n        print(\"图片 \"+imgFileName+\" 检测到{}张人脸，如下：\".format(count))\n        for i in range(count):\n            print(\"人脸{}：{}\".format(i+1,result[i]))\n        print(\"---------------------------\")\n\ndetec_face(\"image/single_face.jpg\")\ndetec_face(\"image/more_face.jpg\")\ndetec_face(\"image/no_face.jpg\")\n\n"}, {"ctype": "head", "data": "运行结果"}, {"ctype": "p", "data": "程序输出：  左侧原图，右侧运行结果 no_face.jpg为不含人脸的风景图片，不做列出 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327102110397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAxMzk2MQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python中的矩阵和数组之间的运算", "作者": "weixin_45699092", "发布时间": "2021-03-27 11:16:32", "内容": [{"ctype": "p", "data": "python中的矩阵和数组之间的运算"}, {"ctype": "p", "data": "一、当矩阵为方阵(p×p维)"}, {"ctype": "code", "data": "a=np.matrix(np.array([[1,2],[3,4]]))\nprint(a.shape)\na\n输出：\n(2, 2)\nmatrix([[1, 2],\n        [3, 4]])\n\n#使用dot\nb=np.array([1,2])\nprint(b.shape)\nb\n输出：\n(2,)\narray([1, 2])\n\na.dot(b)\n输出：\nmatrix([[ 5, 11]]) #5=1*1+2*2,11=3*1+4*2，此时b被看成了2×1的矩阵\n\nb.dot(a)\n输出：\nmatrix([[ 7, 10]]) #7=1*1+2*3,10=1*2+2*4，此时b被看成了1×2的矩阵\n\na.dot(b.T)\n输出：\nmatrix([[ 5, 11]]) \n\nb.T.dot(a)\nmatrix([[ 7, 10]])\n#不管转置与否，b被看成什么样子完全由乘法的顺序和a的形状决定\n\n#使用*\nb*a\n输出：\nmatrix([[ 7, 10]])\n\na*b #报错了\n\nnp.matrix(b)\n输出：\nmatrix([[1, 2]])\n#如果用*的话，b是被看成了1×2的矩阵\n"}, {"ctype": "p", "data": " 总结："}, {"ctype": "p", "data": "设矩阵为p×p维"}, {"ctype": "p", "data": "在用numpy进行科学计算时，数组在矩阵的左右都可以通过dot方法进行矩阵乘法运算，但是在左右两边的计算结果不一样的，不管转置与否，在右边数组被看成p×1维，在左边数组被看成1×p维."}, {"ctype": "p", "data": "在用*进行运算时，数组与矩阵进行运算时会被看做行向量1×p维."}, {"ctype": "p", "data": "二、当矩阵为普通矩阵(m×n维)"}, {"ctype": "code", "data": "a=np.matrix(np.array([[1,2],[3,4],[5,6]]))\nprint(a.shape)\na\n输出：\n(3, 2)\nmatrix([[1, 2],\n        [3, 4],\n        [5, 6]])\n\nb=np.array([1,2,3])\nprint(b.shape)\nb\n输出：\n(3,)\narray([1, 2, 3])\n\nc=np.array([1,2])\nprint(c.shape)\nc\n输出：\n(2,)\narray([1, 2])\n\na.dot(b) #报错，此时维度对不上了\na.dot(c)\n输出：\nmatrix([[ 5, 11, 17]]) \na.dot(c.T)\n输出：\nmatrix([[ 5, 11, 17]])\n#5=1*1+2*2，11=3*1+4*2，17=5*1+6*2，不管转置与否，此时c都被看成了2×1的矩阵\n\nb.dot(a)\n输出：\nmatrix([[22, 28]])\nb.T.dot(a)\n输出：\nmatrix([[22, 28]])\n#22=1*1+2*3+3*5,28=1*2+2*4+3*6=28，不管转置与否，此时b都被看成了1×3的矩阵\nc.dot(a) #报错，此时维度对不上了 \n\nb*a\n输出：\nmatrix([[22, 28]])\n(b.T)*a\n输出：\nmatrix([[22, 28]])\n\nnp.matrix(b)\n输出：\nmatrix([[1, 2, 3]])\n#不管转置与否，此时b都被看成了1×3的矩阵"}, {"ctype": "p", "data": "总结："}, {"ctype": "p", "data": "设矩阵为m×n维"}, {"ctype": "p", "data": "在用numpy进行科学计算时，若数组内有m个数，此时只在矩阵的左边通过dot方法进行矩阵乘法运算，不管转置与否，此时数组被看成了1×m维的矩阵.若数组内有n个数，此时只在矩阵的右边通过dot方法进行矩阵乘法运算，不管转置与否，此时数组被看成了n×1维的矩阵."}, {"ctype": "p", "data": "在用*进行运算时，数组与矩阵进行运算时不管数组转置与否都会被看做行向量1×m或1×n维的矩阵."}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "理解Shebang line: #!/usr/bin/python3", "作者": "quantLearner", "发布时间": "2021-03-27 10:31:51", "内容": [], "cate": "Python"}
{"题目": "Python 面向对象", "作者": "我有两颗糖", "发布时间": "2021-03-27 23:31:53", "内容": [{"ctype": "head", "data": "1. Classes and Instances"}, {"ctype": "p", "data": "类的创建与实例化"}, {"ctype": "code", "data": "class Animal():\n\tdef __init__(self, species, name):\n\t\tself.species = species\n\t\tself.name = name\n\n\tdef get_description(self):\n\t\tdes = self.name + ' is a ' + self.species + '.'\n\t\treturn des.title()\n\ntom = Animal('cat', 'Tom')\ntom.get_description()\t# Tom Is A Cat.\n"}, {"ctype": "p", "data": "方法 __init__() 是一个特殊的方法，创建对象是自动调用该方法！"}, {"ctype": "p", "data": "参数 self"}, {"ctype": "p", "data": "self 是一个指向当前对象实例的引用，让实例能够访问类的属性和方法，作为方法的第一个参数。类实例化时只需要指明实参，self 自动传递，举个例子："}, {"ctype": "code", "data": "class Animal():\n\tdef __init__(self, species, name):\n\t\tself.species = species\n\t\tself.name = name\n\n\tdef hhh(self):\n\t\tdel self\n\ntom = Animal('cat', 'Tom')\nprint(tom.hhh().hhh().hhh().species)\n"}, {"ctype": "p", "data": "这个例子中返回了 self 即对象的引用，此时可以反复调用 hhh ~"}, {"ctype": "p", "data": "如果函数声明中未声明 self 参数，则会报错：TypeError，因为参数 self 是自动传递的！"}, {"ctype": "head", "data": "2. Inheritance"}, {"ctype": "p", "data": "子类的 __init__ 方法中调用父类的构造函数 super().__init__()："}, {"ctype": "code", "data": "class Son(Parent):\n\tdef __init__(self, arg1, ..., argn):\n\t\tsuper().__init__(arg1, ... , argk)\n\t\tself.argi = argi\n"}, {"ctype": "p", "data": "继承例子："}, {"ctype": "code", "data": "class Animal():\n\tdef __init__(self, species, name):\n\t\tself.species = species\n\t\tself.name = name\n\n\tdef get_description(self):\n\t\tdes = self.name + ' is a ' + self.species\n\t\treturn des.title()\n\nclass Cat(Animal):\n\tdef __init__(self, species, name, color):\n\t\tsuper().__init__(species, name)\n\t\tself.color = color\n\ntom = Cat('cat', 'Tom', 'brown')\n"}, {"ctype": "p", "data": "可以重写父类的方法："}, {"ctype": "code", "data": "def get_description(self):\n\tres = super().get_description()\n\tres += ' with ' + self.color + ' color.'\n\treturn res\n"}, {"ctype": "head", "data": "3. import"}, {"ctype": "p", "data": "可以从一个文件中导入类："}, {"ctype": "code", "data": "from animal import Cat, Dog\ncat = Cat('cat', 'Tom', 'brown')\n"}, {"ctype": "p", "data": "或者导入整个文件："}, {"ctype": "code", "data": "import animal\ncat = animal.Cat('cat', 'Tom', 'brown')\n"}], "cate": "Python"}
{"题目": "Python tkinter库之Canvas自定义直线函数画随机色彩圆盘", "作者": "Hann Yang", "发布时间": "2021-03-27 12:51:29", "内容": [{"ctype": "p", "data": "create_line() 需要两个点的坐标，若线段的一个端点作定点，另一个端点作某种运动，写两个点的坐标比较麻烦。如下图自定义一个画直线函数，以角度和长度为变量来作图相对要方便一些："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327124126344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JveXNvZnQyMDAy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "代码如下： 同样的时间间隔，看上去 Line1()会比Line2() “转得”快2倍，角速度前者是后者的2倍。"}, {"ctype": "code", "data": "import tkinter as tk\nimport pyautogui as ag\nimport random\nfrom time import sleep as Delay\nfrom math import sin\nfrom math import cos\nfrom math import pi\n\ndef Window_Open(W, H):\n    X, Y = ag.size()\n    winSize = str(W)+\"x\"+str(H)\n    winPos = winSize + \"+\" + str((X - W) // 2)\n    winPos += \"+\" + str((Y - H) // 2)\n    win.geometry(winPos)\n    win.resizable(False, False)\n    title = u'桌面分辨率：' + str(X) + \"x\" + str(Y)\n    title += ' ' * 5 + u'窗体大小：' + winSize\n    win.title(title)\n    win.update()\n\ndef Line1(x,y,d,rad=0,c='black'):\n    \"x,y 起始点坐标，d=长度，rad=与水平线夹角\"\n    coord = x,y,x + d * cos(pi*rad/180),y - d * sin(pi*rad/180)\n    tCanvas.create_line(coord,fill=c)\n\ndef Line2(x,y,r,rad=0,c='black'):\n    \"x,y 线段中点坐标，r=半长，rad=与水平线夹角\"\n    coord = (x + r * cos(pi*rad/180),y - r * sin(pi*rad/180),\n            x - r * cos(pi*rad/180),y + r * sin(pi*rad/180))\n    tCanvas.create_line(coord,fill=c)\n\nif __name__ == '__main__':\n    \n    win = tk.Tk()\n    Window_Open(480,480)\n    tCanvas = tk.Canvas(win, width=win.winfo_width(), height=480, bg='white')\n    tCanvas.pack(side=\"top\")\n\n    Color = ['red','blue','green','magenta','navy','lawngreen','orange']\n    for i in range(20):\n        for r in range(0,360):\n            c = random.choice(Color)\n            Line1(240,240,200,r,c)\n        tCanvas.update()\n        Delay(0.05)\n\n    Delay(2)\n    \n    for i in range(20):\n        for r in range(0,180):\n            c = random.choice(Color)\n            Line2(240,240,200,r,c)\n        tCanvas.update()\n        Delay(0.05)\n\n    win.mainloop()\n\n"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "Flask优雅的使用教程(1)：route", "作者": "我就算饿死也不做程序员", "发布时间": "2021-03-27 13:22:05", "内容": [{"ctype": "head", "data": "安装"}, {"ctype": "p", "data": "pip install flask"}, {"ctype": "head", "data": "get"}, {"ctype": "code", "data": "import json\n\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n\n@app.route('/api/get/', methods=[\"GET\"])\ndef get():\n    args = request.args\n\n    name = args['name']\n\n    info = json.loads(args['json'])\n\n    print(\"name: {}, info: {}\".format(name, info))\n\n    return jsonify(args)\n"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327132008379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NneXVhbnNoaQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "POST"}, {"ctype": "code", "data": "@app.route('/api/post/', methods=[\"POST\"])\ndef post():\n    req = request.data.decode(\"utf-8\")\n\n    args = json.loads(req)\n\n    print(\"=========== POST ===========\")\n    print(\"para1: {}\".format(args['para1']))\n    print(\"para2: {}\".format(args['para2']))\n    print(\"para3: {}\".format(args['para3']))\n    print(\"para4: {}\".format(args['para4']))\n    return jsonify(args)\n\n  \nif __name__ == '__main__':\n    app.run(host='0.0.0.0')\n"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327132041718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NneXVhbnNoaQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "File"}, {"ctype": "p", "data": "------------------------------------- 文件上传 -------------------------------------"}, {"ctype": "code", "data": "@app.route('/api/upload_file/', methods=[\"POST\"])\ndef upload_file():\n\n    f = request.files['file']\n    f.save(\"/Users/hong/Desktop/flask.png\")\n\n    return \"Test Success\"\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327132103500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NneXVhbnNoaQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "LSTM预测股市的起伏-pytorch", "作者": "lodew920", "发布时间": "2021-03-27 18:10:57", "内容": [{"ctype": "head", "data": "深度学习之LSTM"}, {"ctype": "p", "data": "长短记忆神经网络——通常称作LSTM，是一种特殊的RNN，能够学习长的依赖关系。 他们由Hochreiter＆Schmidhuber引入，并被许多人进行了改进和普及。他们在各种各样的问题上工作的非常好，现在被广泛使用.LSTM是为了避免长依赖问题而精心设计的。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327163319216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODMxMw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "巨大的股市数据集"}, {"ctype": "p", "data": "此次数据集来自于股市数据集，包括历史日价格和所有美国股票和ETF的交易量。 因为这次计算量很小，不需要借用kaggle上的GPU，所以直接在本地电脑运行。 代码和数据集已经上传到了我的github和gitee gitee地址 github地址 数据集的格式如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032716381996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODMxMw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "环境"}, {"ctype": "code", "data": "windows10\npycharm 2019.1\n"}, {"ctype": "head", "data": "实验步骤"}, {"ctype": "head", "data": "1. 导入依赖的包"}, {"ctype": "code", "data": "print(\"================导入包=================\")\nimport numpy as np\nimport pandas as pd\nfrom pylab import mpl, plt\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\nimport math\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nimport torch\nimport torch.nn as nn\n"}, {"ctype": "head", "data": "2. 定义变量"}, {"ctype": "code", "data": "look_back = 60\nn_steps = look_back-1\nbatch_size = 32\nnum_epochs = 10\ninput_dim = 1\nhidden_dim = 32\nnum_layers = 2\noutput_dim = 1\n"}, {"ctype": "head", "data": "3. 加载数据集"}, {"ctype": "code", "data": "print(\"=================加工数据集=================\")\ndef stocks_data(symbols, dates):\n    df = pd.DataFrame(index=dates)\n    for symbol in symbols:\n        df_temp = pd.read_csv(\"./Data/Stocks/{}.us.txt\".format(symbol), index_col='Date',\n                parse_dates=True, usecols=['Date', 'Close'], na_values=['nan'])\n        df_temp = df_temp.rename(columns={'Close': symbol})\n        df = df.join(df_temp)\n    return df\ndates = pd.date_range('2015-01-02','2016-12-31',freq='B')\nsymbols = ['goog','ibm','aapl']\ndf = stocks_data(symbols, dates)\ndf.fillna(method='pad')\ndates = pd.date_range('2010-01-02','2017-10-11',freq='B')\ndf1=pd.DataFrame(index=dates)\ndf_ibm=pd.read_csv(\"./Data/Stocks/ibm.us.txt\", parse_dates=True, index_col=0)\ndf_ibm=df1.join(df_ibm)\ndf_ibm=df_ibm[['Close']]\ndf_ibm=df_ibm.fillna(method='ffill')\nscaler = MinMaxScaler(feature_range=(-1, 1))\ndf_ibm['Close'] = scaler.fit_transform(df_ibm['Close'].values.reshape(-1,1))\ndef load_data(stock, look_back):\n    data_raw = stock.values\n    data = []\n    for index in range(len(data_raw) - look_back):\n        data.append(data_raw[index: index + look_back])\n    data = np.array(data)\n    test_set_size = int(np.round(0.2 * data.shape[0]))\n    train_set_size = data.shape[0] - (test_set_size)\n    x_train = data[:train_set_size, :-1, :]\n    y_train = data[:train_set_size, -1, :]\n    x_test = data[train_set_size:, :-1, :]\n    y_test = data[train_set_size:, -1, :]\n    return [x_train, y_train, x_test, y_test]\nx_train, y_train, x_test, y_test = load_data(df_ibm, look_back)\nx_train = torch.from_numpy(x_train).type(torch.Tensor)\nx_test = torch.from_numpy(x_test).type(torch.Tensor)\ny_train = torch.from_numpy(y_train).type(torch.Tensor)\ny_test = torch.from_numpy(y_test).type(torch.Tensor)\ntrain = torch.utils.data.TensorDataset(x_train,y_train)\ntest = torch.utils.data.TensorDataset(x_test,y_test)\ntrain_loader = torch.utils.data.DataLoader(dataset=train,\n                                           batch_size=batch_size,\n                                           shuffle=False)\ntest_loader = torch.utils.data.DataLoader(dataset=test,\n                                          batch_size=batch_size,\n                                          shuffle=False)\n# =================over=================\n"}, {"ctype": "head", "data": "4 定义模型"}, {"ctype": "code", "data": "print(\"=================定义模型=================\")\nclass LSTM(nn.Module):\n    def __init__(self, input_dim, hidden_dim, num_layers, output_dim):\n        super(LSTM, self).__init__()\n        self.hidden_dim = hidden_dim\n        self.num_layers = num_layers\n        self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True)\n        self.fc = nn.Linear(hidden_dim, output_dim)\n    def forward(self, x):\n        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).requires_grad_()\n        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).requires_grad_()\n        out, (hn, cn) = self.lstm(x, (h0.detach(), c0.detach()))\n        out = self.fc(out[:, -1, :])\n        return out\nmodel = LSTM(input_dim=input_dim, hidden_dim=hidden_dim, output_dim=output_dim, num_layers=num_layers)\nfor i in range(len(list(model.parameters()))):\n    print(list(model.parameters())[i].size())\n# =================over=================\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164455655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODMxMw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "5. 定义损失函数"}, {"ctype": "code", "data": "loss_fn = torch.nn.MSELoss()\n"}, {"ctype": "head", "data": "6. 定义优化器"}, {"ctype": "code", "data": "optimiser = torch.optim.Adam(model.parameters(), lr=0.01)\n"}, {"ctype": "head", "data": "7. 运行"}, {"ctype": "code", "data": "print(\"=================运行=================\")\nhist = np.zeros(num_epochs)\nseq_dim = look_back - 1\n\nfor t in range(num_epochs):\n    y_train_pred = model(x_train)\n    loss = loss_fn(y_train_pred, y_train)\n    print(\"Epoch \", t, \"MSE: \", loss.item())\n    hist[t] = loss.item()\n    optimiser.zero_grad()\n    loss.backward()\n    optimiser.step()\n# =================over=================\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164435715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODMxMw==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "8. 预测"}, {"ctype": "code", "data": "print(\"=================预测=================\")\ny_test_pred = model(x_test)\ny_train_pred = scaler.inverse_transform(y_train_pred.detach().numpy())\ny_train = scaler.inverse_transform(y_train.detach().numpy())\ny_test_pred = scaler.inverse_transform(y_test_pred.detach().numpy())\ny_test = scaler.inverse_transform(y_test.detach().numpy())\ntrainScore = math.sqrt(mean_squared_error(y_train[:,0], y_train_pred[:,0]))\nprint('Train Score: %.2f RMSE' % (trainScore))\ntestScore = math.sqrt(mean_squared_error(y_test[:,0], y_test_pred[:,0]))\nprint('Test Score: %.2f RMSE' % (testScore))\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164523822.png"}, {"ctype": "code", "data": "figure, axes = plt.subplots(figsize=(15, 6))\naxes.xaxis_date()\n\naxes.plot(df_ibm[len(df_ibm)-len(y_test):].index, y_test, color = 'red', label = 'Real IBM Stock Price')\naxes.plot(df_ibm[len(df_ibm)-len(y_test):].index, y_test_pred, color = 'blue', label = 'Predicted IBM Stock Price')\n#axes.xticks(np.arange(0,394,50))\nplt.title('IBM Stock Price Prediction')\nplt.xlabel('Time')\nplt.ylabel('IBM Stock Price')\nplt.legend()\nplt.savefig('ibm_pred.png')\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164543324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODMxMw==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "Django：DjangoProject项目结构简介", "作者": "mulus", "发布时间": "2021-03-27 23:11:44", "内容": [{"ctype": "p", "data": "     本例中，myproject就是项目，mysite就是app即模块"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327194715581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwODYzNQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "这些目录和文件的用处是： 1、最外层的 mysproject/ 根目录只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。"}, {"ctype": "p", "data": "2、manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。可以阅读 django-admin 和 manage.py 获取所有 manage.py 的细节。"}, {"ctype": "p", "data": "3、里面一层的 myproject/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls)."}, {"ctype": "p", "data": "4、myproject/init.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。"}, {"ctype": "p", "data": "5、myproject/settings.py：Django 项目的配置文件。"}, {"ctype": "p", "data": "6、myproject/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。"}, {"ctype": "p", "data": "7、myproject/asgi.py：作为你的项目的运行在 ASGI 兼容的 Web 服务器上的入口。"}, {"ctype": "p", "data": "8、myproject/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。    注意到：http://127.0.0.1:8000/，端口号后面默认有/"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327201426717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwODYzNQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "case1："}, {"ctype": "p", "data": "在mysite/views.py中"}, {"ctype": "code", "data": "from django.http import HttpResponse\ndef index(request):\n    return HttpResponse(\"hello world, my first page\")\n"}, {"ctype": "p", "data": "在myproject/urls.py中"}, {"ctype": "code", "data": "from mysite import views\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path(\"login/\", views.index)  # 将login路由到views.index, views.index通过httpresponse返回结果\n\n]\n\n"}, {"ctype": "p", "data": "运行，  从报错信息可以看出，run之后，会运行myproject/urls.py查找url对应的文件"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327205631193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwODYzNQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "在浏览器url里加入login后，加载成功mysite/views.py的内容。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327205849148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwODYzNQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "case2："}, {"ctype": "p", "data": "case1里，我们把要返回的内容“hello world, my first page”放在url对应的views里，然后在views里通过httpresponse写死的方式，返回到浏览器"}, {"ctype": "p", "data": "case2方式，"}, {"ctype": "p", "data": "myproject/urls下"}, {"ctype": "code", "data": "from mysite import views\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path(\"login/\", views.login)  # 将login路由到views.login，views.login调用login.html\n# 与case1 不同\n]\n"}, {"ctype": "p", "data": "在myproject/Templates创建一个login.html"}, {"ctype": "code", "data": "<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>我的登录</title>\n</head>\n<body>\n    <form action=\"\" method=\"post\">\n        用户名：<input type=\"text\" name=\"username\"><br>\n        密码：<input type=\"password\" name=\"password\"><br>\n        <input type=\"submit\" value=\"点我登录呀\">\n    </form>\n</body>\n</html>\n"}, {"ctype": "p", "data": "   "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327212202372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwODYzNQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "PS: source, bilibili"}], "cate": "Python"}
{"题目": "leetcode  1302. Deepest Leaves Sum（python）", "作者": "王大丫丫", "发布时间": "2021-03-27 16:40:58", "内容": [{"ctype": "head", "data": "描述"}, {"ctype": "p", "data": "Given the root of a binary tree, return the sum of values of its deepest leaves."}, {"ctype": "p", "data": "Example 1:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/bebe94d58255ebf989051b94eb12b330.png"}, {"ctype": "code", "data": "Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\nOutput: 15\n"}, {"ctype": "p", "data": "Example 2:"}, {"ctype": "code", "data": "Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\nOutput: 19\n"}, {"ctype": "p", "data": "Note:"}, {"ctype": "code", "data": "The number of nodes in the tree is in the range [1, 104].\n1 <= Node.val <= 100\n"}, {"ctype": "head", "data": "解析"}, {"ctype": "p", "data": "根据题意，其实就是算最底层的树的节点的值的和，需要用一个字典来记录，key 为深度，value 为该深度的树的所有节点的数值，DFS 遍历之后得到 res ，然后计算最后一层的和即可。"}, {"ctype": "head", "data": "解答"}, {"ctype": "code", "data": "class Solution(object):\n    def deepestLeavesSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        res = {}\n        def lastLevel(root, res, count):\n            if not root:\n                return\n            if count not in res:\n                res[count] = []\n            res[count].append(root.val)\n            if root.left:\n                lastLevel(root.left, res, count + 1)\n            if root.right:\n                lastLevel(root.right, res, count + 1)\n        lastLevel(root, res, 0)\n        return sum(res[max(res.keys())])\n"}, {"ctype": "head", "data": "运行结果"}, {"ctype": "code", "data": "Runtime: 92 ms, faster than 79.13% of Python online submissions for Deepest Leaves Sum.\nMemory Usage: 20.8 MB, less than 79.37% of Python online submissions for Deepest Leaves Sum.\n"}, {"ctype": "p", "data": "原题链接：https://leetcode.com/problems/deepest-leaves-sum"}, {"ctype": "p", "data": "您的支持是我最大的动力"}], "cate": "Python"}
{"题目": "openpyxl操作表格的基本用法", "作者": "xxy_yang", "发布时间": "2021-03-27 18:30:28", "内容": [{"ctype": "head", "data": "创建文件， 以及创建xlsx表格"}, {"ctype": "code", "data": "from openpyxl import Workbook, load_workbook\nimport os\n\n\n# 创建excel文件, 默认会有一个sheet命名的表\ndef create_xlsx(_path, _name):\n    path_file = os.path.join(_path, _name)\n    # 创建一个空白工作簿\n    wb = Workbook()\n    # 注意： 保存路径下含有相同文件会被覆盖,\n    wb.save(path_file)\n\n\n# 创建工文件， 同时创建表\ndef create_table(_path, _name):\n    path_file = os.path.join(_path, _name)\n    # 创建一个空白工作簿\n    wb = Workbook()\n    # 创建一个表名： sheet1, 位置再第一位\n    ws = wb.create_sheet('sheet1', 0)\n    ws2 = wb.create_sheet('sheet2', 1)\n    # 保存文件\n    wb.save(path_file)\n\n"}, {"ctype": "head", "data": "读取表格的相关属性， 或者值"}, {"ctype": "code", "data": "from openpyxl import Workbook, load_workbook\nwb = load_workbook('work2.xlsx')\n# 读取文件的所有表名\ntable_name = wb.sheetnames\n# 根据表名获取表,\nsheet_name = table_name[0]\n# 读取某一个表\nsheet = wb[sheet_name]\n# 读取表格的某一行数据\nrow_data = sheet['1']\n# 获取某一列数据, 获取的结果是tuple: (<Cell '订单'.A1>, <Cell '订单'.B1>)\ncol_data = sheet['B']\n# 获取某一个单元格的数据\none_cell = sheet['B2'].value\n# 获取单元格的值\ncell_data = sheet.cell(row=2, column=3).value\n# 修改某一个单元格的值, 最后必须要保存\nsheet['B2'].value = 'hello'\n"}, {"ctype": "head", "data": "读取excel数据， 结果返回： 每一行为dict, 添加到list中"}, {"ctype": "code", "data": "def dict_key(ws):\n    for row in ws.rows:\n        key_value = [data.value for data in row]\n        return key_value\n        \n\n# 读取文件内容以及表的内容\ndef read_xlsx(path_name):\n    wb = load_workbook(path_name,  read_only=True)\n    # 读取文件的所有表名\n    table_name = wb.sheetnames\n    # 根据表名获取表,\n    sheet_name = table_name[0]\n    _list = []\n    ws = wb[sheet_name]\n    key_value = dict_key(ws)\n    # 遍历表格的多行数据， ws.rows: 获取表格多少行\n    count = 0\n    for row in ws.rows:\n        count += 1\n        if count == 1:\n            continue\n         value_list = [data.value for data in row]\n        _dict = dict(zip(key_value, value_list))\n        _list.append(_dict)\n    return _list\n\n"}, {"ctype": "head", "data": "表格数据增加一列数据"}, {"ctype": "code", "data": " name = '案例.xlsx'\n    wb = load_workbook(name)\n    # 读取文件的所有表名\n    table_name = wb.sheetnames\n    # 根据表名获取表,\n    sheet_name = table_name[0]\n    sheet = wb[sheet_name]\n    sheet.cell(row=1, column=19, value='销售额')\n    for row_index in range(2, sheet.max_row+1):\n        sheet.cell(row=row_index, column=19, value=row_index)\n    wb.save(name)\n"}, {"ctype": "head", "data": "绘制折线图"}, {"ctype": "code", "data": "    from openpyxl import Workbook, load_workbook\n    import os\n    from openpyxl.chart import BarChart, Reference, AreaChart\n    wb = Workbook()\n    ws = wb.active\n    rows = [\n        ['Number', 'Batch 1', 'Batch 2'],\n        [2, 40, 30],\n        [3, 40, 25],\n        [4, 50, 30],\n        [5, 30, 10],\n        [6, 25, 5],\n        [7, 50, 10],\n    ]\n\n    for row in rows:\n        ws.append(row)\n\n    chart = AreaChart()\n    chart.title = \"Area Chart\"\n    chart.style = 13\n    chart.x_axis.title = 'Test'\n    chart.y_axis.title = 'Percentage'\n    cats = Reference(ws, min_col=1, min_row=1, max_row=7)\n    data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=7)\n    chart.add_data(data, titles_from_data=True)\n    chart.set_categories(cats)\n    ws.add_chart(chart, \"A10\")\n    wb.save(\"area.xlsx\")\n"}, {"ctype": "p", "data": "官方文档请看： http://yumos.gitee.io/openpyxl3.0/index.html#document-charts/introduction"}], "cate": "Python"}
{"题目": "py实现外星人入侵（二次开发）——1.读入最高分（包含文件的基本操作和文件相对路径讲解）", "作者": "筱羊冰冰", "发布时间": "2021-03-27 08:05:36", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "在之前的博客中，我详细的介绍了一下大战外星人的现目组成，从这篇博客开始，我将尝试用不同的方式来二次开发（魔改）这个项目。 这次我将魔爪放在了最高分部分上，我们知道之前的最高分在每一次重新运行游戏就消失了，这次我们采取将最高分读入到文件中。"}, {"ctype": "head", "data": "先写入"}, {"ctype": "p", "data": "写入部分还是比较简单的，这里我采取的思路是在三条命都没了之后、在游戏退出之前写入当前最高分。 虽然书上的意思是在sys.exit()之前，但是玩一半退出了，不给你保留也没什么问题。"}, {"ctype": "p", "data": "首先找到要修改的位置：game_function文件的ship_hit函数 在函数中，我们有判断三条命是否用完了的情况，并对两种结果都进行了操作，我们将在else中添加内容。"}, {"ctype": "p", "data": "然后要考虑，可能之前已经有了这样一个最高分文件，但是对我没有影响，我的想法是简单粗暴一些，反正之前的最高分也不要了，与其取出然后再写入不如直接使用\"w\"方法直接覆盖之前的文档。"}, {"ctype": "p", "data": "（下面可能有一点啰嗦，简单说了一下几种文件打开类型和打开函数，不感兴趣的直接看代码部分吧）"}, {"ctype": "p", "data": "对了，先介绍一下py的几种常见的读入文件格式："}, {"ctype": "table", "data": "字母模式w写入模式r读取模式r+读写模式a附加模式"}, {"ctype": "p", "data": "我们假设之前有一个文件，那么a就是在之前的基础上接着写； w就是覆盖掉之前的文件，然后重写； r则是只能读取，不能写入； r+则比较厉害，能写入和读取。"}, {"ctype": "p", "data": "如果是之前没有文件，w和r+会生成一个空文档； a也会生成，但是会有一个io.UnsupportedOperation: not readable的报错； 至于r，还是别难为它吧，直接报错文件找不到。"}, {"ctype": "p", "data": "回归正题，别忘了我们采取的是\"w\"模式。 一般来说打开文件我比较喜欢的是with open，这里也简单说一下吧。 with open的结构是这样的："}, {"ctype": "code", "data": "with open(\"file name\",\"模式\") as file_object:\n\t内容\n"}, {"ctype": "p", "data": "首先with open是单独的一个模块，主意好缩进； 两个参数分别为文件名和打开类型（不写默认为r）； file_object属于打开文件的别名，学过C的都知道也有类似的东西（不过孩子已经ptsd了，立下flag以后不被逼就不写C）"}, {"ctype": "p", "data": "除此之外，还有："}, {"ctype": "code", "data": "file_object = open(\"file name\",\"模式\")\n"}, {"ctype": "p", "data": "不过这是我们就需要使用close函数了，with open相当于是将关闭文件的时间交给py来判断。"}, {"ctype": "head", "data": "代码部分："}, {"ctype": "code", "data": "#stats.max_name存储了我的最高分文件名称，这个就是自己随便起\nwith open(\"./alien/\"+stats.max_name,\"w\") as max_num:\n\thighest = str(stats.high_score)\n    max_num.write(highest)       \n"}, {"ctype": "p", "data": "write方法是将字符串写入文件中，所以我在写入之前将stats中的最高分拿出来做了一下类型转换。"}, {"ctype": "p", "data": "最终是这样的： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323210716668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYm9ydHQ=,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "可能会奇怪我这个文件路径吧，这是我文件的组成。  首先，alien文件夹中包括了我所有的项目文件，我也将最高分文档存储在了这里。 但如果我直接使用state.max_name作为地址则会将文件创建到alien文件夹同一层。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323201307829.png"}, {"ctype": "p", "data": "这就要谈到文件地址和执行地址了。 虽然我们的game_functiong.py（也就是我们添加内容的文件）在alien文件夹内，按照这样的说法我们在使用同一文件夹下的max.txt应当只需要stats.max_name，但是很明显这样错了，原因是虽然我们的py文件在文件夹内，但是执行地址是在alien文件夹，所以实际上是在alien文件夹的同一层创建了这样一个txt文件。"}, {"ctype": "p", "data": "因此我们需要使用\"./alien/\"+stats.max_name的方式来实现先进入alien文件夹，然后创建、打开文档。"}, {"ctype": "p", "data": "注意一下，我在vscode中打开的文件夹是ALIEN/alien，alien中存在项目文件和max.txt， 但如果换成直接打开alien文件夹，路径不管怎样都是有问题的。 路径这一难题我会持续关注和修改的，至少这个解释回答了我目前的疑问。"}, {"ctype": "head", "data": "再读取"}, {"ctype": "p", "data": "读取的部分我准备添加在游戏的主程序最开始部分，在游戏循环之前。"}, {"ctype": "p", "data": "首先要解决的一个问题，就是在我第一次进行游戏的时候是没有文档的，所以我需要创建一个文档，但是又不好判断，所以最开始的方式选择的是异常，然后感觉啰嗦，就上网上查了一下，找到os库有现成的函数能判断文件存在与否。 但是我大意了，没有闪，\"a+\"就能解决我的问题。 （还在纠结为什么没有这样一个方便的模式，原来是学的不深忘记了）"}, {"ctype": "p", "data": "在第三部分我也会讲一下剩下的两个方式，不过这部分我们还是使用\"a+\"来实现。"}, {"ctype": "code", "data": "    with open(\"./alien/\"+stats.max_name,\"a+\") as max_num:\n        max_num.seek(0)                     #将文档光标移动到最开始\n        high = max_num.read()\n        high = high.strip()\n        #print(\"hello\"+high+\"world\")        #测试用的\n        if high != \"\":\n            max_num.write(\"0\")\n        else:\n            stats.high_score = int(high)\n"}, {"ctype": "p", "data": "对应着write方法，我们也有着读取的read，只不过读取的为字符串，还会没事在最后面给你加一个换行符，还是很烦人的。 我采取的方式是先读取内容，使用strip方法去掉两端的空格、回车，如果最终是空，说明文件没有内容，否则将内容拿出来，转成int型赋值给stats.high_score。 strip是去除两边的空白字符，rstrip是右边，左边是lstrip，为了省事就直接两边一起清。"}, {"ctype": "p", "data": "最后一个问题就是应该放在哪个准确位置，这里我们要知道在创建记分牌对象\"sb\"的时候，就已经将当前的stats数据拿出来进行处理了，就等着屏幕刷新渲染到窗口上，而且我们在stats中初始化类有一个将high_score赋值为0的操作：  所以我们只好将其放在stats对象和sb对象中间： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210323211633384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYm9ydHQ=,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "解决文件问题的其他办法"}, {"ctype": "head", "data": "异常"}, {"ctype": "code", "data": "    try:\n        with open(\"./alien/\"+stats.max_name,\"r\") as max_num:\n            high = max_num.read()\n            high = high.strip()\n            #print(high)\n            stats.high_score = int(high)\n    except FileNotFoundError:\n    \t#with open函数的另外一种调用方法，懂的都懂\n        with open(\"./alien/\"+stats.max_name, mode='w', encoding='utf-8') as max_num:\n            max_num.write(\"0\")\n"}, {"ctype": "p", "data": "因为我们有时候也不知道用户会发生什么，所以需要对一些错误进行判断，才有了这样的一个结构。 说的可能有一点绕，就比如让你输入一个数字进行计算，你敲一个\"q\"，如果没有数字检测就gg了， 但是我们可以使用这样的结构，即使是发生了报错，也能使用另一种输出方式，比如弹出一个\"你的输入有问题\"，也不至于因为不能运行导致程序挂了或者让用户看到报错。"}, {"ctype": "p", "data": "比如："}, {"ctype": "code", "data": "try:\n\t……(在操作中发生了错误)\nexcept 报错内容:\n\t错误提示或者补救措施\n"}, {"ctype": "p", "data": "在我们的程序中，就是先看看能不能打开存储文档，如果打不开会有一个\"FileNotFoundError\"的报错，这样我们就可以使用\"w\"方法创建一个文档，并存储上字符串0。 **with一定要后面跟内容，不然会\"IndentationError: expected an indented block\"。**所以我才在最后添加了一个写入0操作。"}, {"ctype": "p", "data": "如果没有报错，像我们这个就是直接在try中实现操作，还可以在expect下面加一个相同缩进的else"}, {"ctype": "code", "data": "try:\n\t......\nexcept error:\n\t......\nelse:\n"}, {"ctype": "head", "data": "import os"}, {"ctype": "code", "data": "#最前面有一个import os\n    if os.path.exists('./alien/'+stats.max_name):\n        with open(\"./alien/\"+stats.max_name,\"r\") as max_num:\n            high = max_num.read()\n            high = high.strip()\n            stats.high_score = int(high)\n    else:\n        with open(\"./alien/\"+stats.max_name, mode='w', encoding='utf-8') as max_num:\n            max_num.write(\"0\")\n"}, {"ctype": "p", "data": "简单来说就是使用os自带的方法来进行检查，判断是否存在该文件"}, {"ctype": "head", "data": "总结"}, {"ctype": "p", "data": "好了，这期的魔改就到此结束了，接下来我还会对其他部分进行修改。"}], "cate": "Python"}
{"题目": "在centos 下 发送mail", "作者": "lhl.", "发布时间": "2021-03-27 15:38:40", "内容": [{"ctype": "head", "data": "搭建mail"}, {"ctype": "p", "data": "昨天学习的使用centos下搭建及使用mail，趁着还热乎自己总结一下和大家分享学习，想必大家都知道mail是什么，mail就是邮箱，我们之前使用的比如企鹅邮箱、网易邮箱等等，这都是一个平台，centos下的邮箱有什么用途呢？centos下使用这个我们可以把一些服务器报警的一些内容直接通过mail发送到你的手机或者其他邮箱中。"}, {"ctype": "head", "data": "1.安装mail所需要的包"}, {"ctype": "p", "data": "首先安装 mailx 与postfix 为我们使用"}, {"ctype": "code", "data": "yum -y install mailx postfix\n"}, {"ctype": "p", "data": "启动一下服务"}, {"ctype": "code", "data": "systemctl enable --now postfix\n"}, {"ctype": "head", "data": "2.配置邮箱"}, {"ctype": "p", "data": "本次我们以企鹅邮箱为例，开启此服务，会有一个秘钥"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327152205444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNjU5Ng==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.配置mail"}, {"ctype": "p", "data": "我们把刚才发送短信的秘钥拿出来，打开mail.rc文件，最下面输入固定格式的内容"}, {"ctype": "code", "data": "nano /etc/mail.rc\n"}, {"ctype": "p", "data": "固定格式为："}, {"ctype": "code", "data": "set from=123456@qq.com \nset smtp=smtp.qq.com\nset smtp-auth-user=123456@qq.com\nset smtp-auth-password=短信的秘钥\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327152823635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNjU5Ng==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.发送邮箱测试"}, {"ctype": "code", "data": " mail -s ceshi 目的邮箱@qq.com < /etc/hostname  \n"}, {"ctype": "p", "data": " 这样我们就发送出来了"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327153452313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNjU5Ng==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "总结"}, {"ctype": "p", "data": "其实使用centos发送邮箱也是运维人大家都常用的方式 使用mail步骤总结 1.安装所需包 2.启动服务 3.修改mail.rc文件 4.使用mail发送格式"}], "cate": "Python"}
{"题目": "【cookbook pandas】学习笔记 chap 11. Combining Pandas Objects", "作者": "萝卜丝皮尔", "发布时间": "2021-03-27 14:24:17", "内容": [{"ctype": "head", "data": "Introduction"}, {"ctype": "p", "data": "a wide variety of options are available to combine two or more DataFrame or Series together； the append method is the least flexibility and only allows for new rows to be appended to a DataFrame. the concat method is very versatile and can combine any number of DataFrame or Series on either axis. the join method provides fast lookups by aligning a column of one DataFrame to the index of others. the merge method provides SQL-like capabilities to join two DataFrame together ."}, {"ctype": "head", "data": "appending new rows to DataFrames"}, {"ctype": "p", "data": "crop up 出其不意地发生； appending rows to a small dataset with the .loc attribute and then transition to using the .append method sneaky adj, 悄悄的，偷偷摸摸的"}, {"ctype": "code", "data": "import pandas as pd\nimport numpy as np\nnames=pd.read_csv('names.csv')\nnames\nOut[5]: \n       Name  Age\n0  Cornelia   70\n1     Abbas   69\n2  Penelope    4\n3      Niko    2\n# create a list that contains new data \n# and use the ,loc attribute to set a single row label equal to this new data\nnew_data=['Aria',1]\nnames.loc[4]=new_data\n# the .loc attribute uses labels to refer to rows matching the integer location\n# also append more rows with non-integer labels\nnames.loc['five']=['Zach',3]\nnames\nOut[14]: \n          Name  Age\n0     Cornelia   70\n1        Abbas   69\n2     Penelope    4\n3         Niko    2\n4         Aria    1\nfive      Zach    3\n# to be more explicit in associating variables to values, \n# you may use a dictionary\n# dynamically choose by setting the new labels to the length of the DataFrame\nnames.loc[len(names)]=['Dean',32]\nnames\nOut[19]: \n          Name  Age\n0     Cornelia   70\n1        Abbas   69\n2     Penelope    4\n3         Niko    2\n4         Aria    1\nfive      Zach    3\n6         Dean   32\nnames.loc[len(names)]={Name:'Dean',Age:32}\nTraceback (most recent call last):\n ... ....\nNameError: name 'Name' is not defined\n\nnames.loc[len(names)]={'Name':'Dean','Age':32}\n# a Series can hold the new data as well\nnames.loc[len(names)]=pd.Series({'Name':'Dean','Age':32})\n# use the .loc attribute makes change to the `names` DataFrame in-place\n# and there is no separate copy of the DataFrame that is returned \n# the .append method does not modify the calling DataFrame\n# and returns new copy of the DataFrame with the appended rows\n# the first parameter to .append must be either another DataFrame, Series, dictionary, or a list of these, but not a list like ['Aria',1]\nnames.append({'Name':'Tom','Age':3},ignore_index=True)\nOut[29]: \n       Name  Age\n0  Cornelia   70\n1     Abbas   69\n2  Penelope    4\n3      Niko    2\n4      Aria    1\n5      Zach    3\n6      Dean   32\n7      Dean   32\n8      Dean   32\n9       Tom    3\n# ignore_index=True, then the old index will be removed complete \n# and relaced with a RangeIndex from 0 to -1\n# now, we specify the index for names DataFrame\nnames.index=list('abcdefghij')\nTraceback (most recent call last):\n    raise ValueError(\nValueError: Length mismatch: Expected axis has 9 elements, new values have 10 elements\n\nnames.index=list('abcdefghi')\nnames\nOut[35]: \n       Name  Age\na  Cornelia   70\nb     Abbas   69\nc  Penelope    4\nd      Niko    2\ne      Aria    1\nf      Zach    3\ng      Dean   32\nh      Dean   32\ni      Dean   32\n# append a Series that has a names attribute with the .append method\ns=pd.Series({'Name':'Jame','Age':10},name='j')\nnames.append(s)\nOut[38]: \n       Name  Age\na  Cornelia   70\nb     Abbas   69\nc  Penelope    4\nd      Niko    2\ne      Aria    1\nf      Zach    3\ng      Dean   32\nh      Dean   32\ni      Dean   32\nj      Jame   10\n# .append method is more flexible than the .loc attribute \n# since it supports appending multiple rows at the same time\ns1=pd.Series({'Name':'Zaa','Age':3},name=len(names))\ns2=pd.Series({'Name':'Zrr','Age':9},name=len(names)+1)\nnames.append([s1,s2])\nOut[43]: \n        Name  Age\na   Cornelia   70\nb      Abbas   69\nc   Penelope    4\nd       Niko    2\ne       Aria    1\nf       Zach    3\ng       Dean   32\nh       Dean   32\ni       Dean   32\n9        Zaa    3\n10       Zrr    9\n# for large dataset, using dictionary to append is difficult\n# select a single row as a Series and chain 'to_dict' method to it\n# to get an example row as a dictionary\nbball_16=pd.read_csv('baseball16.csv')\nbball_16\nOut[48]: \n     playerID  yearID  stint teamID lgID  ...   IBB   HBP   SH   SF  GIDP\n0   altuvjo01    2016      1    HOU   AL  ...  11.0   7.0  3.0  7.0  15.0\n1   bregmal01    2016      1    HOU   AL  ...   0.0   0.0  0.0  1.0   1.0\n2   castrja01    2016      1    HOU   AL  ...   0.0   1.0  1.0  0.0   9.0\n3   correca01    2016      1    HOU   AL  ...   5.0   5.0  0.0  3.0  12.0\n4   gattiev01    2016      1    HOU   AL  ...   6.0   4.0  0.0  5.0  12.0\n5   gomezca01    2016      1    HOU   AL  ...   2.0   4.0  3.0  0.0  11.0\n6   gonzama01    2016      1    HOU   AL  ...   1.0   5.0  6.0  1.0  16.0\n7   gourryu01    2016      1    HOU   AL  ...   0.0   1.0  0.0  1.0   7.0\n8    kempto01    2016      1    HOU   AL  ...   0.0   0.0  1.0  1.0   5.0\n9   marisja01    2016      1    HOU   AL  ...   0.0   3.0  4.0  1.0   4.0\n10  rasmuco01    2016      1    HOU   AL  ...   0.0   0.0  1.0  4.0   5.0\n11   reedaj01    2016      1    HOU   AL  ...   0.0   0.0  0.0  1.0   1.0\n12  springe01    2016      1    HOU   AL  ...   2.0  11.0  0.0  1.0  12.0\n13  tuckepr01    2016      1    HOU   AL  ...   0.0   2.0  0.0  0.0   2.0\n14  valbulu01    2016      1    HOU   AL  ...   2.0   1.0  3.0  2.0   5.0\n15  whitety01    2016      1    HOU   AL  ...   1.0   2.0  0.0  2.0   6.0\n[16 rows x 22 columns]\n\ndata_dict=bball_16.iloc[0].to_dict()\ndata_dict\nOut[51]: \n{'playerID': 'altuvjo01',\n 'yearID': 2016,\n 'stint': 1,\n 'teamID': 'HOU',\n 'lgID': 'AL',\n 'G': 161,\n 'AB': 640,\n 'R': 108,\n 'H': 216,\n '2B': 42,\n '3B': 5,\n 'HR': 24,\n 'RBI': 96.0,\n 'SB': 30.0,\n 'CS': 10.0,\n 'BB': 60,\n 'SO': 70.0,\n 'IBB': 11.0,\n 'HBP': 7.0,\n 'SH': 3.0,\n 'SF': 7.0,\n 'GIDP': 15.0}\n# clear the old values with a dictionary comprehension \n# by assigning any previous string values as an empty string and all others as missing values\nnew_data_dict={k: '' if isinstance(v,str) else np.nan \n               for (k,v) in data_dict.items()}\nnew_data_dict\nOut[55]: \n{'playerID': '',\n 'yearID': nan,\n 'stint': nan,\n 'teamID': '',\n 'lgID': '',\n 'G': nan,\n 'AB': nan,\n 'R': nan,\n 'H': nan,\n '2B': nan,\n '3B': nan,\n 'HR': nan,\n 'RBI': nan,\n 'SB': nan,\n 'CS': nan,\n 'BB': nan,\n 'SO': nan,\n 'IBB': nan,\n 'HBP': nan,\n 'SH': nan,\n 'SF': nan,\n 'GIDP': nan}\n# this dictionary can serve as a template for any new data you would like to enter\n\n"}, {"ctype": "p", "data": "appending a single row to a DataFrame is a fairly expensive operation , so, don’t write a loop to append single rows of data to a DataFrame"}, {"ctype": "code", "data": "\n# first create 1000 rows of new data as a list of Series\na =[1,2]\na.append(3)\na\nOut[60]: [1, 2, 3]\n# !!! .append modify list, but not modify DataFrame\nrandom_data=[]\nfor i in range(1000):\n    d=dict()\n    for k,v in data_dict.items():\n        if isinstance(v,str):\n            d[k]=np.random.choice(list('abcde'))\n        else:\n            d[k]=np.random.randint(10)\n    random_data.append(pd.Series(d,name=i+len(bball_16)))\n    \nrandom_data[0]\nOut[66]: \nplayerID    e\nyearID      9\nstint       9\nteamID      c\nlgID        b\nG           0\nAB          3\nR           6\nH           0\n2B          3\n3B          4\nHR          4\nRBI         8\nSB          6\nCS          3\nBB          6\nSO          5\nIBB         7\nHBP         1\nSH          6\nSF          3\nGIDP        5\nName: 16, dtype: object\n# time how long it takes to loop through each item making one append at one time\n%%timeit\nbball_16_copy=bball_16.copy()\nfor row in random_data:\n    bball_16_copy=bball_16_copy.append(row)\n6.2 s ± 376 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n# pass in entire list of Series, we get an enumous speed increase\n%%timeit\nbball_16_copy=bball_16.append(random_data)\n67 ms ± 234 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n# internally, pandas converts the list of Series to a single DataFrame \n# and then appends the data\n\n"}, {"ctype": "head", "data": "Concatenating multiple DataFrames together"}, {"ctype": "p", "data": "as per usual 照常 water-down 大打折扣的，用水冲淡的 haphazardly 偶然地，随意地，杂乱地 .append method is heavily water-down version of concat that can only append new rows to DataFrame; internally, .append just calls the concat function ."}, {"ctype": "code", "data": "# concat function enables concatenating two or more DataFrames (or Series ) together, both vertically and horizontally\nimport pandas as pd\nimport numpy as np\nstock_2016=pd.read_csv('stocks_2016.csv',index_col='Symbol')\nstock_2016\nOut[9]: \n        Shares  Low  High\nSymbol                   \nAAPL        80   95   110\nTSLA        50   80   130\nWMT         40   55    70\nstock_2017\nOut[10]: \n        Shares  Low  High\nSymbol                   \nAAPL        50  120   140\nGE         100   30    40\nIBM         87   75    95\nSLB         20   55    85\nTXN        500   15    23\nTSLA       100  100   300\n# place all the datasets into a single list\ns_list=[stock_2016,stock_2017]\ns_list\nOut[13]: \n[        Shares  Low  High\n Symbol                   \n AAPL        80   95   110\n TSLA        50   80   130\n WMT         40   55    70,\n         Shares  Low  High\n Symbol                   \n AAPL        50  120   140\n GE         100   30    40\n IBM         87   75    95\n SLB         20   55    85\n TXN        500   15    23\n TSLA       100  100   300]\npd.concat(s_list)\nOut[14]: \n        Shares  Low  High\nSymbol                   \nAAPL        80   95   110\nTSLA        50   80   130\nWMT         40   55    70\nAAPL        50  120   140\nGE         100   30    40\nIBM         87   75    95\nSLB         20   55    85\nTXN        500   15    23\nTSLA       100  100   300\n# call the concat function to concatenate them together along the default axis(axis=0)\n# or say , by default, concat function concatenates DataFrames vertically,\n# one top of the other\ntype(pd.concat(s_list))\nOut[18]: pandas.core.frame.DataFrame\n# the preceeding DataFrame , no way to identify the year of each row \n# concat function uses `key` parameter to label each piece\npd.concat(s_list,keys=['2016','2017'])\nOut[22]: \n             Shares  Low  High\n     Symbol                   \n2016 AAPL        80   95   110\n     TSLA        50   80   130\n     WMT         40   55    70\n2017 AAPL        50  120   140\n     GE         100   30    40\n     IBM         87   75    95\n     SLB         20   55    85\n     TXN        500   15    23\n     TSLA       100  100   300\npd.concat(s_list,keys=['2016','2017'],names=['Years','Symbol'])\nOut[23]: \n              Shares  Low  High\nYears Symbol                   \n2016  AAPL        80   95   110\n      TSLA        50   80   130\n      WMT         40   55    70\n2017  AAPL        50  120   140\n      GE         100   30    40\n      IBM         87   75    95\n      SLB         20   55    85\n      TXN        500   15    23\n      TSLA       100  100   300\n# change axis from 0 to 1, to concatenate DataFrame horizontally\npd.concat(s_list,axis=1)\nOut[25]: \n        Shares   Low   High  Shares    Low   High\nSymbol                                           \nAAPL      80.0  95.0  110.0    50.0  120.0  140.0\nTSLA      50.0  80.0  130.0   100.0  100.0  300.0\nWMT       40.0  55.0   70.0     NaN    NaN    NaN\nGE         NaN   NaN    NaN   100.0   30.0   40.0\nIBM        NaN   NaN    NaN    87.0   75.0   95.0\nSLB        NaN   NaN    NaN    20.0   55.0   85.0\nTXN        NaN   NaN    NaN   500.0   15.0   23.0\npd.concat(s_list,axis=1,keys=['2016','2017'],names=['Year',None])\nOut[26]: \nYear     2016                2017              \n       Shares   Low   High Shares    Low   High\nSymbol                                         \nAAPL     80.0  95.0  110.0   50.0  120.0  140.0\nTSLA     50.0  80.0  130.0  100.0  100.0  300.0\nWMT      40.0  55.0   70.0    NaN    NaN    NaN\nGE        NaN   NaN    NaN  100.0   30.0   40.0\nIBM       NaN   NaN    NaN   87.0   75.0   95.0\nSLB       NaN   NaN    NaN   20.0   55.0   85.0\nTXN       NaN   NaN    NaN  500.0   15.0   23.0\npd.concat(s_list,axis='columns',keys=['2016','2017'],names=['Year',None])\nOut[27]: \nYear     2016                2017              \n       Shares   Low   High Shares    Low   High\nSymbol                                         \nAAPL     80.0  95.0  110.0   50.0  120.0  140.0\nTSLA     50.0  80.0  130.0  100.0  100.0  300.0\nWMT      40.0  55.0   70.0    NaN    NaN    NaN\nGE        NaN   NaN    NaN  100.0   30.0   40.0\nIBM       NaN   NaN    NaN   87.0   75.0   95.0\nSLB       NaN   NaN    NaN   20.0   55.0   85.0\nTXN       NaN   NaN    NaN  500.0   15.0   23.0\n# missing values appear whenever a stock symbol is \n# present in one year but not the other \n# concat function, by default, uses an outer join,\n# keeping all rows from each DataFrame in the list\n# set the `join` parameter to change the behavior\npd.concat(s_list,join='inner',keys=['2016','2017'],names=['Year',None])\nOut[33]: \n           Shares  Low  High\nYear                        \n2016 AAPL      80   95   110\n     TSLA      50   80   130\n     WMT       40   55    70\n2017 AAPL      50  120   140\n     GE       100   30    40\n     IBM       87   75    95\n     SLB       20   55    85\n     TXN      500   15    23\n     TSLA     100  100   300\npd.concat(s_list,join='inner',keys=['2016','2017'],names=['Year',None],axis='columns')\nOut[34]: \nYear     2016            2017          \n       Shares Low High Shares  Low High\nSymbol                                 \nAAPL       80  95  110     50  120  140\nTSLA       50  80  130    100  100  300\n# concat function accepts a list as the first parameter \n# this list must be a sequence of pandas objects, \n# typically a list of DataFrame or Series.\n# by default, these objects will be stacked vertically\n# when concatenating vertically, the DataFrame align by their column names \nstock_2016.append(stock_2017)\nOut[40]: \n        Shares  Low  High\nSymbol                   \nAAPL        80   95   110\nTSLA        50   80   130\nWMT         40   55    70\nAAPL        50  120   140\nGE         100   30    40\nIBM         87   75    95\nSLB         20   55    85\nTXN        500   15    23\nTSLA       100  100   300\n\n"}, {"ctype": "head", "data": "Understanding the differences between concat, join, and merge"}, {"ctype": "p", "data": "the .merge and .join DataFrame (not Series) methods and the concat function all provide very similar functionality to combine multiple pandas objects together."}, {"ctype": "p", "data": " .merge 和 .join 很像，二者都是DataFrame方法，都是水平连接数据帧，但不同的是前者默认左连接，后者默认内连接，不过都可以调参数。 concat是函数，既可以水平连接，也可以竖直连接。 suffix 后缀 steak 牛排，碎牛肉 coconut 椰子 A method is a far better choice than B method : A远胜于B switch gears to focus on … 转换注意力于…… sanity check 完整性检查； align data by the values in their columns 按照列中的值对齐数据；"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327080433649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDQ4NDkx,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import pandas as pd\nimport numpy as np\n# read stock data of three years into a list of DataFrame using a loop instead of three different calls to the 'read_csv' function\nyears=2016,2017,2018\n# years is a tuple\nstock_tables=[pd.read_csv(f'stocks_{year}.csv',index_col='Symbol') for year in years]\nstock_tables\nOut[9]: \n[        Shares  Low  High\n Symbol                   \n AAPL        80   95   110\n TSLA        50   80   130\n WMT         40   55    70,\n         Shares  Low  High\n Symbol                   \n AAPL        50  120   140\n GE         100   30    40\n IBM         87   75    95\n SLB         20   55    85\n TXN        500   15    23\n TSLA       100  100   300,\n         Shares  Low  High\n Symbol                   \n AAPL        40  135   170\n AMZN         8  900  1125\n TSLA        50  220   400]\n# o_o .... 还能这样用\nstock_2016,stock_2017,stock_2018=stock_tables\nstock_2016\nOut[12]: \n        Shares  Low  High\nSymbol                   \nAAPL        80   95   110\nTSLA        50   80   130\nWMT         40   55    70\npd.concat(stock_tables,keys=['2016','2017','2018'])\nOut[13]: \n             Shares  Low  High\n     Symbol                   \n2016 AAPL        80   95   110\n     TSLA        50   80   130\n     WMT         40   55    70\n2017 AAPL        50  120   140\n     GE         100   30    40\n     IBM         87   75    95\n     SLB         20   55    85\n     TXN        500   15    23\n     TSLA       100  100   300\n2018 AAPL        40  135   170\n     AMZN         8  900  1125\n     TSLA        50  220   400\npd.concat(stock_tables,axis=1,keys=['2016','2017','2018'])\nOut[14]: \n         2016                2017                 2018               \n       Shares   Low   High Shares    Low   High Shares    Low    High\nSymbol                                                               \nAAPL     80.0  95.0  110.0   50.0  120.0  140.0   40.0  135.0   170.0\nTSLA     50.0  80.0  130.0  100.0  100.0  300.0   50.0  220.0   400.0\nWMT      40.0  55.0   70.0    NaN    NaN    NaN    NaN    NaN     NaN\nGE        NaN   NaN    NaN  100.0   30.0   40.0    NaN    NaN     NaN\nIBM       NaN   NaN    NaN   87.0   75.0   95.0    NaN    NaN     NaN\nSLB       NaN   NaN    NaN   20.0   55.0   85.0    NaN    NaN     NaN\nTXN       NaN   NaN    NaN  500.0   15.0   23.0    NaN    NaN     NaN\nAMZN      NaN   NaN    NaN    NaN    NaN    NaN    8.0  900.0  1125.0\npd.concat(dict(zip(years,stock_tables)),axis='columns')\nOut[15]: \n         2016                2017                 2018               \n       Shares   Low   High Shares    Low   High Shares    Low    High\nSymbol                                                               \nAAPL     80.0  95.0  110.0   50.0  120.0  140.0   40.0  135.0   170.0\nTSLA     50.0  80.0  130.0  100.0  100.0  300.0   50.0  220.0   400.0\nWMT      40.0  55.0   70.0    NaN    NaN    NaN    NaN    NaN     NaN\nGE        NaN   NaN    NaN  100.0   30.0   40.0    NaN    NaN     NaN\nIBM       NaN   NaN    NaN   87.0   75.0   95.0    NaN    NaN     NaN\nSLB       NaN   NaN    NaN   20.0   55.0   85.0    NaN    NaN     NaN\nTXN       NaN   NaN    NaN  500.0   15.0   23.0    NaN    NaN     NaN\nAMZN      NaN   NaN    NaN    NaN    NaN    NaN    8.0  900.0  1125.0\n\n(pd.concat(dict(zip(years,stock_tables)),axis='columns')\n ==pd.concat(stock_tables,axis=1,keys=['2016','2017','2018']))\nTraceback (most recent call last):\n  ...\nValueError: Can only compare identically-labeled DataFrame objects\n\n(pd.concat(dict(zip(years,stock_tables)),axis='columns')\n .equals(concat(stock_tables,axis=1,keys=['2016','2017','2018'])))\nTraceback (most recent call last):\n  File \"D:\\PyCharm2020\\python2020\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 3427, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"<ipython-input-18-1a818f9b814a>\", line 2, in <module>\n    .equals(concat(stock_tables,axis=1,keys=['2016','2017','2018'])))\nNameError: name 'concat' is not defined\n# combining the \n# DataFrame horizontally, we can use the .join and .merge to replicate the functionality of `concat` function\n# here, use .join method to combine stock_2017 and stock_2016 DataFrame\n# be default, the DataFrames align on their index\n# for any of the columns with the same name, use 'lsuffix' and\n# 'rsuffix' parameters to distinguish them in the result\nstock_2016.join(stock_2017,lsuffix='_2016',rsuffix='_2017',how='outer')\nOut[25]: \n        Shares_2016  Low_2016  High_2016  Shares_2017  Low_2017  High_2017\nSymbol                                                                    \nAAPL           80.0      95.0      110.0         50.0     120.0      140.0\nGE              NaN       NaN        NaN        100.0      30.0       40.0\nIBM             NaN       NaN        NaN         87.0      75.0       95.0\nSLB             NaN       NaN        NaN         20.0      55.0       85.0\nTSLA           50.0      80.0      130.0        100.0     100.0      300.0\nTXN             NaN       NaN        NaN        500.0      15.0       23.0\nWMT            40.0      55.0       70.0          NaN       NaN        NaN\n# to replicate the output of the `concat` function, pass a list \n# of dataframes to the .join method\nother=[stock_2016.add_suffix('_2016'),stock_2017.add_suffix('_2017')]\nother\nOut[29]: \n[        Shares_2016  Low_2016  High_2016\n Symbol                                  \n AAPL             80        95        110\n TSLA             50        80        130\n WMT              40        55         70,\n         Shares_2017  Low_2017  High_2017\n Symbol                                  \n AAPL             50       120        140\n GE              100        30         40\n IBM              87        75         95\n SLB              20        55         85\n TXN             500        15         23\n TSLA            100       100        300]\nstock_2018.add_suffix('_2018').join(other,how='outer')\nOut[30]: \n        Shares_2018  Low_2018  High_2018  ...  Shares_2017  Low_2017  High_2017\nSymbol                                    ...                                  \nAAPL           40.0     135.0      170.0  ...         50.0     120.0      140.0\nAMZN            8.0     900.0     1125.0  ...          NaN       NaN        NaN\nTSLA           50.0     220.0      400.0  ...        100.0     100.0      300.0\nWMT             NaN       NaN        NaN  ...          NaN       NaN        NaN\nGE              NaN       NaN        NaN  ...        100.0      30.0       40.0\nIBM             NaN       NaN        NaN  ...         87.0      75.0       95.0\nSLB             NaN       NaN        NaN  ...         20.0      55.0       85.0\nTXN             NaN       NaN        NaN  ...        500.0      15.0       23.0\n[8 rows x 9 columns]\n# check whether they are equal \n\nstock_join=stock_2016.add_suffix('_2016').join(other,how='outer')\nTraceback (most recent call last):\n  ......\nValueError: Indexes have overlapping values: Index(['Shares_2016', 'Low_2016', 'High_2016'], dtype='object')\n# because 'other' contains stock_2016 already.\n\nstock_join=stock_2018.add_suffix('_2018').join(other,how='outer')\nstock_concat=(\n    pd.concat(\n        dict(zip(years,stock_tables)),axis='columns')\n    .swaplevel(axis=1)\n    .pipe(lambda df_:df_.set_axis(df_.columns.to_flat_index(),axis=1))\n    .rename(lambda label:'_'.join([str[x] for x in label),axis=1)))\n  File \"<ipython-input-34-62ed7569d7c4>\", line 6\n    .rename(lambda label:'_'.join([str[x] for x in label),axis=1)))\n                                                        ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\nstock_concat=(\n    pd.concat(\n        dict(zip(years,stock_tables)),axis='columns')\n    .swaplevel(axis=1)\n    .pipe(lambda df_:df_.set_axis(df_.columns.to_flat_index(),axis=1))\n    .rename(lambda label:'_'.join([str(x) for x in label]),axis=1)))\n  File \"<ipython-input-35-1b47d0c47ebf>\", line 6\n    .rename(lambda label:'_'.join([str(x) for x in label]),axis=1)))\n                                                                   ^\nSyntaxError: unmatched ')'\nstock_concat=(\n    pd.concat(\n        dict(zip(years,stock_tables)),axis='columns')\n    .swaplevel(axis=1)\n    .pipe(lambda df_:df_.set_axis(df_.columns.to_flat_index(),axis=1))\n    .rename(lambda label:'_'.join([str(x) for x in label]),axis=1))\nstock_concat.equals(stock_join)\nOut[37]: False\nstock_concat\nOut[38]: \n        Shares_2016  Low_2016  High_2016  ...  Shares_2018  Low_2018  High_2018\nSymbol                                    ...                                  \nAAPL           80.0      95.0      110.0  ...         40.0     135.0      170.0\nTSLA           50.0      80.0      130.0  ...         50.0     220.0      400.0\nWMT            40.0      55.0       70.0  ...          NaN       NaN        NaN\nGE              NaN       NaN        NaN  ...          NaN       NaN        NaN\nIBM             NaN       NaN        NaN  ...          NaN       NaN        NaN\nSLB             NaN       NaN        NaN  ...          NaN       NaN        NaN\nTXN             NaN       NaN        NaN  ...          NaN       NaN        NaN\nAMZN            NaN       NaN        NaN  ...          8.0     900.0     1125.0\n[8 rows x 9 columns]\nstock_join\nOut[39]: \n        Shares_2018  Low_2018  High_2018  ...  Shares_2017  Low_2017  High_2017\nSymbol                                    ...                                  \nAAPL           40.0     135.0      170.0  ...         50.0     120.0      140.0\nAMZN            8.0     900.0     1125.0  ...          NaN       NaN        NaN\nTSLA           50.0     220.0      400.0  ...        100.0     100.0      300.0\nWMT             NaN       NaN        NaN  ...          NaN       NaN        NaN\nGE              NaN       NaN        NaN  ...        100.0      30.0       40.0\nIBM             NaN       NaN        NaN  ...         87.0      75.0       95.0\nSLB             NaN       NaN        NaN  ...         20.0      55.0       85.0\nTXN             NaN       NaN        NaN  ...        500.0      15.0       23.0\n[8 rows x 9 columns]\n#因为我把 stock_join 中的年份顺序弄错了，所以结果是False,本应该是True\n# unlike `concat` and `.join`, `.merge` can only combine two dataframes together \n# be default, `,merge` attempts to align the values in the columns that have the same name for each of dataframes\n# have it align on the index by setting the Boolean parameter `left_index` and 'right_index` to True\nstock_2016.index[:2]\nOut[44]: Index(['AAPL', 'TSLA'], dtype='object', name='Symbol')\nstock_2016.merge(stock_2017,right_index=True,left_index=True)\nOut[45]: \n        Shares_x  Low_x  High_x  Shares_y  Low_y  High_y\nSymbol                                                  \nAAPL          80     95     110        50    120     140\nTSLA          50     80     130       100    100     300\n# by default, .merge uses an inner join and automatically supplies suffixes for identically named columns\n# to replicate `concat` function, change to an outer join and then perform another outer join of the 2018 data \nstock_2016.merge(stock_2017,right_index=True,left_index=True,how='outer',suffixes=('_2016','_2017')).merge(stock_2018.add_suffix('_2018'),right_index=True,left_index=True,how='outer')\nOut[48]: \n        Shares_2016  Low_2016  High_2016  ...  Shares_2018  Low_2018  High_2018\nSymbol                                    ...                                  \nAAPL           80.0      95.0      110.0  ...         40.0     135.0      170.0\nAMZN            NaN       NaN        NaN  ...          8.0     900.0     1125.0\nGE              NaN       NaN        NaN  ...          NaN       NaN        NaN\nIBM             NaN       NaN        NaN  ...          NaN       NaN        NaN\nSLB             NaN       NaN        NaN  ...          NaN       NaN        NaN\nTSLA           50.0      80.0      130.0  ...         50.0     220.0      400.0\nTXN             NaN       NaN        NaN  ...          NaN       NaN        NaN\nWMT            40.0      55.0       70.0  ...          NaN       NaN        NaN\n[8 rows x 9 columns]\nstock_merge=stock_2016.merge(stock_2017,right_index=True,left_index=True,how='outer',suffixes=('_2016','_2017')).merge(stock_2018.add_suffix('_2018'),right_index=True,left_index=True,how='outer')\nstock_merge.equals(stock_concat.sort_index())\nOut[50]: True\n# .merge method is built for this situation where\n# align together the values of columns and not the index or column labels themselves\nnames=['prices','transactions']\nfood_table=[pd.read_csv(\"food_{}.csv\".format(name)) for name in names]\n\nfood_table\nOut[57]: \n[     item store  price  Date\n 0    pear     A   0.99  2017\n 1    pear     B   1.99  2017\n 2   peach     A   2.99  2017\n 3   peach     B   3.49  2017\n 4  banana     A   0.39  2017\n 5  banana     B   0.49  2017\n 6   steak     A   5.99  2017\n 7   steak     B   6.99  2017\n 8   steak     B   4.99  2015,\n    custid     item store  quantity\n 0       1     pear     A         5\n 1       1   banana     A        10\n 2       2    steak     B         3\n 3       2     pear     B         1\n 4       2    peach     B         2\n 5       2    steak     B         1\n 6       2  coconut     B         4]\nfood_prices,food_transactions=food_table\nfood_prices\nOut[60]: \n     item store  price  Date\n0    pear     A   0.99  2017\n1    pear     B   1.99  2017\n2   peach     A   2.99  2017\n3   peach     B   3.49  2017\n4  banana     A   0.39  2017\n5  banana     B   0.49  2017\n6   steak     A   5.99  2017\n7   steak     B   6.99  2017\n8   steak     B   4.99  2015\n# to find the total amount of each transaction, join these dataframes on the `item` and 'store` columns\nfood_transactions.merge(food_prices,on=['item','store'])\nOut[62]: \n   custid    item store  quantity  price  Date\n0       1    pear     A         5   0.99  2017\n1       1  banana     A        10   0.39  2017\n2       2   steak     B         3   6.99  2017\n3       2   steak     B         3   4.99  2015\n4       2   steak     B         1   6.99  2017\n5       2   steak     B         1   4.99  2015\n6       2    pear     B         1   1.99  2017\n7       2   peach     B         2   3.49  2017\n# the prices are aligned correctly with its corresponding items and store\n# but the problem is that as the `steak` item appears twice in each table for store B,\n# a Cartesian product takes place between them, resulting in four rows\n# and, 'coconut' item is missing because there is no corresponding price for it \nfood_transactions.merge(food_prices.query(\"Date==2017\"),on=['item','store'],how='left')\nOut[67]: \n   custid     item store  quantity  price    Date\n0       1     pear     A         5   0.99  2017.0\n1       1   banana     A        10   0.39  2017.0\n2       2    steak     B         3   6.99  2017.0\n3       2     pear     B         1   1.99  2017.0\n4       2    peach     B         2   3.49  2017.0\n5       2    steak     B         1   6.99  2017.0\n6       2  coconut     B         4    NaN     NaN\nfood_transactions.merge(food_prices.query(\"Date==2017\"),how='left')\nOut[68]: \n   custid     item store  quantity  price    Date\n0       1     pear     A         5   0.99  2017.0\n1       1   banana     A        10   0.39  2017.0\n2       2    steak     B         3   6.99  2017.0\n3       2     pear     B         1   1.99  2017.0\n4       2    peach     B         2   3.49  2017.0\n5       2    steak     B         1   6.99  2017.0\n6       2  coconut     B         4    NaN     NaN\n\n# to replicate the result, use .join method \n# firstly , put the joining columns of the `food_prices`,why?? let's explore it.\nfood_price_join=food_prices.query('Date==2017')\nfood_transactions.join(food_price_join,on=[\"item\",'store'])\nTraceback (most recent call last):\n  .. ...\nValueError: len(left_on) must equal the number of levels in the index of \"right\"\n# 这里的报错不要删，它提醒我们在用.join方法时，the passed dataframe 需要设置索引\n# so , put the joining columns of the passed dataframe into the index\nfood_prices_join=food_prices.query('Date==2017')\\\n    .set_index(['item','store'])\nfood_transactions.join(food_prices_join,on=['item','store'])\nOut[77]: \n   custid     item store  quantity  price    Date\n0       1     pear     A         5   0.99  2017.0\n1       1   banana     A        10   0.39  2017.0\n2       2    steak     B         3   6.99  2017.0\n3       2     pear     B         1   1.99  2017.0\n4       2    peach     B         2   3.49  2017.0\n5       2    steak     B         1   6.99  2017.0\n6       2  coconut     B         4    NaN     NaN\n\nfood_transactions.join(food_prices_join)\nTraceback (most recent call last):\n ... ...\nValueError: cannot join with no overlapping index names\n\nfood_transactions.set_index(['item','store']).join(food_prices_join)\nOut[79]: \n               custid  quantity  price    Date\nitem    store                                 \nbanana  A           1        10   0.39  2017.0\ncoconut B           2         4    NaN     NaN\npeach   B           2         2   3.49  2017.0\npear    A           1         5   0.99  2017.0\n        B           2         1   1.99  2017.0\nsteak   B           2         3   6.99  2017.0\n        B           2         1   6.99  2017.0\nfood_prices_join\nOut[80]: \n              price  Date\nitem   store             \npear   A       0.99  2017\n       B       1.99  2017\npeach  A       2.99  2017\n       B       3.49  2017\nbanana A       0.39  2017\n       B       0.49  2017\nsteak  A       5.99  2017\n       B       6.99  2017\n# .join method only align with the index of the passed dataframe\n# but can use the index or columns of the calling DataFrame \n# to use the columns for alignment on the calling DataFrame , \n# you will need to pass them to `on` parameter\n# to replicate this with the concat function, \n# you need to put the `item` and `store` columns in the index of both dataframes\n# however, in this particular case, an error would be produced as a duplicate index value occurs in at least one of the DataFrames(with item steak and store B)\npd.concat([food_prices.query('Date==2017').set_index(['item','store']),food_transactions.set_index(['item','store'])],axis=1)\nTraceback (most recent call last):\n    ......\nValueError: Reindexing only valid with uniquely valued Index objects\n# 这大概是因为 food_transactions contains two records with the same index (steak,store B)\nfood_prices.query('Date==2017') \nOut[89]: \n     item store  price  Date\n0    pear     A   0.99  2017\n1    pear     B   1.99  2017\n2   peach     A   2.99  2017\n3   peach     B   3.49  2017\n4  banana     A   0.39  2017\n5  banana     B   0.49  2017\n6   steak     A   5.99  2017\n7   steak     B   6.99  2017\n\n"}, {"ctype": "p", "data": " it is possible to use ,join in these instances, but all the columns in the passed DataFrame must be moved into the index first.(这里似乎有点问题……不应该是all the columns 吧) concat is going to be a poor choice whenever you intend to align data by values in their columns .  （420（441/627））"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327130501100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDQ4NDkx,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# task: read all files from a particular directory into a DataFrame without knowing their names\n# Python provides a few ways to iterate through directories, with `glob` module be a popular choice\n# the `glob` module has the `glob` function\n# which takes a single parameter(the location of directory you would like to iterate through as a string)\n# to get all the files in the directory, use the string `*`\n# the return of the glob function is a list of string filenames\nimport glob\nimport pandas as pd\nimport numpy as np\ndf_list=[]\nfor filename in glob.glob('gas prices/*.csv'):\n    df_list.append(pd.read_csv(filename,index_col='Week',parse_dates=['Week']))    \n    \ndf_list\nOut[21]: \n[            All Grades\n Week                  \n 2017-09-25       2.701\n 2017-09-18       2.750\n 2017-09-11       2.800\n 2017-09-04       2.794\n 2017-08-28       2.513\n ...                ...\n 2007-01-29       2.213\n 2007-01-22       2.216\n 2007-01-15       2.280\n 2007-01-08       2.354\n 2007-01-01       2.382\n \n [561 rows x 1 columns],\n... ...\n \n \n             Regular\n Week               \n 2017-09-25    2.583\n 2017-09-18    2.634\n 2017-09-11    2.685\n 2017-09-04    2.679\n 2017-08-28    2.399\n ...             ...\n 2007-01-29    2.165\n 2007-01-22    2.165\n 2007-01-15    2.229\n 2007-01-08    2.306\n 2007-01-01    2.334\n \n [561 rows x 1 columns]]\n \ngas=pd.concat(df_list,axis='columns')\ngas\nOut[23]: \n            All Grades  Diesel  Midgrade  Premium  Regular\nWeek                                                      \n2017-09-25       2.701   2.788     2.859    3.105    2.583\n2017-09-18       2.750   2.791     2.906    3.151    2.634\n2017-09-11       2.800   2.802     2.953    3.197    2.685\n2017-09-04       2.794   2.758     2.946    3.191    2.679\n2017-08-28       2.513   2.605     2.668    2.901    2.399\n                ...     ...       ...      ...      ...\n2007-01-29       2.213   2.413     2.277    2.381    2.165\n2007-01-22       2.216   2.430     2.285    2.391    2.165\n2007-01-15       2.280   2.463     2.347    2.453    2.229\n2007-01-08       2.354   2.537     2.418    2.523    2.306\n2007-01-01       2.382   2.580     2.442    2.547    2.334\n[561 rows x 5 columns]\n\n"}, {"ctype": "head", "data": "Connecting to SQL databases"}, {"ctype": "p", "data": "先跳过，日后来补吧😭😭😭😭😭😭😭😭😭😭😭😭😭"}], "cate": "Python"}
{"题目": "Opencv-python4.5学习笔记", "作者": "AI菜鸟要先飞", "发布时间": "2021-03-27 11:26:30", "内容": [{"ctype": "head", "data": "读取、展示、保存图片"}, {"ctype": "code", "data": "import cv2 as cv\nimport sys\n\nimg = cv.imread(\"ying.jpg\")\nif img is None:\n    sys.exit(\"Could not read the image.\")\ncv.imshow(\"Display window\",img)\nk = cv.waitKey(0)\nif k == ord(\"s\"):\n    cv.imwrite(\"ying.png\",img)\n"}, {"ctype": "head", "data": "摄像头读取视频并转为灰度图显示"}, {"ctype": "code", "data": "import cv2 as cv\nimport sys\nimport numpy as np\n\ncap = cv.VideoCapture(0)\nprint(cap.get(cv.CAP_PROP_FRAME_WIDTH))  #640.0\nprint(cap.get(cv.CAP_PROP_FRAME_HEIGHT)) #480.0\ncap.set(cv.CAP_PROP_FRAME_WIDTH,320)\ncap.set(cv.CAP_PROP_FRAME_HEIGHT,240)\nif not cap.isOpened():\n    print(\"Cannot open camera\")\n    exit()\nwhile True:\n    ret,frame = cap.read() #成功读取数据返回ret=True,else ret = False\n\n    if not ret:\n        print(\"Can't receive frame (stream end?).Exitint...\")\n        break\n\n    gray = cv.cvtColor(frame,cv.COLOR_BGR2GRAY) \n    #cvtColor,转换显示颜色，BGR2GRAY:BGR转为灰度\n    cv.imshow(\"frame\",gray)\n    if cv.waitKey(1) == ord('q'):\n        break\n\ncap.release()\ncv.destroyAllWindows()\n"}, {"ctype": "head", "data": "播放视频文件"}, {"ctype": "code", "data": "import numpy as np\nimport cv2 as cv\n\ncap = cv.VideoCapture('vtest.avi')\nwhile cap.isOpened():\n    ret, frame = cap.read()\n    if not ret:\n        print(\"Can't receive frame (stream end?). Exiting ...\")\n        break\n    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)\n    cv.imshow('frame', gray)\n    if cv.waitKey(1) == ord('q'):\n        break\ncap.release()\ncv.destroyAllWindows()\n"}, {"ctype": "head", "data": "从摄像头读取帧保存视频"}, {"ctype": "code", "data": "import cv2 as cv\nimport time\ncap = cv.VideoCapture(0)\n#fourcc是用于表示视频信息的四字节编码\nfourcc = cv.VideoWriter_fourcc('M','J','P','G')\nout = cv.VideoWriter('test.avi',fourcc,30,(640,480),1)\n#保存的文件名，编码类型，fps(帧/秒)，大小，色彩（0表示灰度，其他表示彩色）\nif not cap.isOpened():\n    raise Exception(\"Cannot open camera\")\n\nt0 = time.time()  #用来保存一段时间长度的视频\nwhile True:\n    ret,frame = cap.read()\n    if not ret:\n        print(\"Can't receive frame (stream end?).Exitint...\")\n        break\n    frame = cv.flip(frame,1) #左右翻转\n    out.write(frame)\n    cv.imshow(\"frame\",frame)\n    t = time.time() - t0\n    if t >= 30:\n        break\n    if cv.waitKey(1) == ord('q'):\n        break\n\ncap.release()\ncv.destroyAllWindows()\n"}, {"ctype": "head", "data": "画图、显示文字"}, {"ctype": "code", "data": "img = cv.imread('ying.jpg')\ncv.line(img,(0,0),(800,800),(0,255,0),5)\n#(0,0)线条起点，（800，800）终点，(0,255,0)绿色，厚度5\n#矩形\ncv.rectangle(img,(400,400),(500,500),(255,0,0),5)\n#圆\ncv.circle(img,(550,700),50,(0,0,255),1)\n#(550,700)圆心,50半径,1表示不填充，只显示线条，-1表示填充整个区域\n#椭圆\ncv.ellipse(img,(256,256),(100,50),0,0,360,(0,255,0),-1)\n#(256,256)中心,(100,50)即（a,b）,0,0,两个0为旋转角度，360即显示的区域大小,(0,255,0),-1同上\n#多边形\npts = np.array([[100,100],[200,200],[100,200],[200,100],[300,300]], np.int32)\npts = pts.reshape((-1,1,2))\ncv.polylines(img,[pts],True,(0,255,255))\n#在图像显示文字\nfont = cv.FONT_HERSHEY_SIMPLEX\ncv.putText(img,'come on baby',(10,500), font, 4,(255,255,255),2,cv.LINE_AA)\n\ncv.imshow(\"ying\",img)\ncv.waitKey(0)\ncv.destroyAllWindows()\n"}, {"ctype": "head", "data": "鼠标响应"}, {"ctype": "code", "data": "events = [i for i in dir(cv) if 'EVENT' in i]\nprint(events) #所有事件\n#['EVENT_FLAG_ALTKEY', 'EVENT_FLAG_CTRLKEY', 'EVENT_FLAG_LBUTTON', 'EVENT_FLAG_MBUTTON', 'EVENT_FLAG_RBUTTON',\n#  'EVENT_FLAG_SHIFTKEY', 'EVENT_LBUTTONDBLCLK', 'EVENT_LBUTTONDOWN', 'EVENT_LBUTTONUP', 'EVENT_MBUTTONDBLCLK',\n# 'EVENT_MBUTTONDOWN', 'EVENT_MBUTTONUP', 'EVENT_MOUSEHWHEEL', 'EVENT_MOUSEMOVE', 'EVENT_MOUSEWHEEL',\n#  'EVENT_RBUTTONDBLCLK', 'EVENT_RBUTTONDOWN', 'EVENT_RBUTTONUP']\n\ndrawing = False\nmode = True\nix,iy = -1,-1\n\ndef draw_circle(event,x,y,flags,param):\n    global ix,iy,drawing,mode\n    if event == cv.EVENT_LBUTTONDOWN:\n        drawing = True\n        ix,iy = x,y\n    elif event == cv.EVENT_MOUSEMOVE:\n        if drawing == True:\n            if mode == True:\n                cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)\n            else:\n                cv.circle(img,(x,y),5,(0,0,255),-1)\n    elif event == cv.EVENT_LBUTTONUP:\n        drawing = False\n        if mode == True:\n            cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)\n        else:\n            cv.circle(img,(x,y),5,(0,0,255),-1)\nimg = cv.imread('ying.png')\ncv.namedWindow('ying')\ncv.setMouseCallback('ying',draw_circle)\n\nwhile True:\n    cv.imshow('ying',img)\n    k = cv.waitKey(20) & 0xFF\n    if k == 27:\n        break\n    elif k == ord('m'):\n        mode = not mode\ncv.destroyAllWindows()\n"}, {"ctype": "p", "data": "效果：按下鼠标，该位置为起点，按住鼠标移动，会根据当前鼠标位置和起点画图，按下m切换画图方式。"}, {"ctype": "head", "data": "滑动轨迹条"}, {"ctype": "code", "data": "def nothing(x):\n    pass\n# Create a black image, a window\nimg = np.zeros((300,512,3), np.uint8)\ncv.namedWindow('image')\n# create trackbars for color change\ncv.createTrackbar('R','image',0,255,nothing)\ncv.createTrackbar('G','image',0,255,nothing)\ncv.createTrackbar('B','image',0,255,nothing)\n# create switch for ON/OFF functionality\nswitch = '0 : OFF \\n1 : ON'\ncv.createTrackbar(switch, 'image',0,1,nothing)\nwhile(1):\n    cv.imshow('image',img)\n    k = cv.waitKey(1) & 0xFF\n    if k == 27:\n        break\n    # get current positions of four trackbars\n    r = cv.getTrackbarPos('R','image')\n    g = cv.getTrackbarPos('G','image')\n    b = cv.getTrackbarPos('B','image')\n    s = cv.getTrackbarPos(switch,'image')\n    if s == 0:\n        img[:] = 0\n    else:\n        img[:] = [b,g,r]\ncv.destroyAllWindows()\n"}], "cate": "Python"}
{"题目": "Python(7)函数、面向对象、类、实例", "作者": "yyuan_in", "发布时间": "2021-03-27 10:16:16", "内容": [{"ctype": "head", "data": "嵌套函数(内部函数)"}, {"ctype": "p", "data": "嵌套函数： 在函数内部定义的函数！并且只能在内部调用，不能在外部调用。 一般在什么情况下使用嵌套函数？"}, {"ctype": "p", "data": "封装 - 数据隐藏,外部无法访问“嵌套函数”。贯彻 DRY(Don’t Repeat Yourself) 原则,嵌套函数，可以让我们在函数内部避免重复代码。闭包"}, {"ctype": "code", "data": "def outer():\n    print(\"outer running\")\n\n    def inner01():\n        print(\"inner01 running\")\nouter()\ninner01() #外部无法调用嵌套函数\n'''result:\nTraceback (most recent call last):\n  File \"C:/Users/Ranio/Downloads/Python/mypro_func/mypy_16.py\", line 12, in <module>\n    inner01()\nNameError: name 'inner01' is not defined\nouter running\n'''\n"}, {"ctype": "code", "data": "def printChineseName(name,familyName):\n    print(\"{0} {1}\".format(familyName,name))\n\ndef printEnglishName(name,familyName):\n    print(\"{0} {1}\".format(name, familyName))\n#等价于：\ndef printName(isChinese,name,familyName):\n    def inner_print(a,b):\n        print(\"{0} {1}\".format(a,b))\n\n    if isChinese:\n        inner_print(familyName,name)\n    else:\n        inner_print(name,familyName)\n\nprintName(True,\"一\",\"王\")\nprintName(0,\"Nina\",\"Trump\")\n'''result:\nouter running\ninner01 running\n王 一\nNina Trump\n'''\n"}, {"ctype": "head", "data": "nonlocal 关键字"}, {"ctype": "p", "data": "nonlocal 用来声明外层的局部变量。 global 用来声明全局变量。 声明后，在函数内部就可以改变外层的局部变量或全局变量"}, {"ctype": "code", "data": "a = 100\nprint(\"old a:\",a)\ndef outer():\n    b = 10\n\n    def inner():\n        nonlocal  b         #声明外部函数的局部变量\n        print(\"old b:\",b)\n        b = 20\n\n        global a            #声明全局变量\n        a = 1000\n\n    inner()\n    print(\"new b:\",b)\n\nouter()\nprint(\"new a：\",a)\n'''result:\nold a: 100\nold b: 10\nnew b: 20\nnew a： 1000\n'''\n"}, {"ctype": "head", "data": "LEGB 规则"}, {"ctype": "p", "data": "Python 在查找“名称”时，是按照 LEGB 规则查找的： Local–>Enclosed–>Global–>Built in Local 指的就是函数或者类的方法内部 Enclosed 指的是嵌套函数（一个函数包裹另一个函数，闭包） Global 指的是模块中的全局变量 Built in 指的是 Python 为自己保留的特殊名称。 如果某个 name 映射在局部(local)命名空间中没有找到，接下来就会在闭包作用域 (enclosed)进行搜索，如果闭包作用域也没有找到，Python 就会到全局(global)命名空 间中进行查找，最后会在内建(built-in)命名空间搜索 （如果一个名称在所有命名空间 中都没有找到，就会产生一个 NameError）。"}, {"ctype": "head", "data": "面向对象初步"}, {"ctype": "p", "data": "面向对象（Object oriented Programming，OOP）编程的思想主要是针对大型软件设计而来的。面向对象编程使程序的扩展性更强、可读性更好，使的编程可以像搭积木一样简单。 面向对象编程将数据和操作数据相关的方法封装到对象中，组织代码和数据的方式更加接近人的思维，从而大大提高了编程的效率。 Python 完全采用了面向对象的思想，是真正面向对象的编程语言，完全支持面向对象的基本功能，例如：继承、多态、封装等。 Python 中，一切皆对象。数据类型、函数等，都是对象。 注：Python 支持面向过程、面向对象、函数式编程等多种编程范式。"}, {"ctype": "head", "data": "面向对象和面向过程区别"}, {"ctype": "p", "data": "·面向过程(Procedure Oriented)思维 面向过程编程更加关注的是“程序的逻辑流程”，是一种“执行者”思维，适合编写小 规模的程序。 面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法， 一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车？ 我们很容易就列出实现步骤： 1. 发动车 2. 挂挡 3.踩油门"}, {"ctype": "p", "data": "面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如 何造车？”，就会发现列出 1234 这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。 ·"}, {"ctype": "p", "data": "面向对象(Object Oriented)思维 面向对象更加关注的是“软件中对象之间的关系”，是一种“设计者”思维，适合编写大规模的程序。 面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。"}, {"ctype": "p", "data": "面向对象方式思考造车，发现车由如下对象组成： 1. 轮胎 2. 发动机 3. 车壳 4. 座椅 5. 挡风玻，为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤； 这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想！ 因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。 我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！"}, {"ctype": "p", "data": "面向对象思考方式 遇到复杂问题，先从问题中找名词（面向过程更多的是找动词），然后确立这些名词哪 些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。"}, {"ctype": "p", "data": "面向对象和面向过程的总结  都是解决问题的思维方式，都是代码组织的方式。  解决简单问题可以使用面向过程  解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。"}, {"ctype": "head", "data": "对象的进化"}, {"ctype": "p", "data": "随着编程面临的问题越来越复杂，编程语言本身也在进化，从主要处理简单数据开始， 随着数据变多进化“数组”； 数据类型变复杂，进化出了“结构体”； 处理数据的方式和逻辑变复杂，进化出了“对象”。"}, {"ctype": "p", "data": "简单数据 像 30,40，50.4 等这些数字，可以看做是简单数据。最初的计算机编程，都是像这样 的数字。数组将同类型的数据放到一起。比如：整数数组[20,30,40]，浮点数数组[10.2, 11.3, 12.4]， 字符串数组：[“aa”,”bb”,”cc”]结构体 将不同类型的数据放到一起，是 C 语言中的数据结构。比如： struct resume{ int age; char name[10]; double salary; };对象将不同类型的数据、方法（即函数）放到一起，就是对象。比如："}, {"ctype": "code", "data": "class Student:   #类名一般首字母大写，多个单词采用驼峰原则,e.g.GoodStudent\n    school= \"xd\"#类属性\n    def __init__(self,name,score): #实例属性\n        self.name = name\n        self.score = score\n   \n\n    def say_score(self):   #实例方法\n        print(\"{0}的分数是：{1},学校是{2}\".format(self.name,self.score,Student.school))\n"}, {"ctype": "p", "data": "我们前面学习的数字也是对象。比如：整数 9，就是一个包含了加法、乘法等方法的对象。"}, {"ctype": "head", "data": "类、实例对象、对象"}, {"ctype": "p", "data": "易混名词说明： 当把“类”与“对象”作为同一层级的东西讨论时，这里的“对象”=“实例对象”=“实例” “类”=“类对象” Python 中，“一切皆对象”。类也称为“类对象”，类的实例也称为“实例对象”。 当把“对象”作为更大的概念讨论时（即python中一切皆“对象”的“对象”），“类”和“实例”都是“对象”"}, {"ctype": "p", "data": "我们把对象（即实例、实例对象）比作一个“饼干”，类就是制造这个饼干的“模具”。 我们通过类定义数据类型的属性（数据）和方法（行为）,也就是说，“类将行为和状态打包在一起。  对象是类的具体实体，一般称为“类的实例”。类看做“饼干模具”，对象就是根据这个“模具”制造出的“饼干”。 从一个类创建对象时，每个对象会共享这个类的行为（类中定义的方法），但会有自己的属性值（不共享状态）。更具体一点：“方法代码是共享的，属性数据不共享”。  定义类的语法格式如下： class 类名： 类体 要点如下："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326212641200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5dWFuX2lu,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "类名必须符合“标识符”的规则；一般规定，首字母大写，多个单词使用“驼峰原则”。类体中我们可以定义属性和方法。属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。"}, {"ctype": "code", "data": "class Student:   #类名一般首字母大写，多个单词采用驼峰原则,e.g.GoodStudent\n\n    def __init__(self,name,score): #self必须位于第一个参数。__init__()方法初始化对象，__new__()方法创建对象。实例属性\n        self.name = name\n        self.score = score\n    '''\n    def __init__(self): #若是这样定义的话，所有的student对象的name都是cat，score都是97\n        self.name = cat\n        self.score = 97\n    \n    '''\n\n    def say_score(self):   #self必须位于第一个参数。实例方法\n        print(\"{0}的分数是：{1}\".format(self.name,self.score))\n        \ns1 = Student(\"cat\",97)   #通过类名()调用构造函数__init__(self,name,score)  #s1 是实例对象，自动调用__init__()方法\ns1.say_score()\n        \n"}, {"ctype": "head", "data": "__init__构造方法和__new__方法"}, {"ctype": "p", "data": "类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然后才能使用类定义的功能。 我们前面说过一个 Python 对象包含三个部分：id（identity 识别码）、type（对象类型）、 value（对象的值）。 现在，我们可以更进一步的说，一个 Python 对象包含如下部分："}, {"ctype": "p", "data": "id（identity 识别码）type（对象类型）value（对象的值） (1) 属性（attribute） (2) 方法（method）"}, {"ctype": "p", "data": "创建对象，我们需要定义构造函数__init__()方法。构造方法用于执行“实例对象的初始化工作”，即对象创建后，初始化当前对象的相关属性，无返回值。 init()的要点如下："}, {"ctype": "p", "data": "名称固定，必须为：init()第一个参数固定，必须为：self。 self 指的就是刚刚创建好的实例对象。构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性：name 和 score"}, {"ctype": "code", "data": "def __init__(self,name,score): \n\tself.name = name #实例属性 \n\tself.score = score\n"}, {"ctype": "p", "data": "通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如：s1 = Student(‘张三’, 80)new()方法: 用于创建对象，但我们一般无需重定义该方法。init()方法：初始化创建好的对象，初始化指的是：“给实例属性赋值”如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参 的__init__方法，系统不创建默认的__init__方法。"}, {"ctype": "p", "data": "注：1. Python 中的 self 相当于 C++中的 self 指针，JAVA 和 C#中的 this 关键字。Python 中， self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。"}, {"ctype": "head", "data": "实例属性"}, {"ctype": "p", "data": "实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点："}, {"ctype": "p", "data": "实例属性一般在__init__()方法中通过如下代码定义： self.实例属性名 = 初始值在本类的其他实例方法中，也是通过 self 进行访问： self.实例属性名创建实例对象后，通过实例对象访问： obj01 = 类名() #创建实例对象obj01，调用__init__()初始化属性 obj01.实例属性名 = 值 #可以给已有属性赋值，也可以新加属性 。"}, {"ctype": "code", "data": "class Student:   #类名一般首字母大写，多个单词采用驼峰原则,e.g.GoodStudent\n\n    def __init__(self,name,score): #self必须位于第一个参数。__init__()方法初始化对象，__new__()方法创建对象 #实例属性\n        self.name = name #self.实例属性名 = 初始值\n        self.score = score\n  \n    def say_score(self):   #self必须位于第一个参数 #实例方法\n        print(\"{0}的分数是：{1}\".format(self.name,self.score))# self.实例属性名\ns1 = Student(\"cat\",97)   #创建实例对象s1\ns1.say_score() #调用实例方法。实际上翻译器翻译为：Student.say_score(s1)\n\ns1.age = 18 #给实例对象s1新增加实例属性age和salary，但是因为age与salary不是Student类里面的属性，因此只存在于s1中，s2中没有age和salary\ns1.salary = 30000\ns2 = Student(\"dog\",85)\n"}, {"ctype": "head", "data": "实例方法"}, {"ctype": "p", "data": "实例方法是从属于实例对象的方法。实例方法的定义格式如下： def 方法名(self [, 形参列表])： 函数体 方法的调用格式如下： 对象.方法名([实参列表]) 要点："}, {"ctype": "p", "data": "定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。 · 函数和方法的区别都是用来完成一个功能的语句块，本质一样。方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。直观上看，方法定义时需要有 self，函数不需要。"}, {"ctype": "p", "data": "实例对象的方法调用本质： ·"}, {"ctype": "code", "data": "s2=Student() #创建实例对象s2\ns2.say_score() #调用实例方法\n#等价于\nStudent.say_score(s2)#解释器将s2.say_score()翻译为Student.say_score(s2)\n"}, {"ctype": "p", "data": "其他操作："}, {"ctype": "p", "data": "dir(obj)可以获得对象的所有属性、方法obj.dict 对象的属性字典pass 空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时， 遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。isinstance（对象,类） 判断“对象”是不是“指定类”"}, {"ctype": "code", "data": "print(dir(s2))\n\nprint(s2.__dict__)\n\nclass Man: \n    pass \n\nprint(isinstance(s2,Man))\n"}, {"ctype": "head", "data": "类对象"}, {"ctype": "p", "data": "我们在前面讲的类定义格式中，“class 类名：”。实际上，当解释器执行 class 语句时， 就会创建一个类对象。"}, {"ctype": "code", "data": "class Student:   #类名一般首字母大写，多个单词采用驼峰原则\n\n    def __init__(self,name,score): #self必须位于第一个参数\n        self.name = name #self.实例属性名 = 初始值\n        self.score = score\n\n    def say_score(self):   #self必须位于第一个参数\n        print(\"{0}的分数是：{1}\".format(self.name,self.score))\n        \nstu2 = Student #stu2是类对象\nsss=Student('bird',100) #sss是实例对象\nprint(stu2 is Student)\nprint(\"stu2的类型：{0},Student的类型：{1},sss的类型：{2}\".format(type(stu2),type(Student),type(sss)))\ns1 = Student(\"cat\",97)\ns2 = stu2(\"dog\",85)\n\ns1.say_score()\ns2.say_score()\n\n'''result:\nTrue\nstu2的类型：<class 'type'>,Student的类型：<class 'type'>,sss的类型：<class '__main__.Student'>\ncat的分数是：97\ndog的分数是：85\n\n'''\n"}, {"ctype": "p", "data": "我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。"}, {"ctype": "head", "data": "类属性"}, {"ctype": "p", "data": "类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以被所有实例对象共享。 类属性的定义方式： class 类名： 类变量名= 初始值 在类中或者类的外面，我们可以通过：“类名.类变量名”来读写。"}, {"ctype": "code", "data": "class Student:\n    company = \"xd\"  # 类属性\n    count = 0  # 类属性\n\n    def __init__(self, name, score):\n        self.name = name  # 实例属性\n        self.score = score\n        Student.count = Student.count + 1\n\n    def say_score(self):  # 实例方法\n        print(\"我的公司是：\", Student.company)\n        print(self.name, '的分数是：', self.score)\n\n\ns1 = Student('cat', 97)  # s1是实例对象，自动调用__init__()方法\ns1.say_score()\n\ns2 = Student(\"dog\",60)\ns3 = Student(\"bird\",100)\n\nprint('一共创建{0}个Student对象'.format(Student.count))\n'''result:\n我的公司是： xd\ncat 的分数是： 97\n一共创建3个Student对象\n'''\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326233829917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5dWFuX2lu,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "类方法"}, {"ctype": "p", "data": "类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下： @classmethod def 类方法名(cls [，形参列表]) ： 函数体 要点如下："}, {"ctype": "p", "data": "@classmethod 必须位于方法上面一行第一个 cls 必须有；cls 指的就是“类对象”本身；调用类方法格式：“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传 值类方法中访问实例属性和实例方法会导致错误子类继承父类方法时，传入 cls 是子类对象，而非父类对象"}, {"ctype": "code", "data": "class Student:\n    company = \"aaaaa\"  # 类属性\n\n    def __init__(self,name,age):\n        self.name = name\n        self,age = age\n\n    @classmethod\n    def printCompany(cls):\n        print(cls.company)\n      #  print(self.name)    #类方法和静态方法中，不能调用实例变量、实例方法\n      \nStudent.printCompany()#调用类方法\n\n"}, {"ctype": "head", "data": "静态方法"}, {"ctype": "p", "data": "Python 中允许定义与“类对象”无关的方法，称为“静态方法”。 “静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空 间里面”，需要通过“类调用”。 静态方法通过装饰器@staticmethod 来定义，格式如下： @staticmethod def 静态方法名([形参列表]) ： 函数体"}, {"ctype": "p", "data": "要点如下："}, {"ctype": "p", "data": "@staticmethod 必须位于方法上面一行调用静态方法格式：“类名.静态方法名(参数列表)”。静态方法中访问实例属性和实例方法会导致错误"}, {"ctype": "code", "data": "class Student2:\n    company = \"aaaa\"  # 类属性\n\n    @staticmethod\n    def add(a, b):  # 静态方法。     \n        print(\"{0}+{1}={2}\".format(a,b,(a+b)))\n        #  print(self.name)    #类方法和静态方法中，不能调用实例变量、实例方法\n        return a+b\n\nStudent2.add(20,30) #通过类调用静态方法\n\n"}, {"ctype": "head", "data": "__del__方法(析构函数)和垃圾回收机制"}, {"ctype": "p", "data": "__del__方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如：释放对象占用的资源，例如：打开的文件资源、网络连接等。 Python 实现自动的垃圾回收，当对象没有被引用时（引用计数为 0），由垃圾回收器调用__del__方法。 我们也可以通过 del 语句删除对象，从而保证调用__del__方法。 系统会自动提供__del__方法，一般不需要自定义析构方法。"}, {"ctype": "code", "data": "class Person:\n\n    def __del__(self):\n        print(\"销毁对象{0}\".format(self))\n\np1 = Person()#创建实例对象\np2 = Person()#创建实例对象\ndel p2\nprint(\"程序结束\")\n'''result:\n销毁对象<__main__.Person object at 0x00000227E7E63F88> #del p2\n程序结束\n销毁对象<__main__.Person object at 0x00000227E7E6B388> #程序结束后p1也被销毁了。\n'''\n"}, {"ctype": "head", "data": "__call__方法和可调用对象"}, {"ctype": "p", "data": "定义了__call__方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。"}, {"ctype": "code", "data": "class SalaryAccount:\n    '''工资计算类'''\n\n    def __call__(self, salary):\n        print(\"算工资啦...\")\n        yearSalary = salary*12\n        daySalary = salary//22.5  #国家规定的每个月的平均工作天数\n        hourSalary = daySalary//8\n\n        return dict(yearSalary=yearSalary,monthSalary=salary,daySalary=daySalary,hourSalary=hourSalary)\n\n\ns = SalaryAccount() #创建实例对象s。同时s作为call方法的对象是可调用对象\nprint(s(30000)) #可以像调用函数一样调用对象的__call__方法\n'''result:\n算工资啦...\n{'yearSalary': 360000, 'monthSalary': 30000, 'daySalary': 1333.0, 'hourSalary': 166.0}\n'''\n"}], "cate": "Python"}
{"题目": "十大经典排序算法", "作者": "博可睿", "发布时间": "2021-03-27 00:24:45", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "排序算法是《数据结构与算法》中最基本的算法，排序算法的好坏直接影响程序的执行速度和存储空间的大小"}, {"ctype": "head", "data": "1. 冒泡排序"}, {"ctype": "code", "data": "#include <iostream>\nusing namespace std;\n\nvoid bubble_sort(int arr[], int len){\n    for(int i = 0; i < len - 1; i++){\n        for(int j = 0; j < len - 1 - i; j++){\n            if(arr[j] > arr[j + 1]){\n                int tmp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = tmp; \n            }\n        }\n    }\n}\n\nint main(){\n    int arr[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };\n    int len = sizeof(arr) / sizeof(arr[0]);\n    bubble_sort(arr, len);\n    for(auto item : arr){\n        cout << item << \", \" ;\n    }\n    cout << endl;\n    return 0;\n}\n"}, {"ctype": "head", "data": "2. 选择排序"}, {"ctype": "p", "data": "选择排序是一种直观的排序算法，基本原理如下："}, {"ctype": "p", "data": "以数组{38, 65, 97, 76, 13, 27, 49}为例，具体步骤如下"}, {"ctype": "code", "data": "#include <iostream>\nusing namespace std;\n\nvoid select_sort(int arr[], int len){\n    int tmp;\n    int pos;\n    for(int i = 0; i < len -1; i++){        //注意是len -1\n        tmp = arr[i];\n        pos = i;\n        for(int j = i + 1; j < len; j++){   //注意是len\n            if(arr[j] < tmp){\n                tmp = arr[j];               //记录较小位置的值\n                pos = j;                    //记录较小位置的下标  \n            }\n        }\n        if(pos != i){\n            arr[pos] = arr[i];\n            arr[i] = tmp;\n        }\n    }\n    return ;\n}\n\nint main(){\n    int arr[] = {38, 65, 97, 76, 13, 27, 49};\n    int len = sizeof(arr)/sizeof(arr[0]);\n    select_sort(arr, len);\n    for(auto item : arr){\n        cout << item << \",\";\n    }\n    cout << endl;\n    return 0;\n}\n"}, {"ctype": "head", "data": "2.持续补充…"}], "cate": "Python"}
{"题目": "爬取微信某个公众号的视频，AES-128 key iv m3u8,ts视频解密", "作者": "Caiqiudan", "发布时间": "2021-03-27 00:02:45", "内容": [{"ctype": "code", "data": "class GetBear():\n    def __init__(self, file_path=r'D:\\User\\Videos'):\n        self.url = ''  # 精品课程的url\n        # 第一次登陆的表单\n        self.forms = {\"bizData[type]\": \"1\",\"bizData[page_size]\": \"1000\",}\n        # 第一次登陆的cookie\n        self.headers = {'Cookie': 'Hm_lvt_dcd9b7913ea17882ed30a5cd786ac860=1597035830; anonymous_user_key=dV9hbm9ueW1vdXNfNjA1ZDgwMDc3YTlhMl82YUc3SGM4V2w0; dataUpJssdkCookie={\"wxver\":\"\",\"net\":\"\",\"sid\":\"\"}; sa_jssdk_2015_www_xiong99_com_cn=%7B%22distinct_id%22%3A%221786d3c32ab1e9-0176ee77e2d20e-4c3f227c-1327104-1786d3c32ac25f%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E5%BC%95%E8%8D%90%E6%B5%81%E9%87%8F%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC%22%2C%22%24latest_referrer%22%3A%22http%3A%2F%2Flocalhost%3A8888%2Fnotebooks%2F%25E7%258B%2597%25E7%2586%258A%25E4%25BC%259Avip%25E8%25B5%2584%25E6%25BA%2590%2Fcode.ipynb%22%7D%7D; sensorsdata2015jssdkcross=%7B%22%24device_id%22%3A%221786d3c32ab1e9-0176ee77e2d20e-4c3f227c-1327104-1786d3c32ac25f%22%7D; sajssdk_2015_new_user_www_xiong99_com_cn=1; app_id=\"appKfzfb4lZ6715\"; pc_user_key=7e0c7d89747ffe8d7c3917868590295d; xenbyfpfUnhLsdkZbX=0; userInfo={\"app_id\":\"appKfzfb4lZ6715\",\"user_id\":\"u_5ee5bd7fba1d5_89YkgnRw0k\",\"wx_avatar\":\"http://wechatavator-1252524126.file.myqcloud.com/appKfzfb4lZ6715/image/compress/u_5ee5bd7fba1d5_89YkgnRw0k.png\",\"wx_gender\":2,\"birth\":\"\",\"address\":\"\",\"job\":\"\",\"company\":\"\",\"wx_account\":\"\",\"universal_union_id\":\"oTHW5v56ip5Z6PvntQYL85LSJTLw\",\"can_modify_phone\":true,\"phone\":\"18350225412\",\"pc_user_key\":\"7e0c7d89747ffe8d7c3917868590295d\",\"permission_visit\":0,\"permission_comment\":0,\"permission_buy\":0,\"pwd_isset\":false,\"channels\":[{\"type\":\"wechat\",\"active\":1,\"nickname\":\"WE\"},{\"type\":\"qq\",\"active\":0}],\"area_code\":\"86\"}; superVipData={\"hasSuperVip\":true,\"is_svip\":1,\"url\":\"https://appKfzfb4lZ6715.h5.xiaoeknow.com/content_page/eyJhcHBfaWQiOiJhcHBLZnpmYjRsWjY3MTUiLCJzaGFyZV9mcm9tIjoidV81ZWU1YmQ3ZmJhMWQ1Xzg5WWtnblJ3MGsiLCJwcm9kdWN0X2lkIjoic181ZWRiNTNmYTU4MmRlX1lVTEdzb1BhIiwicmVzb3VyY2VfaWQiOiIiLCJ0eXBlIjoxNSwicmVzb3VyY2VfdHlwZSI6MjMsInNoYXJlX2FnZW50IjoiIiwiZmVhdHVyZSI6IiIsImNvbnRlbnRfYXBwX2lkIjoiIiwic291cmNlIjoiIn0=\",\"short_url\":\"https://gol.h5.xeknow.com/s/LUBrv\"}',}\n        \n        self.father_url = 'https://www.xiong99.com.cn/api/xe.goods.relation.get/1.0.0?app_id=appKfzfb4lZ6715'  # 专栏的url\n        # 第二次登陆的cookie\n        self.father_headers = {'Cookie': 'Hm_lvt_dcd9b7913ea17882ed30a5cd786ac860=1597035830; anonymous_user_key=dV9hbm9ueW1vdXNfNjA1ZDgwMDc3YTlhMl82YUc3SGM4V2w0; dataUpJssdkCookie={\"wxver\":\"\",\"net\":\"\",\"sid\":\"\"}; sa_jssdk_2015_www_xiong99_com_cn=%7B%22distinct_id%22%3A%221786d3c32ab1e9-0176ee77e2d20e-4c3f227c-1327104-1786d3c32ac25f%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22%22%7D%7D; sensorsdata2015jssdkcross=%7B%22%24device_id%22%3A%221786d3c32ab1e9-0176ee77e2d20e-4c3f227c-1327104-1786d3c32ac25f%22%7D; sajssdk_2015_new_user_www_xiong99_com_cn=1; app_id=\"appKfzfb4lZ6715\"; pc_user_key=7e0c7d89747ffe8d7c3917868590295d; xenbyfpfUnhLsdkZbX=0; userInfo={\"app_id\":\"appKfzfb4lZ6715\",\"user_id\":\"u_5ee5bd7fba1d5_89YkgnRw0k\",\"wx_avatar\":\"http://wechatavator-1252524126.file.myqcloud.com/appKfzfb4lZ6715/image/compress/u_5ee5bd7fba1d5_89YkgnRw0k.png\",\"wx_gender\":2,\"birth\":\"\",\"address\":\"\",\"job\":\"\",\"company\":\"\",\"wx_account\":\"\",\"universal_union_id\":\"oTHW5v56ip5Z6PvntQYL85LSJTLw\",\"can_modify_phone\":true,\"phone\":\"18350225412\",\"pc_user_key\":\"7e0c7d89747ffe8d7c3917868590295d\",\"permission_visit\":0,\"permission_comment\":0,\"permission_buy\":0,\"pwd_isset\":false,\"channels\":[{\"type\":\"wechat\",\"active\":1,\"nickname\":\"WE\"},{\"type\":\"qq\",\"active\":0}],\"area_code\":\"86\"}; superVipData={\"hasSuperVip\":true,\"is_svip\":1,\"url\":\"https://appKfzfb4lZ6715.h5.xiaoeknow.com/content_page/eyJhcHBfaWQiOiJhcHBLZnpmYjRsWjY3MTUiLCJzaGFyZV9mcm9tIjoidV81ZWU1YmQ3ZmJhMWQ1Xzg5WWtnblJ3MGsiLCJwcm9kdWN0X2lkIjoic181ZWRiNTNmYTU4MmRlX1lVTEdzb1BhIiwicmVzb3VyY2VfaWQiOiIiLCJ0eXBlIjoxNSwicmVzb3VyY2VfdHlwZSI6MjMsInNoYXJlX2FnZW50IjoiIiwiZmVhdHVyZSI6IiIsImNvbnRlbnRfYXBwX2lkIjoiIiwic291cmNlIjoiIn0=\",\"short_url\":\"https://gol.h5.xeknow.com/s/LUBrv\"}'}\n        \n        self.path = file_path\n        \n    # 获取每个专栏子视频的m3u8网址->调用get_kid_video函数获取视频\n    def get_m3u8(self,father_id, father_type):\n        json = {\"goods_id\":father_id, \"goods_type\":father_type}\n        r = requests.post(self.father_url, json=json, headers=self.headers)\n        \n        father_mes = r.json()['data']['goods_list']\n        for j in range(len(father_mes)):\n            kid_title, kid_m3u8_url = father_mes[j]['title'], father_mes[j]['video_m3u8_url']\n            # 保存m3u8文件\n            print(f'正在获取视频----{kid_title}')\n            GetBear.get_kid_video(self, kid_title, kid_m3u8_url)    # 爬取视频\n    \n    # 获取m3u8的视频->获取key->获取视频并保存->视频解密重新保存\n    def get_kid_video(self, kid_title, kid_m3u8_url):\n        '''\n        kid_title：子视频的名称\n        kid_m3u8_url: 子视频的\n        '''\n        m3u8 = requests.get(kid_m3u8_url).text             # 获取m3u8文件\n        key_url = re.search('\"(.*?)\"',m3u8).group()[1:-1]  # 从m3u8获取key的网址，有两对引号要去掉一对\n        key = requests.get(key_url).content                # 获取key\n        video_url = kid_m3u8_url[:-4] + 'ts?start=0'       # start=0：从0开始爬到完毕\n        # 读取视频并保存\n        ts_path = self.father_path + '\\\\' + kid_title + '.ts'\n        if os.path.exists(ts_path) == True:\n            print(f'已存在视频{ts_path}')\n        else:\n            start = time.time()\n            size = 0\n            video_r = requests.get(video_url, stream=True)     \n            chunk_size = 1024\n            content_size = int(video_r.headers['content-length'])\n            print(f\"下载---{kid_title}.ts，文件大小:{format(content_size/chunk_size/1024,'.2f')}MB\")\n            with open(ts_path, 'wb') as f:\n                  for data in video_r.iter_content(chunk_size=chunk_size):   # 每次只读取一个chunk_size大小\n                      f.write(data)\n                      size = len(data) + size\n                      print('\\r'+'进度：'+int(size/content_size*30)*\"🚀\"+   # 🏃‍💐🌸💮🌹🌺🌻🌼🌷🌱🌿🍀\n                        f\"【{format(size/chunk_size/chunk_size/1024,'.2%')}MB】 【{format(size/content_size,'.2%')}】\",end='')\n            # 视频解密\n            GetBear.decryptSingleAES(ts_path, ts_path, key)\n            end = time.time()\n            print(\"   总耗时:%.2f秒\"%(end - start))\n    # 获取专栏的url->创建专栏的文件夹->get_m3u8\n    def get_videos(self):\n        r = requests.post(self.url, data=self.forms, headers=self.father_headers)\n        mes = r.json()['data']['list']\n        for i in range(len(mes)):\n            if mes[i]['price'] > 0 and mes[i]['resource_type'] != 1:      # 类型1为图文,其他类型为视频，只要爬取视频\n                father_id,father_type,father_title = mes[i]['id'], mes[i]['resource_type'], mes[i]['title']\n                self.father_path = os.path.join(self.path, father_title)\n                print(f'------------------专栏：《{self.father_path}》------------------')\n                # 判断是否存在该文件夹，不存在则创建\n                if os.path.exists(self.father_path) == False:\n                    os.mkdir(self.father_path)\n                    print(f'创建文件夹:{self.father_path}')\n                GetBear.get_m3u8(self, father_id, father_type)\n    \n    # 视频解密\n    def decryptSingleAES( src,dec,key): \n    # src：要解密的文件； dec：解密后的文件；  key、iv 从m3u8可见\n        try:\n            f1 = open(src, 'rb')\n            part = f1.read()  \n            cipher = AES.new(key, AES.MODE_CBC,IV=b'0000000000000000')\n            plain_data = cipher.decrypt(part)\n            if part:\n                f2 = open(dec, 'wb')\n                f2.write(plain_data)  \n        finally:\n            if f1:\n                f1.close()\n            if f2:\n                f2.close()\n\nif __name__ == '__main__':\n    getBear = GetBear()\n    getBear.get_videos()\n    # 如果报错，也许需要改一下cookies\n"}, {"ctype": "p", "data": " 关于ts解密详见：python 解密 M3U8 AES 加密的视频 ValueError: IV must be 16 bytes long问题的解决"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326235935127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhaXFpdWRhbg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "中缀表达式转后缀表达式的计算器代码实现", "作者": "写个啥都想找现成的", "发布时间": "2021-03-27 01:15:22", "内容": [{"ctype": "p", "data": "对于较为复杂的四则运算表达式，例如：9-(5-2.4)*2+6，计算这样的表达式必须考虑计算的优先级，计算机通常很难直接计算这样的表达式，而为了实现计算这种表达式的功能，可以先将其转化为后缀表达式，即所有的运算符都是在运算数的后面，即先把该表达式转换为“9 5 2.4 - 2 * - 6 +”再进行计算，我们先从简单的开始理解。"}, {"ctype": "head", "data": "后缀表达式的计算"}, {"ctype": "p", "data": "对于后缀表达式，用计算机计算起来就容易多了，从左向右遍历，遇到数字就进栈，遇到符号就将栈顶的两个元素出栈，并进行运算，运算得到的结果再进栈，对于“9 5 2.4 - 2 * - 6 +”具体运算过程如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010256551.PNG#pic_center"}, {"ctype": "head", "data": "实现代码："}, {"ctype": "code", "data": "def Calculate(suffix_count):\n    count_list = []\n    for co in suffix_count:\n        if symbol_list.count(co) == 0:  # 判断是否为数字\n            count_list.append(float(co))\n        else:\n            a = count_list.pop()\n            b = count_list.pop()\n            if co == '*':\n                count_list.append(b * a)\n            elif co == '/':\n                count_list.append(b / a)\n            elif co == '+':\n                count_list.append(b + a)\n            elif co == '-':\n                count_list.append(b - a)\n    return count_list[0]\n"}, {"ctype": "head", "data": "中缀表达式转后缀表达式"}, {"ctype": "p", "data": "计算后缀表达式的规则很容易，相信大家都能看懂，而该程序的核心难点是中缀表达式转后缀表达式。我们平时常用的四则运算式的表示法即为中缀表达式，中缀表达式转后缀表达式规则：从左到右遍历中缀表达式，若是数字则输出到后缀表达式中，若是运算符，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出到后缀表达式中，并将当前符号进栈，若为左括号或优先级高于栈顶元素则直接进栈，一直到最终输出后缀表达式为止。"}, {"ctype": "head", "data": "实现代码"}, {"ctype": "code", "data": "symbol_list = ['(', ')', '+', '-', '*', '/']\ndef MiddleToBack(middle_equation):#中缀转后缀\n    symbol_flag=0#运算符优先级标志位\n    count_flag=0#数字标志位\n    suffix_count=[]\n    suffix_symbol=[]\n    otherai=''\n    for ch in middle_equation:\n        if '0'<=ch<='9' or ch=='.':\n            if count_flag==0:#判断若上一位不是数字\n                suffix_count.append(ch)#在列表加上新的数字\n            else:\n                suffix_count[-1]=suffix_count[-1]+ch#在列表末尾的元素加上一位\n            count_flag=1\n        elif symbol_list.count(ch):\n            count_flag=0\n            if ch=='(':\n                symbol_flag=0\n                suffix_symbol.append(ch)\n            elif ch==')':\n                out=''#初始化out\n                while out!='(':\n                    out=suffix_symbol.pop()\n                    if out!='(':\n                        suffix_count.append(out)\n                symbol_flag = 0\n            elif ch == '*':\n                MultiplyAndDivide(symbol_flag,suffix_symbol,suffix_count,ch)\n                symbol_flag=1\n            elif ch == '/':\n                MultiplyAndDivide(symbol_flag,suffix_symbol,suffix_count,ch)\n                symbol_flag=1\n            elif ch=='+':\n                AddAndSubtract(suffix_symbol,suffix_count,ch)\n                symbol_flag=0\n            elif ch=='-':\n                AddAndSubtract(suffix_symbol,suffix_count,ch)\n                symbol_flag=0\n        else:\n            print('error')\n            break\n    while len(suffix_symbol):#把符号栈中剩下的依次给予算式栈\n        suffix_count.append(suffix_symbol.pop())\n    return suffix_count\ndef MultiplyAndDivide(symbol_flag,suffix_symbol,suffix_count,ch):#* /\n    if symbol_flag:\n        suffix_count.append(suffix_symbol.pop())\n    suffix_symbol.append(ch)\ndef AddAndSubtract(suffix_symbol,suffix_count,ch):#+ -\n    if suffix_symbol.count('('):\n        otherai = suffix_symbol[-1]\n        while otherai != '(':\n            suffix_count.append(otherai)\n            suffix_symbol.pop()\n            otherai = suffix_symbol[-1]\n    else:\n        if len(suffix_symbol):\n            symbol_last = suffix_symbol[-1]\n            while symbol_last == '*' or symbol_last == '/':\n                suffix_count.append(suffix_symbol.pop())\n                if len(suffix_symbol):\n                    symbol_last = suffix_symbol[-1]\n                else:\n                    symbol_last = ''\n            while len(suffix_symbol):\n                suffix_count.append(suffix_symbol.pop())\n    suffix_symbol.append(ch)\n"}, {"ctype": "p", "data": "算法思路参考《大话数据结构》，感觉代码写的挺乱的，也有点繁琐，但居然也通过了牛客网的测试，感兴趣的小伙伴也去练习一下试试吧。https://www.nowcoder.com/profile/706249245/myFollowings/detail/16458229"}], "cate": "Python"}
{"题目": "爬取美国各州实时疫情数据", "作者": "DM_freshman", "发布时间": "2021-03-27 09:48:04", "内容": [{"ctype": "head", "data": "爬取美国各州实时疫情数据"}, {"ctype": "p", "data": "首先选择爬虫网站数据来源，这里选取的是腾讯疫情数据实时更新网站https://news.qq.com/zt2020/page/feiyan.htm选取相关数据接口：https://view.inews.qq.com/g2/getOnsInfo?name=disease_foreign"}, {"ctype": "code", "data": "#获取数据\nimport requests\nimport json\nimport pandas as pd\n#爬取数据的网址（腾讯新闻网实时更新）\nAmerica_url = 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_foreign'\nheaders = {\n'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36'\n,'referer': 'https://news.qq.com/'\n}\n#获取到json格式数据\nresponse = requests.get(url=America_url,headers = headers).json()\n\n"}, {"ctype": "p", "data": "保存数据"}, {"ctype": "code", "data": "#将json格式转换成字典\ndata = json.loads(response['data'])\n\n#保存数据\nwith open('./美国疫情.json','w') as f:\n    #再将字典改成json格式\n    f.write(json.dumps(data,indent=2,ensure_ascii=False))   #indent为格式空两格的操作\n\n#将数据保存到Excel\nwith open('./美国疫情.json','r') as f:\n    data = f.read()\n\n"}, {"ctype": "p", "data": "整理保存的数据，选取其中需要的数据，重新写入Excel"}, {"ctype": "code", "data": "#将json格式保存为字典\ndata = json.loads(data)\n\n#获取美国的疫情数据\nAmericaDict = data['foreignList'][0]\n\n#获取美国各州的疫情数据\nProvinceList = AmericaDict['children']\n\n#保存美国总的疫情数据\nAmericaCityList = []\nAmericaTotal = {'更新截止时间':AmericaDict['date'],'province':'北美洲','州':'美国','累计确诊':AmericaDict['confirm'],'治愈':AmericaDict['heal'],'死亡':AmericaDict['dead']}\nAmericaCityList.append(AmericaTotal)\n\n#遍历美国各州\nfor i in range(len(ProvinceList)):\n    date = ProvinceList[i]['date']\n    province_English = ProvinceList[i]['nameMap']\n    province = ProvinceList[i]['name']\n    dead = ProvinceList[i]['dead']\n    heal = ProvinceList[i]['heal']\n    confirm = ProvinceList[i]['confirm']\n    city_list = {'更新截止时间':date,'province':province_English,'州':province,'累计确诊':confirm,'治愈':heal,'死亡':dead}\n    AmericaCityList.append(city_list)\n\n#将json格式转换成DataFrame\nAmericaTotalData = pd.DataFrame(AmericaCityList)\n\n#保存至Excel文档\nAmericaTotalData.to_excel('AmericaData.xlsx',index=False,sheet_name=AmericaDict['date'])\n"}, {"ctype": "p", "data": "查看数据"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032709470278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Nzg1ODA5Mw==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python中怎么样统计一张图像中白色和黑色像素点个数（二值图） |小知识", "作者": "LLLLQZ", "发布时间": "2021-03-27 09:49:26", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "head", "data": "代码实现"}, {"ctype": "code", "data": "import numpy as np\nimport cv2\n\n二值化图像直接\nprint(len(im[im==255]))\nprint(len(im[im==0]))\n\n彩色图像\n\n#读入图像\nimg = cv2.imread('0.jpg')\n#获取尺寸\nh,w,_=img.shape\n#建立一个与图像尺寸相同的全零数组\nnpim = np.zeros((h,w,3), dtype=np.int)\n#将图像3个通道相加赋值给空数组\nnpim[:]=img[:,:,0]+img[:,:,1]+img[:,:,2]\n#统计白色像素个数\nprint(“白色像素%s个”%len（npim[npim==255*3]))\n#统计黑色像素个数\n\nprint(“黑色像素%s个”%len（npim[npim==0]))\n"}], "cate": "Python"}
{"题目": "wo们出python基础啦系列（二）---条件判断", "作者": "佩瑞", "发布时间": "2021-03-27 13:11:43", "内容": [{"ctype": "p", "data": "wo们出python基础啦系列（一）—数据类型 wo们出python基础啦系列（二）—条件判断 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327115303105.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI2MzcxOA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "一一得一，一二得二…乘法表口诀就像是“富强，民主，文明，和谐”一样深深烙印在每一个童年的你我心里，它又像是“天王盖地虎”–“小鸡炖蘑菇”是我们共同的暗号，当发出口令九八七十二，你答道九九归一，一不小心没接上，只自悔小时候乘法表没好好背，这篇推送我们来讲述计算机如何实现判断。"}, {"ctype": "head", "data": "一、if语句"}, {"ctype": "p", "data": "在Python程序中，用if语句实现条件判断，它相当于表达日常中‘如果’的意思，它有三种表现形式。咱们从最简单的单向判断开始。如果满足什么条件，计算机就将执行什么任务，就像是在对暗号，只有说出“芝麻开门”，暗门才能开启。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032711541227.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI2MzcxOA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "二、if双向判断"}, {"ctype": "p", "data": "在对暗号的时候，对上了的给开门，那是我们想要的人，但对于那些来捣蛋的咱们也得治治，所谓非诚勿扰，如果暗号错误，咱们就把他们加入黑名单，这时就需要咱们的双向循环来发挥作用了.（注意要缩进呀） "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327130830277.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI2MzcxOA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "二、if多向判断"}, {"ctype": "p", "data": "“在一瞬间有一百万种选择”（暴露年龄了），当然实际往往更加复杂，我们的选择往往更多，对应的结果也有所不同，我们需要更多的分支来表示，请看下图  你们的关注给了我们继续的动力！ "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032713092192.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI2MzcxOA==,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "2021-03-27", "作者": "NoEmotion247", "发布时间": "2021-03-27 14:04:45", "内容": [{"ctype": "head", "data": "切片操作"}, {"ctype": "p", "data": "切片返回的是列表元素的浅复制。所谓浅复制，是指生成一个新的列表，并且把原列表中所有元素的引用都复制到新列表中。如果原列表中只包含整数、实数、复数等基本类型或元组、字符串这样的不可变类型的数据，一般是没有问题的。 如果原列表中包含列表之类的可变数据类型，由于浅复制时只是把子列表的引用复制到新列表中，这样的话修改任何一个都会影响另外一个。"}, {"ctype": "code", "data": "alist[start:stop:step]  #start表示开始元素位置(默认0) stop表示终止元素位置(默认列表长度) step表示布长(默认1)\n\n"}, {"ctype": "head", "data": "列表排序与逆序"}, {"ctype": "code", "data": "import random\nrandom.shuffle(alist) #随机打乱顺序\nalist.sort() #默认升序\nalist.sort(reverse=True)  #降序排列\n"}, {"ctype": "head", "data": "用于序列操作的常用内置函数"}, {"ctype": "p", "data": "len(列表)：返回列表中的元素个数，同样适用于元组、字典、集合、字符串等。 max(列表)、 min(列表)：返回列表中的最大或最小元素，同样适用于元组、字典、集合、range对象等。 sum(列表)：对列表的元素进行求和运算，对非数值型列表运算需要指定start参数，同样适用于元组、range。"}, {"ctype": "code", "data": " sum(range(1, 11))      #sum()函数的start参数默认为0\n55\n sum(range(1, 11), 5)   #指定start参数为5，等价于5+sum(range(1,11))\n60\n sum([[1, 2], [3], [4]], [])    #这个操作占用空间较大，慎用\n[1, 2, 3, 4]\n"}, {"ctype": "p", "data": "zip()函数用来把多个可迭代对象中的元素压缩到一起，返回一个可迭代的zip对象，其中每个元素都是包含原来的多个可迭代对象对应位置上元素的元组，如同拉拉链一样。"}, {"ctype": "code", "data": "list(zip('abcd', [1, 2, 3]))             #压缩字符串和列表\n[('a', 1), ('b', 2), ('c', 3)]\n list(zip('123', 'abc', ',.!'))           #压缩3个序列\n[('1', 'a', ','), ('2', 'b', '.'), ('3', 'c', '!')]\nx = zip('abcd', '1234')\nlist(x)\n[('a', '1'), ('b', '2'), ('c', '3'), ('d', '4')]\n"}, {"ctype": "p", "data": "enumerate(列表):枚举列表元素，返回枚举对象，其中每个元素为包含下标和值的元组。该函数对元组、字符串同样有效。"}, {"ctype": "code", "data": " for item in enumerate('abcdef'):\n    print(item)\n\n(0, 'a')\n(1, 'b')\n(2, 'c')\n(3, 'd')\n(4, 'e')\n(5, 'f')\n"}, {"ctype": "p", "data": "内置函数map() 把一个函数func依次映射到序列或迭代器对象的每个元素上，并返回一个可迭代的map对象作为结果，map对象中每个元素是原序列中元素经过函数func处理后的结果。"}, {"ctype": "code", "data": "list(map(str, range(5)))  #把列表中元素转换为字符串\n['0', '1', '2', '3', '4']\ndef add5(v):              #单参数函数\n    return v+5\n list(map(add5, range(10)))#把单参数函数映射到一个序列的所有元素\n[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\ndef add(x, y):            #可以接收2个参数的函数\n    return x+y\nlist(map(add, range(5), range(5,10)))\n                              #把双参数函数映射到两个序列上\n[5, 7, 9, 11, 13]\n"}, {"ctype": "p", "data": "内置函数filter() 将一个单参数函数作用到一个序列上，返回该序列中使得该函数返回值为True的那些元素组成的filter对象，如果指定函数为None，则返回序列中等价于True的元素。"}, {"ctype": "code", "data": "seq = ['foo', 'x41', '?!', '***']\ndef func(x):\n    return x.isalnum()                  #测试是否为字母或数字\n\nfilter(func, seq)                   #返回filter对象\n<filter object at 0x000000000305D898>\nlist(filter(func, seq))             #把filter对象转换为列表\n['foo', 'x41']\nlist(filter(str.isalnum, seq))      #等价的用法\n['foo', 'x41']\n"}], "cate": "Python"}
{"题目": "ESP8266开发笔记-window环境搭建python指令找不到", "作者": "Lovely Violin", "发布时间": "2021-03-27 14:25:08", "内容": [{"ctype": "head", "data": "背景"}, {"ctype": "p", "data": "搭建ESP8266_RTOS_SDK-v3.3-rc1的Windows开发环境时出现问题，在执行带python指令的时候 python -m pip install --user -r $IDF_PATH/requirements.txt 提示下面错误： python --version -bash: python: command not found"}, {"ctype": "head", "data": "解决方法"}, {"ctype": "p", "data": "1.下载安装Python 到官网下载https://www.python.org/ 安装，记住安装目录C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39 2. 修改工具 将Python39整个文件夹拷贝到I:\\ESP8266\\RTOS\\msys32\\usr\\bin 添加环境变量 \\msys32\\etc\\profile.d\\esp32_toolchain.sh export PATH=\"$PATH:/usr/bin/Python39\"  3. 结果 成功 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327141848408.png"}], "cate": "Python"}
{"题目": "关于torch.nn.Embedding需要注意的几点", "作者": "mz_老张", "发布时间": "2021-03-27 14:31:19", "内容": [{"ctype": "head", "data": "关于torch.nn.Embedding需要注意的几点"}, {"ctype": "code", "data": "torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None)\n"}, {"ctype": "head", "data": "主要参数说明："}, {"ctype": "p", "data": "num_embeddings：词字典的数量(最大索引值) embedding_dim：词向量的维度 padding_idx：强制指定某索引值的词向量值"}, {"ctype": "head", "data": "关于Embedding的简单理解："}, {"ctype": "p", "data": "说白了，Embedding的作用就是将你所有的词放入到一个字典里(词去重)，该字典的键是词的索引，值是该词，然后Embedding会将这些字典中的\"索引\"转成指定维度的向量,比如："}, {"ctype": "code", "data": "word_dict = {0:'我',1:'喜欢',2:'吃',4:'西瓜'}\neb = torch.nn.Emebdding(4,6) #最大词索引为5，词向量长度为6\neb0 =eb(0)  #将0转成词向量\neb1 =eb(1)  #将1转成词向量\n...\n"}, {"ctype": "head", "data": "注意一：Embedding输入的参数是索引值"}, {"ctype": "p", "data": "上述eb0,eb1中输入的值为你字典的key,也就是自定义字典中的词索引。"}, {"ctype": "head", "data": "注意二：num_embedding是最大词索引值，并不是所有词索引的总和。"}, {"ctype": "code", "data": "import torch\n\neb = torch.nn.Embedding(4,6)\nt = torch.tensor(5)\nr = eb(t)\nprint(r)\n"}, {"ctype": "p", "data": "上述eb就会报错IndexError: index out of range in self 传入的数字必须是小于等于5，"}, {"ctype": "head", "data": "注意三：padding_idx指定索引值转成词向量后，该词向量的元素全为0"}, {"ctype": "p", "data": "padding_idx的作用是将你字典中指定的词索引在进行Emedding时，全部转成的词向量的各元素值全为0 比如：如果指定索引为2的词向量结果"}, {"ctype": "code", "data": "eb = torch.nn.Embedding(4,6,padding_idx=2)\nt = torch.tensor(2)\nr = eb(t)\nprint(r)\n#结果为：\ntensor([0., 0., 0., 0., 0., 0.], grad_fn=<EmbeddingBackward>)\n"}], "cate": "Python"}
{"题目": "IP网段去重复去包含", "作者": "弘毅密令", "发布时间": "2021-03-27 14:33:55", "内容": [{"ctype": "p", "data": "需求：内部资产盘点（漏洞）扫描 问题：公司大了，内网网段“剪不断理还乱”…，拿到上千个网段信息，在扫描前需要去重复和去包含关系，防止重复扫描和提升扫描效率 解决：python脚本，有个处理网段的库灰常好用IPy库实现。（自己尝试通过网络掩码位数写了写逻辑去重，也是不那么得手。（安装 pip install IPy）"}, {"ctype": "p", "data": "处理脚本："}, {"ctype": "code", "data": "#去ip段的重叠、包含等\nfrom IPy import IP\nfile = 'hostnetmask.txt.py'     #需要去重复的ip网段文件（按行）\ndef ipuniq():\n    dlist = []\n    with open(file,'r') as ff:\n        for x in ff.readlines():\n            x = x.strip()\n            with open(file, 'r') as f:\n                for i in f.readlines():\n                    i = i.strip()\n                    if i != x:\n                        if IP(i) in IP(x):        # 判断网段是否包含\n                            print('{} >>>>> {}'.format(i,x))\n                            dlist.append(i)\n        dlist.sort()\n        data = []\n        print('>>>>>>>>>>>>>>>>>>去重复后的网段<<<<<<<<<<<<<<<<<<<<<<<<')\n        with open(file,'r') as df:\n            for n in df.readlines():\n                n = n.strip()\n                if n not in dlist:\n                    print(n)\n                    data.append(n)\n        print(dlist)     #打印去重叠后的网段\n"}], "cate": "Python"}
{"题目": "Python基础入门：从变量到异常处理（第1天）", "作者": "tianchi_suda", "发布时间": "2021-03-27 18:24:41", "内容": [{"ctype": "head", "data": "学习内容概括："}, {"ctype": "head", "data": "1、变量、运算符与数据类型"}, {"ctype": "head", "data": "2、位运算"}, {"ctype": "head", "data": "具体学习内容："}, {"ctype": "head", "data": "一、 变量、运算符与数据类型"}, {"ctype": "head", "data": "注释"}, {"ctype": "code", "data": "\"\"\"\n这是多行注释，用三个双引号\n这是多行注释，用三个双引号\n这是多行注释，用三个双引号\n\"\"\"\nprint('hello china')\n# hello china\n\n'''\n这是多行注释，用三个单引号\n这是多行注释，用三个单引号\n这是多行注释，用三个单引号\n'''\nprint('hello china')\n# hello china\n"}, {"ctype": "head", "data": "运算符"}, {"ctype": "head", "data": "1、算术运算符"}, {"ctype": "code", "data": "print(2 + 3)\nprint(2 - 3)\nprint(2 * 3)\nprint(2 / 3)\nprint(2 // 3)\nprint(3 % 2)\n\n"}, {"ctype": "head", "data": "2、比较运算符"}, {"ctype": "code", "data": "print(3 > 2)\nprint(3 < 4)\nprint(3 == 3)\nprint(3 != 4)\nprint(3 <= 4)\nprint(3 >= 2)\n"}, {"ctype": "head", "data": "3、逻辑运算符"}, {"ctype": "code", "data": "print((3>2) and (4>3))\nprint((4>5) or (6 < 7))\nprint(not (4>5))\n"}, {"ctype": "head", "data": "4、位运算符"}, {"ctype": "code", "data": "print(bin(~2))\nprint(bin(4&5))\nprint(bin(4 | 5))\nprint(bin(4 ^ 5))\nprint(bin(4 >> 1))\nprint(bin(4 << 1))\n"}, {"ctype": "head", "data": "5、三元运算符"}, {"ctype": "code", "data": "x,y = input(),input()\nmax = x if x > y else y\nprint(max)\n"}, {"ctype": "head", "data": "6、其它运算符"}, {"ctype": "code", "data": "letters = ['a','b','c']\nif 'a' in letters:\n    print('a' + 'exists')\nif 'A' not in letters:\n    print('A' + ' not exists')\n"}, {"ctype": "code", "data": "a = ['hello']\nb = ['hello']\nprint(a is b,a == b)\nc = 'hello'\nd = 'hello'\nprint(c is d, c == d)\n"}, {"ctype": "p", "data": "注意："}, {"ctype": "p", "data": "即二者比较与内存地址有关"}, {"ctype": "head", "data": "7、运算符的优先级"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327170524894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDEyNjMz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "变量和赋值"}, {"ctype": "head", "data": "数据类型与转换"}, {"ctype": "p", "data": " 可以使用decimal包中的Decimal控制精确度"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327171052818.png"}, {"ctype": "code", "data": "decimal.getcontext().prec = 5\nc = Decimal(1) / Decimal(3)\nprint(c)\n"}, {"ctype": "p", "data": "获取类型信息，比较类型是否相同，有两种方法"}, {"ctype": "head", "data": "print函数"}, {"ctype": "p", "data": "主要学习sep参数和end参数"}, {"ctype": "code", "data": "shoplist = ['apple','mango','carrot','banana']\nprint(\"This is printed with 'end='&''.\")\nfor item in shoplist:\n    print(item,end = \"&\")\n"}, {"ctype": "code", "data": "shoplist = ['apple','mango','carrot','banana']\nprint(\"This is printed with 'sep='&''.\")\nfor item in shoplist:\n    print(item,\"another string\",sep = '&')\n"}, {"ctype": "head", "data": "二、位运算"}, {"ctype": "p", "data": "前面的学习对于我来说，尚算简单，之前学python基础时，有学过，当然本身也不难。"}, {"ctype": "p", "data": "但位运算，就我而言是比较难的，主要是教程比较简单，看得一头雾水，没有方向，抓不住重点，然后百度了一些见解后，才算入门这块知识。"}, {"ctype": "p", "data": "在学习位运算之前，如果了解以下几点，应该就比较容易入门了。"}, {"ctype": "p", "data": "按位运算，顾名思义，是按位置计算计算机进制的了解以及相互转换（主要是二进制）进制有三种不同的表达形式：原码、反码、补码 位运算都是基于补码操作的Python中bin一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号"}, {"ctype": "code", "data": "print(bin(3))  # 0b11\nprint(bin(-3))  # -0b11\n"}, {"ctype": "p", "data": "所以，在进行位运算时，先得到的是反码。"}, {"ctype": "head", "data": "1、按位非操作"}, {"ctype": "p", "data": "~ 把num的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 ~ 运算中同样会取反。"}, {"ctype": "code", "data": "print(~3)  # -4\n"}, {"ctype": "p", "data": "3的二进制是00000011（以8位为例，不足用0补齐），因为计算机操作的是反码，所以先要转换，不过正数的反码、补码都是原码，所以我们直接取反即可，得到11111100，此时注意，得到的仍然是补码，而且符号位是1，是负数了，先转换为反码，即补码-1，得到11111011，再转为原码，即取反，符号位不变，得到10000100，即-4."}, {"ctype": "head", "data": "2、按位与操作"}, {"ctype": "p", "data": "即相同位置都是1为1，否则为0"}, {"ctype": "code", "data": "3 & 4  # 0\n"}, {"ctype": "p", "data": "3的补码是00000011，4的补码是00000100，按位置看，无同为1的，所以是00000000"}, {"ctype": "head", "data": "3、按位或操作"}, {"ctype": "p", "data": "相同位置有1个1就为1，否则为0"}, {"ctype": "code", "data": "3 | 4  # 7\n"}, {"ctype": "p", "data": "3的补码是00000011，4的补码是00000100，即00000111，转为10进制则为7."}, {"ctype": "head", "data": "4、按位异或操作"}, {"ctype": "p", "data": "相同位置不同则为1，否则为0 异或满足交换律和结合律 m ^ 0 = m m ^ m = 0"}, {"ctype": "code", "data": "3 ^ 4  # 7\n"}, {"ctype": "p", "data": "3的补码是00000011，4的补码是00000100，即00000111，转为10进制则为7"}, {"ctype": "head", "data": "5、按位左移"}, {"ctype": "p", "data": "num << i，num按位左移i位，右边补0"}, {"ctype": "code", "data": "7 << 2  # 28\n"}, {"ctype": "p", "data": "7的补码是00000111，左移两位，即00011100，转为十进制，即2**4+2**3+2**2=28 6、按位右移 num >> i，num按位右移i位，左边补0"}, {"ctype": "code", "data": "7 >> 2  # 1\n"}, {"ctype": "p", "data": "7的补码是00000111，右移两位，即00000001"}, {"ctype": "head", "data": "6、利用位运算实现整数集合"}, {"ctype": "p", "data": "学会此部分重点是需要理解交集、并集、合集、差集的概念。  实际上插入，可以看成是求并集，删除是求差集。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327175939927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDEyNjMz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "学习过程遇到的问题和解决方法"}, {"ctype": "p", "data": "主要就是位运算不太理解。"}, {"ctype": "head", "data": "位运算"}, {"ctype": "p", "data": "总而言之，遇到问题百度以下，你就知道，多看几个人写的内容，总会遇到解释符合自己理解能力的。"}, {"ctype": "head", "data": "总结"}, {"ctype": "p", "data": "1、三元运算符，可以简化代码 2、is，is not是判断内存地址；== ，!=是判断数值 3、运算符级别较多，习惯用小括号 4、变量名对大小写敏感，命名只支持字母、数字、下划线且不能以数字开头 5、decimal包中的Decimal对象和getcontext()方法可以控制精确度 6、bool - 对于数值变量， 0 , 0.0 都可认为是空的。 - 对于容器变量，里面没元素就是空的。 7、判断数据类型是否相同，建议用isinstance() > type（） 8、计算机内部是用补码表示的，正数和0，原码、反码、补码都是本身。 负数的原码，是其绝对值的原码在其符号位上变为1，反码是符号位不变，其余位取反，补码是反码+1 9、位运算都是基于补码运算，按位非操作，会操作符号位。"}], "cate": "Python"}
{"题目": "python学习之matplotlib(2021-03-27)", "作者": "卡拉马佐夫er", "发布时间": "2021-03-27 18:05:20", "内容": [{"ctype": "head", "data": "Python中matplotlib库的学习"}, {"ctype": "p", "data": "matplotlib是什么？"}, {"ctype": "p", "data": "Matplotlib 是Python中类似 MATLAB 的绘图工具，熟悉 MATLAB 也可以很快的上手 Matplotlib"}, {"ctype": "code", "data": "import  matplotlib.pyplot as plt\nimport  numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.gridspec as grid\nfrom matplotlib import animation\n\n########  基本图像绘制  ###########\nx = np.linspace(-10,10,100)\ny1 = x**2\ny2 = np.cos(x)\ny3 = np.exp(x)\nprint(x)\n# plt.plot(x,y)\n# plt.show()\n\n########  figuer的使用  ###########\nplt.figure()\nplt.plot(x,y1)\n\nplt.figure()\nplt.plot(x,y2)\n\nplt.figure(num=3,figsize=(10,5))\nline_1, = plt.plot(x,y1,label = 'up')\nline_2,= plt.plot(x,y3,color = 'red',linewidth = 2.0, linestyle = '--',label = 'down')      #同一图绘制多条曲线\n\nplt.show()\n\n########  figuer的设置  ###########\nplt.xlim(-5,5)\nplt.ylim(-20,20)\nplt.xlabel('I am x')\nplt.ylabel('I am y')                                        #坐标轴范围及标签的设置\nnew_ticks = np.linspace(-6,6,5)\nprint(new_ticks)\nplt.xticks(new_ticks)                                        #更换坐标轴范围\nplt.yticks([-5,5],\n           [r'$really\\ bad$',r'$really\\ good$']              #更换坐标轴单位\n)\n\n##gca = 'get current axis'\nax = plt.gca()\nax.spines['right'].set_color('none')                         #右边的轴消失\nax.spines['top'].set_color('none')                           #上边的轴消失\nax.xaxis.set_ticks_position('bottom')                        #重新指定x轴\nax.yaxis.set_ticks_position('left')                          #重新指定y轴\nax.spines['bottom'].set_position(('data', 0))                #指定 data  设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上\nax.spines['left'].set_position(('data', 0))                  #指定 data  设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上\n\n##图例设置\nplt.legend(handles=[line_1,line_2],labels = ['y1','y2'],loc= 'best')      # plot中加入label，再调用legend函数，传入两条曲线，添加标签，选择最佳位置显示\n\n\n##图标中添加注解\nx0 = 2\ny0 = 4\nplt.scatter(x0,y0,s=50,color='b')                            #添加点\nplt.plot([x0,x0],[y0,0],'k--',lw=2.5)                        #添加辅助线，前面为两个点的x坐标，后面为两个点的y坐标\nplt.plot([x0,0],[y0,y0],'k--',lw=2.5)\nplt.text(3,3,'this is the point')                            #添加注释说明\n\n##设置坐标轴刻度颜色和大小\nfor label in ax.get_xticklabels() + ax.get_yticklabels():\n    label.set_fontsize(12)\n    label.set_bbox(dict(facecolor = 'white',edgecolor = 'None',alpha = 0.7))\n\nplt.show()\n\n###########################################################################\n########  散点图Scatter的绘制  ###########\nn = 1024\nx = np.random.normal(0,1,n)     #\ny = np.random.normal(0,1,n)\nt = np.arctan2(y,x)             # for color value / color bar\nplt.scatter(x,y,s=75,c=t,alpha = 0.7)                       #绘制散点图\nplt.xticks(())                                              #隐藏坐标轴\nplt.yticks(())\nplt.xlim(-1,1)\nplt.ylim(-1,1)\nplt.show()\n\n###########################################################################\n########  柱状图的绘制  ###########\nn = 12\nX=np.arange(n)\ny1 = (1 - X/float(n))*np.random.uniform(0.5,1.0,n)      #产生均匀分布的随机数\ny2 = (1 - X/float(n))*np.random.uniform(0.5,1.0,n)\n\nplt.bar(X,+y1)\nplt.bar(X,-y2)                                          #绘制柱状图\n\nfor x,y in zip(X,y1):\n    plt.text(x , y , '%.2f'%y, ha = 'center', va = 'bottom')\n\nfor x,y in zip(X,y2):\n    plt.text(x, -y, '%.2f'%y, ha = 'center', va = 'top')        #添加数据\n\nplt.show()\n\n###########################################################################\n########  等高线图绘制  ###########\ndef f(x,y):\n    return (1 - x/2 + x**5 + y**3)*np.exp(-x**2-y**2)                #高度值\n\nn = 256\nx = np.linspace(-3,3,n)\ny = np.linspace(-3,3,n)                                              #x,y的值\nX,Y = np.meshgrid(x,y)                                               #网格输入值\n\nplt.contourf(X,Y,f(X,Y),8,alpha = 0.75,cmap = plt.cm.hot)            #填充颜色\nC = plt.contour(X,Y,f(X,Y),8,colors = 'black',linewidth = 5)         #等高线\nplt.clabel(C,inline =True,fontsize = 10)                             #显示值\n\nplt.show()\n\n###########################################################################\n########  image图片  ###########\na = np.random.normal(0,2,9).reshape(3,3)\nprint(a)\nplt.imshow(a,interpolation='nearest',cmap='bone',origin='lower')\nplt.colorbar(shrink=0.9)\nplt.show()\n\n###########################################################################\n########  3D 图绘制  ###########\nfig = plt.figure()\nax = Axes3D(fig)\nx = np.arange(-4,4,0.25)\ny = np.arange(-4,4,0.25)\nx,y = np.meshgrid(x,y)\nr = np.sqrt(x**2 + y**2)\nz = np.cos(r)\n\nax.plot_surface(x,y,z,rstride=1,cstride=1,cmap=plt.get_cmap('rainbow'))\nax.contourf(x,y,z,zdir='z',offset=-2,cmap='rainbow')                    #zdir='z',往z轴方向绘制等高线图\nax.set_zlim(-2,2)\nplt.show()\n\n###########################################################################\n########  subplot 函数使用  ###########\n#方法一\nplt.figure()\n\nplt.subplot(2,1,1)\nx1 = np.linspace(-5,5,100)\ny1 = np.sin(x1)\nplt.plot(x1,y1)\n\nplt.subplot(2,3,4)\nx2 = np.linspace(-5,5,100)\ny2 = np.cos(x2)\nplt.plot(x2,y2)\n\nplt.subplot(2,3,5)\nx3 = np.linspace(-5,5,100)\ny3 = np.tan(x3)\nplt.plot(x3,y3)\n\nplt.subplot(2,3,6)\nx4 = np.linspace(-5,5,100)\ny4 = np.exp(x1)\nplt.plot(x4,y4)\n\nplt.show()\n\n#方法二\n#method 1 :  subplot2grid\nplt.figure()\nax1 = plt.subplot2grid((3,3),(0,0),colspan=3,rowspan=1)           #3*3,起始为（0，0），跨度为1*3\nax1.plot([1,2],[1,2])\nax1.set_title('figuer 1')\nax2 = plt.subplot2grid((3,3),(1,0),colspan=2,)\nax3 = plt.subplot2grid((3,3),(1,2),rowspan=2)\nax4 = plt.subplot2grid((3,3),(2,0))\nax5 = plt.subplot2grid((3,3),(2,1))\n\n#method 2 :  subplot2grid\n#method 2 :  easy to define structure\n\nplt.tight_layout()\nplt.show()\n\n###########################################################################\n########  图中图的绘制  ###########\nfig = plt.figure()\nx = [1,2,3,4,5,6,7]\ny = [1,3,4,2,5,8,6]\nleft,bottom,width,height = 0.1,0.1,0.8,0.8                  #图形位置\nax1 = fig.add_axes([left,bottom,width,height])              #添加小图，传入位置\nax1.plot(x,y,'r')\nax1.set_xlabel('x')\nax1.set_ylabel('y')\nax1.set_title('title')\n\nleft,bottom,width,height = 0.2,0.6,0.25,0.25                #图形位置\nax2 = fig.add_axes([left,bottom,width,height])              #添加小图2\nax2.plot(y,x,'b')\nax2.set_xlabel('x')\nax2.set_ylabel('y')\nax2.set_title('title_inside1')\n\nplt.axes([.6,0.2,0.25,0.25])                                #设置位置\nplt.plot(y[::-1],x,'g')                                     #绘制小图3 [::-1]对y逆序\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('title_inside2')\n\nplt.show()\n\n###########################################################################\n########  主次坐标轴  ###########\nx = np.arange(0,10,0.1)\ny1 = 0.05*x**2\ny2 = -1*y1\n\nfig,ax1 = plt.subplots()\nax2 = ax1.twinx()                               # 反转ax1轴作为新的ax2\nax1.plot(x,y1,'g-')\nax2.plot(x,y2,'b--')\n\nax1.set_xlabel('X data')\nax1.set_ylabel('Y1',color = 'g')\nax2.set_ylabel('Y2',color = 'b')\n\nplt.show()\n\n###########################################################################\n########  用动画来展示画图  ###########\nfig,ax = plt.subplots()\n\nx = np.arange(0,2*np.pi,0.01)\nline,= ax.plot(x,np.sin(x))\n\ndef animate(i):\n    line.set_ydata(np.sin(x+i/20))\n    return  line,\n\ndef init():\n    line.set_ydata(np.sin(x))\n    return  line\n\nani = animation.FuncAnimation(fig = fig,func=animate,frames=1000,init_func=init,interval=20,blit=False)\n\nplt.shojiaw()\n"}, {"ctype": "p", "data": "接下来将学习pytorch，并记录下笔记。"}], "cate": "Python"}
{"题目": "python 字符映射", "作者": "绀目澄清", "发布时间": "2021-03-27 21:26:23", "内容": [{"ctype": "code", "data": "\ndef char_to_int(word):\n    '''\n    把中文string映射为int列表\n    例如：'你今天吃饭了吗？' -> [783, 250, 192, 500, 815, 132, 503, 99]\n    Parameters\n    ----------\n    word : string\n        DESCRIPTION.\n\n    Returns\n    -------\n    list[int].\n    '''\n    char_key_dict_path ='./Data/Chinese_characters_4374.txt'\n    with open(char_key_dict_path, 'r',encoding='utf-8') as f:\n        text=f.read()\n    uniq_words = list(text)  #不能使用 set(self.words) 函数 ,因为每次启动随机,只能用固定的\n    index_to_word = {index: word for index, word in enumerate(uniq_words)}  \n    word_to_index = {word: index for index, word in enumerate(uniq_words)}\n    #把小说的 字 转换成 int\n    words_indexes = []\n    #把字典里没有的字符 用'*'表示，也就是Chinese_characters_3500.txt没有的字符.#\n    for w in word:\n        if (w in  word_to_index) == False:\n            words_indexes.append(1482) #1482 =='*'\n            # print(w,'= *',)\n        else:\n            words_indexes.append(word_to_index[w])\n            # print(w,'= ',self.word_to_index[w])\n    return words_indexes\n\n\n\n\ndef int_to_char(int_list):\n    '''\n    把数字列表映射为中文string\n    Parameters\n    ----------\n    int_list : list[int]\n        DESCRIPTION.\n\n    Returns\n    -------\n    words_indexes : string\n        DESCRIPTION.\n\n    '''\n    char_key_dict_path ='./Data/Chinese_characters_4374.txt'\n    with open(char_key_dict_path, 'r',encoding='utf-8') as f:\n        text=f.read()\n    uniq_words = list(text)  #不能使用 set(self.words) 函数 ,因为每次启动随机,只能用固定的\n    index_to_word = {index: word for index, word in enumerate(uniq_words)}  \n    word_to_index = {word: index for index, word in enumerate(uniq_words)}\n    words_indexes ='' \n    #把字典里没有的字符 用'*'表示，也就是Chinese_characters_3500.txt没有的字符\n    for i in int_list:\n        if (i in  index_to_word) == False:\n            words_indexes=words_indexes+ '*' #1482 =='*'\n            # print(w,'= *',)\n        else:\n             words_indexes=words_indexes+ index_to_word[i]\n            # print(w,'= ',self.index_to_word[i])\n    return words_indexes\n\nint_list =char_to_int('你今天吃饭了吗？')\nprint(int_list)\na=[788, 255, 197, 505, 820, 137, 508, 104, 770, 730, 208, 2275, 104, 1341, 1163, 1978, 635, 137, 1639, 100, 1359, 1003, 123, 2420, 29, 1778, 1838, 407, 1838, 770, 2188, 505, 505, 1833, 1833, 724, 398, 274, 3562, 142, 1083, 858, 553, 2607, 495, 1003, 833, 1070, 1174, 1072, 1639, 1639, 1070, 761, 508, 104, 920, 633, 496, 770, 730, 2275, 1422, 402, 656, 208, 1930, 29, 103, 123, 101, 1359, 770, 1778, 730, 1585, 496, 635, 761, 1070, 131, 1566, 2339, 4079, 1596, 108, 103, 635, 635, 1501, 208, 732, 1070, 761, 101, 369, 831, 1187, 1957, 101, 788, 1501, 100, 123, 696, 770, 184, 208, 488, 2233, 101, 1816, 1163, 656, 833, 4079, 152, 635, 384, 151, 100, 112, 1908, 422, 443, 777, 2363, 1943, 1815, 2131, 424, 812, 1572, 102, 2572, 1639, 100, 472, 468, 833, 1306, 2355, 227, 770, 1501, 858, 788, 29, 123, 398, 1908, 4273, 324, 1486, 416, 788, 123, 423, 2123, 123, 1741, 2188, 1816, 671, 104, 208, 1286, 100, 123, 29, 123, 734, 962, 1422, 962, 671, 1833, 101, 620, 1908, 343, 1183, 137, 761, 29, 317, 1995, 1639, 104, 620, 739, 459, 2108, 497, 539, 1889, 1566, 123, 962, 302, 1489, 461, 113, 1717, 922, 2406, 114, 4079, 572, 136, 100, 788, 468, 407, 1978, 777, 365, 920, 1053, 235, 1226, 763, 1122, 100, 633, 920, 101, 730, 2431, 369, 184, 1226, 1226, 369, 103, 833, 571, 235, 770, 156, 310, 642, 151, 833, 696, 2057, 427, 770, 1070, 427, 1306, 1070, 1174, 779, 184, 1395, 157, 101, 1817, 667, 770, 1070, 1778, 3558]\nc=int_to_char(a)\n"}], "cate": "Python"}
{"题目": "python中常用转义字符", "作者": "孤与卿", "发布时间": "2021-03-28 19:56:30", "内容": [{"ctype": "head", "data": "python中常用转义字符"}, {"ctype": "head", "data": "1.为何需要转义字符"}, {"ctype": "p", "data": "当字符串中遇到换行、制表符、回车、退格等操作时，我们不好直接实现，需要通过转义字符来实现此类功能"}, {"ctype": "head", "data": "2.如何实现"}, {"ctype": "p", "data": "用 \\ +字母来实现相应的功能"}, {"ctype": "table", "data": "转义字符代表含义\\n换行\\t制表符\\r回车\\b退格\\’输出单引号\\\"输出双引号\\\\\\"}, {"ctype": "head", "data": "3.代码展示"}, {"ctype": "code", "data": "print('test1 Live a good life \\n  meet slowly')  # newline 换行\nprint('test2 Live \\t a good life meet slowly')  # tab  制表符\nprint('test3 Livee \\t a good life meet slowly')  # 制表符从头开始划分4个空，如果遇到前面全满了则输出四个空格，如果没有满，则只是补齐\nprint('test4 Live \\r a good life meet slowly')  #  回车，\\r  （return） 前面的字符全部消失\nprint('test5 Live \\b a good life meet slowly')  #  退格一个\nprint('test6 http:\\\\\\\\www.baidu.com')  # 遇到两个\\\\只输出一个\nprint('test7 \\'Live a good life meet slowly\\'')\nprint('test8 \\\"Live a good life meet slowly\\\"')\n\n#原字符 不希望字符串中的转义字符起作用，就使用原字符，在字符串前面加r\nprint(r'test9 Live a good life \\n  meet slowly')\n#注意最后一个字符不能是一个反斜线\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328195408482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzI3OTQ0,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "\\n"}, {"ctype": "p", "data": "换行符没啥好说的，就是注意空格也是一个字符"}, {"ctype": "head", "data": "\\t"}, {"ctype": "p", "data": "制表符中有个注意事项，把字符从头开始每4个划分，如果遇到前面全满了则输出四个空格，如果没有满，则补齐后输出不足四个字符的空格数，我做个表格示意一下 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328195216357.png"}, {"ctype": "head", "data": "\\r"}, {"ctype": "p", "data": "回车符运行时会把前面所有的字符都去掉，相当于在Word中选中前面的字符后清除"}, {"ctype": "head", "data": "\\b"}, {"ctype": "p", "data": "相当于Word中的退格"}, {"ctype": "p", "data": "有问题欢迎留言"}], "cate": "Python"}
{"题目": "SLR分析器", "作者": "qq_41073663", "发布时间": "2021-03-28 14:34:53", "内容": [{"ctype": "head", "data": "一、实验目的"}, {"ctype": "p", "data": "设计实现一个LR编译器或一个完整的编译程序，掌握编译器的基本原理和实现技术。"}, {"ctype": "head", "data": "二、实验内容"}, {"ctype": "p", "data": "LR（0）、SLR或LR（1）等语法分析器。 2. 基于实验一（词法分析器）和实验二（LL<1>等语法分析器）的基础上，完成一个完整的编译器。 3. 自行选题"}, {"ctype": "head", "data": "三、实验环境"}, {"ctype": "p", "data": "WIN10 + Python3.8"}, {"ctype": "head", "data": "四、实验要求"}, {"ctype": "p", "data": "1.对于内容一LR分析器的要求  （1）自行定义两种文法，可参照教材和实验指导书。  （2）LR分析表需要自动生成。 2.对于内容二编译器的要求  （1）输入源代码可参考实验一，自行定义文法。  （2）输入源代码可以根据兴趣确定，自行定义文法。如数学计算式的识别。 3.对于内容三的要求 自行选题难度不少于内容一和内容二。"}, {"ctype": "head", "data": "五、实验原理（及其相关流程图）"}, {"ctype": "p", "data": "构造SLR(1)分析表的步骤流程图："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142202818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "已知有文法G[E]如下：  则其拓广文法G’[S’]如图：  应该得到的该文法G’[S’]的DFA为：  实验代码分析及实现流程图："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142252607.png"}, {"ctype": "head", "data": "第一步：拓广文法"}, {"ctype": "p", "data": "（1）数据结构："}, {"ctype": "code", "data": "kuoguangsentences = []    # 存放拓广后的语句列表 如B->BD|d  =>  [\"B->BD\",\"B->d\"]\nSentences = {}      # 语句字典，方便查找 如B->BD|d  =>  {B:[\"BD\",\"d\"]}\n"}, {"ctype": "p", "data": "（2）关键代码："}, {"ctype": "code", "data": "def kuoguang(sentences):\n    Sentences[\"S'\"] = sentences[0].split(\"->\")[0]    # 文法开头增加S’-> ?\n    for i, value in enumerate(sentences):   # 遍历语句，将每句语法中的|分开，并存放在语法字典中\n        begin = value.split(\"->\")[0]    # begin存放语句的开头，即 B->aA 去掉”->“拆分成 [\"B\", \"aA\"], 存放B\n        Sentences[begin] = []   # 初始化语法字典存放的非终结符,即 {B:[]}\n        for j in value.split(\"->\")[1].split(\"|\"):\n            Sentences[begin].append(j)     # 语法字典增加非终结符对应的语句，即 {B:[]} =>  {B:[\"aA\"]}\n    for i in Sentences:\n        for j in Sentences[i]:\n            kuoguangsentences.append(i + \"->\" + j)      # 根据语法字典还原语句放入拓广语句列表中，方便打印，即{B:[\"aA\"]} =>  \"B->aA\"\n"}, {"ctype": "p", "data": "（3）流程图： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142716128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "第二步：求LR0项目集"}, {"ctype": "p", "data": "（1）数据结构："}, {"ctype": "code", "data": "itemsentences = []      # 存放所有项目语句的列表，方便打印\nItem = {}   # 项目集的字典，方便查找\n"}, {"ctype": "p", "data": "（2）关键代码："}, {"ctype": "code", "data": "# 遍历语法字典，将每个位置的情况都添加，即B->aA  =>  [\"B->·aA\",\"B->a·A\",\"B->aA·\"]\ndef LR0item(Sentences):\n    for i in Sentences:     # 遍历语法字典中的非终结符\n        Item[i] = []    # 初始化对应非终结符的项目集列表\n        for j in Sentences[i]:      # 遍历对应非终结符的语句\n            for n in range(len(j) + 1):     # 读取语句中的每一个符号对应的位置\n                list_p = list(j)    # 将语句转化为列表方便操作\n                list_p.insert(n, \"·\")       # 在相应的位置插入\"·\"\n                q = \"\".join(list_p)      # 再将语句转化为str类型\n                itemsentences.append(i + \"->\" + q)      # 存放列表当中\n                Item[i].append(q)       # 存放字典中\n"}, {"ctype": "p", "data": "（3）流程图： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142738508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "第三步：求LR（0）项目集规范族"}, {"ctype": "p", "data": "（1）数据结构："}, {"ctype": "code", "data": "StandardLR0item = {}    # 存放DFA的字典，即：{I0:[\"B->bD\".....],I1:[\"D->·cB\".....],....}\nnum = 0     # 记录项目集的下标，即：I0,I1.....In\nafter = []      # 记录当前项目集其中一个语句进入下一状态集的符号，即： E->a·A  =>  E->aA·  ,存放A  => [\"A\"]\nitemfirst = []      # 存放用于求闭包集合的语句的列表\ncheck = {}      # 存放当前集合前往另一状态集合的记录的字典， 即： I0 --A--> I1 , 存放{I0：[\"A\",\"I1\"]}\n"}, {"ctype": "p", "data": "（2）关键代码："}, {"ctype": "code", "data": "def Standarditem(item, cengshu):    # item为对应的项目集In，层数为项目集的下标数字n\n    global num      # 记录项目集的下标\n    after = {}      # 记录当前项目集其中一个语句进入下一状态集的符号，即： E->a·A  =>  E->aA·  ,存放A  => [\"A\"]\n    clourse = []    # 记录查询过的闭包集合\n    for i in item:      # 遍历项目集中的语句\n        last = i.split(\"·\")[1]  # 获得\"·\"之后的符号串\n        if last == '':      # 如果\"·\"之后没有符号串，则不进入下一状态，直接遍历下一语句\n            continue\n        str1 = i.replace('·', \"\")   # str1存放去除\"·\"的语句，即：B->a·D  =>  B->aD\n        str1 = list(str1)   # 将str1转化为列表，方便操作\n        str1.insert(i.find(\"·\") + 1, \"·\")   # 在后一位符号插入\"·\"， 即：B->a·D  =>  B->aD·\n        str1 = \"\".join(str1)    # 将str1转化为符号串\n        if last[0] not in after:    # last[0]即为原语句中\"·\"的后一位符号，判断是否已经根据这个符号探寻过\n            for p in range(1, len(StandardLR0item) - 1):    # 判断上一次探寻的项目集是否已经包含在另一个项目集当中\n                if is_subsequence(StandardLR0item[num], StandardLR0item[p]):    # 使用is_subsequence()函数来判断前一列表是否包含在另一个列表当中，如果包含，则返回真，并进行如下操作\n                    StandardLR0item.pop(num)    # 若包含，则删除这一项目集合\n                    num -= 1    # 项目集合下标-1\n                    if cengshu in check:    # 记录这一个集合根据状态n，指向前面已经探寻过的项目集当中\n                        check[cengshu].update({StandardLR0item[p][0].split(\"·\")[0][-1]: p})\n                    else:\n                        check.update({cengshu: {StandardLR0item[p][0].split(\"·\")[0][-1]: p}})\n                    break\n            num += 1    # 如果该状态没探寻过，则下标+1，创建新的项目集合\n            num1 = num  # num1记录上一个项目集的下标\n            after[last[0]] = num    # 记录来源，状态+原项目集合的下标\n            clourse = []    # 初始化记录查询过的闭包集合\n            if cengshu in check:    # 记录这一个集合根据状态n，指向后面已经未探寻过的项目集\n                check[cengshu].update({last[0]: num})\n            else:\n                check.update({cengshu: {last[0]: num}})\n        else:\n            num1 = after[last[0]]   # 如果存在，那么返回对应状态指向的项目集的下标\n        for j in itemsentences:     # 遍历项目集的语句\n            if str1 == j:   # 如果遍历的语句与新的语句str1相等，那么存放对应项目集的列表当中\n                if num1 not in StandardLR0item:\n                    StandardLR0item[num1] = [j]\n                else:\n                    if j not in StandardLR0item[num1]:\n                        StandardLR0item[num1].append(j)\n                    else:\n                        continue\n        if i.index(\"·\") + 2 < len(i):   # 判断是否增加闭包集合，假如新语句的\"·\"已经是最后一位，则不用判断\n            v = last[1]     # v是原语句中\"·\"对应后两位的符号\n            if v.isupper() and num in StandardLR0item and v not in clourse:   # 如果是非终结符，则在对应的项目集中增加其闭包集合\n                p = Closure(v)  # 求原语句中\"·\"对应后两位的符号的闭包集合\n                p.Create()\n                StandardLR0item[num][1:1] = CLOUSRE[v]      # 在对应的项目集中增加其闭包集合\n                clourse.append(v)\n    for p in range(1, len(StandardLR0item) - 1):    # 最后一句语句中需要再次判断上一次探寻的项目集是否已经包含在另一个项目集当中\n        if is_subsequence(StandardLR0item[num], StandardLR0item[p]): # 使用is_subsequence()函数来判断前一列表是否包含在另一个列表当中，如果包含，则返回真，并进行如下操作\n            StandardLR0item.pop(num)    # 若包含，则删除这一项目集合\n            num -= 1    # 项目集合下标-1\n            if cengshu in check:    # 记录这一个集合根据状态n，指向前面已经探寻过的项目集当中\n                check[cengshu].update({StandardLR0item[p][0].split(\"·\")[0][-1]: p})\n            else:\n                check.update({cengshu: {StandardLR0item[p][0].split(\"·\")[0][-1]: p}})\n            break\n"}, {"ctype": "p", "data": "（3）流程图： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142904113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "第四步：生成SLR分析表"}, {"ctype": "p", "data": "（1）数据结构："}, {"ctype": "code", "data": "VC = []     # 存放非终结符\nVT = []     # 存放终结符\nACTION = {}     # 存放ACTION表\nGOTO = {}      # 存放GOTO表\n"}, {"ctype": "p", "data": "（2）关键代码："}, {"ctype": "code", "data": "def CREATETABLE():  # 根据项目集更新ACTION和GOTO表\n    for v in VT:    # 初始化ACTION表\n        for n in range(len(StandardLR0item)):\n            if v in ACTION:\n                ACTION[v].update({n: \"\"})\n            else:\n                ACTION.update({v: {n: \"\"}})\n    for v in VC:    # 初始化GOTO表\n        for n in range(len(StandardLR0item)):\n            if v in GOTO:\n                GOTO[v].update({n: \"\"})\n            else:\n                GOTO.update({v: {n: \"\"}})\n    if \"S'\" in GOTO:    # GOTO表去除S‘\n        GOTO.pop(\"S'\")\n    for i in StandardLR0item:   # 循环项目集\n        for j in StandardLR0item[i]:    # 循环项目集中的语句\n            if j.find(\"·\") + 1 == len(j):   # 若·符号是结尾，判断是否执行acc操作还是归约操作\n                str1 = j.split(\"·\")[0]\n                n = str1.split(\"->\")[0]     # 存放语句对应的非终结符\n                if n == \"S'\":       # 如果非终结符为S'则更新acc到ACTION表中\n                    TABLE('#', i, \"acc\")\n                else:\n                    for p in range(len(kuoguangsentences)):\n                        if str1 == kuoguangsentences[p]:\n                            for m in FOLLOW[n]:     # 循环在该非终结符对应的FOLLOW集合中的终结符，更新其对应的归约操作到ACTION表中\n                                TABLE(m, i, \"r\" + str(p))\n            else:\n                v = j.split(\"·\")[1][0]      # 判断是移进操作，更新到对应的ACTION表中\n                TABLE(v, i, check[i][v])\n"}, {"ctype": "p", "data": "（3）流程图： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142936688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "六、实验运行结果图"}, {"ctype": "p", "data": "本小组在完成SLR语法分析器的同时也实现了其可视化工作，如下图：  实例文法为： E->E+T|T T->TF|F F->(E)|i 实例输入串为： i+ii （归约顺序：64264631） (i+i)*i （归约顺序：64264154632）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032814300551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "第一步：得到拓广文法  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032814302552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "第二步：得到LR0项目集  第三步：构造LR0项目集规范族的DFA  （上述步骤基本与LR0相同，在SLR中，根据DFA构造SLR分析表的时候需要用到FOLLOW集） 因此第四步应该是：生成FOLLOW集"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328143050659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "第五步：生成分析表  额外功能 1.栈分析 输入串（i+i*i）进行栈分析，归约顺序：64264631  输入串（(i+i)*i）进行栈分析，归约顺序：64264154632 2.生成DFA构造图   3.其它文法展示"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328143120522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "（1） S->bAS|bA A->aSc"}, {"ctype": "p", "data": " （2） S->BB B->aB|b  （3） S->aAcBe A->b A ->Ab B->d  （4） A->G=E E->E+T|E-T|T T->TF|T/F|F F->(E)|i G->i  （5） E->E+E|EE|(E)|i I7和I8的二义性未解决  **"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328143241124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDczNjYz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "要源码的留邮箱"}, {"ctype": "p", "data": "**"}], "cate": "Python"}
{"题目": "2021-03-26 复习pandas数据处理", "作者": "小黑班♪(･ω･)ﾉ", "发布时间": "2021-03-27 23:52:38", "内容": [{"ctype": "p", "data": "21.读取本地EXCEL数据"}, {"ctype": "code", "data": "import pandas as pd\nimport numpy as np\n\ndf = pd.read_excel('pandas325.xlsx')\n"}, {"ctype": "p", "data": "22.查看df数据前5行"}, {"ctype": "code", "data": "df.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326174416417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "23.将salary列数据转换为最大值与最小值的平均值"}, {"ctype": "code", "data": "def fun(df):\n    lst =df['salary'].split('-')\n    smin = int(lst[0].strip('k'))\n    smax = int(lst[1].strip('k'))\n    \n    df['salary'] = int((smax-smin)/2*1000) #把k去除后，再*回来\n    return df\n\ndf = df.apply(fun,axis=1)\ndf.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327160924521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds) 该方法可将函数应用到由各列或行形成的一维数组（Series）上，默认为列，axis指定行列"}, {"ctype": "p", "data": "24.将数据根据学历进行分组并计算平均薪资"}, {"ctype": "code", "data": "edu_salary = df.groupby(by='education')\nedu_salary.mean()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327163048425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "tips:分组（groupby）后再算均值"}, {"ctype": "p", "data": "25.将createTime列时间转换为月-日"}, {"ctype": "code", "data": "for i in range(len(df)):\n    df.iloc[i,0] = df.iloc[i,0].to_pydatetime().strftime('%m-%d')\ndf.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327163646335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "Timestamp.to_pydatetime() 将timestap对象转换为datetime对象 time.strftime(format[, t]) 接收时间元组并返回可读字符串表示的时间，格式由format决定 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164415915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "26.查看索引、数据类型和内存信息"}, {"ctype": "code", "data": "df.info()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327170022893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "27.查看数值型列的汇总统计"}, {"ctype": "code", "data": "df.describe()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327170136788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "describe() 查看数据的分布情况 图片依次为数量、均值、标准差、最小值、第一四分位数（从小到大排列后第25%的数字）、中位数、75%的数字、最大值"}, {"ctype": "p", "data": "28.新增一列根据salary将数据分为三组"}, {"ctype": "code", "data": "bins = [0,5000,7000,15000]\ngroup_names = ['low','middle','high']\ndf['cate'] = pd.cut(df['salary'],bins,labels=group_names)\ndf\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327215858202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "df.cut(x, bins, right=True, labels=None, retbins=False, precision=3, include_lowest=False, duplicates='raise') x:Series bins:进行分组的依据 整数，表示将x中的数值分成等宽的n份，每一组最大值和最小值之差相约等 标量序列，序列数值表示分档分解值 间隔索引，bins中的值必须不重叠 right:默认为true，表示包含最右值的数值 labels:数值或布尔值，指定分箱的标签"}, {"ctype": "p", "data": "29.按照salary列对数据降序排列"}, {"ctype": "code", "data": "df.sort_values('salary',ascending=False)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327221013767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "30.取出第12行数据"}, {"ctype": "code", "data": "df.loc[11]\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327221225514.png"}, {"ctype": "p", "data": "loc[]利用索引名称获取想要的行列 iloc[]利用索引的具体位置（整数型参数）来获取想要的行列"}, {"ctype": "p", "data": "31.计算salary列的中位数"}, {"ctype": "code", "data": "np.median(df['salary'])\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327222013217.png"}, {"ctype": "p", "data": "32.绘制薪资水平频率分布直方图（※）"}, {"ctype": "code", "data": "# from matplotlib import pyplot as plt\ndf.salary.plot(kind='hist')\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327223107678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "注：第一次看到这种写法，需要学习"}, {"ctype": "p", "data": "33.绘制薪资水平密度曲线"}, {"ctype": "code", "data": "df.salary.plot(kind='kde',xlim=(0,20000))\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327223338896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "DataFrame.plot(x=None, y=None, kind='line', ax=None, subplots=False, sharex=None, sharey=False, layout=None, figsize=None, use_index=True, title=None, grid=None, legend=True, style=None, logx=False, logy=False, loglog=False, xticks=None, yticks=None, xlim=None, ylim=None, rot=None, fontsize=None, colormap=None, position=0.5, table=False, yerr=None, xerr=None, stacked=True/False, sort_columns=False, secondary_y=False, mark_right=True, **kwds) DataFrame中的绘图方法 kind:图像类型 xlim:设置x轴坐标范围，数值（最小值）、列表或元组（区间范围）"}, {"ctype": "p", "data": "原文链接：https://blog.csdn.net/h_hxx/article/details/90635650`"}, {"ctype": "p", "data": "34.删除最后一列categories"}, {"ctype": "code", "data": "df.drop(columns='cate',inplace=True)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327224551154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "35.将df的第一列与第二列合并为新的一列"}, {"ctype": "code", "data": "df['test_one'] = df['createTime']+df['education']\ndf\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327224820356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "36.将education列与salary列合并为新的一列"}, {"ctype": "code", "data": "# df['test_two'] = df['education']+str(df['salary'])\terror: 当列edu 加上所有salary值\n# df\ndel df['test_two']\ndf\n\ndf['test_two'] = df['salary'].map(str) + df['education']\ndf\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327225217145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327225654530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "map(str) 在此处将int类型转换为str类型 astype(str) 将对象强制转换为指定类型 个人觉得实际应用上没有区别，都是类型转换，创建新对象不在源对象上改变"}, {"ctype": "p", "data": "37.计算salary最大值与最小值之差"}, {"ctype": "code", "data": "df[['salary']].apply(lambda x:x.max()-x.min())\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327231632555.png"}, {"ctype": "p", "data": "lambda 匿名函数"}, {"ctype": "p", "data": "38.将第一行与最后一行拼接"}, {"ctype": "code", "data": "pd.concat([df[:1],df[-2:-1]],axis=0)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327232658864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "39.将第8行数据添加至末尾"}, {"ctype": "code", "data": "df.append(df.iloc[7])\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327232904191.png"}, {"ctype": "p", "data": "40.查看每列的数据类型"}, {"ctype": "code", "data": "df.dtypes\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233020380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "41.将createTime列设置为索引"}, {"ctype": "code", "data": "df.set_index('createTime')\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233130605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "42.生成一个和df长度相同的随机数dataframe"}, {"ctype": "code", "data": "df.info()\n# counts 20\ndf1 = pd.DataFrame(pd.Series(np.random.randint(1,10,20)))\ndf1\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233421661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "43.将上一题生成的dataframe与df合并"}, {"ctype": "code", "data": "df = pd.concat([df,df1],axis=1)\ndf\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233610569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "44.生成新的一列new为salary列减去之前生成随机数列"}, {"ctype": "code", "data": "df['new'] = df['salary'] - df[0]\ndf\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233735398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "45.检查数据中是否含有任何缺失值"}, {"ctype": "code", "data": "df.isnull().values.any()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233907805.png"}, {"ctype": "p", "data": "只写df.isnull()或df.isnull().values会生成所有数据的true／false矩阵，需要自己数，df.isnull().values.any()系统判断缺失值"}, {"ctype": "p", "data": "46.将salary列类型转换为浮点数"}, {"ctype": "code", "data": "df['salary'].astype(float)\n# df['salary'].astype(np.float64)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327234315189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "47.计算salary大于10000的次数"}, {"ctype": "code", "data": "len(df[df['salary']>10000])\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327234417439.png"}, {"ctype": "p", "data": "48.查看每种学历出现的次数"}, {"ctype": "code", "data": "df.education.value_counts()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327234625118.png"}, {"ctype": "p", "data": "49.查看education列共有几种学历"}, {"ctype": "code", "data": "df['education'].nunique()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327234731527.png"}, {"ctype": "p", "data": "50.提取salary与new列的和大于10000的最后3行"}, {"ctype": "code", "data": "df1 = df[['salary','new']]\nrows = df1.apply(np.sum,axis=1)\n# rows\nres = df.iloc[np.where(rows > 10000)[0][-3:],:]\nres\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327235048189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTQ4NzU4OQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "Python模拟随机漫步", "作者": "分析101", "发布时间": "2021-03-27 12:20:47", "内容": [{"ctype": "p", "data": "本文用Python模拟随机漫步行为。"}, {"ctype": "head", "data": "1 使用内建的的random模块"}, {"ctype": "code", "data": "import random\n\nposition = 0\nwalk = [position]\nsteps = 1000\nfor i in range(steps):\n    step = 1 if random.randint(0, 1) else -1\n    position += step\n    walk.append(position)\n"}, {"ctype": "p", "data": "random模块每次只能生成一个样本值，效率很低。如果要生成大量样本值，可用numpy.random模块。"}, {"ctype": "p", "data": "可用下面的代码测试两者生成\n    \n     \n      \n       \n        1\n       \n       \n        ,\n       \n       \n        000\n       \n       \n        ,\n       \n       \n        000\n       \n      \n      \n       1,000,000\n      \n     \n    1,000,000个样本值的速度："}, {"ctype": "code", "data": "import numpy as np\nfrom random import normalvariate\n\nN = 1000000\n\n%timeit samples = [normalvariate(0, 1) for _ in range(N)]\n%timeit np.random.normal(size=N)\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "head", "data": "2 使用numpy.random"}, {"ctype": "code", "data": "import numpy as np\n\nnp.random.seed(12345)\n\nnsteps = 1000\ndraws = np.random.randint(0, 2, size=nsteps)\nsteps = np.where(draws > 0, 1, -1)\nwalk = steps.cumsum()\n"}, {"ctype": "p", "data": "注意，random.randint(a,b)函数生成的是\n    \n     \n      \n       \n        [\n       \n       \n        a\n       \n       \n        ,\n       \n       \n        b\n       \n       \n        ]\n       \n      \n      \n       [a,b]\n      \n     \n    [a,b]之间的整数，而numpy.random.randint(a,b)生成的是\n    \n     \n      \n       \n        [\n       \n       \n        a\n       \n       \n        ,\n       \n       \n        b\n       \n       \n        )\n       \n      \n      \n       [a,b)\n      \n     \n    [a,b)之间的整数。"}, {"ctype": "p", "data": "最终生成的walk为numpy.ndarray类型的数据。可以看一下最小和最大到达的地方，以及在何时首先偏离原点10的距离。"}, {"ctype": "code", "data": "print(walk.min())\nprint(walk.max())\nprint((np.abs(walk) >= 10).argmax())\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "head", "data": "3 同时模拟多个随机漫步"}, {"ctype": "p", "data": "使用numpy.random()可以同时模拟多个随机漫步。这里同时模拟\n    \n     \n      \n       \n        5\n       \n       \n        ,\n       \n       \n        000\n       \n      \n      \n       5,000\n      \n     \n    5,000个，步长依旧设为\n    \n     \n      \n       \n        1\n       \n       \n        ,\n       \n       \n        000\n       \n      \n      \n       1,000\n      \n     \n    1,000。"}, {"ctype": "code", "data": "nwalks = 5000\nnsteps = 1000\ndraws = np.random.randint(0, 2, size=(nwalks, nsteps)) # 0 or 1\nsteps = np.where(draws > 0, 1, -1)\nwalks = steps.cumsum(axis=1)\n"}, {"ctype": "p", "data": "得到的walks，是一个\n    \n     \n      \n       \n        5\n       \n       \n        ,\n       \n       \n        000\n       \n       \n        ×\n       \n       \n        1\n       \n       \n        ,\n       \n       \n        000\n       \n      \n      \n       5,000\\times 1,000\n      \n     \n    5,000×1,000的矩阵，也是numpy.ndarray类型的数据。"}, {"ctype": "p", "data": "一共有多少次随机漫步，达到过偏离原点30的距离？"}, {"ctype": "code", "data": "hits30 = (np.abs(walks) >= 30).any(1)\nhits30\nhits30.sum() # Number that hit 30 or -30\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "p", "data": "在这些随机漫步过程中，平均用了多少步才偏离原点30？"}, {"ctype": "code", "data": "crossing_times = (np.abs(walks[hits30]) >= 30).argmax(1)\ncrossing_times.mean()\n"}, {"ctype": "p", "data": "输出："}], "cate": "Python"}
{"题目": "草稿1", "作者": "小明623", "发布时间": "2021-03-27 01:34:43", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "自己也是小白，目前在白嫖李老师的教学视频，有一说一他讲的真的很细致，非常适合新手入门爬虫。目前我跟着学习了将近一个星期，下面就是根据他的教学内容写的爬取图片的小程序"}, {"ctype": "head", "data": "一、语言：编程语言是python，编译器是pycharm"}, {"ctype": "p", "data": "关于这些网上有很多介绍，想安装的话也可以搜到安装教程，这里就不再叙述了。也可以直接使用python3在线编程（http://www.dooccn.com/python3/），这个上面也是可以运行的（应该可以叭，没试过）。"}, {"ctype": "head", "data": "二、代码"}, {"ctype": "head", "data": "1.全部代码"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "# coding=utf-8\nimport re #网页解析，获取数据\nfrom bs4 import BeautifulSoup  #引入bs4其中的一个模块进行网页解析，获取数据\nimport urllib.request,urllib.error #指定url，获取网页数据\nimport requests\n\nimport os\npath = \"以下载\"\nos.makedirs(os.path.join(\"D:\\py\\daima\\爬虫下载\",path))\nos.chdir(os.path.join(\"D:\\py\\daima\\爬虫下载\",path))\n\ndef main():\n    jichuURL=\"http://www.heisiyun.com/\"\n    huoquyuanam(\"http://www.heisiyun.com\")\n    paquneirong(jichuURL)\n    heji = paquneirong(jichuURL)\n    # print(heji[0])\n    baocuntupian(heji)\n    \ndef huoquyuanam(url):\n    toubuxinxi={\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36\"}\n    request = urllib.request.Request(url,headers=toubuxinxi)   #用rullib.request携带着toubuxinxi去访问传进来的url，用Request封装起来\n    html = \" \"\n    response = urllib.request.urlopen(request)\n    html = response.read()  # 访问了网页的源码\n    return html    #返回源码\n\ntupian = re.compile(r'class=\"zoom\" data-original=\"(.*?)\" id=\"aimg')\ndef paquneirong(jichuURL):\n    datalist = []\n    for i in range(0,5):\n        data = []\n        url = jichuURL+\"/thread-35%s-1-1.html\"%(i)\n        html = huoquyuanam(url)\n        soup= BeautifulSoup(html,\"html.parser\")  #此时soup是网页的打开内容\n        for mbn in soup.find_all('div',class_=\"mbn savephotop\"):  #mbn是所有图片的源码（包括标签、链接和其他代码）\n            mbn = str(mbn)\n            lianjie = re.findall(tupian,mbn)     #通过正则表达式清洗，lianjie是所有图片的链接，不包括其他代码\n            data.append(lianjie)  #此时data是一个列表\n        datalist.insert(i,data)         #将每一个图集的所有链接放到datalist中去,此时data位于datalist的第0位，形成一个二位列表\n    return datalist\n\ndef baocuntupian(heji):\n    i = 0\n    for url in heji:\n        # print(type(url))   #此时url是列表类型\n        for x in range(0,len(url)):\n            a = str(url[x][0])\n            toubuxinxi = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36\"}\n            response = requests.get(a, headers=toubuxinxi)\n            f = open('%s.jpg' % (i + 1), 'wb')\n            f.write(response.content)\n            f.close()\n            print(\"以下载%s张图片\" % (i + 1))\n            i = i + 1\n\nif __name__==\"__main__\":\n    main()"}, {"ctype": "head", "data": "2.引入的库"}, {"ctype": "p", "data": "代码如下："}, {"ctype": "code", "data": "import re #网页解析，获取数据\nfrom bs4 import BeautifulSoup  #引入bs4其中的一个模块进行网页解析，获取数据\nimport urllib.request,urllib.error #指定url，获取网页数据\nimport requests\n"}, {"ctype": "p", "data": "re:用正则表达式需要的库 bs4：就是靓汤，一种爬虫程序里常见的库，可以用来解析链接 urllib：用来获取网页数据的 requests：用来下载东西的（应该是叭）"}, {"ctype": "head", "data": "2.获取图片链接及代码详解"}, {"ctype": "p", "data": "1.这句是转码用的，防止程序不能正确读取中文"}, {"ctype": "code", "data": "coding=utf-8\n"}, {"ctype": "p", "data": "2.这里是用到os库，用来转换文件目录的。先用os.makedirs(os.path.join(“D:\\py\\daima\\爬虫下载”,path)) 创建一个文件夹，文件夹名称是path传来的\"以下载\"，文件目录是D:\\py\\daima\\爬虫下载 好像用\"D:\\py\\daima\\爬虫下载\"也可以创建一个新的文件夹，而且如果已有该文件夹的话程序会报错，这个我也不是很清楚，有懂的朋友可以在评论区指出 然后用os.chdir(os.path.join(“D:\\py\\daima\\爬虫下载”,path)) 转到该目录下面，这样下载的图片都保存在该目录了"}, {"ctype": "code", "data": "path = \"以下载\"\nos.makedirs(os.path.join(\"D:\\py\\daima\\爬虫下载\",path))\nos.chdir(os.path.join(\"D:\\py\\daima\\爬虫下载\",path))\n"}, {"ctype": "p", "data": "3.将各个步骤定义成一个个的函数，最后在这个main方法中统一调用"}, {"ctype": "code", "data": "def main():\njichuURL=\"http://www.heisiyun.com/\"\nhuoquyuanam(\"http://www.heisiyun.com\")\npaquneirong(jichuURL)\nheji = paquneirong(jichuURL)\n# print(heji[0])\nbaocuntupian(heji)\n"}, {"ctype": "p", "data": "创立一个基础URL：http://www.heisiyun.com/（不是什么正经网站🙄，请勿在公共场合及父母陪同下观看( •̀ ω •́ )✧）"}, {"ctype": "p", "data": "调用的方法有： 1： huoquyuanam（） ：获取网页的源码：将网址传给该方法，通过该方法去访问网址，获取到网页源码后赋值给html,最后返回html"}, {"ctype": "code", "data": "def huoquyuanam(url):\ntoubuxinxi={\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36\"}\nrequest = urllib.request.Request(url,headers=toubuxinxi)   #用rullib.request携带着toubuxinxi去访问传进来的url，用Request封装起来\nhtml = \" \"\nresponse = urllib.request.urlopen(request)  #这句应该是将获取到的内容传给response，不是很懂\nhtml = response.read()  # 访问了网页的源码\t#用read去读取内容，此时的html是str类型\nreturn html    #返回源码\n"}, {"ctype": "p", "data": "toubuxinxi={“User-Agent”:\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36 该代码是爬虫程序想要浏览网页时需要创建一个头部信息用来模拟电脑操作，也是一个最简单的反爬方法 具体操作步骤可以在网上搜，这里就不赘诉了，有更好的反爬方法请在评论区多多赐教哦"}, {"ctype": "p", "data": "2.paquneirong(jichuURL) ：爬取内容：将基础URL作为参数传给该方法，然后通过对子页面链接的对比找出规律，用字符串相加的方式拼接出各级子页面链接。然后用正则表达式对各级子页面的信息进行处理，筛选出图片的链接后赋给datalist，最后传出datalist"}, {"ctype": "code", "data": "def paquneirong(jichuURL):\ndatalist = []\nfor i in range(0,5):\n    data = []\n    url = jichuURL+\"/thread-35%s-1-1.html\"%(i)\n    html = huoquyuanam(url)\n    soup= BeautifulSoup(html,\"html.parser\")  #此时soup是网页的打开内容，用的解析方法是html.parser解析\n    for mbn in soup.find_all('div',class_=\"mbn savephotop\"):  #mbn是所有图片的源码（包括标签、链接和其他代码）\n        mbn = str(mbn)\n        lianjie = re.findall(tupian,mbn)     #通过正则表达式清洗，lianjie是所有图片的链接，不包括其他代码\n        data.append(lianjie)  #此时data是一个列表\n    datalist.insert(i,data)         #将每一个图集的所有链接放到datalist中去,此时data位于datalist的第0位，形成一个二维列表\nreturn datalist\n"}, {"ctype": "p", "data": "url = jichuURL+\"/thread-35%s-1-1.html\"%(i) 通过对比发现各级子页面的链接都是http://www.heisiyun.com/thread-350-1-1.html 这种格式，可以拆分为基础URL（http://www.heisiyun.com/）加上（thread-350-1-1.html），其中350这些参数的不同决定了访问的是哪级子页面，所以350可以用变量的方式代替，这样就能得到了各级子页面的链接 接着用for循环遍历出范围从0到5（不包括5）的数字，放到网页链接中，每循环一次就会得到一个子页面的链接，循环4次就会得到 http://www.heisiyun.com/thread-350-1-1.html http://www.heisiyun.com/thread-351-1-1.html http://www.heisiyun.com/thread-352-1-1.html http://www.heisiyun.com/thread-353-1-1.html http://www.heisiyun.com/thread-354-1-1.html 这四个子页面链接，也就是url。当然这个范围不是固定的，也可以设置更大的范围 在循环内调用 huoquyuanam（） 方法，将得到的url传到该方法中，就可以得到该链接的源码，然后值赋给html，再用BeautifulSoup进行解析，得到的是网页的源码内容 此时的网页源码内容有很多，有各种标签、图片链接和其他看不懂的东西，我们要对这些内容进行一个筛选，只要图片链接。为了更清晰的对比，此时可以输出一下soup，得到下面的结果  对比发现，图片链接都在这个范围里  此时我们可以对此进行筛选，用soup.find_all(标签，属性)的方法：标签是div，就是以这个为开头，其中包括属性class=“mbn savephotop”，因为class是python的关键字，所以需要加个_用来表示它是一个属性 因为一个子页面里面有很多的图片，所以用for循环找出所有的图片链接"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326234918360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NTkxMjgxMg==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "for mbn in soup.find_all('div',class_=\"mbn savephotop\"):  #mbn是所有图片的源码（包括标签、链接和其他代码）\n\tmbn = str(mbn)  #此时的需要把mbn转化为字符串类型，打印出来的话就是下图显示的内容\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210326234704559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NTkxMjgxMg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "可以看到我们的筛选有效了，但是它还不是单纯的图片链接，我们只要图片链接。所以还需要进一步的筛选，我用的是正则表达式，因为要对每一个子页面都进行该操作，所以就在该循环内进行筛选。使用正则表达式，不仅需要调用re库，还需要先定义一个格式（筛选的方法）"}, {"ctype": "code", "data": "tupian = re.compile(r'class=\"zoom\" data-original=\"(.*?)\" id=\"aimg')\n"}, {"ctype": "p", "data": "通过仔细对比发现一个’div’,class_=“mbn savephotop\"里面有两个重复的图片链接，所以我们筛选出其中一个就行，这里筛选出 class=“zoom” data-original=”(.*?)\" id=\"aimg 的内容，其中(.*?)就是我们需要的图片链接"}, {"ctype": "code", "data": "lianjie = re.findall(tupian,mbn)     #通过正则表达式清洗，lianjie是所有图片的链接，不包括其他代码。这句话的意思是用刚刚定义的tupian方法去筛选mbn里面的内容，筛选完毕之后赋值给链接\ndata.append(lianjie)  #此时data是一个列表。意思是将得到的链接（lianjie）放在列表data里\n"}, {"ctype": "p", "data": "通过上面的循环我们得到了一个子页面的所有图片链接，因为有很多个子页面，所以我们在这个循环外面把得到的data放到列表datalist里面去，再通过最上面的循环将每一个子页面里面的图片链接放到列表datalist中，此时的datalist是一个二维列表，它的第0位是第一个子页面里面的所有图片链接（也就是data，它也是一个列表），下面图的数字和箭头表示循环步骤  需要注意的是，因为data = [ ]在循环步骤2、3的外面，所以data赋值给datalist（也就是步骤4）之后，data就重置了，为空，这样再次进入循环之后里面存放的是全新的图片链接，不会重复。这个知识点很简单，但是当时我困扰了老半天`(>﹏<)′ md… 最后返回datalist"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327001415588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NTkxMjgxMg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.通过图片链接保存图片"}, {"ctype": "p", "data": "因为得到图片链接列表（datalist）后我在传参的时候总是提示错误，具体什么原因我也不太清楚，所以我在main方法里面用 heji = paquneirong(jichuURL) 的方式将那些链接用heji接收了，所以下面在保存图片时传的参数是heji而不是datalist，有清楚的朋友也可以在评论区讲一下为什么不能直接把datalist传到baocuntupian（）里 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327003128165.png"}, {"ctype": "code", "data": "def baocuntupian(heji):\ni = 0\nfor url in heji:\t\t\t\t\t  #此时url是列表类型\n    for x in range(0,len(url)):\n        a = str(url[x][0])\n        toubuxinxi = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36\"}\n        response = requests.get(a, headers=toubuxinxi)\n        f = open('%s.jpg' % (i + 1), 'wb')\n        f.write(response.content)\n        f.close()\n        print(\"以下载%s张图片\" % (i + 1))\n        i = i + 1\n"}, {"ctype": "p", "data": "for url in heji: 用for循环遍历出所有的url，此时的url也是一个二维列表，包含的内容是一个子页面里面所有的图片链接，如下图所示。仔细观看发现这个二维列表里面有很多个子列表，子列表里面只有1个元素，那就是图片链接。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032700423786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NTkxMjgxMg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "所以我们还需要在用一个for循环，遍历出当前子页面里面每一个图片链接，循环次数就是该列表的长度，用到的代码是： for x in range(0,len(url)): #表示从第0位开始，一直到该列表的最后一位"}, {"ctype": "p", "data": "第一张的图片链接是二维列表的第0位的第0位（有点绕哦，看下图） 所以我们需要用 a = str(url[x][0]) 这段代码把每一个图片链接提取出来并转化为字符串格式"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327004949806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NTkxMjgxMg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "然后就是去访问这个链接，用到的方法和获取源码类似，也是创建个头部信息，然后去访问"}, {"ctype": "code", "data": "toubuxinxi = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36\"}\nresponse = requests.get(a, headers=toubuxinxi)\n"}, {"ctype": "p", "data": "这里用的是reques.get方法直接获取网页内容，完了之后就是保存图片了"}, {"ctype": "code", "data": "f = open('%s.jpg' % (i + 1), 'wb')\nf.write(response.content)\nf.close()\nprint(\"以下载%s张图片\" % (i + 1))\ni = i + 1\n"}, {"ctype": "p", "data": "上面那些是文件的操作，具体的操作方法可以在网上搜搜，不仅可以保存为图片（jpg），还可以保存为其他格式，这里就不在叙述了。 f.write(response.content) 这个是将读取到的信息用二进制写入到文件里，就是先创建个空的jpg文件，然后再把图片内容给装进去。之所以这么用是因为我只会这一种方法 md… ,有更好的方法欢迎在评论区里讲解一下哦 然后 print(“以下载%s张图片” % (i + 1)) 是在每下载一个图片之后就输出 以下载**张图片。这样能更直观的看到下载进度，要不半天没反应还以为电脑卡死了。"}, {"ctype": "p", "data": "END"}, {"ctype": "head", "data": "总结"}], "cate": "Python"}
{"题目": "Python学习第八天总结", "作者": "一枚学渣.", "发布时间": "2021-03-27 00:05:54", "内容": [{"ctype": "head", "data": "一.字典相关函数"}, {"ctype": "head", "data": "1.增 fromkeys()"}, {"ctype": "p", "data": "使用一组键和默认值创建字典"}, {"ctype": "code", "data": "'''.\nlst = ['top', 'middle', 'bottom']\n# 初始化一个字典\ndic = {}.fromkeys(lst, None)\nprint(dic)  # {'top': None, 'middle': None, 'bottom': None}\n\n'''这种写法易出现一些尴尬局面'''\ndic = {}.fromkeys(lst, [])\ndic['top'].append(2)\nprint(dic)  # {'top': [2], 'middle': [2], 'bottom': [2]}\n\n'''为了避免这种情况的出现推荐使用dic[key] = value的方法直接添加'''\ndic = {}\ndic['top'] = []\ndic['middle'] = []\ndic['bottom'] = []\ndic['top'].append(1)\nprint(dic)  # {'top': [1], 'middle': [], 'bottom': []}\n"}, {"ctype": "head", "data": "2.删"}, {"ctype": "head", "data": "1.pop()"}, {"ctype": "p", "data": "通过键去删除键值对(若没有该键,可设置默认值,预防报错)"}, {"ctype": "code", "data": "dic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\nres = dic.pop('bottom')\nprint(res)\t# EZ\nprint(dic)\t# {'top': '瑞文', 'middle': '发条'}\n\n# 如果不存在该键,那么打印第二个默认值,防止报错\nres = dic.pop('a', '没有该键')\nprint(res)\t# 没有该键\n"}, {"ctype": "head", "data": "2.popitem()"}, {"ctype": "p", "data": "删除最后一个键值对,返回删除的对象"}, {"ctype": "code", "data": "dic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\nres = dic.popitem()\nprint(res)\t# ('bottom', 'EZ')\nprint(dic)\t# {'top': '瑞文', 'middle': '发条'}\n"}, {"ctype": "head", "data": "3.clear()"}, {"ctype": "p", "data": "清空字典"}, {"ctype": "code", "data": "dic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\ndic.clear()\nprint(dic)\t# {}\n"}, {"ctype": "head", "data": "3.改 update()"}, {"ctype": "code", "data": "# 1.没有该键就添加'''\ndic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\ndic_new = {'jungle': '盖伦'}\ndic.update(dic_new)\nprint(dic)  # {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ', 'jungle': '盖伦'}\n\n# 2.有该键就更新\ndic_new = {'jungle': '盖伦', 'top': '星妈'}\ndic.update(dic_new)\nprint(dic)\t# {'top': '星妈', 'middle': '发条', 'bottom': 'EZ', 'jungle': '盖伦'}\n\n# 3.了解\ndic.update(support='风女', a='lue', z=3)\nprint(dic)  # {'top': '星妈', 'middle': '发条', 'bottom': 'EZ', 'jungle': '盖伦', 'support': '风女', 'a': 'lue', 'z': 3}\n"}, {"ctype": "head", "data": "4.查"}, {"ctype": "head", "data": "1.get()"}, {"ctype": "p", "data": "通过键获取值(若没有该键可设置默认值,预防报错)"}, {"ctype": "code", "data": "dic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\nprint(dic.get('top1'))  # 没有该键,默认返货None\n# 可设置默认值\nprint(dic.get('top1', '没有该键'))\n"}, {"ctype": "head", "data": "2.keys()"}, {"ctype": "p", "data": "将字典的键组成新的可迭代对象"}, {"ctype": "code", "data": "dic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\nres = dic.keys()\nprint(res, type(res))\t# dict_keys(['top', 'middle', 'bottom']) <class 'dict_keys'>\n\nfor i in dic.keys():\n\tprint(i)\n'''\ntop\nmiddle\nbottom\n'''\n"}, {"ctype": "head", "data": "3.values()"}, {"ctype": "p", "data": "将字典的值组成新的可迭代对象"}, {"ctype": "code", "data": "dic = {'top': '瑞文', 'middle': '发条', 'bottom': 'EZ'}\nfor i in dic.values():\n\tprint(i)\n'''\n瑞文\n发条\nEZ\n'''\n"}, {"ctype": "head", "data": "4.items()"}, {"ctype": "p", "data": "将字典的键值对凑成一个个元组,组成新的可迭代对象"}, {"ctype": "code", "data": "for i in dic.items():\n\tprint(i)\n'''\n('top', '瑞文')\n('middle', '发条')\n('bottom', 'EZ')\n'''\nfor k, v in dic.items():\n\tprint(k, v)\n'''\ntop 瑞文\nmiddle 发条\nbottom EZ\n'''\n"}, {"ctype": "head", "data": "二.集合相关操作"}, {"ctype": "head", "data": "1.相关操作(交差并补)"}, {"ctype": "head", "data": "1.intersection()"}, {"ctype": "p", "data": "交集"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小花', '小白', '小黑', '小粉'}\n\nres = set1.intersection(set2)\nprint(res)\t# {'小粉'}\n# 简化符号 &\nres = set1 & set2\nprint(res)\t# {'小粉'}\n"}, {"ctype": "head", "data": "2.difference ()"}, {"ctype": "p", "data": "差集"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小花', '小白', '小黑', '小粉'}\n\nres = set1.difference(set2)\nprint(res)\t# {'小红', '小明', '小黄'}\n# 简化符号 -\nres = set1 - set2\nprint(res)\t# {'小红', '小明', '小黄'}\n"}, {"ctype": "head", "data": "3.union()"}, {"ctype": "p", "data": "并集"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小花', '小白', '小黑', '小粉'}\n\nres = set1.union(set2)\nprint(res)\t# {'小黑', '小明', '小粉', '小红', '小白', '小黄', '小花'}\n# 简化符号 |\nres = set1 | set2\nprint(res)\t# {'小黑', '小明', '小粉', '小红', '小白', '小黄', '小花'}\n"}, {"ctype": "head", "data": "4.symmetric_difference()"}, {"ctype": "p", "data": "对称差集"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小花', '小白', '小黑', '小粉'}\n\nres = set1.symmetric_difference(set2)\nprint(res)\t# {'小花', '小黄', '小明', '小白', '小红', '小黑'}\n# 简化符号 ^\nres = set1 ^ set2\nprint(res)\t# {'小花', '小黄', '小明', '小白', '小红', '小黑'}\n"}, {"ctype": "head", "data": "5.issubset()"}, {"ctype": "p", "data": "判断是否是子集"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小黄', '小粉'}\n\nres = set1.issubset(set2)\nprint(res)\t# False\n# 简化符号 <\nres = set1 < set2\nprint(res)\t# False\n"}, {"ctype": "head", "data": "6.issuperset()"}, {"ctype": "p", "data": "判断是否是父集"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小黄', '小粉'}\n\nres = set1.issuperset(set2)\nprint(res)\t# True\n# 简化符号 >\nres = set1 > set2\nprint(res)\t# True\n"}, {"ctype": "head", "data": "7.isdisjoint()"}, {"ctype": "p", "data": "检测两个集合是否不相交 不相交 True 相交 False"}, {"ctype": "code", "data": "set1 = {'小明', '小红', '小黄', '小粉'}\nset2 = {'小黄', '小粉'}\n\nres = set1.isdisjoint(set2)\nprint(res)\t# False\n"}, {"ctype": "head", "data": "2.相关函数"}, {"ctype": "head", "data": "1.增"}, {"ctype": "head", "data": "1.add()"}, {"ctype": "p", "data": "向集合中添加数据(一次加一个)"}, {"ctype": "code", "data": "setvar = {'诺手', '瑞文'}\nsetvar.add('VN')\n\nprint(setvar)\t# {'诺手', 'VN', '瑞文'}\n"}, {"ctype": "head", "data": "2.update()"}, {"ctype": "p", "data": "迭代增加(一次一堆)"}, {"ctype": "code", "data": "setvar = {'诺手', '瑞文'}\nlst = ['风女', '流浪', '提莫']\n\nsetvar.update(lst)\nprint(setvar)\t# {'风女', '流浪', '瑞文', '提莫', '诺手'}\n"}, {"ctype": "head", "data": "2.删"}, {"ctype": "head", "data": "1.clear()"}, {"ctype": "p", "data": "清空集合"}, {"ctype": "code", "data": "setvar = {'诺手', '瑞文'}\n\nsetvar.clear()\nprint(setvar)\t# set()\n"}, {"ctype": "head", "data": "2.pop()"}, {"ctype": "p", "data": "随机删除集合中的一个数据"}, {"ctype": "code", "data": "setvar = {'诺手', '瑞文'}\n\nres = setvar.pop()\nprint(res)\nprint(setvar)\n"}, {"ctype": "head", "data": "3.remove()"}, {"ctype": "p", "data": "删除集合指定的值,不存在会报错"}, {"ctype": "code", "data": "setvar = {'诺手', '瑞文'}\n\n# setvar.remove('瑞文1') error\nsetvar.remove('诺手')\nprint(setvar)\n"}, {"ctype": "head", "data": "4.discard()"}, {"ctype": "p", "data": "删除集合中指定的值(不存在的不删除 推荐使用)"}, {"ctype": "code", "data": "setvar = {'诺手', '瑞文'}\n\nsetvar.discard('瑞文1')\nprint(setvar)\n"}, {"ctype": "head", "data": "3.冰冻集合frozenset()"}, {"ctype": "p", "data": "1.frozenset() 可强转容器类型数据变为冰冻集合 2.冰冻集合一旦创建,不能在进行任何修改,只能做交差并补操作"}, {"ctype": "code", "data": "lst1 = [1, 2, 3]\nlst2 = ['a', 'b', 'c']\nfz1 = frozenset(lst1)\nfz2 = frozenset(lst2)\n\nprint(fz1, type(fz1))\n# 冰冻集合只能做交差并补\nres = fz1 - fz2\nprint(res)\n\n# 尝试添加元素到集合中? 不可以\n# fz1.add(2)  error\n# print(fz1)\n"}, {"ctype": "head", "data": "三.文件的操作"}, {"ctype": "code", "data": "fp = open(文件名,模式,编码集)\nfp : 文件io对象 (文件句柄)\ni  : input 输入\no  : output 输出\n\nfp.write()  写入\nfp.read()   读取\n"}, {"ctype": "head", "data": "1.文件的写入操作"}, {"ctype": "code", "data": "# 1.打开文件\nfp = open('0322.txt', 'w', encoding='utf-8')  # 打开冰箱\n# 2.写入数据\nfp.write('把大象放进去')  # 把大象放进去\n# 3.关闭文件\nfp.close()  # 关闭冰箱\n"}, {"ctype": "head", "data": "2.文件的读取操作"}, {"ctype": "code", "data": "# 1.打开文件\nfp = open('0322.txt', 'r', encoding='utf-8')\n# 2.读取数据\nprint(fp.read())\n# 3.关闭文件\nfp.close()\n"}, {"ctype": "head", "data": "3.字节流"}, {"ctype": "code", "data": "字节流: 数据传输或存储的一种二进制格式,多个字节组合在一起就是字节流\nb'abc': b开头的字节流,必须符合ascii编码标准,不能是中文或其他字符\n\n将字符串和字节流(Bytes)类型进行转换 (参数写成转化的字符编码格式)\n\tencode() 编码 将字符串转化为字节流(Bytes流)\n\tdecode() 解码 将Bytes流转化为字符串\n"}, {"ctype": "code", "data": "bytes_str = b'abc'\n# bytes_str = b'你好'  error\nprint(bytes_str, type(bytes_str))\n\nstrvar = '你好'\n# encode() 编码 将字符串转化为字节流(Bytes流)\nres = strvar.encode('utf-8')\nprint(res, type(res))\n\n# decode() 解码 将Bytes流转化为字符串\nres2 = res.decode('utf-8')\nprint(res2, type(res2))\n\n# utf-8编码下,一个中文三个字节\nbytes_str = b'\\xe4\\xbd\\xa0'\nres = bytes_str.decode('utf-8')\nprint(res)\n\n\n# 程序员表达爱意\nstrvar = \"我爱你,不管你知不知道反正我说了\"\nres = strvar.encode()\nprint(res)\nprint(res.decode())\n"}, {"ctype": "head", "data": "4.字节流的写入操作"}, {"ctype": "p", "data": "如果是字节流模式,不需要指定任何的编码集"}, {"ctype": "code", "data": "fp = open('0323.txt', 'wb')\nfp.write(res)\nfp.close()\n"}, {"ctype": "head", "data": "5.字节流的读取操作"}, {"ctype": "code", "data": "fp = open('0323.txt', 'rb')\nprint(fp.read())\nfp.close()\nprint(res.decode())\n"}, {"ctype": "head", "data": "6.复制图片"}, {"ctype": "p", "data": "二进制字节流 => 图片,音频,视频"}, {"ctype": "code", "data": "# 把图片中所有的字节流获取一下\nfp = open('1.png', 'rb')\nbytes_date = fp.read()\nfp.close()\n\n# 存入到第二个文件中,形成图片文件\nfp = open('2.jpg', 'wb')\nfp.write(bytes_date)\nfp.close()\n\n"}, {"ctype": "head", "data": "四.文件的扩展模式 +"}, {"ctype": "code", "data": "utf-8 编码格式下 默认一个中文三个字节 一个英文或符号 占用一个字节\nread()  功能: 读取字符的个数(里面的参数代表字符个数)\nseek()  功能: 调整至真的位置(里面的参数代表字节个数)\n\tseek(0) 移动到开头\n\tseek(0,2) 移动到结尾\ntell()  功能: 当前光标左侧所有的字节数(返回字节数)\n"}, {"ctype": "head", "data": "1.r+ 先读后写"}, {"ctype": "p", "data": "指针光标默认开头,不能自动创建新文件"}, {"ctype": "code", "data": "fp = open('0323.txt', 'r+', encoding='utf-8')\n# 先读\nprint(fp.read())\n# 再写\nfp.write('abce')\n# 移动光标位置\nfp.seek(0)\nprint(fp.read())\n"}, {"ctype": "head", "data": "2.r+ 先写后读"}, {"ctype": "code", "data": "fp = open('0323.txt', 'r+', encoding='utf-8')\n# 先写\n# 为了防止覆盖原内容,直接把光标放到最后\nfp.seek(0, 2)\nfp.write('123')\n# 调整光标位置到开头\nfp.seek(0)\n# 后读\nprint(fp.read())\nfp.close()\n"}, {"ctype": "head", "data": "3.w+ 可读可写"}, {"ctype": "code", "data": "fp = open('0323.txt', 'w+', encoding='utf-8')\nfp.write('111')\n# 移动光标到开头\nfp.seek(0)\nprint(fp.read())\nfp.close()\n"}, {"ctype": "head", "data": "4.a+ 可读可写"}, {"ctype": "code", "data": "fp = open('0324.txt', 'a+', encoding='utf-8')\nfp.write('666')\n# 光标移动到开头\nfp.seek(0)\nprint(fp.read())\nfp.close()\n"}, {"ctype": "head", "data": "5.区分 a+ 和 r+"}, {"ctype": "code", "data": "# fp = open('0324.txt', 'r+', encoding='utf-8')\nfp = open('0324.txt', 'a+', encoding='utf-8')  # 即使移动光标,也在最后追加\nfp.seek(3)\nfp.write('a')\nfp.close()\n"}, {"ctype": "head", "data": "6.tell seek read 三个函数的使用"}, {"ctype": "code", "data": "fp = open('0324.txt', 'r+', encoding='utf-8')\n# 移动5个字节\nfp.seek(5)\n# 读取3个字符,取决于模式,如果是字符串模式单位是字符个数,如果是字节流模式,单位是字节的个数\nfp.read(3)\nprint(fp.tell())\nfp.close()\n"}, {"ctype": "code", "data": "# 注意点 : 有可能把光标移动到字符中的一个字节里,出现无效开始字节出现报错\nfp = open('0325.txt', 'r+', encoding='utf-8')\n# print(fp.read(3))\n# print(fp.tell())\n\nfp.seek(4)  # error b'\\xe4\\xbd\\xa0'b'\\xe4\\xbd\\xa0'\n# print(fp.read())  error\nfp.close()\n"}, {"ctype": "head", "data": "7.复制图片"}, {"ctype": "p", "data": "使用with语法进行优化 [可以自动实现文件关闭功能]"}, {"ctype": "code", "data": "with open('1.jpg', 'rb') as f:\n\tbytes_date = f.read()\n# 存入到第二个文件中,形成图片\nwith open('1-1.png', 'wb') as f:\n\tf.write(bytes_date)\n\n# 优化写法\nwith open('1.jpg', 'rb') as f1, open('2-1.jpg', 'wb') as f2:\n\tf2.write(f1.read())\n"}, {"ctype": "head", "data": "五.文件的相关函数"}, {"ctype": "head", "data": "1.刷新缓冲区"}, {"ctype": "code", "data": "'''\n刷新缓冲区 flush\n当文件关闭的时候自动刷新缓冲区\n当整个程序运行结束的时候自动刷新缓冲区\n当缓冲区写满了 会自动刷新缓冲区\n手动刷新缓冲区\n'''\nfp = open('1.txt', 'a+', encoding='utf-8')\nfp.write('qqq')\n# 手动刷新缓冲区,直接把内容写入到文件中\nfp.flush()\nwhile 1:\n\tpass\n"}, {"ctype": "head", "data": "2.相关函数"}, {"ctype": "head", "data": "1.readable(),writable()"}, {"ctype": "p", "data": "readable() 功能: 判断文件对象是否可读 writable() 功能: 判断文件对象是否可写"}, {"ctype": "code", "data": "fp =open('1.txt', 'w', encoding='utf-8')\nprint(fp.readable())  # False\nprint(fp.writable())  # True\nfp.close()\n"}, {"ctype": "head", "data": "2.readline()"}, {"ctype": "p", "data": "读取一行文件内容"}, {"ctype": "code", "data": "'''\nreadline() \n括号里的参数默认不写,读取的是当前行\n如果参数值>当前行字符总个数 => 按照当前行进行读取\n如果参数值<当前行字符总个数 => 按照参数个数来读取\n'''\n# 1.1默认读取一行\nwith open('2.txt', 'r+', encoding='utf-8') as f:\n\tres = f.readline()  # 当前行\n\tres = f.readline(4)  # 读四个\n\tres = f.readline(10000)  # 当前行\n\tprint(res)\n\n# 1.2读取所有内容\nwith open('2.txt', 'r+', encoding='utf-8') as f:\n\t# 先读取一行\n\tres = f.readline()\n\t# 如果不为空,开始循环\n\twhile res:\n\t\t# 打印数据\n\t\tprint(res)\n\t\t# 再读一行\n\t\tres = f.readline()\n\n# 1.3可以直接遍历文件对象f(可迭代对象)一行一行遍历文件中的数据\nwith open('2.txt', 'r+', encoding='utf-8') as f:\n\tfor i in f:\n\t\tprint(i)\n"}, {"ctype": "head", "data": "3.readlines()"}, {"ctype": "p", "data": "将文件中的内容按照换行读取到列表当中"}, {"ctype": "code", "data": "with open('2.txt', 'r+', encoding='utf-8') as f:\n\tlst = f.readlines()\n\tprint(lst)\n\n# 把数据两边的空白符去掉,返回新列表\nnew_lst = []\nfor i in lst:\n\tnew_lst.append(i.strip())  # 去掉两边空格,并添加到新列表中\nprint(new_lst)\n"}, {"ctype": "head", "data": "4.wirtelines()"}, {"ctype": "p", "data": "将内容是字符串的可迭代性数据写入文件中 参数:内容为字符串类型的可迭代性数据"}, {"ctype": "code", "data": "lst = ['床前明月光', '疑是地上霜', '举头望明月', '低头思故乡']\nnew_lst = []\nwith open('3.txt', 'w+', encoding='utf-8') as f:\n\tfor i in lst:\n\t\tnew_lst.append(i + '\\n')\n\tf.writelines(new_lst)\n"}, {"ctype": "p", "data": "在地上霜后面加上 我的大刀早已饥渴难耐"}, {"ctype": "code", "data": "lst = ['床前明月光', '疑是地上霜', '举头望明月', '低头思故乡']\nnew_lst = []\nwith open('4.txt', 'w+', encoding='utf-8') as f:\n\tlst.insert(2, '我的大刀早已饥渴难耐')\n\tfor i in lst:\n\t\tnew_lst.append(i + '\\n')\n\tf.writelines(new_lst)\n"}, {"ctype": "head", "data": "5.truncate()"}, {"ctype": "p", "data": "把要截取的字符串提出来,然后清空内容将提取的字符串重新写入到文件中(字节)"}, {"ctype": "code", "data": "with open('5.txt', 'r+', encoding='utf-8') as f:\n\t# truncate(字节) 截取 -> 清空 -> 重写\n\tf.truncate(23)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327000516381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTYwMDMy,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "支持向量机可视化", "作者": "sinat_37050813", "发布时间": "2021-03-27 00:11:34", "内容": [{"ctype": "p", "data": "以《机器学习》书中的数据为例，绘制决策边界，并对支持向量进行标注"}, {"ctype": "code", "data": "data = np.array(\n       [[0.697, 0.460, 1],\n        [0.774, 0.376, 1],\n        [0.634, 0.264, 1],\n        [0.608, 0.318, 1],\n        [0.556, 0.215, 1],\n        [0.403, 0.237, 1],\n        [0.481, 0.149, 1],\n        [0.437, 0.211, 1],\n        [0.666, 0.091, 0],\n        [0.243, 0.267, 0],\n        [0.245, 0.057, 0],\n        [0.343, 0.099, 0],\n        [0.639, 0.161, 0],\n        [0.657, 0.198, 0],\n        [0.360, 0.370, 0],\n        [0.593, 0.042, 0],\n        [0.719, 0.103, 0]])\n"}, {"ctype": "code", "data": "def plot_support(support_vector, data, labels, clf):\n    for i in range(len(data)):\n        if labels[i] == 1:\n            plt.scatter(data[i][0],data[i][1],c='b',s=20, label = '1')\n        else:\n\t        plt.scatter(data[i][0],data[i][1],c='g',s=20, label = '0')\n    for j in support_vector:\n        plt.scatter(data[j][0], data[j][1], s = 100,c = '',\n                    linewidth=1.5, edgecolor='red')\n    x_tmp = np.linspace(0, 1, 500)\n    y_tmp = np.linspace(0, 0.8, 500)\n    X_tmp, Y_tmp = np.meshgrid(x_tmp, y_tmp)\n    xy = np.vstack([X_tmp.ravel(), Y_tmp.ravel()]).T\n    P = clf.decision_function(xy).reshape(X_tmp.shape)\n    plt.contour(X_tmp, Y_tmp, P, levels=[-1,0,1],colors='k',\n                linewidths=1, linestyles=[\"--\",\"-\",\"--\"])\n    plt.show()\n\n\nX = [i[:2] for i in data]\nY = [i[2] for i in data]\nclf = svm.SVC(C=10)\nclf.fit(X, Y)\nsupport = clf.support_\nplot_support(support, X, Y, clf)\n"}, {"ctype": "p", "data": "效果图如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327001051720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM3MDUwODEz,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "pyInstaller打包用到pygal时遇到的问题", "作者": "s桑梓", "发布时间": "2021-03-27 00:17:54", "内容": [{"ctype": "head", "data": "问题描述："}, {"ctype": "p", "data": "    python调用pygal库后，用pyinnstaller打包后，运行程序的时候出现："}, {"ctype": "p", "data": "        FileNotFoundError: [Errno 2] No such file or directory: ‘C:\\\\Users\\\\XXXX\\\\AppData\\\\Local\\\\Temp\\\\_MEI31482\\\\pygal\\\\css\\\\base.css’（文件找不到错误）"}, {"ctype": "p", "data": "解决方法：     在对应的Python版本路径：“\\Python3p5\\Lib\\site-packages\\PyInstaller\\hooks”下编写hook-pygal.py（py文件名） 文件，内容如下："}, {"ctype": "code", "data": "from PyInstaller.utils.hooks import collect_data_files\ndatas = collect_data_files('pygal')"}, {"ctype": "head", "data": "然后再重新打包即可"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "参考：https://blog.csdn.net/Hello_liucz/article/details/104714893"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "selenium  自动 刷新博客浏览量", "作者": "Gangjian_think", "发布时间": "2021-03-27 00:19:50", "内容": [{"ctype": "head", "data": "selenium 自动 刷新浏览量"}, {"ctype": "code", "data": "\nfrom selenium import webdriver\nimport requests\nimport time\nimport random\n\nrequests.packages.urllib3.disable_warnings()\n\n\ndef get_html_text():\n    driver = webdriver.Chrome()\n    art_url = \"https://blog.csdn.net/Gangjian_0914?spm=1003.2020.3001.5343\"\n    driver.get(art_url)\n    article_num_path = '//*[@id=\"floor-user-profile_485\"]/div/div[1]/div[2]/div[3]/ul/li[2]/a/div[1]'\n    article_num = driver.find_element_by_xpath(article_num_path).get_attribute('innerText')\n    print(\"你有 %s 篇 博客！\" % article_num)\n\n    \"\"\"\n    方法一： for循环 1-> n 依次 遍历所有的 子篇 博客\n    \"\"\"\n    for i in range(1,int(article_num)+1):\n        # article_url_path = '//*[@id=\"floor-user-profile_485\"]/div/div[2]/div/div[2]/div/div[2]/div/article[{}]/a'\n        article_url_path = '//*[@id=\"floor-user-profile_485\"]/div/div[2]/div/div[2]/div/div[2]/div/div/div[{}]/article/a'\n        url_redir = driver.find_element_by_xpath(article_url_path.format(str(i)))\n        url_redir.click()\n        print(\"当前刷新到 第 %s 条 博客！\" % i)\n        time.sleep(3)\n        driver.refresh()\n        t = random.randint(10,30) # 页面停留时间随机，防止被和谐\n        print(\"停留时间 %s s!\" % t)\n        time.sleep(t)\n\n\n    \"\"\"\n    方法二：随机选取 子篇 博客进行刷新  (建议使用随机刷新)\n    for num in range(1, 50):\n        i = random.randint(1, int(article_num) + 1)\n        article_url_path = '//*[@id=\"floor-user-profile_485\"]/div/div[2]/div/div[2]/div/div[2]/div/div/div[{}]/article/a'\n        url_redir = driver.find_element_by_xpath(article_url_path.format(str(i)))\n        url_redir.click()\n        print(\"当前刷新到 第 %s 条 博客！\" % i)\n        time.sleep(3)\n        driver.refresh()\n        t = random.randint(10, 30)  # 页面停留时间随机，防止被和谐\n        print(\"停留时间 %s s!\" % t)\n        time.sleep(t)\n\n    \"\"\"\n    # if i == article_num:\n    driver.quit()\n\n\nget_html_text()\n\n"}], "cate": "Python"}
{"题目": "Django——用户session配置", "作者": "jammny", "发布时间": "2021-03-27 00:41:07", "内容": [{"ctype": "head", "data": "一、cookie和session的区别"}, {"ctype": "p", "data": "cookie是保存在客户端中，而session一般是保存在服务端中。Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。两者相比使用session会比较安全点，因此后台管理员用户的信息一般都保存在session中。"}, {"ctype": "p", "data": "session只能够存储字典。"}, {"ctype": "head", "data": "二、配置session具体信息"}, {"ctype": "code", "data": "'''\n/setting.py\n'''\nSESSION_ENGINE = 'django.contrib.sessions.backends.db'  # 引擎（默认）\nSESSION_COOKIE_NAME = \"sessionid\"  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）\nSESSION_COOKIE_PATH = \"/\"  # Session的cookie保存的路径（默认）\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名（默认）\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie（默认）\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输（默认）\nSESSION_COOKIE_AGE = 1800  # Session的cookie失效日期，单位秒（默认2周）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = True  # 是否关闭浏览器使得Session过期（默认关闭）\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存（默认）"}, {"ctype": "head", "data": "三、session具体使用"}, {"ctype": "p", "data": "1、设置session：request.session['userinfo'] = name"}, {"ctype": "p", "data": "2、获取session在cookie中存储的key：sessionKey = request.session.session_key"}, {"ctype": "p", "data": "3、删除当前session：request.session.delete(sessionKey)"}, {"ctype": "code", "data": "'''\n# 具体使用场景\n'''\n\n#登陆认证\nclass Login(View):\n    def post(self, request):\n        username = request.POST.get('username')\n        password = request.POST.get('password')\n        if username == 'admin' and password == 'admin':\n            request.session['userinfo'] = username  # 设置session\n            \n    def get(self, request):\n                pass\n\n#注销\ndef logout(request):\n    sessionKey = request.session.session_key # 获取session在cookie中存储的key\n    if sessionKey:\n        request.session.delete(sessionKey) # 删除当前session"}, {"ctype": "p", "data": "除此之外，还有一些不常用的使用"}, {"ctype": "p", "data": "4、设置过期时间：request.session.set_expiry(time)"}, {"ctype": "p", "data": "● 如果time是整数，Session会在这些秒数后失效。"}, {"ctype": "p", "data": "● 如果time是datatime或timedelta, Session会在这个时间后失效。"}, {"ctype": "p", "data": "● 如果time是0，Session会在用户关闭浏览器后失效。"}, {"ctype": "p", "data": "● 如果time是None, Session会依赖全局Session失效策略。"}, {"ctype": "p", "data": "5、获取seesion的值：request.session.get('key',None)"}, {"ctype": "p", "data": "6、删除seesion：del request.session('key')"}, {"ctype": "p", "data": "7、获取所有session的key和value："}, {"ctype": "p", "data": "request.session.values()"}, {"ctype": "p", "data": "request.session.keys()"}, {"ctype": "p", "data": "request.session.items()"}], "cate": "Python"}
{"题目": "力扣岛屿数量题解", "作者": "castingA3T", "发布时间": "2021-03-27 00:53:09", "内容": [{"ctype": "p", "data": "原题连接：https://leetcode-cn.com/problems/number-of-islands/"}, {"ctype": "code", "data": "给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n\n\n示例 1：\n\n输入：grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n输出：1\n示例 2：\n\n输入：grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n输出：3\n\n\n提示：\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] 的值为 '0' 或 '1'\n通过次数224,926提交次数423,888"}, {"ctype": "p", "data": "可以使用广度优先搜索的策略："}, {"ctype": "p", "data": "先从头开始检查，如果检查到第一个1时，岛屿数量就加1，然后把这个1改为0；"}, {"ctype": "p", "data": "和这个1相邻的，都加入到队列中，再次检查，如果检查到1，就再改为0，直到队列中的坐标为0为止；"}, {"ctype": "code", "data": "grid = [[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"1\"],[\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"1\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"0\",\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\"],[\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\"],[\"0\",\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"0\",\"1\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\"],[\"1\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"1\",\"1\",\"0\",\"0\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"1\",\"1\",\"0\",\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"1\",\"0\",\"0\",\"1\",\"1\"],[\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"1\",\"1\",\"0\",\"0\",\"0\"]]\n\n\ncount = 0  # 存储岛屿数量\nfor i in range(len(grid)):\n    for j in range(len(grid[0])):\n        if grid[i][j] == '0':\n            continue\n        # 如果是1，就加入到队列中检查，是1的话它的邻居也要加入到队列中\n        queue = [[i,j]]\n        while queue:\n            m,n = queue.pop(0)  # 使用列表pop的方法弹出一个坐标\n            # 不能越界且检查到1\n            if 0<=m<len(grid) and 0<=n<len(grid[0]) and grid[m][n] == '1':\n                grid[m][n] = '0'\n                # 1的邻居加入到队列中检查\n                queue += [[m+1,n],[m-1,n],[m,n-1],[m,n+1]]\n        count += 1\nprint(count)"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "scrapy爬虫学习  安装scrapy 新建项目 启动爬虫", "作者": "打小我就狂", "发布时间": "2021-03-27 12:17:52", "内容": [{"ctype": "head", "data": "1.安装:"}, {"ctype": "head", "data": "第一种容易出错:"}, {"ctype": "p", "data": "     pip install -i http://pypi.douban.com/simple scrapy"}, {"ctype": "head", "data": "第二种下载安装包安装:"}, {"ctype": "head", "data": "网站:https://www.lfd.uci.edu/~gohlke/pythonlibs/"}, {"ctype": "head", "data": "需要下载的4个包:"}, {"ctype": "head", "data": "1.lxml"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010407774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.twisted 高性能的包重要"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010505982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.scrapy:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010540496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4.PyWin32"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010622663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "安装 最好按顺序安装最后安卓scrapy:"}, {"ctype": "p", "data": "CMD进入到下载的包目录下"}, {"ctype": "p", "data": "1."}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010741284.png"}, {"ctype": "p", "data": "2."}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032701081917.png"}, {"ctype": "p", "data": "3."}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010837775.png"}, {"ctype": "p", "data": "4."}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327010928956.png"}, {"ctype": "head", "data": "完成:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011002542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "创建项目目录框架:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032701103647.png"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011056117.png"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011326541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "创建爬虫文件:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011610494.png"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011638144.png"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032701165193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "启动爬虫:"}, {"ctype": "head", "data": "1.CMD启动"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327011816418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.pycharm启动调试:"}, {"ctype": "p", "data": "生成main文件.处理命令:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327113643358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327113732970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDk1NzAx,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "from scrapy.cmdline import execute\n\nimport sys\nimport os\n\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\nexecute([\"scrapy\", \"crawl\", \"jobbole\"])\n"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "2021最新 超详细环境配置 避开安装cuda所有坑", "作者": "小生听雨园", "发布时间": "2021-03-27 11:09:59", "内容": [{"ctype": "head", "data": "先安装好Anaconda"}, {"ctype": "p", "data": "(说一下背景：我安装了三天配置cuda的环境 一度怀疑自己。甚至准备淘宝找人安装了，安装好之后，我把自己踩过的坑总结了一下)"}, {"ctype": "head", "data": "1.提供几个会用到的网站"}, {"ctype": "p", "data": "cuda toolkit历史版本：https://developer.nvidia.com/cuda-toolkit-archive cuda toolkit最新版本：https://developer.nvidia.com/cuda-downloads pytorch：https://pytorch.org visual studio2019：https://visualstudio.microsoft.com/zh-hans/vs/"}, {"ctype": "head", "data": "2.检查当前显卡驱动能支持的最高cuda版本"}, {"ctype": "head", "data": "2.1命令行"}, {"ctype": "p", "data": "nvidia-smi  显示的cuda version就是支持的最高版本"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327095646761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.2控制面板"}, {"ctype": "p", "data": "  其实也可以不用检查，安装11.1版本cuda，他会自动将当前显卡驱动升级"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327095821213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.安装visual studio2019"}, {"ctype": "p", "data": "网址：Visual studio.  这样选择就行，记得！！Community, 安装好之后"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327100605120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4.安装cuda"}, {"ctype": "p", "data": " 选择哪个都行，network最好挂梯子，其实差不多  以管理员身份运行  勾选这几个必须的就行 然后安装结束会提示其他版本visual studio没安装， 勾选lunch samples!!! 没报错就安装完成了 打开命令行，输入 nvcc -V"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327100833341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "5.配置环境变量"}, {"ctype": "p", "data": "下面的两个就是你的安装目录，会自动配置好，和Path同级 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327102332370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "\nCUDA_SDK_PATH = G:\\nvidia cuda\nCUDA_LIB_PATH = %CUDA_PATH%\\lib\\x64\nCUDA_BIN_PATH = %CUDA_PATH%\\bin\nCUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\\bin\\win64\nCUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\\common\\lib\\x64\n\n"}, {"ctype": "p", "data": "环境变量配置完记得重启 进入安装路径G:\\nvidia cuda\\extras\\demo_suite 输入 bandwidthTest.exe 和 deviceQuery.exe分别提示Rsult=PASS 则安装成功"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327103959204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "6.安装pytorch"}, {"ctype": "p", "data": "在用户目录下，··``C:\\Users\\29676 备份一下， 许多教程里面都告诉添加清华镜像，但是这里不建议，可以添加中科大镜像 因为清华镜像下载到的不是gpu版本的，而是cpu版本的 记得开梯子！！！"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327104221973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "6.1创建虚拟环境"}, {"ctype": "p", "data": "不要添加清华镜像，否则安装py3.7版本的虚拟环境会报错。因为镜像站没有3.7 conda create -n learn_env python=3.7创建python3.7的虚拟环境 conda activate learn_env激活  按照这样选，别选conda安装 在上一部激活的虚拟环境里执行 pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html 失败就多运行几次 （不支持断点续传的原因） 安装好之后，python进入python"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327105202399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import torch\ntorch.cuda.is_available()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327105650980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1NDA5NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "如果为false的话看看其他博文，"}, {"ctype": "head", "data": "7.安装jupyter"}, {"ctype": "p", "data": "虽然安装好anaconda后，会自动安装jupyter，但他无法使用虚拟环境 我们决定在虚拟环境里面安装jupyter 在上一步退出pyhon exit() 别退出虚拟环境"}, {"ctype": "head", "data": "7.1"}, {"ctype": "code", "data": "conda install nb_conda\n"}, {"ctype": "p", "data": "安装完后"}, {"ctype": "code", "data": "jupyter notebook\n"}, {"ctype": "p", "data": "即可调用，而且anaconda prompt必须以管理员身份运行，否则，jupyter创建新项目会出错"}, {"ctype": "p", "data": "原创文章转载请标明出处"}], "cate": "Python"}
{"题目": "selenium.common.exceptions.WebDriverException: Message: newSession", "作者": "嘟啦~", "发布时间": "2021-03-27 10:08:06", "内容": [{"ctype": "head", "data": "web自动化测试配置环境错误"}, {"ctype": "p", "data": "今天在安装selenium和webdriver时出现了错误，测试用的是火狐浏览器，语言是python，集成开发环境是pycharm。错误如下："}, {"ctype": "p", "data": "Traceback (most recent call last): File “F:/Selenium3_python/test.py”, line 2, in  driver=webdriver.Firefox() File “D:\\python3.7.6\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py”, line 154, in init keep_alive=True) File “D:\\python3.7.6\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py”, line 151, in init self.start_session(desired_capabilities, browser_profile) File “D:\\python3.7.6\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py”, line 240, in start_session response = self.execute(Command.NEW_SESSION, parameters) File “D:\\python3.7.6\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py”, line 308, in execute self.error_handler.check_response(response) File “D:\\python3.7.6\\lib\\site-packages\\selenium\\webdriver\\remote\\errorhandler.py”, line 194, in check_response raise exception_class(message, screen, stacktrace) selenium.common.exceptions.WebDriverException: Message: newSession "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327095206891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA4ODk2Mg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "解决办法"}, {"ctype": "code", "data": "把geckodriver升级到最新版本，并放在python安装路径下的Scripts文件夹下\n下载链接为：https://github.com/mozilla/geckodriver/releases\n我下载的是最新版 0.29.0\n"}, {"ctype": "p", "data": " 祝愿各位安装配置永远没有错，哈哈哈哈哈"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032709583760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA4ODk2Mg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "tabulate库：我去年制了个表", "作者": "织夜虫", "发布时间": "2021-03-27 10:18:28", "内容": [{"ctype": "head", "data": "功能"}, {"ctype": "p", "data": "python的tabulate库提供打印表格数据的功能，支持以下数据类型："}, {"ctype": "p", "data": "输出表格可以通过参数自定义风格"}, {"ctype": "head", "data": "tabulate库的函数"}, {"ctype": "p", "data": "tabulate库只有一个函数tabulate()"}, {"ctype": "p", "data": "介绍一些常用参数："}, {"ctype": "code", "data": "from tabulate import tabulate\ntable=[['张三','北京','男'],\\\n        ['李四','上海','男'],\\\n        ['洛丽','南宁','女'],]\nheader=['姓名','祖籍','性别']\nprint(tabulate(table,headers=header,showindex='always'))\n"}, {"ctype": "p", "data": "输出如下："}, {"ctype": "code", "data": "    姓名    祖籍    性别\n--  ----  ----  ----\n 0  张三    北京    男\n 1  李四    上海    男\n 2  洛丽    南宁    女\n"}, {"ctype": "code", "data": "+----+------+------+------+\n|    | 姓名   | 祖籍   | 性别   |\n+====+======+======+======+\n|  0 | 张三   | 北京   | 男    |\n+----+------+------+------+\n|  1 | 李四   | 上海   | 男    |\n+----+------+------+------+\n|  2 | 洛丽   | 南宁   | 女    |\n+----+------+------+------+\n"}, {"ctype": "p", "data": "可用格式有："}, {"ctype": "p", "data": "plainsimplegithubgridfancy_gridpipeorgtbljiraprestoprettypsqlrstmediawikimoinmoinyoutrackhtml\"unsafehtmllatexlatex_rawlatex_booktabslatex_longtabletextiletsv"}, {"ctype": "code", "data": "print(tabulate([[1.2345],[12.345],[123.45],[1234.5],[12345]]))\nprint(tabulate([[1.2345],[12.345],[123.45],[1234.5],[12345]],numalign='left'))\n"}, {"ctype": "p", "data": "输出如下："}, {"ctype": "code", "data": "----------\n    1.2345\n   12.345\n  123.45\n 1234.5\n12345\n----------\n------\n1.2345\n12.345\n123.45\n1234.5\n12345\n------\n"}, {"ctype": "code", "data": "print(tabulate([[\"pi\",3.141593],[\"e\",2.718282]], floatfmt=\".3f\"))\n"}, {"ctype": "p", "data": "​ 输出："}, {"ctype": "code", "data": "--  -----\npi  3.142\ne   2.718\n--  -----\n"}, {"ctype": "p", "data": "也可以像colalign的格式一样控制每一列不同的精确度"}, {"ctype": "p", "data": "详情参考官方文档"}], "cate": "Python"}
{"题目": "批量删除repos库", "作者": "茁壮小草", "发布时间": "2021-03-27 11:07:42", "内容": [{"ctype": "p", "data": "以前，装作很好学的样子，fork了不少别的代码，然鹅一个都没有认真学习下，就放哪儿了几年，实在无法忍受自己github库的杂乱，想着去整理下，当70多个库，一个个删除，预估得1个多小时。在网上查了下别的方法，也结合别人写的做了有一些尝试，现在将内容写成博客记录。"}, {"ctype": "head", "data": "生成删除权限的toekn"}, {"ctype": "head", "data": "参考github开发文档"}, {"ctype": "p", "data": "文档有关链接如下：https://docs.github.com/en/rest/reference/repos#delete-a-repository"}, {"ctype": "p", "data": "Delelte API 接口如下："}, {"ctype": "code", "data": "/repos/{owner}/{repo}\n"}, {"ctype": "p", "data": "官网删除的案例："}, {"ctype": "code", "data": "curl \\\n  -X DELETE \\\n  -H \"Accept: application/vnd.github.v3+json\" \\\n  https://api.github.com/repos/octocat/hello-world\n"}, {"ctype": "p", "data": "改为python案例后："}, {"ctype": "code", "data": "# encoding=utf-8\nfrom time import sleep\nimport requests\nimport logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n\nheaders = {\n    \"Accept\": \"application/vnd.github.v3+json\",\n    \"Authorization\": \"token xxx\", # 此处贴token\n    \"X-OAuth-Scopes\": \"repo\"\n}\n\nwith open('/Users/zhang/Desktop/repos.txt', 'r', encoding='utf-8') as f:\n    data = f.readlines()\n\nurl = \"https://api.github.com/repos/{}/{}\"\nurls = []\nfor line in data:\n    name, repo = line.strip().split(\"/\")\n    urls.append(url.format(name, repo))\n\nfor l in urls:\n    logger.info('删除repos链接：%s' % l)\n    res = requests.delete(url=l, headers=headers)\n    logger.info('删除状态：%s' % res)\n"}, {"ctype": "p", "data": "注意：repos.txt格式如下："}, {"ctype": "code", "data": "zhangwe/nlp\nzhangwe/math\nzhangwe/line\n"}], "cate": "Python"}
{"题目": "刷题笔记：网易2021校招笔试题电影院选座", "作者": "import_torch_as_tf", "发布时间": "2021-03-27 10:48:35", "内容": [{"ctype": "p", "data": "题目描述："}, {"ctype": "p", "data": "疫情逐步缓和后，电影院终于开业了，但是由于当前仍处于疫情期间，应尽量保持人群不聚集的原则。 所以当小易来电影院选定一排后，尽量需要选择一个远离人群的位置。 已知由0和1组成的数组表示当前排的座位情况,其中1表示已被选座，0表示空座 请问小易所选座位和最近人的距离座位数最大是多少？ 有如下假设：至少有一个人已选座，至少有一个空座位，且座位数限制为"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327103722365.png"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327103749362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hzcHl6bQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "我的思路："}, {"ctype": "p", "data": "需要找到数组中长度最长的连续为0的子数组，长度记为m，然后（m+1）//2就是答案，但是有两种情况是特例，那就是最长的0子数组刚好在数组的左右边界时，像[0,0,0,0,1,0,1]，这时0数组的长度4就是答案，所以这种情况要特殊考虑。"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": "a = list(map(int, input().split()))\nres = []\ni = 0\nl = a.index(1)#左边界0数组的长度\nr = a[::-1].index(1)#右边界0数组的长度\nm = 0\nfor i in range(1,len(a)-1):#找数组中间0数组的最大长度，因为数组中不是0就是1，所以可以用index来得到0数组的长度\n    if 1 in a[i:]:\n        m = max(m, a[i:].index(1))\nprint(max(l,r,(m+1)//2))"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "中文自然语言处理--基于双向GRU 生成各种古诗", "作者": "糯米君_", "发布时间": "2021-03-27 10:52:09", "内容": [{"ctype": "p", "data": "使用 LSTM 的变形 GRU 中文字符级建模，训练出一个能作诗的模型 数据集集为4000+古诗，一行一首，标题、作者已去掉： https://download.csdn.net/download/fgg1234567890/16153813"}, {"ctype": "code", "data": "import os\nimport random\nimport pandas as pd\nimport numpy as np\n# 引入需要的模块\nfrom keras.layers import Bidirectional\nfrom keras.layers import GRU\nimport keras\nfrom keras.callbacks import LambdaCallback\nfrom sklearn.model_selection import train_test_split\nfrom keras.layers import Dense, Input, Flatten, Dropout\nfrom keras.layers import Embedding\nfrom keras.models import Model\nfrom keras.utils import plot_model\nfrom keras.models import load_model\nfrom keras.optimizers import Adam\n\n# 步骤：\n# 语料准备\n# 语料预处理\n# 模型参数配置\n# 构建模型\n# 训练模型\n# 模型作诗\n# 绘制模型网络结构图\n\npuncs = [']', '[', '（', '）', '{', '}', '：', '《', '》']\n\n# 预处理\ndef preprocess_file(Config):\n    # 语料文本内容\n    files_content = ''\n    with open(Config.poetry_file, 'r', encoding='utf-8') as f:\n        for line in f:\n            # 每行的末尾加上\"]\"符号代表一首诗结束\n            for char in puncs:\n                line = line.replace(char, \"\")\n            files_content += line.strip() + \"]\"\n\n    words = sorted(list(files_content))\n    words.remove(']')\n    counted_words = {}\n    for word in words:\n        if word in counted_words:\n            counted_words[word] += 1\n        else:\n            counted_words[word] = 1\n\n    # 去掉低频的字\n    erase = []\n    for key in counted_words:\n        if counted_words[key] <= 2:\n            erase.append(key)\n    for key in erase:\n        del counted_words[key]\n    del counted_words[']']\n    wordPairs = sorted(counted_words.items(), key=lambda x: -x[1])\n\n    words, _ = zip(*wordPairs)\n    # word到id的映射\n    word2num = dict((c, i+1) for i, c in enumerate(words))\n    num2word = dict((i, c) for i, c in enumerate(words))\n    word2numF = lambda x: word2num.get(x, 0)\n    return word2numF, num2word, words, files_content\n\nclass Config(object):\n    '''\n    模型参数配置。预先定义模型参数和加载语料以及模型保存名称\n    '''\n    poetry_file = './qtais_tab2.txt'\n    weight_file = 'poetry_model.h5'\n    # 根据前六个字预测第七个字\n    max_len = 6\n    batch_size = 512\n    learning_rate = 0.001\n\nclass PoetryModel(object):\n    def __init__(self, config):\n        '''\n        init 函数定义，通过加载 Config 配置信息，进行语料预处理和模型加载，\n        如果模型文件存在则直接加载模型，否则开始训练。\n        '''\n        self.model = None\n        self.do_train = True\n        self.loaded_model = False\n        self.config = config\n\n        # 文件预处理\n        self.word2numF, self.num2word, self.words, self.files_content = preprocess_file(self.config)\n        if os.path.exists(self.config.weight_file):\n            self.model = load_model(self.config.weight_file)\n            self.model.summary()\n        else:\n            self.train()\n        self.do_train = False\n        self.loaded_model = True\n\n    def build_model(self):\n        '''\n        建立模型\n        用 Keras 来构建网络模型，这里使用 LSTM 的 GRU 来实现，当然直接使用 LSTM 也没问题。\n        '''\n        input_tensor = Input(shape=(self.config.max_len,))\n        embedd = Embedding(len(self.num2word)+1, 300, input_length=self.config.max_len)(input_tensor)\n        lstm = Bidirectional(GRU(128, return_sequences=True))(embedd)\n        dropout = Dropout(0.6)(lstm)\n        # lstm = Bidirectional(GRU(128, return_sequences=True))(embedd)\n        # dropout = Dropout(0.6)(lstm)\n        flatten = Flatten()(dropout)\n        dense = Dense(len(self.words), activation='softmax')(flatten)\n        self.model = Model(inputs=input_tensor, outputs=dense)\n        optimizer = Adam(lr=self.config.learning_rate)\n        self.model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])\n\n    def sample(self, preds, temperature=1.0):\n        '''\n        当temperature=1.0时，模型输出正常\n        当temperature=0.5时，模型输出比较open\n        当temperature=1.5时，模型输出比较保守\n        在训练的过程中可以看到temperature不同，结果也不同\n        '''\n        preds = np.asarray(preds).astype('float64')\n        preds = np.log(preds) / temperature\n        exp_preds = np.exp(preds)\n        preds = exp_preds / np.sum(exp_preds)\n        probas = np.random.multinomial(1, preds, 1)\n        return np.argmax(probas)\n\n    def generate_sample_result(self, epoch, logs):\n        '''\n        训练过程中，每个 epoch 打印出当前的学习情况\n        '''\n        print(\"\\n==================Epoch {}=====================\".format(epoch))\n        for diversity in [0.5, 1.0, 1.5]:\n            print(\"------------Diversity {}--------------\".format(diversity))\n            start_index = random.randint(0, len(self.files_content) - self.config.max_len - 1)\n            generated = ''\n            sentence = self.files_content[start_index: start_index + self.config.max_len]\n            generated += sentence\n            for i in range(20):\n                x_pred = np.zeros((1, self.config.max_len))\n                for t, char in enumerate(sentence[-6:]):\n                    x_pred[0, t] = self.word2numF(char)\n\n                preds = self.model.predict(x_pred, verbose=0)[0]\n                next_index = self.sample(preds, diversity)\n                next_char = self.num2word[next_index]\n                generated += next_char\n                sentence = sentence + next_char\n            print(sentence)\n\n    def predict(self, text):\n        '''\n        根据给定的提示，来进行预测。\n        根据给出的文字，生成诗句，如果给的 text 不到四个字，则随机补全。\n        '''\n        if not self.loaded_model:\n            return\n        with open(self.config.poetry_file, 'r', encoding='utf-8') as f:\n            file_list = f.readlines()\n        random_line = random.choice(file_list)\n        # 如果给的text不到四个字，则随机补全\n        if not text or len(text) != 4:\n            for _ in range(4 - len(text)):\n                random_str_index = random.randrange(0, len(self.words))\n                text += self.num2word.get(random_str_index) if self.num2word.get(random_str_index) not in [',', '。',\n                                                                                                           '，'] else self.num2word.get(\n                    random_str_index + 1)\n        seed = random_line[-(self.config.max_len):-1]\n        res = ''\n        seed = 'c' + seed\n        for c in text:\n            seed = seed[1:] + c\n            for j in range(5):\n                x_pred = np.zeros((1, self.config.max_len))\n                for t, char in enumerate(seed):\n                    x_pred[0, t] = self.word2numF(char)\n                preds = self.model.predict(x_pred, verbose=0)[0]\n                next_index = self.sample(preds, 1.0)\n                next_char = self.num2word[next_index]\n                seed = seed[1:] + next_char\n            res += seed\n        return res\n\n    def data_generator(self):\n        '''\n        用于生成数据，提供给模型训练时使用。\n        给定前六个字，生成第七个字，所以在后面生成训练数据的时候，会以6的跨度，1的步长截取文字，生成语料。\n        如果出现了 ] 符号，说明 ] 符号之前的语句和之后的语句是两首诗里面的内容，\n        两首诗之间是没有关联关系的，所以我们后面会舍弃掉包含 ] 符号的训练数据。\n        '''\n        print(\"len(self.files_content):\", len(self.files_content))\n        i = 0\n        while 1:\n            x = self.files_content[i: i + self.config.max_len]\n            y = self.files_content[i + self.config.max_len]\n            puncs = [']', '[', '（', '）', '{', '}', '：', '《', '》', ':']\n            if len([i for i in puncs if i in x]) != 0:\n                i += 1\n                continue\n            if len([i for i in puncs if i in y]) != 0:\n                i += 1\n                continue\n            y_vec = np.zeros(\n                shape=(1, len(self.words)),\n                dtype=np.bool\n            )\n            y_vec[0, self.word2numF(y)] = 1.0\n            x_vec = np.zeros(\n                shape=(1, self.config.max_len),\n                dtype=np.int32\n            )\n            for t, char in enumerate(x):\n                x_vec[0, t] = self.word2numF(char)\n            yield x_vec, y_vec\n            i += 1\n\n    def train(self):\n        '''\n        用来进行模型训练。\n        TensorFlow回调函数：tf.keras.callbacks.LambdaCallback:\n        用于动态创建简单的自定义回调的回调。\n        此回调是使用将在适当时间调用的匿名函数构造的。请注意，回调需要位置参数，如下所示：\n        on_epoch_begin和on_epoch_end要求两个位置参数： epoch，logs\n        on_batch_begin和on_batch_end要求两个位置参数： batch，logs\n        on_train_begin并on_train_end要求一个位置参数： logs\n        参数：\n        on_epoch_begin：在每个epoch开始时调用。\n        on_epoch_end：在每个epoch结束时调用。\n        on_batch_begin：在每个批处理开始时调用。\n        on_batch_end：在每个批处理结束时调用。\n        on_train_begin：在模型训练开始时调用。\n        on_train_end：在模型训练结束时调用。\n        '''\n        # number_of_epoch = len(self.files_content) // self.config.batch_size\n        number_of_epoch = 10\n        if not self.model:\n            self.build_model()\n        self.model.summary()\n        self.model.fit_generator(\n            generator=self.data_generator(),\n            verbose=True,\n            steps_per_epoch=self.config.batch_size,\n            epochs=number_of_epoch,\n            callbacks=[\n                # 该回调函数将在每个epoch后保存模型到filepath\n                keras.callbacks.ModelCheckpoint(self.config.weight_file, save_weights_only=False),\n                LambdaCallback(on_epoch_end=self.generate_sample_result)])\n\nmodel = PoetryModel(Config)\n\ntext = input(\"text:\")\nsentence = model.predict(text)\nprint(sentence)\n# 绘制网络结构图\nplot_model(model.model, to_file='model.png')\n\n"}, {"ctype": "p", "data": "原文： https://soyoger.blog.csdn.net/article/details/108729402"}], "cate": "Python"}
{"题目": "Python 第二章 集合", "作者": "若只如初見~~", "发布时间": "2021-03-27 14:23:51", "内容": [{"ctype": "head", "data": "2.4 集合"}, {"ctype": "p", "data": "1. 基本概念"}, {"ctype": "p", "data": "集合："}, {"ctype": "p", "data": "2. 集合的创建、添加、删除、交集、并集、差集、超集、子集、判断是否相交"}, {"ctype": "p", "data": "2.1 创建集合      创建集合时我们可以先创建一个空字典，会用到 set() 函数，然后再添加元素。 例："}, {"ctype": "code", "data": "s1 = {1, 2, 3, 4, 5, 6, 6, 7}  # 集合中的元素不重复，会自动去重\nprint(s1, type(s1))\n\ns2 = {}                # 定义空字典\nprint(s2, type(s2))\n\ns3 = set([])\nprint(s3, type(s3))    # 定义空集合\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "{1, 2, 3, 4, 5, 6, 7} <class 'set'>\n{} <class 'dict'>\nset() <class 'set'>\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.2 集合中添加元素"}, {"ctype": "p", "data": "例1：s.add(b) 向集合 s 中添加一个元素 b"}, {"ctype": "code", "data": "s = {'beijing', 'shanghai', 'guangzhou'}\ns.add('shenzhen')\nprint(s, type(s))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "{'shenzhen', 'shanghai', 'beijing', 'guangzhou'} <class 'set'>\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "例2：s.update([a、b、c]) 向集合 s 中添加多个元素 a、b、c"}, {"ctype": "code", "data": "s = {'beijing', 'shanghai', 'guangzhou'}\ns.update(['shenzhen', 'hangzhou'])\nprint(s, type(s))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "{'shanghai', 'beijing', 'shenzhen', 'hangzhou', 'guangzhou'} <class 'set'>\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.3 集合中删除元素"}, {"ctype": "p", "data": "例1：s.pop() 随机删除集合中的某个元素"}, {"ctype": "code", "data": "s = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns.pop()\nprint(s, type(s))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "{'shanghai', 'shenzhen', 'beijing', 'hangzhou'} <class 'set'>\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "例2：s.remove(a) 删除集合 s 中指定元素 a"}, {"ctype": "code", "data": "s = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns.remove('guangzhou')\nprint(s, type(s))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "{'hangzhou', 'shanghai', 'shenzhen', 'beijing'} <class 'set'>\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.4 集合的交集      s.intersection(b) 或 s & b 都可以计算出集合 s 和 集合 b 的交集。 例："}, {"ctype": "code", "data": "s1 = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns2 = {'beijing', 'shanghai', 'hangzhou', 'wuhan', 'nanjing'}\nprint('交集:', s1.intersection(s2))\nprint('交集:', s1 & s2)\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "交集: {'hangzhou', 'shanghai', 'beijing'}\n交集: {'hangzhou', 'shanghai', 'beijing'}\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.5 集合的并集      s.union(b) 或 s | b 都可以计算出集合 s 和 集合 b 的交集。 例："}, {"ctype": "code", "data": "s1 = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns2 = {'beijing', 'shanghai', 'hangzhou', 'wuhan', 'nanjing'}\nprint('交集:', s1.union(s2))\nprint('交集:', s1 | s2)\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "并集: {'wuhan', 'beijing', 'nanjing', 'hangzhou', 'shenzhen', 'shanghai', 'guangzhou'}\n并集: {'wuhan', 'beijing', 'nanjing', 'hangzhou', 'shenzhen', 'shanghai', 'guangzhou'}\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.6 集合的差集      s.difference(b) 或 s - （s&b）都可以计算出集合 s 和 集合 b 的差集。 例："}, {"ctype": "code", "data": "s1 = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns2 = {'beijing', 'shanghai', 'hangzhou', 'wuhan', 'nanjing'}\nprint('差集:', s1.difference(s2))\nprint('差集:', s1 - (s1 & s2))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "差集: {'shenzhen', 'guangzhou'}\n差集: {'shenzhen', 'guangzhou'}\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.7 集合的超集      s.issuperset(b) 可以计算出集合 s 是否是集合 b 的超集，即集合 b 包含于集合 a，如果集合 a 和 b 相等则互为超集。 例："}, {"ctype": "code", "data": "s1 = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns2 = {'beijing', 'shanghai', 'hangzhou'}\nprint('超集:', s1.issuperset(s2))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "超集: True\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.8 集合的子集      s.issubset(b) 可以计算出集合 s 是否是集合 b 的子集。 例："}, {"ctype": "code", "data": "s1 = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns2 = {'beijing', 'shanghai', 'hangzhou'}\nprint('子集:', s1.issubset(s2))\nprint('子集:', s2.issubset(s1))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "子集: False\n子集: True\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "2.9 判断两集合是否相交      s.isdisjoint(b) 可以判断集合 s 是否是集合 b 的是否不相交，不相交返回 False，相交返回 True。 例："}, {"ctype": "code", "data": "s1 = {'beijing', 'shanghai', 'guangzhou', 'shenzhen', 'hangzhou'}\ns2 = {'beijing', 'shanghai', 'hangzhou'}\nprint('是否不相交:', s1.isdisjoint(s2))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "是否不相交: False\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "3. 集合特性"}, {"ctype": "p", "data": "3.1 去重      集合中的元素都是唯一的，因此可用来去掉重复值。 例："}, {"ctype": "code", "data": "s1 = [1, 2, 3, 3, 4, 5, 6, 6]\ns2 = set(s1)\nprint(s2, type(s2))\nprint(list(s2), type(list(s2)))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "{1, 2, 3, 4, 5, 6} <class 'set'>\n[1, 2, 3, 4, 5, 6] <class 'list'>\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "3.2 成员操作符      a in b 判断元素 a 是否在集合 b 中。 例："}, {"ctype": "code", "data": "s1 = [1, 2, 3, 3, 4, 5, 6, 6]\nprint(1 in s1)\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "True\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "3.3 迭代：for 循环 例："}, {"ctype": "code", "data": "s1 = [1, 2, 3, 3, 4, 5, 6, 6]\nfor i in s1:\n    print(i)\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "1\n2\n3\n3\n4\n5\n6\n6\n\n进程已结束，退出代码 0\n"}, {"ctype": "p", "data": "3.4 枚举：返回对应元素及其索引值      enumerate（）函数能返回集合中每个元素的下标和值，从而实现索引。 例："}, {"ctype": "code", "data": "s1 = [1, 2, 3, 3, 4, 5, 6, 6]\nfor index, value in enumerate(s1):\n    print('索引：%s,值：%s' % (index, value))\n"}, {"ctype": "p", "data": "输出："}, {"ctype": "code", "data": "索引：0,值：1\n索引：1,值：2\n索引：2,值：3\n索引：3,值：3\n索引：4,值：4\n索引：5,值：5\n索引：6,值：6\n索引：7,值：6\n\n进程已结束，退出代码 0\n"}], "cate": "Python"}
{"题目": "再看Exception in Python", "作者": "quantLearner", "发布时间": "2021-03-27 10:48:15", "内容": [{"ctype": "p", "data": "廖雪峰的官方网站RealPython"}], "cate": "Python"}
{"题目": "python办公自动化之xlsxwriter", "作者": "々橙若℃ №", "发布时间": "2021-03-27 16:03:15", "内容": [{"ctype": "head", "data": "学习目标："}, {"ctype": "head", "data": "学习内容："}, {"ctype": "p", "data": "提示：这里可以添加要学的内容 例如： 1、 xlsxwriter的基本写入"}, {"ctype": "head", "data": "学习时间："}, {"ctype": "p", "data": "提示：这里可以添加计划学习的时间 例如： 1、 2021-03-27 15:30~2021-03-27 17:00"}, {"ctype": "head", "data": "学习记录："}, {"ctype": "head", "data": "1.简介"}, {"ctype": "code", "data": " 1.xlsxwriter相对其他模块支持更多的excel的功能\n 2.100% 兼容excel xlsx文件，支持excel2003 excel2007等版本\n 3.xlsxwriter处理速度更快，支持大文件写入\n"}, {"ctype": "head", "data": "2.安装xlsxwriter"}, {"ctype": "code", "data": " pip install xlswriter\n"}, {"ctype": "head", "data": "3.代码记录"}, {"ctype": "code", "data": "import  xlsxwriter\n#创建工作表\nwriter = xlsxwriter.Workbook('data.xlsx')\n#创建工作sheet\nsheet = writer.add_worksheet('newSheet')\ncellStyle = writer.add_format({'bold':True})\nsheet.write(0,0,'2021年度',cellStyle)\ntitleStyle = writer.add_format()\ntitleStyle.set_size(16)\ntitleStyle.set_color('red')\ntitleStyle.set_align('center')\ntitleStyle.set_bold()\nsheet.merge_range(1,0,2,2,'第一季度的销售统计',titleStyle)\ndata = (\n    ['一月份',500,450],\n    ['二月份', 680, 520],\n    ['三月份', 720, 610],\n)\n#写入表头\nrowStyle = writer.add_format()\nrowStyle.set_bg_color('#808080')\nsheet.write_row(3,0,['月份','预期销售额','实际销售额'],rowStyle)\n\n#写入数据\nfor i,item in enumerate(data):\n    #从0列开始逐行写入数据\n     sheet.write_row(i+4,0,item)\n\n#导入excel公式\nsheet.write(7,1,\"=sum(B5:B7)\")\nsheet.write(7,2,\"=sum(C5:C7)\")\nsheet.write_url(9,0,'https://www.baidu.com',string='更多数据')\nsheet.insert_image(10,0,'view.png')\n#关闭\nwriter.close()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327162528155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyNjUzOTg=,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4.写入图标数据"}, {"ctype": "code", "data": "import  xlsxwriter\n#创建工作表\nwriter = xlsxwriter.Workbook('data.xlsx')\n#创建工作sheet\nsheet = writer.add_worksheet('newSheet')\ncellStyle = writer.add_format({'bold':True})\nsheet.write(0,0,'2021年度',cellStyle)\ntitleStyle = writer.add_format()\ntitleStyle.set_size(16)\ntitleStyle.set_color('red')\ntitleStyle.set_align('center')\ntitleStyle.set_bold()\nsheet.merge_range(1,0,2,2,'第一季度的销售统计',titleStyle)\ndata = (\n    ['一月份',500,450],\n    ['二月份', 680, 520],\n    ['三月份', 720, 610],\n)\n#写入表头\nrowStyle = writer.add_format()\nrowStyle.set_bg_color('#808080')\nsheet.write_row(3,0,['月份','预期销售额','实际销售额'],rowStyle)\n\n#写入数据\nfor i,item in enumerate(data):\n    #从0列开始逐行写入数据\n     sheet.write_row(i+4,0,item)\n\n#导入excel公式\nsheet.write(7,1,\"=sum(B5:B7)\")\nsheet.write(7,2,\"=sum(C5:C7)\")\nsheet.write_url(9,0,'https://www.baidu.com',string='更多数据')\nsheet.insert_image(10,0,'view.png')\n\n#写入图标数据\nchart = writer.add_chart({'type':'column'}) #设置图标类型 column 柱状图 line 这项图\nchart.set_title({'name':'第一季度销售统计'}) #设置图标标题\n#设置x 、 y轴描述信息\nchart.set_x_axis({'name':\"月份\"})\nchart.set_y_axis({'name':'销售额'})\n#设置图标数据\nchart.add_series({\n   'name':'预期销售额',\n    'categories':'=newSheet!$A$5:$A$7',\n    'values':['newSheet',4,1,6,1],\n})\nchart.add_series({\n   'name':'实际销售额',\n    'categories':'=newSheet!$A$5:$A$7',\n    'values':['newSheet',4,2,6,2],\n})\nsheet.insert_chart('A23',chart)\n#关闭\nwriter.close()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032716490664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyNjUzOTg=,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "医学影像中用 python 读取 nrrd 文件，nrrd转nii，以及遇到的一些问题和解决方法", "作者": "许先生~", "发布时间": "2021-03-27 15:16:58", "内容": [{"ctype": "p", "data": "遇到的问题："}, {"ctype": "p", "data": "如果只想看解决方法，直接跳到第四点"}, {"ctype": "head", "data": "用 python 读取 nrrd 文件："}, {"ctype": "p", "data": "用 python 读取 nrrd 文件一般使用 pynrrd 这个库"}, {"ctype": "head", "data": "1、安装pynrrd:"}, {"ctype": "code", "data": "// pip 安装\npip install pynrrd\n"}, {"ctype": "p", "data": "完成后进入python IDLE"}, {"ctype": "code", "data": "// 检查nrrd是否安装成功\nimport nrrd\n"}, {"ctype": "p", "data": "如果是正常使用的话，这样安装就完全OK了，但是如果相对 nrrd 做出一些贡献："}, {"ctype": "code", "data": "pip install git+https://github.com/mhe/pynrrd.git\ncd pynrrd\npip install .  // 注意不要忘了最后的小点 \n"}, {"ctype": "p", "data": "完成后像上面一样测试一下是否安装成功"}, {"ctype": "head", "data": "2、安装成功之后读取 nrrd 文件"}, {"ctype": "code", "data": "//先导入 nrrd 库\nimport nrrd\ndata_path=r'你自己的 nrrd 文件路径’\ndata,options=nrrd.read(data_path)  # 读入 nrrd 文件\n'''\ndata：保存图片的多维矩阵;\nnrrd_options：保存图片的相关信息\n'''\n可以打印查看data 和 nrrd_options 里面的内容：\nprint(data)\nprint(options)\n"}, {"ctype": "p", "data": "输出结果："}, {"ctype": "head", "data": "3、查看 nrrd 文件的形状"}, {"ctype": "code", "data": "print(data.shape)\n"}, {"ctype": "p", "data": "正常情况下读取出来的 nrrd 数据应该都是类似这种的格式:[w, h, n] 第三维度保存的是图像的序号； 但是在一些情况先我们读出来的数据格式是：[c, w, h, n] ;这乍一看没啥为题，就是多了第一维度的通道信息。 这没毛病，但是在后面我们进一步处理的时候可能就会报错，因为这毕竟是医学影响数据，我们是要将其转换为图像数据的吧。"}, {"ctype": "p", "data": "**"}, {"ctype": "head", "data": "4、将 nrrd 矩阵转换为图像数据"}, {"ctype": "p", "data": "我的 nrrd 文件转成图像后是用于深度学习， data.shape = (3, 512, 512, 237) 所以就先将其转换为PIL 格式（需要用到PIL库）"}, {"ctype": "code", "data": "//安装PIL库\npip install pillow\n"}, {"ctype": "code", "data": "import PIL  # 测试PIL库是否安装成功\n\nfrom PIL import Image\nimg=Image.fromarray(data[:,:,20]) # 截取前20张图片\n"}, {"ctype": "p", "data": "但是就在这里，报了一个错："}, {"ctype": "p", "data": "究其原因，是因为[c, w, h, n]中，c的原因；如果要想成功的将其转换为图像数据，可以使用下面这条命令"}, {"ctype": "code", "data": "img=Image.fromarray(data[1,:,:,20]) # 截取第一个通道的前20张图片\n"}, {"ctype": "p", "data": "但是我经过对比，发现三个通道上的信息不同，如果随意选择一个进行提取，那么就会丢失另外两个通道的信息。后面我问其他人，他们说第一个维度上的数值还有为 2 的，瞬间就给我整懵了。 后来经过查询以及对三个通道的图像对比，怀疑第一维度上面的信息可能表示 患者接受扫描的期相，1 表示平扫，只有一期；2 表示增强，有动脉期和静脉期；3 表示造影，有动脉期、静脉期和平衡期。 同时从扫描角度考虑，在这几个扫描期相中，患者的位置是相对固定的，也就是说我们可以随意选择其中一个期相都可以；但是反过来，我们可以将所有期相的数据都利用上。 如果只是想随意选择其中的一个期相，使用上面一个命令即可，如果想将所有的期相都用起来，那么需要增加一个循环。"}, {"ctype": "code", "data": "for j in range(img.shape[0]):\n\tfor i in range(img.shape[3]):\n\t\timg=Image.fromarray(data[j,:,:,i]) # 截取第j个通道的前i张图\n//循环结束后，就可以将所有数据都提取出来并直接转换为图片数据\n\n"}, {"ctype": "code", "data": "//最后贴一个相对比较完整的代码\nimport PIL\nimport nrrd\nimport os\n\ndata_path=./data/PA1.nrrd # nrrd 文件的保存路径\nsave_path=./data/save     # 图片数据的保存文件夹\n\n# 检查路径\nassert os.path.exists(data_path), data_path+' : path error !'\nif not os.paht.exists(save_path):\n\tos.makedir(save_path)\n\t\ndata, options = nrrd.read(data_path)\nfor j in range(data.shape[0]):\n\tfor i in range(data.shape[3]):\n\t\timg=Image.fromarray(data[j,:,:,i]) # 截取第j个通道的前i张图\n\t\ttemp_path=save_path + '/' + str(j) + '_' + str(i) +'.png'\n\t\timg.convert('RGB').save(tmp_path) # 保存图像数据\n//循环结束后，就可以将所有数据都提取出来并直接转换为图片数据\n\n"}, {"ctype": "head", "data": "5、nrrd 转nii"}, {"ctype": "code", "data": "import nrrd\nimport nibabel as nib\nimport numpy as np\n\n# nrrd 文件保存路径\ndata_path=r'./data/1.nrrd'\nsave_path='./data/1.nii'\n\ndata,options=nrrd.read(data_path)  # 读取 nrrd 文件\nimg=nib.Nifti1Image(data,np.eye(4)) # 将 nrrd 文件转换为 .nii 文件\nnib.save(img,save_path) # 保存 nii 文件\n"}, {"ctype": "p", "data": "nibabel 库是用来读取 nii 数据的，它和 numpy 需要另外安装"}, {"ctype": "code", "data": "pip install bibabel\npip install numpy\n"}, {"ctype": "p", "data": "这是我在遇到这个问题后想到的可能的解决方法，如果大家有好的想法、解决方式，欢迎补充。"}, {"ctype": "p", "data": "参考文章： 1、https://blog.csdn.net/Michelexie/article/details/81907613?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161681364616780271592594%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=161681364616780271592594&biz_id=0 2、https://blog.csdn.net/qwer7512090/article/details/100163481?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161681364616780271592594%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=161681364616780271592594&biz_id=0"}], "cate": "Python"}
{"题目": "2021-03-27", "作者": "打开秋天的内核", "发布时间": "2021-03-27 12:05:25", "内容": [{"ctype": "head", "data": "增加打劫功能"}, {"ctype": "p", "data": "其实打劫功能还是相对简单的，比那个不入气的判断要简单一些。大致的思路是： 1、确定打劫的特征状态。在没有提子前，当出现打劫时，应该是黑白各有一子均无外气。 2、当这种特征状态是首次出现，可以进行提劫；如果是连续重复出现，说明是违规提劫，要返回到上一个状态。 其实就这么简单。 那个不入气的逻辑有些曲折。例如轮黑落子，先看一下黑是否已经无外气，如果是，再判断白棋是否也无外气，如果是，说明是提白棋，不是不入气；如果不是（白棋无外气），说明黑是不入气，返回到上一个状态。有些晕哈。 另外增加了一个小的功能，标注当前落子。"}, {"ctype": "code", "data": "# coding=gbk\nimport os\nimport sys\nimport copy\n\nimport pygame\nfrom pygame.locals import *\n\npygame.</"}], "cate": "Python"}
{"题目": "刷题笔记：网易2021校招笔试分割字符串的最大得分", "作者": "import_torch_as_tf", "发布时间": "2021-03-27 11:06:13", "内容": [{"ctype": "p", "data": "题目描述："}, {"ctype": "p", "data": "给你一个由若干 0 和 1 组成的字符串s，请你计算并返回将该字符串分割成两个子字符串（即左子字符串和右子字符串, 子字符串允许为空）所能获得的最大得分。"}, {"ctype": "p", "data": "已知分割字符串的得分规则如下： 左子字符串中：0得2分，1得1分 右子字符串中：1得2分，0得1分  子字符串为空则得0分"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327110326857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hzcHl6bQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "我的思路："}, {"ctype": "p", "data": "先按照计分规则定义计分函数，然后穷举字符串切割位置，分别计算得分，最后返回最高得分即可。"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": "def df(s, l):\n    score = 0\n    for i in s:\n        if i == '0':\n            if l == 'left':\n                score += 2\n            else:\n                score += 1\n        else:\n            if l == 'left':\n                score += 1\n            else:\n                score += 2\n    return score\ns = input()\nres = []\nfor i in range(len(s)+1):\n    l, r = s[:i], s[i:]\n    res.append(df(l,'left')+df(r,'right'))\nprint(max(res))"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "递归函数和调用栈", "作者": "敲拟码", "发布时间": "2021-03-27 12:03:42", "内容": [{"ctype": "p", "data": "递归函数： 编写递归函数时，必须告诉它合适停止递归。 正因为如此，每个递归函数都有两部分：基线条件和递归条件。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无线循环。 例："}, {"ctype": "code", "data": "def countdown(i):\n    print (i)\n    if i <= 0:    #基线条件\n        return\n    else:\t\t  #递归条件\n        countdown(i-1)\nprint (countdown(10))\n"}, {"ctype": "p", "data": "调用栈： 栈的两种操作：压入和弹出，最后压入的函数最先执行 例："}, {"ctype": "code", "data": "def greet(name):\n    print (\"hello, \"+ name + \"!\")\n    greet2(name)\n    print (\"getting ready to say bye...\")\n    bye()\ndef greet2(name):\n    print (\"how are you, \" + name +\"?\")\ndef bye():\n    print (\"ok bye!\")\na=\"zhou\"\nprint(greet(a))\n\n#输出结果为：\nhello, zhou!\nhow are you, zhou?\ngetting ready to say bye...\nok bye!\nNone\n"}, {"ctype": "p", "data": "递归调用栈： 下面是计算阶乘的递归函数："}, {"ctype": "code", "data": "def fact(x):\n    if x==1:\n        return 1\n    else:\n        return x * fact(x-1)\nprint(fact(3))\n"}, {"ctype": "p", "data": "  注意：每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327120107307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NzgxNzg1,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "web自动化入门篇", "作者": "喵不猫-", "发布时间": "2021-03-27 12:00:21", "内容": [{"ctype": "head", "data": "web自动化学习"}, {"ctype": "head", "data": "1.简介"}, {"ctype": "code", "data": "web自动化；web就是web端，自动化就是通过工具或者其他手段来代替传统的\n手工测试\n"}, {"ctype": "head", "data": "2.准备工作"}, {"ctype": "head", "data": "环境："}, {"ctype": "p", "data": "1.pycharm 下载地址：https://www.jetbrains.com/pycharm/download/#section=windows 选择，如下界面进行下载，可以下免费的"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327115555682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2MxNzE5NTYxMDUz,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "2.对应浏览器driver（这里是chrome地址）"}, {"ctype": "p", "data": "首先点击右上角的三个点，找到帮助，点击关于Google chrome界面如下，就可以看到自己的版本了 打开如下链接：http://npm.taobao.org/mirrors/chromedriver/?  下载下来是个压缩包，解压放在python的安装目录下（是python不是pycharm） 然后准备工作就完成了"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114936636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2MxNzE5NTYxMDUz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "尝试"}, {"ctype": "p", "data": "1.打开pycharm，创建一个新项目"}, {"ctype": "code", "data": "\"\"\"\n对毕设做web自动化测试\n\"\"\"\n\n# 导入webdriver\nfrom selenium import webdriver\n#打开浏览器\ndriver = webdriver.Chrome()\n#打开网站\ndriver.get('https://www.baidu.com/')\n#找到对应位置，打开浏览器的Console，输入$x('在这里输入对应的xpath')，\n#然后就会看到是否被检索到，检索到那么就是我们需要的xpath，虽然可以复制，但有的时候复制下来的xpath是错误的\ndriver.find_element_by_xpath('').send_keys('1') #输入账号1\ndriver.find_element_by_xpath('').send_keys('1') #输入密码1\ndriver.find_element_by_xpath('').click() #点击登录\ndriver.close() #关闭当前一个窗口\ndriver.quit()    #退出相关驱动程序,并关闭所有窗口\n\n"}, {"ctype": "p", "data": "上面不完整，先这样，慢慢完善"}], "cate": "Python"}
{"题目": "idea设置java类注释模板与方法注释模板", "作者": "etna", "发布时间": "2021-03-27 11:51:30", "内容": [{"ctype": "head", "data": "类注释模板"}, {"ctype": "p", "data": "File -> Settings -> Editor -> File and Code Templates -> Includes -> File Header "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "code", "data": "/**\n * <p>\n * $description\n * </p>\n * \n * @author liuqingbo\n * @since ${DATE} ${TIME}\n */\n"}, {"ctype": "p", "data": "效果如下： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "方法注释模板"}, {"ctype": "head", "data": "设置步骤"}, {"ctype": "p", "data": "File -> Settings -> Editor -> Live Templates -> 点击右上角的 + 的 Template Group，新增个模板组"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "点击右上角的 + 的Live Template，新增个方法注释模板"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "Template text 填写内容"}, {"ctype": "code", "data": "**\n * <p>\n * \n * </p>\n *$param$\n * @return $return$\n * @author liuqingbo \n * @since $date$\n */\n"}, {"ctype": "p", "data": "参数设置 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "参数（param）脚本"}, {"ctype": "code", "data": "groovyScript(\"def result=' \\\\n'; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {if(params[i] == '') return ' '; result+=' * @param ' + params[i]  + ((i < params.size() - 1) ? ' \\\\n' : ' ')}; return result\", methodParameters())\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "使用方式"}, {"ctype": "p", "data": "在方法上键入 /* + tab键即可生成。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114507600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMyODE2,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "Leetcode136：只出现一次的数字（简单题）python3", "作者": "阿呆呆meimei", "发布时间": "2021-03-27 11:43:31", "内容": [{"ctype": "p", "data": "题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。"}, {"ctype": "p", "data": "说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？"}, {"ctype": "p", "data": "示例 1: 输入: [2,2,1] 输出: 1"}, {"ctype": "p", "data": "示例 2: 输入: [4,1,2,1,2] 输出: 4"}, {"ctype": "p", "data": "思路：这里考虑不使用额外的空间，就在此数组上进行操作，首先进行排序，然后选择不与后面一个相同的那个元素或者是最后一个元素即可！"}, {"ctype": "code", "data": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(0,len(nums)-1,2):\n            if nums[i]!=nums[i+1]:\n                return nums[i]\n        return nums[-1]\n"}], "cate": "Python"}
{"题目": "matplotlib中文字体乱码 尤其是Axes3D", "作者": "coderwangson", "发布时间": "2021-03-27 11:42:54", "内容": [{"ctype": "head", "data": "matplotlib中文字体乱码 尤其是Axes3D"}, {"ctype": "p", "data": "乱码的情况通常是因为你没有安装响应的字体，所以只需要下载对应字体，并正确配置即可。"}, {"ctype": "p", "data": "首先，下载字体：https://github.com/StellarCN/scp_zh/blob/master/fonts/SimHei.ttf"}, {"ctype": "p", "data": "这里给出来的是黑体。"}, {"ctype": "p", "data": "其次，需要让matplotlib找到字体，这里有两种方案，第一种，直接把字体放到matplotlib库的目录里，第二种放到你项目的目录里，具体操作如下。"}, {"ctype": "p", "data": "1、放到matplotlib目录里 可以解决Axes3D乱码问题"}, {"ctype": "p", "data": "首先用下面的代码找到你matplotlib字体的目录："}, {"ctype": "code", "data": "import matplotlib\nprint(matplotlib.matplotlib_fname())\n"}, {"ctype": "p", "data": "上面的输出应该如下："}, {"ctype": "p", "data": "xxxx/site-packages/matplotlib/mpl-data/matplotlibrc"}, {"ctype": "p", "data": "对应字体目录应该是："}, {"ctype": "p", "data": "xxxx/site-packages/matplotlib/mpl-data/fonts/ttf/"}, {"ctype": "p", "data": "所以只需要把上面下载的SimHei.ttf放到该目录下即可。"}, {"ctype": "p", "data": "然后在代码里面用如下的代码就可以找到了："}, {"ctype": "code", "data": "import matplotlib\nmatplotlib.rcParams['font.family'] = 'SimHei'\n"}, {"ctype": "p", "data": "这种方案因为是全局的，所以可以解决Axes3D的乱码问题。"}, {"ctype": "p", "data": "2、放到任意位置"}, {"ctype": "p", "data": "下面的方案是局部的，你可以把字体放到任意位置，然后在代码里配置字体位置，并且加载字体即可。代码如下："}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nfrom matplotlib.font_manager import FontProperties\nfont = FontProperties(fname=\"SimHei.ttc\", size=12)\nplt.title(\"中文\",fontproperties=font)\n"}], "cate": "Python"}
{"题目": "MicroPython Socket TCP链接记录二 全局采集数据", "作者": "weixin_44247218", "发布时间": "2021-03-27 11:46:25", "内容": [{"ctype": "head", "data": "MicroPython Socket TCP链接记录二 全局采集数据"}, {"ctype": "p", "data": "模拟测试 ，非生产日用， 生产最终选择使用简单的http来实现数据采集定时上报到后端，后端根据最后数据上传时间来判断设备是否掉线，毕竟花时间调试完socket了后，公司试用了下觉得不行那就浪费时间了"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114249598.gif#pic_center"}, {"ctype": "head", "data": "socketserver全局下发命令到客户端 完成数据采集并上传"}, {"ctype": "p", "data": "因为手上暂时没有很多设备,所以先用电脑的异步客户端模拟设备,服务器发送ping命令,客户端返回pong+id"}, {"ctype": "head", "data": "模拟设备掉线"}, {"ctype": "p", "data": "  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327114300838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI0NzIxOA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "代码如下"}, {"ctype": "p", "data": "服务端"}, {"ctype": "code", "data": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# @Time    : 2021/3/25 10:26\n# @Author  : Link\n# @Site    : 服务端\n# @File    : socket_server.py\n# @Software: PyCharm\n\nfrom socketserver import BaseRequestHandler, ThreadingTCPServer\n\nimport threading\n\nfrom queue import Queue\nfrom time import sleep\n\nqueue = Queue(maxsize=10)\nconnect_queen = {}  # 每新建一个链接 则维护一个queue\n\n\ndef broadcast_queue_th():\n    while True:\n        inst = input(\"请输入下发命令(直接回车关闭链接)>>> :\")\n        queue.put(inst)\n\n        inst = queue.get()\n        for _, _queue in connect_queen.items():\n            _queue.put(inst)\n\n\nclass Handler(BaseRequestHandler):\n\n    # def handle(self) -> None:\n    #     address, pid = self.client_address\n    #     print(\"%s connected! pid: %s\" % (address, pid))\n    #     while True:\n    #         try:\n    #             data = self.request.recv(1024)\n    #             if not data: break\n    #             print('->pid:%s say client:%s' % (pid, data))\n    #             self.request.send(data.upper())\n    #         except ConnectionError:\n    #             print('->pid:%s close connect' % (pid))\n    #             break\n    #     print(\"request close\\n\")\n    #     self.request.close()\n\n    # 启动一个用于发布全局数据的链接\n    def handle(self) -> None:\n        address, pid = self.client_address\n        connect_queen[pid] = Queue(maxsize=2)\n        while True:\n            try:\n                data = connect_queen[pid].get()\n                if not data: break #断开链接\n                self.request.send(data.encode('utf-8'))\n                recv = self.request.recv(30).decode(\"utf-8\")  # 等待数据 阻塞\n                if recv:\n                    print(recv)\n                    self.request.send(\"33\".encode('utf-8'))\n                sleep(.2)\n            except ConnectionError:\n                break\n        del connect_queen[pid]\n        self.request.close()\n\n\nif __name__ == '__main__':\n    # 启动数据发布进程\n    th = threading.Thread(target=broadcast_queue_th, name=\"thi\")\n    th.start()\n    # 启动服务器\n    server = ThreadingTCPServer(('0.0.0.0', 8080), Handler)\n    server.serve_forever()  # 链接循环\n"}, {"ctype": "p", "data": "客户端"}, {"ctype": "code", "data": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# @Time    : 2021/3/26 15:56\n# @Author  : Link\n# @Site    : 客户端\n# @File    : socket_client.py\n# @Software: PyCharm\n\nimport socket\nimport asyncio\nimport random\n\n# 创建十个测试链接\nclients = [socket.socket(socket.AF_INET, socket.SOCK_STREAM) for _ in range(10)]\nfor client in clients:\n    client.connect(('127.0.0.1', 8080))\n\n\nasync def client_connect_server_send(client, i):\n    while True:\n        client.send(f'hello{i}'.encode('utf-8'))\n        print(client.recv(1024).decode(\"utf-8\"))\n        await asyncio.sleep(.5)\n    # client.close()\n\n\nasync def client_connect_server_recv(client, i):\n    sl = 0\n    sl_t = random.randint(10, 20)\n    equipment = \"micro{}\".format(i)\n    while True:\n        sl += 1\n        if sl >= sl_t:\n            print(\"micro{} connect close!\".format(i))\n            break\n        data = client.recv(36).decode(\"utf-8\") # 服务器断开链接后会一直返回空,没有断开就会阻塞住\n        if data:\n            # 获取到服务器发送来的全局指令\n            send_data = equipment_exec(equipment, data).encode('utf-8')\n            client.send(send_data)\n            # 服务器上传数据后解析成功返回33\n            res = client.recv(10).decode(\"utf-8\")\n            if res == \"33\":\n                print(\"success\")\n            else:\n                print(res)\n        else:\n            print(\"micro{} connect close!\".format(i))\n            break\n        await asyncio.sleep(.5)\n    client.close()\n\n\ndef equipment_exec(equipment: str, inst: str) -> str:\n    \"\"\"\n    每次获取到服务器的指令后 都要进行返回\n    \"\"\"\n    if inst == \"hello\":\n        return \"this is %s\" % equipment\n    if inst == \"ping\":\n        return \"pong %s\" % equipment\n    return \"nothing\"\n\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    tasks = [client_connect_server_recv(client=client, i=index) for index, client in enumerate(clients)]\n    loop.run_until_complete(asyncio.wait(tasks))\n"}, {"ctype": "p", "data": "先启动服务端，再启动客户端，手动在客户端发送命令测试，客户端在接收到十到二十次数据后会断线"}], "cate": "Python"}
{"题目": "python可变对象与不可变对象", "作者": "织夜虫", "发布时间": "2021-03-27 10:23:36", "内容": [{"ctype": "p", "data": "我的python版本：3.8.6"}, {"ctype": "head", "data": "不可变对象immutable：对象内容不可原地改变"}, {"ctype": "p", "data": "不可变的对象有：int、字符串(string)、float、元组(tuple)"}, {"ctype": "code", "data": "a=10\nb=a\nprint(id(a))\nprint(id(b))\nprint()\nb=11\nprint(id(a))\nprint(id(b))\n#输出：\n#140736928221120\n#140736928221120\n#\n#140736928221120\n#140736928221152\n"}, {"ctype": "p", "data": "可以看到，b=10时它的地址是与a一样的，在b=11后它的地址就变了。python变量都是指针，不可变对象的指针并不是固定地指向一个地址，而是“我的值是10，那我就指向存放10的那个地址，我的值改成11了，那我就指向存放11的那个地址”，原来放10的那个地址依然是10，所以准确地说，变量改变的是指针指向。"}, {"ctype": "p", "data": "值得一说的是，python中有一个小整数的概念，指的是[-5,256]这个区间的整数，它们放在一个small_int的数组里，用户使用这个区间的int的时候系统就会直接从这个数组里引用，所以前后两次执行两次的id()是一样的，而不在这个区间的int（大整数）以及其它不可变对象在程序每次程序执行时都会新分配一个地址，每次执行的id都是随机的。"}, {"ctype": "code", "data": "print(id(257))\n#第一次执行：1675989624976\n#第二次执行：1865732470928\n#第三次执行：1928663681168\n"}, {"ctype": "p", "data": "至于string对象，python有个intern机制（字符串驻留），它就是一个字典，以字符串为key，以地址为value，每个字符串及其被分配的地址都会放在这个字典里，每次定义字符串对象的时候都会和这个字典比较，有了就直接引用，省点空间，没有就创建。"}, {"ctype": "code", "data": "a='abc'\nb='abc'\nprint(id(a)==id(b))#True\n"}, {"ctype": "p", "data": "字符串是不可变对象，我们用replace()函数把a的对象’abc’改成’def’，字符串使用replace需要重新赋值，生成一个新的对象，变量a指向这个新对象，而不是原来的’abc’上面做更改。现在知道什么叫‘不可变’了吧。"}, {"ctype": "code", "data": "a='abc'\nprint(id(a))#2352432259120\na=a.replace('abc','z')\nprint(id(a))#2352452781232\n#两次id不同了，a指向了新的对象\n"}, {"ctype": "head", "data": "可变对象：对象内容可以原地改变"}, {"ctype": "p", "data": "解释器为每个对象维护不同内存区域，每个可变对象都由解释器重新创建内存空间，并不复用。"}, {"ctype": "p", "data": "可变对象有：字典(dict)、列表(list)、集合(set)"}, {"ctype": "code", "data": "lt1=[1,2,3,4]\nlt2=lt1\nlt3=[1,2,3,4]\nprint(id(lt1))#2567070829824\nprint(id(lt2))#2567070829824\nprint(id(lt3))#2567070868928\n#lt1：新建对象；lt2：引用对象；lt3：新建对象。\nlt1.append(100)\nprint(lt1)#[1, 2, 3, 4, 100]\nprint(lt2)#[1, 2, 3, 4, 100]\nprint(lt3)#[1, 2, 3, 4]\nprint(id(lt1))#2567070829824\n"}, {"ctype": "p", "data": "lt2只是引用lt1的对象，两者指向同一地址，多个引用，并不是多个对象，其中一个的变化会影响的另外一个。而lt3是一个新对象，尽管它也是[1,2,3,4]，但并不因为对象的值相等就指向同一对象，lt1和lt2的变化与lt3无关。"}, {"ctype": "p", "data": "lt1的对象虽然变化了，但变化前后的id并不改变，还是那个地址，这就是‘可变的’对象。"}, {"ctype": "head", "data": "可变对象/不可变对象作为函数参数"}, {"ctype": "p", "data": "可变对象函数参数时，函数内对参数的对象的改变会影响到原始对象；"}, {"ctype": "p", "data": "不可变对象作为参数时，函数内对参数的改变不会影响到原始参数，改变的是函数内变量的指向对象。"}], "cate": "Python"}
{"题目": "Python", "作者": "在努力的自学小白", "发布时间": "2021-03-27 15:40:44", "内容": [{"ctype": "head", "data": "python小白自学记录"}, {"ctype": "head", "data": "**一、变量，运算符与数据类型"}, {"ctype": "p", "data": "1、经典实例：Hello World"}, {"ctype": "code", "data": "\tprint(\"Hello World\")\n"}, {"ctype": "p", "data": "2、print 输出语句 （1）输出数字（例如：输出数字2）"}, {"ctype": "code", "data": "print(2)\n"}, {"ctype": "p", "data": "#print(“2”)和print(2)输出有什么区别？  从运行上来看二者似乎都是2，没有区别；但没有引号的数字是2，可以进行加减等运算，而有引号的2是字符串，不再是数字。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327120754867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FwcGxlXzUyMDA1MjE0,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "（2）输出英文单词（例如：输出“hello”）"}, {"ctype": "code", "data": "print(\"hello\")\n"}, {"ctype": "p", "data": "（3）输出汉字（例如：输出“你好”）"}, {"ctype": "code", "data": "print(\"你好\")\n"}, {"ctype": "p", "data": "（4）输出多个词语（例如：输出“你好 世界”）"}, {"ctype": "code", "data": "print(\"你好 世界\")\n"}, {"ctype": "p", "data": "（5）end 与 sep 的使用 sep：指定间隔符号（未指定时默认逗号） end：结尾"}, {"ctype": "code", "data": "print(\"www\",123,\"com\",sep=\".\")\nprint(\"www\",123,\"com\",end=\".\")\n"}, {"ctype": "p", "data": " （6）输出图形"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327121735586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FwcGxlXzUyMDA1MjE0,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "print(\"*\"*10)\nprint(\"*\"*9+\"*\")\nprint(\"*\"*9+\"*\")\nprint(\"*\"*9+\"*\")\nprint(\"*\"*10)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327122605197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FwcGxlXzUyMDA1MjE0,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "一、变量和赋值 使用变量前先赋值； 变量名可以包括数字，字母，下划线，但不能以数字开头； python变量名大小写敏感。"}, {"ctype": "code", "data": "a=2,\nb=3,\nc=a+b,\nprint(c)\n"}, {"ctype": "p", "data": "输出：5"}, {"ctype": "p", "data": "二、运算符"}, {"ctype": "p", "data": "算数运算符 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327125530908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FwcGxlXzUyMDA1MjE0,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "print(1 + 1)  \nprint(2 - 1)  \nprint(3 * 4)  \nprint(3 / 4)  \nprint(3 // 4) \nprint(3 % 4)  \nprint(2 ** 3) \n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327125559402.png"}, {"ctype": "p", "data": "比较运算符"}, {"ctype": "table", "data": "操作符名称>大于>=大于等于<小于<=小于等于==等于!=不等于"}, {"ctype": "code", "data": "print(3 > 4)\nprint(3 >= 4)\nprint(4 < 9)\nprint(3 <= 2)\nprint(4 == 4)\nprint(2 != 5)  \n"}, {"ctype": "p", "data": " 逻辑运算符"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327125034121.png"}, {"ctype": "table", "data": "操作符名称and与or或not非"}, {"ctype": "code", "data": "print((3 > 2) and (3 < 6))\nprint((1 > 3) or (6 < 2))\nprint(not (8 > 7))\n"}, {"ctype": "p", "data": " 位运算符"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032713182816.png"}, {"ctype": "table", "data": "操作符名称~按位取反&按位与`按位或^按位异或<<左移>>右移"}, {"ctype": "code", "data": "print(bin(4))\nprint(bin(5))\nprint(bin(~4), ~4)\nprint(bin(4 & 5), 4 & 5)\nprint(bin(4 | 5), 4 | 5)\nprint(bin(4 ^ 5), 4 ^ 5)\nprint(bin(4 << 2), 4 << 2)\nprint(bin(4 >> 2), 4 >> 2)  \n"}, {"ctype": "p", "data": " 其他运算符"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032713255938.png"}, {"ctype": "table", "data": "操作符名称in存在not in不存在is是is not不是"}, {"ctype": "p", "data": "运算符的优先级  三、数据类型 （1）int 整型 (<class ‘int’ >)"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327133427802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FwcGxlXzUyMDA1MjE0,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "a = 5\nprint(a, type(a))\n"}, {"ctype": "p", "data": " （2）float 浮点数类型（<class ‘float’>）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327134106292.png"}, {"ctype": "code", "data": "b=3.1\nprint(b,type(b))\n"}, {"ctype": "p", "data": " #在运算0.1+0.2时会出现这样的结果"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144012239.png"}, {"ctype": "code", "data": "c=0.1+0.2\nprint(c,type(c))\n"}, {"ctype": "p", "data": " 不确定尾数导致的结果错误，在此使用round()函数语法进行计算；"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144255544.png"}, {"ctype": "code", "data": "round(x,y)\n"}, {"ctype": "p", "data": "0.1+0.2后保留3位小数，就可以得到准确数值。"}, {"ctype": "code", "data": "c=round(0.1+0.2,3)\nprint(c,type(c))\n\n"}, {"ctype": "p", "data": " （3）复数类型（<class ‘complex’>） 复数是由一个实数和一个虚数组合构成，表示为：x+yj 一个复数时一对有序浮点数 (x,y)，其中 x 是实数部分，y 是虚数部分。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144642963.png"}, {"ctype": "code", "data": "a = complex(2, 4)\nprint (a,type(a))\n"}, {"ctype": "p", "data": " 实部、虚部和共轭复数"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032715024371.png"}, {"ctype": "code", "data": "a = complex(2, 4)\na.real\nprint (a.real,type(a.real))\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327150452856.png"}, {"ctype": "code", "data": "a = complex(2, 4)\na.imag\nprint (a.imag,type(a.imag))\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327150545732.png"}, {"ctype": "code", "data": "a = complex(2, 4)\na.conjugate()\nprint (a.conjugate(),type(a.conjugate()))\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327150627735.png"}, {"ctype": "p", "data": "（4）字符串型 (<class ‘str’>)"}, {"ctype": "code", "data": "a = \"hello\"\nprint (a,type(a))\n"}, {"ctype": "p", "data": " \"hello\"为一个由五个字符组成的字符串，如果没有引号，hello就为一个变量. （5）其他数据类型 列表（list）、元组（tuple）、集合（set）、字典（dict）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327150920708.png"}, {"ctype": "head", "data": "二、位运算"}, {"ctype": "p", "data": "（1）原码，反码和补码 原码：就是其二进制表示（第一位为符号位）"}, {"ctype": "code", "data": "00 00 00 11 \n10 00 00 11 \n"}, {"ctype": "p", "data": "反码：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。"}, {"ctype": "code", "data": "00 00 00 11 \n11 11 11 00 \n"}, {"ctype": "p", "data": "补码：正数的补码就是原码，负数的补码是反码+1。"}, {"ctype": "code", "data": "00 00 00 11 \n11 11 11 01 \n"}, {"ctype": "p", "data": "符号位：最高位为符号位，0表示正数，1表示负数。"}, {"ctype": "p", "data": "（2）按位运算 ① & ：按位与运算符，两个相应位都为1时结果为1，否则为0；（全1 为1）"}, {"ctype": "code", "data": "1 & 1 = 1\n1 & 0 = 0\n0 & 1 = 0\n0 & 0 = 0\n"}, {"ctype": "p", "data": "② | ：按位或运算符，对应的两个二进位有一个为1时，就为1；（有1则1，无1则0）"}, {"ctype": "code", "data": "1 | 1 = 1\n1 | 0 = 1\n0 | 1 = 1\n0 | 0 = 0\n"}, {"ctype": "p", "data": "③ ^ ：按位异或运算符，当两对应的二进位不同时，为1；（不同为1，相同为0）"}, {"ctype": "code", "data": "1 ^ 1 = 0\n1 ^ 0 = 1\n0 ^ 1 = 1\n0 ^ 0 = 0\n"}, {"ctype": "p", "data": "④ ~ ：按位取反运算符，对数据的每个二进制位取反（1变为0，0变为1）；"}, {"ctype": "code", "data": "00 01 01 01 \n~\n11 10 10 10\n"}, {"ctype": "p", "data": "⑤ >> ：右移动运算符，把 >> 左边的运算数的各二进位全部右移若干位，>> 右边的数指定移动的位数；"}, {"ctype": "p", "data": "⑥ << ：左移动运算符，运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0。"}], "cate": "Python"}
{"题目": "Python实现各种排序算法", "作者": "小·幸·运", "发布时间": "2021-03-27 12:58:55", "内容": [{"ctype": "head", "data": "一、快速排序"}, {"ctype": "p", "data": "快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。"}, {"ctype": "p", "data": "步骤为："}, {"ctype": "p", "data": "挑选基准值：从数列中挑出一个元素，称为\"基准\"（pivot）;分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成;递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。 递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。"}, {"ctype": "p", "data": "选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。"}, {"ctype": "code", "data": "class Solution:\n    '''快速排序'''\n    def partition(self, low, high, nums):\n        '''取数组中间值作为枢轴'''\n        if low >= high:\n            return\n        i, j = low, high\n        nums[low], nums[(i + j) // 2] = nums[(i + j) // 2], nums[low]\n        pivot = nums[low]\n        while i < j:\n            while i < j and nums[j] >= pivot:\n                j -= 1\n            nums[i] = nums[j]\n            while i < j and nums[i] < pivot:\n                i += 1\n            nums[j] = nums[i]\n        nums[i] = pivot\n        return i\n\n    def quickSort(self, low, high, nums):\n    '''low:数组左边界，high:数组右边界(n-1)'''\n        if low >= high:\n            return\n        pivot = self.partition(low, high, nums)\n        self.quickSort(low, pivot-1, nums)\n        self.quickSort(pivot+1, high, nums)\n"}, {"ctype": "p", "data": "时间复杂度：O(nlog2n)。 最好情况（待排序列接近无序）：O(nlog2n)；最坏情况（待排序列接近有序）：O(n2)"}, {"ctype": "p", "data": "空间复杂度：O(nlogn)"}, {"ctype": "p", "data": "稳定性：快排是一种不稳定排序，比如基准值的前后都存在与基准值相同的元素，那么相同值就会被放在一边，这样就打乱了之前的相对顺序"}, {"ctype": "p", "data": "比较性：因为排序时元素之间需要比较，所以是比较排序。"}, {"ctype": "head", "data": "二、堆排序"}, {"ctype": "code", "data": "class Solution:\n    '''堆排序(大顶堆)'''\n    def update(self, i, high, nums):\n        j = 2 * i + 1\n        while j < high:\n            if j + 1 < high and nums[j] < nums[j + 1]:\n                j += 1\n            if nums[i] < nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n            else:\n                break  # 已经调整完毕，提前截止\n            i = j\n            j = 2 * i + 1\n\n    def createMaxHeap(self, low, high, nums):\n    '''向下调整，从n/2开始'''\n        for i in range(high // 2, -1, -1):\n            self.update(i, high, nums)\n\n    def heapSort(self, nums):\n        n = len(nums)\n        for i in range(n):\n            self.createMaxHeap(0, n-i,nums)\n            ##把堆顶元素置换到数组最后\n            nums[0], nums[n-i-1] = nums[n-i-1], nums[0]\n\n"}, {"ctype": "head", "data": "归并排序"}, {"ctype": "code", "data": "class Solution:\n    def mergeSort_A(self, nums: List[int]) -> int:\n        def merge(left, right):        #传入左右两个待合并序列\n            res = []\n            i,j = 0,0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i+= 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]        #把剩余的部分并进来\n            res += right[j:]\n            return res\n\n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums)//2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        return mergeSort(nuts)\n"}, {"ctype": "p", "data": "时间复杂度：O(nlogn)。 最好情况, 最坏情况均为O(nlogn)"}, {"ctype": "p", "data": "空间复杂度：O(n)"}, {"ctype": "p", "data": "特性：是一种稳定排序"}], "cate": "Python"}
{"题目": "关于在centos7下运行sklearn包时报错ModuleNotFoundError: No module named ‘_ctypes‘的解决办法", "作者": "joey小天使", "发布时间": "2021-03-27 13:57:12", "内容": [{"ctype": "head", "data": "1.服务器配置"}, {"ctype": "p", "data": " 操作系统是CentOS7.2"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032713500428.png"}, {"ctype": "head", "data": "2.使用pip下载sklearn包"}, {"ctype": "p", "data": "使用这条指令，下载sklearn包"}, {"ctype": "code", "data": " pip install -U scikit-learn\n"}, {"ctype": "head", "data": "3.运行时报错解决"}, {"ctype": "head", "data": "导入模块"}, {"ctype": "code", "data": "import time\n\nimport pylab\nimport xlrd\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nimport pandas as pd\nimport sklearn\nimport openpyxl\nimport sys\n\n\nprint(sklearn.__version__)\n"}, {"ctype": "p", "data": "运行时报错："}, {"ctype": "code", "data": "ModuleNotFoundError: No module named ‘_ctypes‘\n"}, {"ctype": "p", "data": "解决办法： python3中有个内置模块叫ctypes，它是python3的外部函数库模块，提供了兼容C语言的数据类型，并通过它调用Linux系统下的共享库(Shared library)，此模块需要使用centos7系统中外部函数库(Foreign function library)的开发链接库(头文件和链接库)。 由于在centos7系统中没有安装外部函数库(libffi)的开发链接库软件包，所以在运行sklearn的时候就报了\"ModuleNotFoundError: No module named ‘_ctypes’\"的错误。 直接下载："}, {"ctype": "code", "data": "#yum install libffi-devel -y\n"}, {"ctype": "p", "data": "进入/usr/bin/python3的目录下："}, {"ctype": "code", "data": "#make install\n"}, {"ctype": "p", "data": "经过跑码：  正常运行： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327135604655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvZXlfcm8=,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python语法糖 lambda函数的简单使用和应用方式", "作者": "BrotherHappy", "发布时间": "2021-03-27 14:46:07", "内容": [{"ctype": "head", "data": "lambda函数的用法："}, {"ctype": "head", "data": "lambda的形式"}, {"ctype": "p", "data": "lambda的形式是唯一的就像是下面这样子："}, {"ctype": "code", "data": "lambda arugment_list:expression\n‘‘‘\n语法中的argument_list是参数列表，它的结构和python中的function的参数列表是一样的，例如：\na,b a=1,b=2 *args **kargs\n语法中的expression是一个关于参数的表达式并且：\n表达式中出现的参数需要在argument_list中有定义 ，并且表达式只能是单行的，如下是一些合法的表达式\n1\nNone\na+b\nsum(a)\n1 if a>10 else 0\n’’’\n"}, {"ctype": "p", "data": "那么lambda有什么用处呢?"}, {"ctype": "code", "data": "f = lambda x,y,z : x*y*z\nf(1,2,3) # >>3\n当然也可以直接在lambda后面直接传入参数如\n(lambda x,y,z : x*y*z)(1,2,3)\t# >>3 这样子调用的结果和上面的是一样子的\n"}, {"ctype": "code", "data": "filter(lambda x:x%3==0,[1,2,3,4,5,6])\t# >>[3,6]\n\nsquares = list(map(lambda x:x**2,range(5))) # >>返回一个平方后的列表  注意map返回的是一个可以迭代的map类型的对象\n\na =  [‘(a’,3),('b':2),('c',1)]\nsorted(a,key = lambda x : x[0])\t# >> 输出一个按照元组第一个元素排序后的列表\n\nreduce(func,iterable[,initializer])函数也是一个神奇的函数，其中的func一般有两个参数，并且在可迭代的对象中先对前两个元素进行计算并且计算结果在和第三个元素进行计算\nfrom functiontools import reduce\nreduce(lambda x,y : '{},{}'.format(x,y),[1,2,3,4,5,6,7,8,9]\t\t# 就可以输出‘1，2，3，4，5，6，7，8，9’\n"}, {"ctype": "code", "data": "def increment(n):\n\treturn lambda x:x+=n\nf = increment(6)\nf(4)\t\t\t\t\t\t\t\t\t# >> 10\n\n(lambda a : a*(lambda b: b*b)(a))(2)   # 多重嵌套可以实现 2**3  \n"}], "cate": "Python"}
{"题目": "python下修改配置文件参数", "作者": "liangkang233", "发布时间": "2021-03-27 14:14:24", "内容": [{"ctype": "head", "data": "功能"}, {"ctype": "p", "data": "由于刚好有需求要更改配置文件参数，想到python简单易用的特点，所以边学边做了这个程序帮助修改参数。该程序功能为读取一个二进制文本其中的参数按照指定格式修改。"}, {"ctype": "head", "data": "参考教程"}, {"ctype": "p", "data": "文件读写教程. 正则表达式教程. python的很多基础都是在廖雪峰老师这学的，写的很详细不错，所以后面的分析就不详细说了。"}, {"ctype": "head", "data": "源码"}, {"ctype": "code", "data": "#!/usr/bin/python3\n# coding: utf-8\nspeed = int(input(\"Please enter the adjustment speed: \"))\n\n#修改test.config文件\nwith open('test.config', 'r', encoding='utf-8') as old_config :\n    lines = old_config.readlines()         # readlines返回每行字符串组成的list\n    flen=len(lines)\n    for i in range(flen):\n        if lines[i].startswith(\"SIMULATION-TIME\") :\n            config_value = lines[i].split(' ')\n            value = int( config_value[1][0:-2:1] )  # 用切片删去S和回车转成值         \n            value = int(3600 / speed)\n            lines[i] = config_value[0] + ' ' + str(value) + 'S\\n'\n            break\n        else :\n            continue\nwith open('test.config','w', encoding='utf-8') as new_config :   \n    new_config.writelines(lines)\n\n#修改test.nodes文件\nwith open('test.nodes', 'r', encoding='utf-8') as old_nodes :\n    lines = old_nodes.readlines()         # readlines返回每行字符串组成的list\n    flen=len(lines)\n    for i in range(flen):\n        if lines[i] == '\\n' :\n            break\n        node_value = lines[i].split(' ', 2)\n        if node_value[1] == '0' :\n            continue\n        else :\n            value = int( node_value[1][0:-1:1] )\n            value = int( value / speed )\n            lines[i] = node_value[0] + ' ' + str(value) + 'S ' + node_value[2] \nwith open('test.nodes','w', encoding='utf-8') as new_nodes :   \n    new_nodes.writelines(lines)\n\nprint(\"Modified to complete\")\n"}, {"ctype": "head", "data": "代码分析"}, {"ctype": "p", "data": "python修改文本暂时没找到直接更改办法，上述代码都是先读取文本复制到内存中的列表，修改后再将列表写入文件。修改test.config文件代码，使用readlines返回每行字符串组成的list。当然也可以用readline和while读取每一行来进行操作。 使用startswith对每行行首判断寻找关键字符串类型，之后使用split空格分开为字符串列表后用切片提取出值对应的字符串。 例如下图中config文件会读取到lines[8]这行有待寻找关键字，用split生成list[‘SIMULATION-TIME’, ‘3600S\\n’], 进行切片操作[1:-2:1]得到字符串’3600’ (回车\\n也需要切片去除)，这样转化成int型处理完再转为字符串填充回原来列表中即可。 之后类似的对test.nodes进行操作 此处，由于其配置文件规则简单由空格区分，所以处理起来只需要split和列表切片，若是复杂的字符串数据还是得用上面教程中的正则表达式来处理。"}], "cate": "Python"}
{"题目": "faster-rcnn中的sample函数注释解析", "作者": "winnerziqi", "发布时间": "2021-03-27 14:39:10", "内容": [{"ctype": "code", "data": "class sampler(Sampler):\n  def __init__(self, train_size, batch_size):\n    self.num_data = train_size # 得到数据的数量\n    self.num_per_batch = int(train_size / batch_size) # 得到数据批次的标号\n    self.batch_size = batch_size #\n    self.range = torch.arange(0,batch_size).view(1, batch_size).long() # 得到0-batch_size的标号\n    self.leftover_flag = False\n    if train_size % batch_size: # 如果数据不能被整除\n      self.leftover = torch.arange(self.num_per_batch*batch_size, train_size).long() # 不能被整除部分的数据\n      self.leftover_flag = True # 保留最后不能整除的批次数据\n\n  def __iter__(self):\n    # 将数据批次的标号打乱，并和数据批次的长度相乘，得到随机排序后的照片起始标号\n    rand_num = torch.randperm(self.num_per_batch).view(-1,1) * self.batch_size\n    # 将起始位置扩充，得到具体每一张图片对应的标号\n    self.rand_num = rand_num.expand(self.num_per_batch, self.batch_size) + self.range\n    # 将所有标号打平铺开\n    self.rand_num_view = self.rand_num.view(-1)\n\n    if self.leftover_flag: # 如果保留最后的批次数据\n      # 将不能整除的数据与之前的数据合并\n      self.rand_num_view = torch.cat((self.rand_num_view, self.leftover),0)\n    # 对所有的标号进行迭代\n    return iter(self.rand_num_view)\n\n  def __len__(self):\n    return self.num_data\n"}], "cate": "Python"}
{"题目": "python的Requests基本用法", "作者": "weixin_44897491", "发布时间": "2021-03-27 14:53:11", "内容": [{"ctype": "p", "data": "requests库是urlib的库加强版，更加简洁灵活的运用在接口测试过程中"}, {"ctype": "code", "data": "import requests\nurl = 'http://www.baidu.com/'\nresponse = requests.get(url)\nprint('response.text',response.text)\nprint('response.content',response.content.decode())\nprint('response.status_code',response.status_code)\nprint('response.url',response.url)\nprint('response.request.headers',response.request.headers)\nprint('response.headers',response.headers)\nprint('response.request.cookies',response.request._cookies)\nprint('response.cookies',response.cookies)\n"}, {"ctype": "p", "data": "response.text -----表示获取接口响应正文 reponse.context -----表示获取接口响应正文 response.status_code ----表示获取接口返回的状态码 reponse.request.headers ---- 获取接口请求头的headers reponse.headers ----获取接口响应的headers reponse.cookies -----获取接口响应的cookies reponse.request.cookies ----获取接口请求的cookies reponse.url -------获取接口请求的url"}, {"ctype": "code", "data": "import requests\nurl = 'http://www.baidu.com/'\nresponse = requests.post(url)\nprint('response.text',response.text)\nprint('response.content',response.content.decode())\nprint('response.status_code',response.status_code)\nprint('response.url',response.url)\nprint('response.request.headers',response.request.headers)\nprint('response.headers',response.headers)\nprint('response.request.cookies',response.request._cookies)\nprint('response.cookies',response.cookies)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327145146570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg5NzQ5MQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "使用python完成对波形的采样率的扩增", "作者": "码破苍穹", "发布时间": "2021-03-27 14:47:24", "内容": [{"ctype": "p", "data": "可以通过先内插再采样的方法实现功能。"}, {"ctype": "p", "data": "如有20Khz采样率的采样信号，希望得到该波形在24Khz采样率下的信号，可以先将采样信号内插12倍，再进行10倍下采样。"}, {"ctype": "p", "data": "内插函数可以选用scipy的样条插值函数"}, {"ctype": "code", "data": "import scipy.interpolate as spi\n\ndef wave_process(original_data):\n    data_num = len(original_data)\n\n    interp_rate = 12\n    inter_data_num = data_num * interp_rate\n\n    old_x = [ i for i in range(data_num)]\n    new_x = [i/interp_rate for i in range(inter_data_num)]  #内插后以更小的间距进行填充\n\n\n    ipo3=spi.splrep(old_x,original_data, k=3) #k=3，三次样条插值\n    iy3=spi.splev(new_x,ipo3) #根据观测点和样条参数，生成插值\n\n    down_rate = 10\n    sample_frac = 1/down_rate\n\n    node_inter = int(1 / sample_frac)  \n\n    node_num = int(inter_data_num / node_inter)\n    print (node_num, node_inter)\n\n    sample_y = []\n    for i in range(node_num):\n        sample_y.append(iy3[i*node_inter])\n        \n    return sample_y"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "PyQt5实现简易计算器", "作者": "ElantSama", "发布时间": "2021-03-27 15:22:49", "内容": [{"ctype": "p", "data": "因为懒得算按钮集位置，就索性重复了"}, {"ctype": "code", "data": "import sys\nfrom PyQt5.QtWidgets import *\n\nclass Window(QWidget):\n\tdef __init__(self):\n\t\tsuper().__init__()\n\t\tself.initUI()\n\tdef initUI(self):\n\t\tself.let = QLineEdit(self)\n\t\tself.let.move(0,0)\n\t\tself.let.resize(1000,500)\n\t\tself.btn1 = QPushButton(self)\n\t\tself.btn1.setText('7')\n\t\tself.btn1.resize(250,250)\n\t\tself.btn1.move(0,500)\n\t\tself.btn1.clicked.connect(self.clickNum)\n\t\tself.btn2 = QPushButton(self)\n\t\tself.btn2.setText('8')\n\t\tself.btn2.resize(250,250)\n\t\tself.btn2.move(250,500)\n\t\tself.btn2.clicked.connect(self.clickNum)\n\t\tself.btn3 = QPushButton(self)\n\t\tself.btn3.setText('9')\n\t\tself.btn3.resize(250,250)\n\t\tself.btn3.move(500,500)\n\t\tself.btn3.clicked.connect(self.clickNum)\n\t\tself.btn4 = QPushButton(self)\n\t\tself.btn4.setText('4')\n\t\tself.btn4.resize(250,250)\n\t\tself.btn4.move(0,750)\n\t\tself.btn4.clicked.connect(self.clickNum)\n\t\tself.btn5 = QPushButton(self)\n\t\tself.btn5.setText('5')\n\t\tself.btn5.resize(250,250)\n\t\tself.btn5.move(250,750)\n\t\tself.btn5.clicked.connect(self.clickNum)\n\t\tself.btn6 = QPushButton(self)\n\t\tself.btn6.setText('6')\n\t\tself.btn6.resize(250,250)\n\t\tself.btn6.move(500,750)\n\t\tself.btn6.clicked.connect(self.clickNum)\n\t\tself.btn7 = QPushButton(self)\n\t\tself.btn7.setText('1')\n\t\tself.btn7.resize(250,250)\n\t\tself.btn7.move(0,1000)\n\t\tself.btn7.clicked.connect(self.clickNum)\n\t\tself.btn8 = QPushButton(self)\n\t\tself.btn8.setText('2')\n\t\tself.btn8.resize(250,250)\n\t\tself.btn8.move(250,1000)\n\t\tself.btn8.clicked.connect(self.clickNum)\n\t\tself.btn9 = QPushButton(self)\n\t\tself.btn9.setText('3')\n\t\tself.btn9.resize(250,250)\n\t\tself.btn9.move(500,1000)\n\t\tself.btn9.clicked.connect(self.clickNum)\n\t\tself.btn10 = QPushButton(self)\n\t\tself.btn10.setText('0')\n\t\tself.btn10.resize(250,250)\n\t\tself.btn10.move(250,1250)\n\t\tself.btn10.clicked.connect(self.clickNum)\n\t\tself.btn11 = QPushButton(self)\n\t\tself.btn11.setText('C')\n\t\tself.btn11.resize(250,250)\n\t\tself.btn11.move(0,1250)\n\t\tself.btn11.clicked.connect(self.clickNum)\n\t\tself.btn12 = QPushButton(self)\n\t\tself.btn12.setText('.')\n\t\tself.btn12.resize(250,250)\n\t\tself.btn12.move(500,1250)\n\t\tself.btn12.clicked.connect(self.clickNum)\n\t\tself.btn13 = QPushButton(self)\n\t\tself.btn13.setText('+')\n\t\tself.btn13.resize(250,250)\n\t\tself.btn13.move(750,500)\n\t\tself.btn13.clicked.connect(self.clickNum)\n\t\tself.btn14 = QPushButton(self)\n\t\tself.btn14.setText('-')\n\t\tself.btn14.resize(250,250)\n\t\tself.btn14.move(750,750)\n\t\tself.btn14.clicked.connect(self.clickNum)\n\t\tself.btn15 = QPushButton(self)\n\t\tself.btn15.setText('*')\n\t\tself.btn15.resize(250,250)\n\t\tself.btn15.move(750,1000)\n\t\tself.btn15.clicked.connect(self.clickNum)\n\t\tself.btn16 = QPushButton(self)\n\t\tself.btn16.setText('/')\n\t\tself.btn16.resize(250,250)\n\t\tself.btn16.move(750,1250)\n\t\tself.btn16.clicked.connect(self.clickNum)\n\t\tself.btn17 = QPushButton(self)\n\t\tself.btn17.setText('=')\n\t\tself.btn17.resize(1000,300)\n\t\tself.btn17.move(0,1500)\n\t\tself.btn17.clicked.connect(self.clickNum)\n\tdef clickNum(self):\n\t\tt = self.let.text()\n\t\tnew = self.sender().text()\n\t\tself.let.setText(t+new)\n\t\tif new == 'C':\n\t\t\tself.let.setText('')\n\t\tif new == '=':\n\t\t\tresult = eval(str(t))\n\t\t\tself.let.setText(str(result))\nif __name__ == '__main__':\n\tapp = QApplication(sys.argv)\n\troot = Window()\n\troot.show()\n\tsys.exit(app.exec_())\n"}, {"ctype": "p", "data": "附上效果图：  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327152941145.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUwOTQ5NzY3,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "PTA 1004 成绩排名----Python3提交 （超级详细）", "作者": "爱代码的小哥", "发布时间": "2021-03-27 15:26:58", "内容": [{"ctype": "p", "data": "题目要求： 写入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。"}, {"ctype": "p", "data": "输入格式： 每个测试输入包含 1 个测试用例，格式为"}, {"ctype": "p", "data": "第 1 行：正整数 n 第 2 行：第 1 个学生的姓名 学号 成绩 第 3 行：第 2 个学生的姓名 学号 成绩 … … … 第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。"}, {"ctype": "p", "data": "输出格式： 对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。"}, {"ctype": "p", "data": "代码实现："}, {"ctype": "code", "data": " #成绩排名\nimport numpy as np\nn = int(input()) #输入学生的个数\nstudent = []  #定义一个学生列表\nfor i in range(0,n): #循环输入每个学生的信息，并将其加入列表\n        s1,s2,s3 = input().split(\" \")\n        student.append(s1)\n        student.append(s2)\n        student.append(s3)\nstudent =  np.array(student)\nstudent = student.reshape((n,3))  #改变列表为n 行三列的数组\n#按成绩进行排序\nstudent = sorted(student,key=(lambda x:float(x[2])),reverse=True)\nprint(f\"{student[0][0]} {student[0][1]}\")\nprint(f\"{student[n-1][0]} {student[n-1][1]}\")\n"}], "cate": "Python"}
{"题目": "python练习之剑指 Offer 11. 旋转数组的最小数字", "作者": "白速龙王的回眸", "发布时间": "2021-03-27 15:36:01", "内容": [{"ctype": "p", "data": "序： 经典的二分搜索"}, {"ctype": "p", "data": "把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。"}, {"ctype": "p", "data": "示例 1："}, {"ctype": "p", "data": "输入：[3,4,5,1,2] 输出：1"}, {"ctype": "p", "data": "示例 2："}, {"ctype": "p", "data": "输入：[2,2,2,0,1] 输出：0"}, {"ctype": "p", "data": "来源：力扣（LeetCode）"}, {"ctype": "p", "data": "分析： 1.以首为l，以尾为r，设中间为m，开始二分搜索 2.以r作为基准：若num[m]<num[r],说明在m到r这区间内肯定没有最小值，放心地令r=m;若num[m] > num[r]，说明m和r这区间中肯定有最小值，放心的令l = m 3.那么num[m] == num[r]时呢？举两个例子说明问题。例一，[1,3,3]，l=0,r=2,m=1，这里如果让l=m直接凉凉；例二，[3,3,1,3]，l=0,r=3,m=1,这里如果让r=m直接凉凉。看起来不能简单粗暴取中点了。那么此时我们可以肯定，num[r]绝对不是最小值，不妨r -= 1，虽然效率没有二分高，但也算是迈了一小步。 4.终止条件：l和m相差1时，直接输出最小值，否则会陷入死循环。"}, {"ctype": "code", "data": "class Solution:\n    def minArray(self, numbers: List[int]) -> int:\n        l , r = 0, len(numbers) - 1\n\n        while(l < r):\n            \n            m = (l + r) // 2\n            if(m == l):\n                return min(numbers[l], numbers[r])\n\n            if(numbers[m] < numbers[r]):\n                r = m\n            elif(numbers[m] > numbers[r]):\n                l = m\n            else:\n                r -= 1\n                \n        return numbers[l]    \n"}, {"ctype": "p", "data": "总结： 二分搜索注意退出判断，以及特殊情况下（如相等）不能取中点，只能使端点-1or+1进行过渡。"}], "cate": "Python"}
{"题目": "如何使用python获取免费的股票行情数据？使用Baostock的API获取股票数据", "作者": "夏悠", "发布时间": "2021-03-27 17:45:15", "内容": [{"ctype": "head", "data": "如何获取免费的股票行情数据？"}, {"ctype": "p", "data": "内容摘要：使用Baostock的API获取股票行情数据；格式化获得的股票行情数据。"}, {"ctype": "head", "data": "1.导入必要的模块"}, {"ctype": "p", "data": "关键模块是： ①numpy、pandas:用来处理数据 ②baostock：用来获取股票数据"}, {"ctype": "code", "data": "\n# 处理数据\nimport numpy as np\nimport pandas as pd\n\n# 获取股票数据\nimport baostock as bs"}, {"ctype": "head", "data": "2.获取股票数据"}, {"ctype": "p", "data": "我们利用baostock获取股票数据。为什么用baostock，而不用tushare?"}, {"ctype": "p", "data": "因为baostock是一个免费、开源的证券数据平台（无需注册）。 提供大量准确、完整的证券历史行情数据、上市公司财务数据等。 通过python API获取证券数据信息，满足量化交易投资者、数量金融爱好者、计量经济从业者数据需求。"}, {"ctype": "p", "data": "下载安装 方式1： pip install baostock 使用国内源安装："}, {"ctype": "code", "data": "pip install baostock -i https://pypi.tuna.tsinghua.edu.cn/simple/ --trusted-host pypi.tuna.tsinghua.edu.cn"}, {"ctype": "p", "data": "方式2"}], "cate": "Python"}
{"题目": "torch.load() 及 torch.save() 总结", "作者": "xingzeng307", "发布时间": "2021-03-27 19:06:18", "内容": [{"ctype": "head", "data": "1. torch.load()"}, {"ctype": "p", "data": " torch: 是pytorch里的一个包，包括了张量(tensor) 的数据结构以及对其的操作  pickle 模块: 实现了对一个 Python 对象结构的二进制序列化(pickling)和反序列化(unpickling)。 pickling: 是一个把Python对象转化成一个字节流的过程。也可称为序列化(serialization)、编组(marshalling)；而相对应反向操作unpickling是将一个字节流转化成一个python对象的过程，也可称为扁平化(flattening) "}, {"ctype": "code", "data": "# 参数f: 理解为要加载的文件名; map_location: 可以是函数或者torch.device或者字典，规定存储位置的映射; pickle_module: 前面提到的用来做反序列化的module; **pickle_load_args: optional, 可传入参数到pickle_module.load()中\ntorch.load(f, map_location=None, pickle_module=<module 'pickle' from '/opt/conda/lib/python3.6/pickle.py'>, **pickle_load_args)\n"}, {"ctype": "code", "data": "# for example: 将所有张量加载到CPU设备\ntorch.load('tensors.pt', map_location=torch.device('cpu'))\n"}, {"ctype": "head", "data": "2. torch.save()"}, {"ctype": "p", "data": "将一个对象(oject)保存到磁盘文件中"}, {"ctype": "code", "data": "# 参数：obj：保存的对象；f: 理解为文件名(通常是pt文件)；pickle_module: 前面提到的用来做序列化的module\ntorch.save(obj, f, pickle_module=<module 'pickle' from '/opt/conda/lib/python3.6/pickle.py'>, pickle_protocol=2, _use_new_zipfile_serialization=True)\n"}, {"ctype": "p", "data": "举例"}, {"ctype": "code", "data": "# Save to file\nx = torch.tensor([0, 1, 2, 3, 4])\ntorch.save(x, 'tensor.pt')\n"}, {"ctype": "code", "data": "# load file\nx = torch.load('tensor.pt')\n"}, {"ctype": "p", "data": "参考资料： https://pytorch.org/docs/stable/generated/torch.save.html https://pytorch.org/docs/stable/generated/torch.load.html https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch/"}], "cate": "Python"}
{"题目": "gray2rgb&resize", "作者": "我是谁who", "发布时间": "2021-03-27 17:52:38", "内容": [{"ctype": "code", "data": "#gray2rgb&resize This is a sample Python script.\n\n# Press Shift+F10 to execute it or replace it with your code.\n# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.\n\nimport os\nimport cv2\n\ndef print_hi(name):\n    # Use a breakpoint in the code line below to debug your script.\n    print(f'Hi, {name}')  # Press Ctrl+F8 to toggle the breakpoint.\n\ndef convertImg(path,num):\n    print(\"happy...\")\n    for root,dirs,files in os.walk(path):\n        for name in files:\n            if(name.endswith('.jpg')):\n                path_img=os.path.join(root,name)\n\n                print(\"path_img:    \"+path_img)\n\n                img1 = cv2.imread(path_img, 0)\n                print(img1)\n                print(img1.shape)\n                height, width = img1.shape[:2]\n                size = (int(width * 0.25), int(height * 0.25))\n                img1 = cv2.resize(img1, size, interpolation=cv2.INTER_AREA)\n                print(img1.shape)\n                img1_rgb = cv2.cvtColor(img1, cv2.COLOR_GRAY2RGB)\n                #cv2.imshow('img1_rgb', img1_rgb)\n                print(num + name)\n                cv2.imwrite(num + name, img1_rgb)\n                #name='1/'+name\n                #txt.write(name+\" \"+name+'\\n')\n\n# Press the green button in the gutter to run the script.\nif __name__ == '__main__':\n    print_hi('PyCharm')\n\n    path = 'D:\\\\road_img\\\\5'\n    #txtName='1.txt'\n    #txt = open(txtName, 'w')\n    convertImg(path,'./5/')\n    #txt.close()\n\n\n# See PyCharm help at https://www.jetbrains.com/help/pycharm/\n"}], "cate": "Python"}
{"题目": "使用Python语言，进行简单的接口测试", "作者": "Warolitbos", "发布时间": "2021-03-27 19:44:42", "内容": [{"ctype": "head", "data": "使用Python语言，进行简单的接口测试"}, {"ctype": "p", "data": "在正常的测试中，当我们需要进行接口测试时，通常使用接口调试工具，如postman进行接口测试 但在python语言中，我们可以使用requests第三方库进行接口测试。 使用简单的线性编程的方法，进行编写："}, {"ctype": "code", "data": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport requests,json\n# 接口的url\nurl = \"http://v.juhe.cn/laohuangli/d\"\n# 接口头部信息\nheaders = {\n\t\"Accept\": \"*/*\",\n\t\"Accept-Encoding\": \"gzip, deflate, br\",\n\t\"Content-Type\": \"application/json\"\n}\n# 接口的参数\nparams = {\n    \"key\": \"4820422dbea4fc4c6a1e4f3177ff0006\",\n    \"date\": \"2021-01-18\",\n}\n# 发送接口\nr = requests.request(\"post\", url, headers=headers, params=params)\nr = r.json()\njs = json.dumps(r, indent=4, separators=(',', ': '), ensure_ascii=False)\n# 打印返回结果\nprint(js)\n\n"}, {"ctype": "p", "data": "再进阶一步，使用面向过程编程的方法进行编写： 使用def()函数："}, {"ctype": "code", "data": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport json\nimport requests\n\n\ndef requests_huangli():\n\t# 接口的url\n\turl = \"http://v.juhe.cn/laohuangli/d\"\n\t# 接口头部信息\n\theaders = {\n\t\t\"Accept\": \"*/*\",\n\t\t\"Accept-Encoding\": \"gzip, deflate, br\",\n\t\t\"Content-Type\": \"application/json\"\n\t}\n\t# 接口的参数\n\tparams = {\n\t\t\"key\": \"4820422dbea4fc4c6a1e4f3177ff0006\",\n\t\t\"date\": \"2021-01-18\",\n\t}\n\t# 发送接口\n\tr = requests.request(\"post\", url, headers=headers, params=params)\n\tr = r.json()\n\tjs = json.dumps(r, indent=4, separators=(',', ': '), ensure_ascii=False)\n\t# 打印返回结果\n\tprint(js)\n\n\nif __name__ == '__main__':\n\trequests_huangli()\n\n"}, {"ctype": "p", "data": "再进一步，使用面向对象编程的方法进行代码编写： 使用class类： 注：由于当前代码逻辑不需要利用到self指针进行定位，故需要添加@staticmethod进行静态调用"}, {"ctype": "code", "data": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport json\nimport requests\n\n\nclass huangli:\n\n\t@staticmethod\n\tdef requests_huangli():\n\t\t# 接口的url\n\t\turl = \"http://v.juhe.cn/laohuangli/d\"\n\t\t# 接口头部信息\n\t\theaders = {\n\t\t\t\"Accept\": \"*/*\",\n\t\t\t\"Accept-Encoding\": \"gzip, deflate, br\",\n\t\t\t\"Content-Type\": \"application/json\"\n\t\t}\n\t\t# 接口的参数\n\t\tparams = {\n\t\t\t\"key\": \"4820422dbea4fc4c6a1e4f3177ff0006\",\n\t\t\t\"date\": \"2021-01-18\",\n\t\t}\n\t\t# 发送接口\n\t\tr = requests.request(\"post\", url, headers=headers, params=params)\n\t\tr = r.json()\n\t\tjs = json.dumps(r, indent=4, separators=(',', ': '), ensure_ascii=False)\n\t\t# 打印返回结果\n\t\tprint(js)\n\n\nif __name__ == '__main__':\n\thuangli.requests_huangli()\n\n"}, {"ctype": "p", "data": "全部返回结果： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327192135844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpcnVzU2NhbkxvZw==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "scrapy爬虫案例-----赶集网", "作者": "无发可脱丶", "发布时间": "2021-03-27 20:56:27", "内容": [{"ctype": "head", "data": "1.蜘蛛侠思路："}, {"ctype": "p", "data": "赶集网 爬取网站的url地址：点击超链接-----赶集网主页-------"}, {"ctype": "p", "data": "-点击【切换城市】转到有所有城市的主页"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327191813548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RqX2hhbmhhbg==,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327191713494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RqX2hhbmhhbg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.构造爬虫及代码解读"}, {"ctype": "code", "data": "#创建爬虫项目\nscrapy startproject ganji_crawl\n\n#创建爬虫\nscrapy genspider ganji anshan.ganji.com\n"}, {"ctype": "head", "data": "(1)settings.py"}, {"ctype": "code", "data": "LOG_LEVEL='WARNING' #日志的输出等级，不想看那么多日志信息就可以写成WARNING\n\nUSER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36'#把自己伪装成浏览器\n\nROBOTSTXT_OBEY = False #不遵从机器人协议\n\n#把注释去掉就行\nITEM_PIPELINES = {\n   'erShouFang.pipelines.ErshoufangPipeline': 300,\n}\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327194611970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RqX2hhbmhhbg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "(2)ganji.py"}, {"ctype": "code", "data": "import scrapy\nimport re\nfrom ..items import ErshoufangItem\nclass GanjiSpider(scrapy.Spider):\n    name = 'ganji' #爬虫名，运行的关键参数\n    start_urls = ['http://www.ganji.com/index.htm']\n\n    def start_requests(self):\n        for urls in self.start_urls:\n            yield scrapy.Request(url=urls,callback=self.parse_province)\n"}, {"ctype": "code", "data": " def parse_province(self,response):\n        all_city_href = response.xpath('.//div[@class=\"all-city\"]/dl/dd/a/@href').extract()[:1]  #300个城市中选前1个\n        for city_href in all_city_href:\n            yield scrapy.Request(url=city_href+\"zufang\",callback=self.parse_detail_urls)\n"}, {"ctype": "code", "data": "    def parse_detail_urls(self,response):\n        print(\"province_urls:\" + response.url)\n        all_detail_url = response.xpath('.//dd[@class=\"dd-item title\"]/a/@href').extract()\n        for detail_url in all_detail_url:\n            if \"http\" in detail_url:\n                yield scrapy.Request(url=detail_url,callback=self.parse_detail)\n            if \"http\" not in detail_url:\n                yield scrapy.Request(url=\"http:\"+detail_url,callback=self.parse_detail)\n        next_url = response.xpath('.//a[@class=\"next\"]/@href').get()\n        if next_url:\n            yield scrapy.Request(url=next_url, callback=self.parse_detail_urls)\n"}, {"ctype": "code", "data": "    def parse_detail(self,response):\n        print(\"detail_ulrs:\"+response.url)\n        item = ErshoufangItem()  #存储\n        item['title'] = response.xpath('normalize-space(.//title/text())').get()\n        item['money']  = response.xpath('.//div[@class=\"price-wrap\"]/span[1]/text()').get()\n        item['ya_type']  = response.xpath('.//div[@class=\"price-wrap\"]/span[2]/text()').get()\n        item['huxing']  = response.xpath('.//ul[@class=\"er-list f-clear\"]/li[1]/span[2]/text()').get()\n        mianji  = response.xpath('.//ul[@class=\"er-list f-clear\"]/li[2]/span[2]/text()').get()\n        item['zu_type']  =re.findall('\\w{2}',mianji)[0]\n        item['pingfa']  =re.findall('\\w{2}',mianji)[1]\n        item['chaoxiang']  = response.xpath('.//ul[@class=\"er-list f-clear\"]/li[3]/span[2]/text()').get()\n        louceng = response.xpath('.//ul[@class=\"er-list f-clear\"]/li[4]/span[2]/text()').get()\n        item['cengshu']  = re.findall('\\d+',louceng)[0]\n        item['zhuangxiu']  = response.xpath('.//ul[@class=\"er-list f-clear\"]/li[5]/span[2]/text()').get()\n        item['xiaoqu']  = response.xpath('.//ul[@class=\"er-list-two f-clear\"]/li[1]/span[2]/a/span/text()').get()\n        item['ditie']  = response.xpath('.//ul[@class=\"er-list-two f-clear\"]/li[2]/div/span/text()').get()\n        item['dizhi']  = response.xpath('normalize-space(.//ul[@class=\"er-list-two f-clear\"]/li[3]/span[2]/text())').get()\n        item['name']  = response.xpath('.//div[@class=\"user-info-top\"]/div[1]/a/text()').get()\n        yield item\n"}, {"ctype": "head", "data": "(3)run.py"}, {"ctype": "code", "data": "from scrapy import cmdline\ncmdline.execute('scrapy crawl ganji'.split())\n"}, {"ctype": "head", "data": "(4)items.py"}, {"ctype": "code", "data": "class ErshoufangItem(scrapy.Item):\n    # define the fields for your item here like:\n    title = scrapy.Field()\n    money = scrapy.Field()\n    ya_type = scrapy.Field()\n    huxing = scrapy.Field()\n    zu_type = scrapy.Field()\n    pingfa = scrapy.Field()\n    chaoxiang = scrapy.Field()\n    cengshu = scrapy.Field()\n    zhuangxiu = scrapy.Field()\n    xiaoqu = scrapy.Field()\n    ditie = scrapy.Field()\n    dizhi = scrapy.Field()\n    name = scrapy.Field()\n"}, {"ctype": "head", "data": "(5)pipelines.py"}, {"ctype": "code", "data": "class ErshoufangPipeline(object):\n    def __init__(self):\n        # self.connect = pymysql.connect(host='localhost',user='root',passwd='123456',db='ershoufang')\n        # self.cursor = self.connect.cursor()\n        self.file =codecs.open('./zufang.json','w','utf-8')\n        self.dic = \"\"\n"}, {"ctype": "code", "data": "    def process_item(self, item, spider):\n        # sql=\"\"\"\n        # insert into table(title,money) values(%s,%s)\n        # \"\"\"\n        # self.cursor.execute(sql,(item['title'],item['money']))\n        # self.connect.commit()  #提交\n        lines = json.dumps(dict(item),ensure_ascii=False)+\",\\n\"\n        self.dic+=lines  \n        return item\n    def close_spider(self,spider):\n        self.file.write(\"[{0}]\".format(self.dic[:-2])) \n        self.file.close()\n        # self.connect.close()\n        # self.cursor.close()\n"}, {"ctype": "head", "data": "(6)前十条数据"}, {"ctype": "code", "data": "[{\"title\": \"红岭家园 2室1厅1卫，鞍千路 - 赶集网\", \"money\": \"900\", \"ya_type\": \"半年付\", \"huxing\": \"2室1厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"66\", \"chaoxiang\": \"南北\", \"cengshu\": \"22\", \"zhuangxiu\": \"简单装修\", \"xiaoqu\": \"红岭家园\", \"ditie\": \"暂无信息\", \"dizhi\": \"立山立山广场 - 鞍千路\", \"name\": \"696882\"},\n{\"title\": \"华润置地广场 1室0厅1卫，建国大道,近民生西路 - 赶集网\", \"money\": \"1300\", \"ya_type\": \"押一付一\", \"huxing\": \"1室0厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"50\", \"chaoxiang\": \"西\", \"cengshu\": \"27\", \"zhuangxiu\": \"精装修\", \"xiaoqu\": \"华润置地广场\", \"ditie\": \"暂无信息\", \"dizhi\": \"铁东二一九 - 建国大道,近民生西路\", \"name\": \"置家\"},\n{\"title\": \"解放西路52号小区 1室1厅1卫，解放西路52乙号 - 赶集网\", \"money\": \"400\", \"ya_type\": \"年付\", \"huxing\": \"1室1厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"40\", \"chaoxiang\": \"南北\", \"cengshu\": \"6\", \"zhuangxiu\": \"简单装修\", \"xiaoqu\": \"解放西路52号小区\", \"ditie\": \"暂无信息\", \"dizhi\": \"铁西九街口 - 解放西路52乙号\", \"name\": \"hbjes_au6\"},\n{\"title\": \"铁东一道街 3室2厅1卫 - 赶集网\", \"money\": \"1000\", \"ya_type\": \"半年付\", \"huxing\": \"3室2厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"86\", \"chaoxiang\": \"东西\", \"cengshu\": \"6\", \"zhuangxiu\": \"简单装修\", \"xiaoqu\": null, \"ditie\": \"暂无信息\", \"dizhi\": \"铁东站前\", \"name\": \"王先生\"},\n{\"title\": \"调军台小区 1室1厅1卫，鞍千路 - 赶集网\", \"money\": \"950\", \"ya_type\": \"押一付三\", \"huxing\": \"1室1厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"55\", \"chaoxiang\": \"东南\", \"cengshu\": \"17\", \"zhuangxiu\": \"精装修\", \"xiaoqu\": \"调军台小区\", \"ditie\": \"暂无信息\", \"dizhi\": \"立山立山广场 - 鞍千路\", \"name\": \"吴女士\"},\n{\"title\": \"烈士山社区 1室1厅1卫，胜利南路26号 - 赶集网\", \"money\": \"350\", \"ya_type\": \"年付\", \"huxing\": \"1室1厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"50\", \"chaoxiang\": \"西北\", \"cengshu\": \"8\", \"zhuangxiu\": \"简单装修\", \"xiaoqu\": \"烈士山社区(民生东路北)\", \"ditie\": \"暂无信息\", \"dizhi\": \"铁东二一九 - 胜利南路26号\", \"name\": \"蓝眼泪335\"},\n{\"title\": \"中天社区 3室2厅1卫，铁东二道街 - 赶集网\", \"money\": \"1500\", \"ya_type\": \"年付\", \"huxing\": \"3室2厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"15\", \"chaoxiang\": \"东南\", \"cengshu\": \"6\", \"zhuangxiu\": \"精装修\", \"xiaoqu\": \"中天社区\", \"ditie\": \"暂无信息\", \"dizhi\": \"铁东站前 - 铁东二道街\", \"name\": \"宁女士\"},\n{\"title\": \"联盟社区 3室0厅1卫，联盟街11号 - 赶集网\", \"money\": \"500\", \"ya_type\": \"半年付\", \"huxing\": \"3室0厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"73\", \"chaoxiang\": \"南北\", \"cengshu\": \"7\", \"zhuangxiu\": \"简单装修\", \"xiaoqu\": \"联盟社区\", \"ditie\": \"暂无信息\", \"dizhi\": \"铁东烈士山 - 联盟街11号\", \"name\": \"张女士\"},\n{\"title\": \"红星小区 2室1厅1卫，红星南街22号 - 赶集网\", \"money\": \"375\", \"ya_type\": \"押一付三\", \"huxing\": \"2室1厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"68\", \"chaoxiang\": \"南\", \"cengshu\": \"6\", \"zhuangxiu\": \"简单装修\", \"xiaoqu\": \"红星小区\", \"ditie\": \"暂无信息\", \"dizhi\": \"海城永安路 - 红星南街22号\", \"name\": \"杨迎女士\"},\n{\"title\": \"港丽花园 1室1厅1卫，解放东路150号 - 赶集网\", \"money\": \"1200\", \"ya_type\": \"半年付\", \"huxing\": \"1室1厅1卫\", \"zu_type\": \"整租\", \"pingfa\": \"38\", \"chaoxiang\": \"南\", \"cengshu\": \"33\", \"zhuangxiu\": \"精装修\", \"xiaoqu\": \"港丽花园\", \"ditie\": \"暂无信息\", \"dizhi\": \"铁东解放路 - 解放东路150号\", \"name\": \"女士\"},\n"}, {"ctype": "head", "data": "3.蜘蛛侠的小Tips（不是黑丝）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032720405832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RqX2hhbmhhbg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "这只蜘蛛结束了朴实无华的一生，想要练习也可以试着去爬取这个网站的更多城市，二手房、厂房啥的j举一反三，不理解的地方可以一起学习交流。代码不完美的地方请多多谅解，多多指教，多多交流。"}], "cate": "Python"}
{"题目": "对装饰器的一点理解", "作者": "tester_FAN", "发布时间": "2021-03-27 20:00:02", "内容": [{"ctype": "p", "data": "看了很多关于装饰器的文章，发现还是要手动自己写写代码，总结总结才能加深印象。 1、装饰器用来扩展已有函数的功能，在不改变函数内部结构的情况，扩展函数的功能。 2、装饰器传入的是一个函数，返回的也是一个函数。"}, {"ctype": "code", "data": "def demo1(func):\n    def spend():\n        start_time = time.time()\n        func()\n        end_time = time.time()\n        total_time = (end_time - start_time) * 1000\n        print(\"函数耗时%d ms\" % total_time)\n\n    return spend  # 注意pycharm自动补齐，会加上一个括号，这里不需要括号\n    \n@demo1\ndef test():\n    s = 0\n    for i in range(101):\n        s = s + i\n        time.sleep(0.1)\n    print(s)\n\n\nif __name__ == '__main__':\n    test()\n"}, {"ctype": "p", "data": "得到如下结果  3、多个装饰器"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327193308991.png"}, {"ctype": "code", "data": "def demo2(func):\n    def sheet():\n        print(\"测试开始\")\n        func()\n        print(\"测试结束\")\n\n    return sheet\n\n\n@demo1\n@demo2\ndef test():\n    s = 0\n    for i in range(101):\n        s = s + i\n        time.sleep(0.1)\n    print(s)\n"}, {"ctype": "p", "data": "先执行第二个装饰器，再执行第一个装饰器，最后执行函数本身，输出结果如下，  4、当函数中有不定长的参数时，使用收集参数"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327193758884.png"}, {"ctype": "code", "data": "def demo3(func):\n    def tester(*args, **kwargs):\n        print(\"start test...\")\n        func(*args, **kwargs)\n        print(\"end test...\")\n\n    return tester\n\n\n@demo3\ndef plus(a, b, c):\n    print(a+b+c)\n\n\nif __name__ == '__main__':\n    plus(10, 12, 15)\n"}, {"ctype": "p", "data": "输出结果如下，  5、当被装饰的函数中会return一个值时，必须在装饰器中，return被装饰函数的结果。否则执行函数返回的是None。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327194633864.png"}, {"ctype": "code", "data": "def demo3(func):\n    def tester(*args, **kwargs):\n        print(\"start test...\")\n        ret = func(*args, **kwargs)\n        print(\"end test...\")\n        return ret  # 这里返回被装饰函数的return结果\n\n    return tester\n\n\n@demo3\ndef plus(a, b, c):\n    return a+b+c\n\n\nif __name__ == '__main__':\n    print(plus(10, 12, 15))\n"}, {"ctype": "p", "data": "输出如下， "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327195901617.png"}], "cate": "Python"}
{"题目": "python字符串函数split_Python常见字符串操作函数小结【split()、join()、strip()】", "作者": "gaoluan6052", "发布时间": "2021-03-27 20:01:58", "内容": [{"ctype": "p", "data": "本文实例讲述了Python常见字符串操作函数。分享给大家供大家参考，具体如下："}, {"ctype": "p", "data": "str.split(’ ')"}, {"ctype": "p", "data": "1.按某一个字符分割，如‘.’"}, {"ctype": "code", "data": ">>> s = ('www.google.com')\n>>> print(s)\nwww.google.com\n\n>>> s.split('.')\n['www', 'google', 'com']\n"}, {"ctype": "p", "data": "2.按某一个字符分割，且分割n次。如按‘.'分割1次；参数maxsplit位切割的次数"}, {"ctype": "code", "data": ">>> s = 'www.google.com'\n>>> s\n'www.google.com'\n\n>>> s.split('.', maxsplit=1)\n['www', 'google.com']\n"}, {"ctype": "p", "data": "3.按某一字符串分割。如：‘||’"}, {"ctype": "code", "data": ">>> s = 'WinXP||Win7||Win8||Win8.1'\n\n>>> s\n\n'WinXP||Win7||Win8||Win8.1'\n\n>>> s.split('||')\n\n['WinXP', 'Win7', 'Win8', 'Win8.1']\n\n"}, {"ctype": "p", "data": "’ '.join(str)"}, {"ctype": "p", "data": "Python中有join()和os.path.join()两个函数，具体作用如下："}, {"ctype": "p", "data": "join()： 连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串"}, {"ctype": "p", "data": "os.path.join()： 将多个路径组合后返回"}, {"ctype": "p", "data": "对序列进行操作(分别使用’ ‘与’:'作为分隔符)"}, {"ctype": "code", "data": ">>> seq1 = ['hello','good','boy','doiido']\n\n>>> print ' '.join(seq1)\n\nhello good boy doiido\n\n>>> print ':'.join(seq1)\n\nhello:good:boy:doiido\n"}, {"ctype": "p", "data": "对字符串进行操作"}, {"ctype": "code", "data": ">>> seq2 = \"hello good boy doiido\"\n\n>>> print ':'.join(seq2)\n\nh:e:l:l:o: :g:o:o:d: :b:o:y: :d:o:i:i:d:o\n"}, {"ctype": "p", "data": "对元组进行操作"}, {"ctype": "code", "data": ">>> seq3 = ('hello','good','boy','doiido')\n\n>>> print ':'.join(seq3)\n"}, {"ctype": "code", "data": "hello:good:boy:doiido\n"}, {"ctype": "p", "data": "对字典进行操作"}, {"ctype": "code", "data": ">>> seq4 = {'hello':1,'good':2,'boy':3,'doiido':4}\n\n>>> print ':'.join(seq4)\n\nboy:good:doiido:hello\n"}, {"ctype": "p", "data": "合并目录"}, {"ctype": "code", "data": ">>> import os\n\n>>> os.path.join('/hello/','good/boy/','doiido')\n\n'/hello/good/boy/doiido'\n\nstr.strip()\n"}, {"ctype": "p", "data": "声明：s为字符串，rm为要删除的字符序列"}, {"ctype": "p", "data": "s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符；"}, {"ctype": "p", "data": "s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符；"}, {"ctype": "p", "data": "s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符；"}, {"ctype": "p", "data": "当rm为空时，默认删除空白符(包括’\\n’, ‘\\r’, ‘\\t’, ’ ')"}, {"ctype": "p", "data": "例如："}, {"ctype": "code", "data": ">>> a = '123abc'\n\n>>> a.strip('21')\n"}, {"ctype": "p", "data": "‘3abc’ 结果是一样的"}, {"ctype": "code", "data": ">>> a.strip('12')\n\n'3abc'\n"}, {"ctype": "p", "data": "2.这里的rm删除序列是只要边(开头或结尾)上的字符在删除序列内，就删除掉。"}, {"ctype": "p", "data": "例如 ："}, {"ctype": "code", "data": ">>> a = '123abc'\n\n>>> a.strip('21')\n"}, {"ctype": "p", "data": "‘3abc’ 结果是一样的"}, {"ctype": "code", "data": ">>> a.strip('12')\n\n'3abc'\n"}], "cate": "Python"}
{"题目": "python练习之剑指 Offer 10- II. 青蛙跳台阶问题", "作者": "白速龙王的回眸", "发布时间": "2021-03-27 14:46:06", "内容": [{"ctype": "p", "data": "一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。"}, {"ctype": "p", "data": "答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。"}, {"ctype": "p", "data": "来源：力扣（LeetCode）"}, {"ctype": "p", "data": "分析： Fibonacci的变式，具体见剑指offer兔子数列"}, {"ctype": "code", "data": "class Solution:\n    def numWays(self, n: int) -> int:\n        a, b = 1, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a % 1000000007\n"}, {"ctype": "p", "data": "总结： 无它，Fibonacci改变初值。"}], "cate": "Python"}
{"题目": "2021-03-27python爬虫学习", "作者": "IshidaYamato", "发布时间": "2021-03-27 22:12:08", "内容": [{"ctype": "p", "data": ""}, {"ctype": "code", "data": "import requests\nif __name__==\"__main__\":\n    url='https://www.sogou.com/'\n    response=requests.get(url=url)\n    page_text=response.text\n    print(page_text)\n    with open('./sogou.html','w',encoding='utf-8')as fp:\n        fp.write(page_text)\n    print('爬起数据结束')\n"}, {"ctype": "p", "data": "2.简易网页采集 -UA检测 -UA伪装"}, {"ctype": "code", "data": "#UA检测：门户网站的服务器会检测对应请求的载体身份标识，如果检测到标识为某一浏览器\n#说明该请求是正常的请求，如果不是基于浏览器，则该请求不正常（爬虫）服务器拒绝该次请求\n#UA伪装：让爬虫对应的请求载体伪装成某一款浏览器\n\nimport requests\nif __name__==\"__main__\":\n    #UA伪装：将对应的user-agent封装到一个字典中\n    headers={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome'\n                          '/89.0.4389.90 Safari/537.36 Edg/89.0.774.63'}\n    url='https://www.sogou.com/web'\n    #处理url携带参数：封装到字典中\n    kw=input('enter a word:')\n    param={\n        'query':kw\n    }\n    #对指定的url发起的请求对应url是携带参数的，并且请求过程中处理了参数\n    response=requests.get(url=url,params=param,headers=headers)\n    page_text=response.text\n    fileName=kw+'.html'\n    with open(fileName,'w',encoding='utf-8')as fp:\n        fp.write(page_text)\n    print(fileName,'保存成功！！！')\n"}, {"ctype": "p", "data": ""}, {"ctype": "p", "data": "破解百度翻译 -post请求（携带了参数） -响应数据是一组json数据"}, {"ctype": "code", "data": "\nimport requests\nimport json\nif __name__==\"__main__\":\n    #1指定url\n    post_url='https://fanyi.baidu.com/sug'\n    #2进行UA伪装：\n    hearders={\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome'\n                      '/89.0.4389.90 Safari/537.36 Edg/89.0.774.63'\n    }\n    #3post请求参数处理（同get请求一致）\n    data={\n        'kw':'cat'\n    }\n    #4请求发送\n    response=requests.post(url=post_url,data=data)\n    #5获取响应数据json()返回obj/如果确认响应数据是json类型才能使用-Content-Type:application/json\n    dic_obj=response.json()\n    print(dic_obj)\n    #6进行持久化存储\n    fp=open('./cat.json','w',encoding='utf-8')\n    json.dump(dic_obj,fp=fp,ensure_ascii=False)\n    print(\"over\")\n"}, {"ctype": "p", "data": "设置动态"}, {"ctype": "code", "data": "import requests\nimport json\nif __name__==\"__main__\":\n    #1指定url\n    post_url='https://fanyi.baidu.com/sug'\n    #2进行UA伪装：\n    hearders={\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome'\n                      '/89.0.4389.90 Safari/537.36 Edg/89.0.774.63'\n    }\n    #3post请求参数处理（同get请求一致）\n    word=input('enter a word:')\n    data={\n        'kw':word\n    }\n    #4请求发送\n    response=requests.post(url=post_url,data=data)\n    #5获取响应数据json()返回obj/如果确认响应数据是json类型才能使用-Content-Type:application/json\n    dic_obj=response.json()\n    print(dic_obj)\n    #6进行持久化存储\n    fileName=word+'.json'\n    fp=open(fileName,'w',encoding='utf-8')\n    json.dump(dic_obj,fp=fp,ensure_ascii=False)\n    print(\"over\")\n"}, {"ctype": "p", "data": "4.爬取豆瓣电源榜"}, {"ctype": "code", "data": "import requests\nimport json\nif __name__==\"__main__\":\n    url='https://movie.douban.com/j/chart/top_list'\n    parm={\n        'type': '24',\n        'interval_id': '100:90',\n        'action':'',\n        'start': '0',#第1部电影去取\n        'limit': '20',#一次取出的个数\n    }\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.63'\n    }\n    response=requests.get(url=url,params=parm,headers=headers)\n    list_data=response.json()\n    fp=open('./douban.json','w',encoding='utf-8')\n    json.dump(list_data,fp=fp,ensure_ascii=False)\n    print('查询结束！！')\n"}], "cate": "Python"}
{"题目": "html常见文本属性", "作者": "记住保存", "发布时间": "2021-03-27 20:30:22", "内容": [{"ctype": "head", "data": "HTML文本属性"}, {"ctype": "p", "data": "在html文档中，标记名、属性、元素内容共同决定了一个元素的显示内容和行为"}, {"ctype": "p", "data": "其中文本的相关属性可以设置text文本的相关样式"}, {"ctype": "table", "data": "属性作用color设置文本的颜色text-transform控制文本的大小写text-justify规定当text-align设置为“justify”时所使用的方法direction规定文本的方向/书写方向unicode-bidi设置文本的方向text-outline设置文本的轮廓letter-spacing设置字符间距white-space规定如何处理元素中的空白text-overflow规定当文本溢出包含元素时发生的事情line-height设置行高word-space设置单词间距text-decoration规定添加到文本的装饰效果hanging-punctuation规定标点字符是否位于线框之外text-wrap规定文本的换行规则text-align规定文本的水平对齐方式punctuation-trim规定是否对标的按字符进行剪切text-indent规定文本块首行的缩进text-align-last设置如何对齐最后一行或紧挨着强制换行符之前的行text-emphasis向元素的文本应用重点标记word-break规定非中日韩文本的换行规则word-warp允许对长的不可分割的单词进行分割并换行到下一行"}], "cate": "Python"}
{"题目": "Selenium3 Python WebDriver API源码探析（19）加载FireFox用户配置文件", "作者": "mighty13", "发布时间": "2021-03-27 00:10:31", "内容": [{"ctype": "head", "data": "FireFox用户配置文件"}, {"ctype": "p", "data": "Firefox 将用户个人信息（例如书签、密码、首选项、扩展、Cookie、证书等）保存在一系列文件中，它们被叫做用户配置文件，它们与 Firefox 的程序文件保存在不同位置。 因此，WebDriver如果能够加载已有的FireFox用户配置文件可带来很多便利！"}, {"ctype": "head", "data": "查找用户配置文件"}, {"ctype": "p", "data": "Firefox默认在本地路径C:\\Users\\<your Windows login username>\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\保存配置文件，可通过以下方式获取路径。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210325235249450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pZ2h0eTEz,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "加载FireFox用户配置文件"}, {"ctype": "p", "data": "根据《Selenium3 Python WebDriver API源码探析（18）FireFox WebDriver实现，安装扩展》可知，webdriver在实例化时可设置firefox_profile参数，取值为FirefoxProfile 对象或字符串。如果没有定义，将在操作系统的临时目录中生成一个新的自定义配置文件。"}, {"ctype": "p", "data": "FirefoxProfile 对象为selenium\\webdriver\\firefox\\firefox_profile.py中FirefoxProfile类的实例。 类签名为：class FirefoxProfile(profile_directory=None): 参数profile_directory为用户配置文件路径。"}, {"ctype": "head", "data": "案例：加载FireFox用户配置文件"}, {"ctype": "code", "data": "import selenium.webdriver as webdriver\nfrom selenium.webdriver.firefox.firefox_profile import FirefoxProfile\n# 用户配置文件路径\nprofile_path = r'C:\\Users\\Administrator\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\1yh6m4pk.default-release'\n# 创建FirefoxProfile对象\nmy_profile = FirefoxProfile(profile_directory=profile_path)\n# 设置webdriver启动时加载的用户配置文件\ndriver = webdriver.Firefox(firefox_profile=my_profile)\n\nprint(driver.firefox_profile.path)\n"}, {"ctype": "head", "data": "控制台输出："}, {"ctype": "p", "data": "C:\\Users\\Administrator\\AppData\\Local\\Temp\\1\\tmppd69_1qi\\webdriver-py-profilecopy 注意，用户配置文件比较大的慎重使用！！ Webdriver启动之后都会把指定的Firefox配置文件路径复制到临时目录中。每次使用的临时目录不同，使用不慎可能导致磁盘空间不足。"}, {"ctype": "p", "data": "FirefoxProfile类源码："}, {"ctype": "code", "data": "self.tempfolder = tempfile.mkdtemp()\nnewprof = os.path.join(self.tempfolder, \"webdriver-py-profilecopy\")\n"}, {"ctype": "head", "data": "界面对比"}, {"ctype": "p", "data": "正常浏览器的界面，书签添加了腾讯首页，扩展安装了Video DownloadHelper。 不加载用户配置文件，即新用户配置文件的geckodriver界面。 加载用户配置文件，观察可发现webdriver加载了之前添加的书签和扩展。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210325235840327.png"}, {"ctype": "head", "data": "参考文献"}, {"ctype": "p", "data": "https://support.mozilla.org/zh-CN/kb/%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"}], "cate": "Python"}
{"题目": "使用Tensorflow和numpy分别构建简单神经网络", "作者": "Enoch Liu98", "发布时间": "2021-03-27 17:57:26", "内容": [{"ctype": "head", "data": "使用Tensorflow和numpy分别构建简单神经网络"}, {"ctype": "head", "data": "numpy构建"}, {"ctype": "code", "data": "'''\n用底层numpy实现神经网络\n这里使用的时pytorch风格的实现方式\n'''\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n'''\n定义layer基本类\n'''\nclass Layer:\n    def __init__(self):\n        pass\n    def forward(self,input):\n        return input\n    def backward(self,input,grad_output):\n        pass\n\n'''\n定义基本的神经网络激活函数\n'''\n#ReLU损失函数\nclass ReLU(Layer):\n    def __init__(self):\n        pass\n    def forward(self,input):\n        return np.maximum(0,input)\n    def backward(self,input,grad_output):\n        #判断输入是否大于0，如果不大于0，则梯度直接就是0，否则为1\n        relu_grad=input>0\n        return grad_output*relu_grad\n#Sigmoid损失函数\nclass Sigmoid(Layer):\n    def __init__(self):\n        pass\n    def _sigmoid(self,x):\n        return 1.0/(1+np.exp(-x))\n    def forward(self,input):\n        return self._sigmoid(input)\n    def backward(self,input,grad_output):\n        #这里时sigmoid函数的特性\n        sigmoid_grad=self._sigmoid(input)*(1-self._sigmoid(input))\n        return grad_output*sigmoid_grad\n\n\n#Tanh损失函数\nclass Tanh(Layer):\n    def __init__(self):\n        pass\n    def _tanh(self,x):\n        return np.tanh(x)\n    def forward(self,input):\n        return self._tanh(input)\n    def backward(self,input,grad_output):\n        tanh_grad=1-(self._tanh(input))**2\n        return grad_output*tanh_grad\n\n'''\n定义全连接层\n'''\nclass Dense(Layer):\n    def __init__(self,input_units,output_units,learning_rate=0.01):\n        self.learning_rate=learning_rate\n        self.weights=np.random.rand(input_units,output_units)*0.01\n        self.biases=np.zeros(output_units)\n    def forward(self,input):\n        return np.dot(input,self.weights)+self.biases\n    def backward(self,input,grad_output):\n        grad_input=np.dot(grad_output,self.weights.T)\n        grad_weights=np.dot(input.T,grad_output)/input.shape[0]\n        grad_biases=grad_output.mean(axis=0)\n        self.weights=self.weights-self.learning_rate*grad_weights\n        self.biases=self.biases-self.learning_rate*grad_biases\n        return grad_input\n\nclass NNet(Layer):\n    def __init__(self):\n        self.network=[]\n        self.network.append(Dense(1,94))\n        self.network.append(Tanh())\n        self.network.append(Dense(94,1))\n    def forward(self,X):\n        activations=[]\n        input=X\n        for layer in self.network:\n            activations.append(layer.forward(input))\n            input=activations[-1]\n\n        return activations\n    def predict(self,X):\n        logits=self.forward(X)[-1]\n        return logits\n    def train(self,X,y):\n        layer_activations=self.forward(X)\n        layer_inputs=[X]+layer_activations\n        logits=layer_activations[-1]\n\n        loss=np.square(logits-y).sum()\n        loss_grad=2.0*(logits-y)\n        for layer_i in range(len(self.network))[::-1]:\n            layer=self.network[layer_i]\n            loss_grad=layer.backward(layer_inputs[layer_i],loss_grad)\n\n        return np.mean(loss)\n\nif  __name__==\"__main__\":\n    x_train=np.linspace(-np.pi,0.7*np.pi,140).reshape(140,-1)\n    y_train=np.sin(x_train)\n    x_test=np.linspace(np.pi*0.7,np.pi,60).reshape(60,-1)\n    y_test=np.sin(x_test)\n    nnet=NNet()\n\n    losses=[]\n    for epoch in range(100000):\n        loss=nnet.train(x_train,y_train)\n        losses.append(loss)\n        print(loss)\n\n    plt.plot(range(len(losses)),losses)\n    plt.show()\n\n\n\n\n\n\n"}, {"ctype": "p", "data": "numpy方法构建主要采用的pytorch常用的模板，也就是构建，前向传播，反向传播"}, {"ctype": "head", "data": "Tensorflow构建"}, {"ctype": "code", "data": "#!/usr/bin/python3\n# coding=utf-8\nimport tensorflow as tf\nimport pandas as pd\nimport numpy as np\nimport random\nbatch_size=30\nn_epochs=10\nn_batches=85//batch_size\nn_test_batches=68//batch_size\n'''\n构建数据集\n'''\ndef transform(mclass):\n    if mclass==1:\n        return [1,0,0]\n    elif mclass==2:\n        return [0,1,0]\n    else:\n        return [0,0,1]\n\niris_test=np.loadtxt(\"iris/train.txt\",encoding=\"UTF-8-sig\")\nrandom.shuffle(iris_test)\niris_x_test=iris_test[:,:4]\nprint(iris_x_test)\niris_y_test=iris_test[:,4]\niris_y_test=np.array(list(map(transform,iris_y_test)))\nprint(iris_y_test)\nprint(iris_test.shape)\n\n\n\niris=np.loadtxt(\"iris/test.txt\",encoding=\"UTF-8-sig\")\nrandom.shuffle(iris)\niris_x=iris[:,:4]\nprint(iris_x)\niris_y=iris[:,4]\niris_y=np.array(list(map(transform,iris_y)))\nprint(iris_y)\nprint(iris.shape)\n\n\nX=tf.placeholder(shape=[None,4],dtype=tf.float32,name='X')\nY=tf.placeholder(shape=[None,3],dtype=tf.float32,name='Y')\n\n\nW_l1=tf.Variable(tf.random_normal([4,8]))\nb_l1=tf.Variable(tf.zeros([8]))\nWb_l1=tf.matmul(X,W_l1)+b_l1\nl1=tf.nn.relu(Wb_l1)\n\nW_l2=tf.Variable(tf.random_normal([8,3]))\nb_l2=tf.Variable(tf.zeros([3]))\nprediction=tf.matmul(l1,W_l2)+b_l2\n#prediction=tf.nn.relu(Wb_l2)\n\n# W_l3=tf.Variable(tf.random_normal([5,3]))\n# b_l3=tf.Variable(tf.zeros([3]))\n# prediction=tf.matmul(l2,W_l3)+b_l3\n\nloss=tf.nn.softmax_cross_entropy_with_logits(labels=Y,logits=prediction)\nloss=tf.reduce_mean(loss)\n\ntrain_step=tf.train.AdamOptimizer(0.1).minimize((loss))\n\ncorrect=tf.equal(tf.argmax(Y,1),tf.argmax(prediction,1))\naccuracy=tf.reduce_mean(tf.cast(correct,tf.float32))\n\ninit=tf.global_variables_initializer()\nwith tf.Session() as sess:\n    sess.run(init)\n    for epoch in range(n_epochs):\n        train_acc=.0\n        test_acc=.0\n        for batch in range(n_batches):\n            X_batch=iris_x[batch*batch_size:(batch+1)*batch_size]\n            Y_batch=iris_y[batch*batch_size:(batch+1)*batch_size]\n            train_val,acc_val,y=sess.run([train_step,accuracy,prediction],feed_dict={X:X_batch,Y:Y_batch})\n            print(acc_val)\n            train_acc+=acc_val\n        train_acc/=n_batches\n        print(\"train_acc:\",train_acc)\n\n        for batch in range(n_test_batches):\n            X_batch=iris_x_test[batch*batch_size:(batch+1)*batch_size]\n            Y_batch=iris_y_test[batch*batch_size:(batch+1)*batch_size]\n            acc_val=sess.run(accuracy,feed_dict={X:X_batch,Y:Y_batch})\n            test_acc+=acc_val\n        test_acc/=n_batches\n        print(\"test_acc:\", test_acc)\n"}], "cate": "Python"}
{"题目": "python之字典的操作", "作者": "月疯", "发布时间": "2021-03-27 19:34:51", "内容": [{"ctype": "p", "data": " api序列："}, {"ctype": "p", "data": "测试："}, {"ctype": "code", "data": "#-*- coding: utf-8 -*-\n#字典\n#1、字典的创建\nd1={\"one\":1,\"two\":2,\"three\":3}#字面量句法\nd2=dict(one=1,two=2,three=3)\nd3=dict([(\"one\",1),(\"two\",2),(\"three\",3)])\nd4=dict({\"one\":1,\"two\":2,\"three\":3})\nd5=dict(zip([\"one\",\"two\",\"three\"],[1,2,3]))#zip并行解包\nprint(d1==d2==d3==d4==d5)#True\nprint(d1)\n\n#2、python内置函数（len，type，str）\n# 计算字典的长度\nss=len(d1)\nprint(ss)\n#以字符方式输出字典,即将字典转换成字符串\nss1=str(d1)\nprint(ss1)\n# 判断类型\nss2=type(d1)\nprint(ss2)\n\n#清空字典\nd5.clear()\nprint(d5)\n\n#复制字典\nd6=d4.copy()\nprint(d6)\n\n#以序列作为kye创建一个新字典，value为所有键对应的初始值\ndre={\"name\":\"huitao\",\"age\":13}\ntup=[1,2,3,4]\n\ndre_n=dre.fromkeys(tup,\"vale\")\n\nprint(dre_n)\n\n#返回指定key的value，如果key不存在，则返回默认值\n\nvv=dre.get(\"name\",\"呵呵\")\n#如果name不存在，则返回去（“呵呵”）\nprint(vv)\n\n# in 判断key是否存在，是则返回True，否则返回False\n\nres= \"name\" in dre\n\nprint(res)\n\n#items 返回可遍历的的元组，元组的元素为(key,value)形式\n\nsw=dre.items()\nprint(sw)\n\n# keys 返回字典的所有key\nkeys=dre.keys()\nprint(keys)\n\n#setdefault 如果key存在，则返回其对应的value，否则将该key和默认值插入到字典中，并返回默认值\n\nsn=dre.setdefault(\"name\",\"lala\")\n\nprint(sn)\n\n# update 更新字典(合并字典)\ndre.update(d1)\nprint(dre)\n\n# values,返回字典中所有的value\n\nny=dre.values()\nprint(ny)\n\n#-----------------------------------遍历、修改、删除----------------------------\n\noop={\"name\":\"huitao\",\"age\":13,\"schoole\":\"shanghai\"}\n#遍历字典\n#方法1\nfor(k,v) in oop.items():\n    print(\"%s,%s\" %(k,v))\n#方法2\nfor key in oop.keys():\n    print(\"%s,%s\"%(key,oop[key]))\n#修改字典\noop[\"schoole\"]=\"shanbei\"\nprint(oop)\n\n#删除字典\ndel oop[\"schoole\"]\n\nprint(oop)"}, {"ctype": "p", "data": "总结："}], "cate": "Python"}
{"题目": "爬虫日记(27)：通过浏览器抓取数据", "作者": "caimouse", "发布时间": "2021-03-27 22:41:33", "内容": [{"ctype": "p", "data": "昨天测试一个网站，它需要SSL连接，并且需要SSL验证，这样对于采用scrapy或requests库来说，都比较麻烦，很容易就出错，比如下面的例子："}, {"ctype": "code", "data": "#爬虫日记-蔡军生（qq:9073204)\n\n#https://mysoft.blog.csdn.net/\n\n#2020-03-26\n\n\n\nimport requests\n\n\n\nurl = 'https://raw.githubusercontent.com/fate0/proxylist/master/proxy.list'\n\n\n\n\n\ntry:\n\n    res = requests.get(url, verify=\"D:/work/scrapy/src/abc.cer\")\n\n    print(res)\n\n    if res.status_code == 200:\n\n        print('Ok')\n\n    else:\n\n        print('Fail')\n\nexcept Exception as e:\n\n    print(e)"}, {"ctype": "p", "data": "当你运行这个例子时，就会输出下面的错误："}, {"ctype": "p", "data": "HTTPSConnectionPool(host='raw.githubusercontent.com', port=443): Max retries exceeded with url: /fate0/proxylist/master/proxy.list (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', "}], "cate": "Python"}
{"题目": "Tensorflow2.x框架-用 Tensorflow API：tf.keras 搭建网络八股 class", "作者": "诗雨时", "发布时间": "2021-03-28 12:40:19", "内容": [{"ctype": "p", "data": "用 Tensorflow API：tf.keras 搭建网络八股 class"}, {"ctype": "p", "data": "目录"}, {"ctype": "p", "data": "一、import 导入相关模块（导包）"}, {"ctype": "p", "data": "二、导入数据集"}, {"ctype": "p", "data": "三、Class() 搭建网络结构"}, {"ctype": "p", "data": "四、compile() 配置训练方法"}, {"ctype": "p", "data": "五、fit() 执行训练过程"}, {"ctype": "p", "data": "六、summary() 输出网络结构和参数统计"}, {"ctype": "p", "data": "七、完整代码"}, {"ctype": "head", "data": "一、import 导入相关模块（导包）"}, {"ctype": "code", "data": "# 模块导入\nimport numpy as np\nimport tensorflow as tf\nfrom sklearn import datasets\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras import Model"}, {"ctype": "p", "data": "import 相关模块。比如 import tensorflow as tf"}, {"ctype": "head", "data": "二、导入数据集"}, {"ctype": "code", "data": "# 导入数据集，分别为输入特征和标签\nx_train = datasets.load_iris().data\ny_train = datasets.load_iris().target"}, {"ctype": "p", "data": "告知要喂入网络的训练集和测试集是什么，也就是要指定 训练集的输入特征x_train 和 训练集的标签y_train，还可以指定 测试集的输入特征x_test 和 测试集的标签y_test。"}, {"ctype": "head", "data": "三、Class() 搭建网络结构"}, {"ctype": "code", "data": "# 搭建网络结构\nclass IrisModel(Model):\n    def __init__(self):\n        super(IrisModel, self).__init__()\n        self.d1 = Dense(3, activation=\"softmax\", kernel_regularizer=tf.keras.regularizers.l2())\n\n    def call(self, x):\n        y = self.d1(x)\n        return y\n\n\nmodel = IrisModel()"}, {"ctype": "p", "data": "使用 Sequential() 可以搭建出上层输出就是下层输入的顺序网络结构，但是无法写出一些带有跳连的非顺序网络结构，这个时候我们可以选择用类 class 搭建神经网络结构。"}, {"ctype": "p", "data": "用类 class 搭建网络结构："}, {"ctype": "code", "data": "class MyModel(Model):\n    def __init__(self):\n        super(MyModel, self).__init__()\n        # 定义网络结构快\n        pass\n    \n    def call(self, x):\n        # 调用网络结构快\n        pass\n        return y\n    \nmodel = MyModel() "}, {"ctype": "head", "data": "四、compile() 配置训练方法"}, {"ctype": "code", "data": "# 配置训练方法\nmodel.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),\n              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),\n              metrics=[\"sparse_categorical_accuracy\"])"}, {"ctype": "p", "data": "训练方法配置："}, {"ctype": "code", "data": "model.compile(optimizer=优化器, \n              loss=损失函数,\n              metrics=[\"准确率\"]\n              )"}, {"ctype": "p", "data": " optimizer 可选："}, {"ctype": "p", "data": "（1）\"sgd\" or tf.keras.optimizers.SGD(lr=学习率, momentum=动量参数)"}, {"ctype": "p", "data": "（2）\"adagrad\" or tf.keras.optimizers.Adagrad(lr=学习率)"}, {"ctype": "p", "data": "（3）\"adadelta\" or tf.keras.optimizers.Adadelta(lr=学习率)"}, {"ctype": "p", "data": "（4）\"adam\" or tf.keras.optimizers.Adam(lr=学习率, beta_1=0.9, beta_2=0.999)"}, {"ctype": "p", "data": " loss 可选："}, {"ctype": "p", "data": "（1）\"mse\" or tf.keras.losses.MeanSquaredError()"}, {"ctype": "p", "data": "（2）\"sparse_categorical_crossentropy\" or tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False)"}, {"ctype": "p", "data": "    有些神经网络的输出，是经过了softmax 等函数的概率分布；有些则不经过概率分布直接输出。"}, {"ctype": "p", "data": "    from_logits=False：神经网络预测结果输出前经过了概率分布。"}, {"ctype": "p", "data": "    from_logits=True：神经网络预测结果输出前没有经过概率分布，直接输出了。"}, {"ctype": "p", "data": "     坑：运行结果显示的网络评测指标和蒙的概率一样，比如，十分类我们的正确率是十分之一，网络结构又没有什么问题，很可能是 from_logits 参数设置错了。"}, {"ctype": "p", "data": " metrics 可选："}, {"ctype": "p", "data": "（1）\"accuracy\"：y_ 和 y 都是数值，比如 y_=[1]    y=[1]"}, {"ctype": "p", "data": "    示例：鸢尾花分类标签是第1类鸢尾花用数值 [1] 表示，网络输出结果是第1类鸢尾花也用数值 [1] 表示。"}, {"ctype": "p", "data": "（2）\"categorical_accuracy\" ：y_ 和 y 都是独热码（概率分布），如 y_=[0, 1, 0]    y=[0.256, 0.695, 0.04]"}, {"ctype": "p", "data": "    示例：鸢尾花分类标签是第1类鸢尾花用独热码 [0, 1, 0] 表示，网络输出结果是第1类鸢尾花也用概率分布 [0.256, 0.695, 0.04] 表示。"}, {"ctype": "p", "data": "（3）\"sparse_categorical_accuracy\"：y_ 是数值，y 是独热码（概率分布），如y_=[1]    y=[0.256, 0.695, 0.04]"}, {"ctype": "p", "data": "    示例：鸢尾花分类标签是第1类鸢尾花用数值 [1] 表示，网络输出结果是第1类鸢尾花也用概率分布 [0.256, 0.695, 0.04] 表示。"}, {"ctype": "head", "data": "五、fit() 执行训练过程"}, {"ctype": "code", "data": "# 执行训练过程\nmodel.fit(x_train, \n          y_train, \n          batch_size=32, \n          epochs=500, \n          validation_split=0.2, \n          validation_freq=20\n          )"}, {"ctype": "p", "data": "执行训练过程："}, {"ctype": "code", "data": "model.fit(训练集的输入特征, \n          训练集的标签,\n          batch_size=每次喂入神经网络的样本数,\n          epochs=迭代多少次数据集,\n          validation_data=(测试集的输入特征, 测试集的标签), \n          validation_split=从训练集划分多少比例的数据给测试集, \n          validation_freq=每多少次epoch迭代使用测试集验证一次结果\n          )"}, {"ctype": "p", "data": "validation_data / validation_split 二选一。"}, {"ctype": "head", "data": "六、summary() 输出网络结构和参数统计"}, {"ctype": "code", "data": "# 打印出网络结构和参数统计\nmodel.summary()"}, {"ctype": "p", "data": "  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20200524143700843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTA3NTA2,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "示例：鸢尾花分类神经网络是四输入三输出的一层网络，这一层是 Dense 全连接。"}, {"ctype": "p", "data": "           共有 15 个参数，可训练参数 15 个，不可训练参数 0 个。"}, {"ctype": "head", "data": "七、完整代码"}, {"ctype": "code", "data": "# 模块导入\nimport numpy as np\nimport tensorflow as tf\nfrom sklearn import datasets\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras import Model\n\n# 导入数据集，分别为输入特征和标签\nx_train = datasets.load_iris().data\ny_train = datasets.load_iris().target\n\n# 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）\n# seed：随机种子，是一个整数，当设置之后，每次生成的随机数都一样\nnp.random.seed(116)     # 使用相同的seed，保证输入特征和标签一一对应\nnp.random.shuffle(x_train)\nnp.random.seed(116)\nnp.random.shuffle(y_train)\ntf.random.set_seed(116)\n\n\n# 搭建网络结构\nclass IrisModel(Model):\n    def __init__(self):\n        super(IrisModel, self).__init__()\n        self.d1 = Dense(3, activation=\"softmax\", kernel_regularizer=tf.keras.regularizers.l2())\n\n    def call(self, x):\n        y = self.d1(x)\n        return y\n\n\nmodel = IrisModel()\n\n# 配置训练方法\nmodel.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),\n              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),\n              metrics=[\"sparse_categorical_accuracy\"])\n\n# 执行训练过程\nmodel.fit(x_train,\n          y_train,\n          batch_size=32,\n          epochs=500,\n          validation_split=0.2,\n          validation_freq=20\n          )\n\n# 打印出网络结构和参数统计\nmodel.summary()"}], "cate": "Python"}
{"题目": "躲在被窝里偷偷学爬虫(8)---爬虫界的平头哥selenium", "作者": "跟着哈哥学大智若愚", "发布时间": "2021-03-28 19:29:01", "内容": [{"ctype": "head", "data": "selenium库"}, {"ctype": "head", "data": "1，爬虫中为何要使用selenium？"}, {"ctype": "p", "data": "当你经常爬取网页过程中，就会发现许多我们想要获取的数据并不能通过简单的解析HTML代码来获取，因为这些数据是通过AJAX加载或js渲染等其他手段动态加载才能呈现在页面上的。"}, {"ctype": "head", "data": "2，何为selenium库？"}, {"ctype": "p", "data": "selenuim是一种自动化测试工具，它支持多种浏览器，如Firefox，Safari，Google Chrome，IE，Edge等。在爬虫中，我们将其运行在浏览器中，就像真正的用户在操作一样，进而解决以上所提出的难题，就同平头哥把毒蛇当辣条一样统统解决！正因如此，许多网站对于selenium爬虫才显得头皮发麻，四肢无力"}, {"ctype": "head", "data": "3，selenium使用前的准备"}, {"ctype": "p", "data": "①先进行环境安装：在dos窗口输入pip install selenium回车即可"}, {"ctype": "p", "data": "②下载一个浏览器的驱动程序(小编在这里以谷歌浏览器为例)，输入网址http://chromedriver.storage.googleapis.com/index.html进行下载对应版本的驱动"}, {"ctype": "p", "data": "查看自己谷歌浏览器版本号：在谷歌浏览器中输入此url(chrome://settings/help)回车即可  然后到刚才下载驱动的页面找对应的版本  下载后进行解压，将里面的exe可执行文件进行复制，往谷歌浏览器的根目录下粘贴一份  往自己写selenium爬虫代码的同目录粘贴一份 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328162252382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hwbDk4MDM0Mjc5MQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "4，登录淘宝 + 规避检测"}, {"ctype": "p", "data": "部分大网站，会专门检测用户往服务器发起的是否是基于selenium的请求，所以我们要想办法规避服务器检测"}, {"ctype": "code", "data": "# !/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Author:HePengLi\n# @Time:2021-03-28\n\nfrom selenium import webdriver\nimport time\n\n\n# 实例化一个浏览器对象(导入驱动器路径)\nbro = webdriver.Chrome(executable_path='chromedriver.exe')\n\n# 实现规避检测\nscript = '''\nObject.defineProperty(navigator, 'webdriver', {\n    get: () => undefined\n})\n'''\nbro.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", {\"source\": script})\n\n# 对指定url发请求\nbro.get('https://www.taobao.com/')\n# 模拟鼠标点击左上角的红字\"亲,请登录\"\nbro.find_element_by_xpath('//*[@id=\"J_SiteNavLogin\"]/div[1]/div[1]/a[1]').click()\n# 录入账号\nuser = bro.find_element_by_xpath('//*[@id=\"fm-login-id\"]')\nuser.send_keys('账号') # 此处填写淘宝账号\ntime.sleep(1)\n# 录入密码\npwd = bro.find_element_by_xpath('//*[@id=\"fm-login-password\"]')\npwd.send_keys('密码') # 此处填写淘宝账号的密码\ntime.sleep(1)\n# 模拟鼠标点击登录按钮\nbro.find_element_by_xpath('//*[@id=\"login-form\"]/div[4]/button').click()\n\n\ntime.sleep(30)\n# 关闭浏览器\nbro.quit()\n"}, {"ctype": "head", "data": "5，自动进入京东搜索iPhone，并爬取前三页的价格和对应详情 + 实现无头化界面 + 规避检测"}, {"ctype": "p", "data": "我们有时使用selenium爬取页面数据，并不希望弹出浏览器界面，所以就可以实现无头化界面爬取"}, {"ctype": "code", "data": "# !/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Author:HePengLi\n# @Time:2021-03-28\n\nfrom selenium import webdriver\nfrom lxml import etree\nimport time\nfrom selenium.webdriver.chrome.options import Options\n\nurl = 'https://www.jd.com'\n\n# 实现无头化界面\noption = Options()\noption.add_argument('--headless')\noption.add_argument('--disable-gpu')\n\nbro = webdriver.Chrome(executable_path='chromedriver.exe', options=option)\n\n# 实现规避检测\nscript = '''\nObject.defineProperty(navigator, 'webdriver', {\n    get: () => undefined\n})\n'''\nbro.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", {\"source\": script})\n\nbro.get(url)\ntime.sleep(2)\nall_page = []\n# 定位输入框\nsearch_k = bro.find_element_by_class_name('text')\n# 往搜索框中录入数据\nsearch_k.send_keys('iphone')\ntime.sleep(1)\nbutt = bro.find_element_by_class_name('button')\nbutt.click()\ntime.sleep(2)\n\n# 捕获当前页面的源码数据\n# 当前页面全部加载完成后对应的数据\npage_content = bro.page_source\nall_page.append(page_content)\n# 点击下一页\nfor i in range(2):\n    next_page = bro.find_element_by_xpath('//*[@id=\"J_bottomPage\"]/span[1]/a[9]')\n    next_page.click()\n    time.sleep(1)\n    all_page.append(bro.page_source)\n\n# print(all_page)\n\nf = open('jd.txt', 'w', encoding='utf-8')\n# 解析数据\nfor page in all_page:\n\n    tree  =etree.HTML(page)\n    li_list = tree.xpath('//*[@id=\"J_goodsList\"]/ul/li')\n    # print(li_list)\n\n    for li in li_list:\n        price = li.xpath('.//div[@class=\"p-price\"]/strong//text()')\n        # 处理数据\n        if len(price) == 2:\n            pri = price[0] + price[1]\n        else:\n            pri = price[1] + price[2]\n        # print(pri)\n        # print(price[1], price[2])\n\n        content = li.xpath('.//div[@class=\"p-name p-name-type-2\"]/a/em//text()')\n        # print(content)\n        # 处理数据\n        if len(content) == 2:\n            con = content[0] + content[1]\n        elif len(content) == 3:\n            con = content[0] + content[1] + content[2]\n        else:\n            con = content[0] + content[1] + content[2] + content[3]\n\n        # print(pri+con)\n        data = '价格：' + pri + '  ' +'具体详情：' + con\n        # print(data)\n        f.write(data + '\\n')\nprint('\\033[31;1mDownload over!!!\\033[0m')\n\ntime.sleep(5)\nbro.quit()\n"}, {"ctype": "p", "data": " 温馨提醒：像京东淘宝等大网站的商品价格一般不要轻易爬取，退一步，即使爬取也不要一次贪多，否则极容易被封掉IP"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328192416787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hwbDk4MDM0Mjc5MQ==,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "Yolov3训练教程Keras", "作者": "AIOT魔法师", "发布时间": "2021-03-27 16:44:54", "内容": [{"ctype": "p", "data": "欢迎关注的公众号： 不定期发布各类教程、理论笔记、搬运前沿动态。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164231139.png"}, {"ctype": "p", "data": "环境搭建教程在上一篇博客Keras yolov3环境搭建 1、打开文件夹 用 pycharm 打开 keras-yolo3 文件夹打开的文件夹应该是这样的：2、新建voc2007数据集（存放自己的图片及标注信息） 新建的文件夹（ImageSets 文件夹下还有个名为 Main 的小文件夹自己创建吧没截图）如下：  3、将要训练的图片放在 JPEGImages 里面： labelimg 标注的 xlm 文件放在 Annotations 里面  4、在 VOC2007 里新建一个 py 文件，在此取名 voc.py  VOC中的代码如下："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327162731738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2NzYwMA==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import os\nimport random\n\ntrainval_percent = 0.2 #测试集占0.2\ntrain_percent = 0.8    #训练集占0.8\nxmlfilepath = 'Annotations'\ntxtsavepath = 'ImageSets\\Main'\ntotal_xml = os.listdir(xmlfilepath)\n\nnum = len(total_xml)\nlist = range(num)\ntv = int(num * trainval_percent)\ntr = int(tv * train_percent)\ntrainval = random.sample(list, tv)\ntrain = random.sample(trainval, tr)\n\nftrainval = open('ImageSets/Main/trainval.txt', 'w')\nftest = open('ImageSets/Main/test.txt', 'w')\nftrain = open('ImageSets/Main/train.txt', 'w')\nfval = open('ImageSets/Main/val.txt', 'w')\n\nfor i in list:\n    name = total_xml[i][:-4] + '\\n'\n    if i in trainval:\n        ftrainval.write(name)\n        if i in train:\n            ftest.write(name)\n        else:\n            fval.write(name)\n    else:\n        ftrain.write(name)\n\nftrainval.close()\nftrain.close()\nfval.close()\nftest.close()\n"}, {"ctype": "p", "data": "直接复制以上代码即可，然后运行 voc.py 文件 运行后会在mian 文件夹里会多了四个 txt 文件  5、修改 voc_annotation.py 文件并运行 更改这里的 classes 的数量，你voc2007里标注了哪几种，你就留哪几种就行  比如voc中只标注将 coco_classes.txt 和 voc_classes.txt 中也只留下VOC2007 中所标注的那个类型rson”，那只留下“person”，然后再运行一下就行，运行完成后会多出这几个 txt 文件  6、修改 model_data 将 coco_classes.txt 和 voc_classes.txt 中也只留下VOC2007 中所标注的那个类型比如标注的只有 “person” 那只留下“person”  7、修改 yolo3.cfg 大概在 610、696 和 783 行的位置，把 classes 的数值都改为 1   8、添加官方权重 将 yolo.h5 改名为 yolo_weights.h5 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327163300236.png"}, {"ctype": "p", "data": "9、新建 logs 文件夹存放训练的权重文件。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327163623295.png"}, {"ctype": "p", "data": "10、开始训练 在 keras-yolo3-master 文件夹下新建 一个名为 trainyolo.py 的文件 trainyolo代码如下："}, {"ctype": "code", "data": "import numpy as np\nimport tensorflow as tf\nimport keras.backend as K\nfrom keras.layers import Input, Lambda\nfrom keras.models import Model\nfrom keras.optimizers import Adam\nfrom keras.callbacks import TensorBoard, ModelCheckpoint, ReduceLROnPlateau, EarlyStopping\nfrom yolo3.model import yolo_body\nfrom yolo3.model import yolo_loss\nfrom keras.backend.tensorflow_backend import set_session\nfrom yolo3.utils import get_random_data\n\ndef get_classes(classes_path):\n    '''loads the classes'''\n    with open(classes_path) as f:\n        class_names = f.readlines()\n    class_names = [c.strip() for c in class_names]\n    return class_names\n\ndef get_anchors(anchors_path):\n    '''loads the anchors from a file'''\n    with open(anchors_path) as f:\n        anchors = f.readline()\n    anchors = [float(x) for x in anchors.split(',')]\n    return np.array(anchors).reshape(-1, 2)\n\ndef data_generator(annotation_lines, batch_size, input_shape, anchors, num_classes):\n    '''data generator for fit_generator'''\n    n = len(annotation_lines)\n    i = 0\n    while True:\n        image_data = []\n        box_data = []\n        for b in range(batch_size):\n            if i==0:\n                np.random.shuffle(annotation_lines)\n            image, box = get_random_data(annotation_lines[i], input_shape, random=True)\n            image_data.append(image)\n            box_data.append(box)\n            i = (i+1) % n\n        image_data = np.array(image_data)\n        box_data = np.array(box_data)\n        y_true = preprocess_true_boxes(box_data, input_shape, anchors, num_classes)\n        yield [image_data, *y_true], np.zeros(batch_size)\n\ndef preprocess_true_boxes(true_boxes, input_shape, anchors, num_classes):\n\n    assert (true_boxes[..., 4]<num_classes).all(), 'class id must be less than num_classes'\n    \n    num_layers = len(anchors)//3 \n    anchor_mask = [[6,7,8], [3,4,5], [0,1,2]] if num_layers==3 else [[3,4,5], [1,2,3]]\n\n    true_boxes = np.array(true_boxes, dtype='float32')\n    input_shape = np.array(input_shape, dtype='int32') # 416,416\n    boxes_xy = (true_boxes[..., 0:2] + true_boxes[..., 2:4]) // 2\n    boxes_wh = true_boxes[..., 2:4] - true_boxes[..., 0:2]\n    true_boxes[..., 0:2] = boxes_xy/input_shape[:]\n    true_boxes[..., 2:4] = boxes_wh/input_shape[:]\n\n    m = true_boxes.shape[0]\n    grid_shapes = [input_shape//{0:32, 1:16, 2:8}[l] for l in range(num_layers)]\n    y_true = [np.zeros((m,grid_shapes[l][0],grid_shapes[l][1],len(anchor_mask[l]),5+num_classes),\n        dtype='float32') for l in range(num_layers)]\n    anchors = np.expand_dims(anchors, 0)\n    anchor_maxes = anchors / 2.\n    anchor_mins = -anchor_maxes\n    valid_mask = boxes_wh[..., 0]>0\n\n    for b in range(m):\n        wh = boxes_wh[b, valid_mask[b]]\n        if len(wh)==0: continue\n        wh = np.expand_dims(wh, -2)\n        box_maxes = wh / 2.\n        box_mins = -box_maxes\n\n        intersect_mins = np.maximum(box_mins, anchor_mins)\n        intersect_maxes = np.minimum(box_maxes, anchor_maxes)\n        intersect_wh = np.maximum(intersect_maxes - intersect_mins, 0.)\n        intersect_area = intersect_wh[..., 0] * intersect_wh[..., 1]\n        box_area = wh[..., 0] * wh[..., 1]\n        anchor_area = anchors[..., 0] * anchors[..., 1]\n        iou = intersect_area / (box_area + anchor_area - intersect_area)\n        best_anchor = np.argmax(iou, axis=-1)\n\n        for t, n in enumerate(best_anchor):\n            for l in range(num_layers):\n                if n in anchor_mask[l]:\n                    i = np.floor(true_boxes[b,t,0]*grid_shapes[l][1]).astype('int32')\n                    j = np.floor(true_boxes[b,t,1]*grid_shapes[l][0]).astype('int32')\n                    k = anchor_mask[l].index(n)\n                    c = true_boxes[b,t, 4].astype('int32')\n                    y_true[l][b, j, i, k, 0:4] = true_boxes[b,t, 0:4]\n                    y_true[l][b, j, i, k, 4] = 1\n                    y_true[l][b, j, i, k, 5+c] = 1\n\n    return y_true\n\n\nconfig = tf.ConfigProto()\nconfig.gpu_options.allocator_type = 'BFC'\nconfig.gpu_options.per_process_gpu_memory_fraction = 0.7\nconfig.gpu_options.allow_growth = True\nset_session(tf.Session(config=config)) \n\nif __name__ == \"__main__\":\n    annotation_path = '2007_train.txt'\n    classes_path = 'model_data/voc_classes.txt'    \n    anchors_path = 'model_data/yolo_anchors.txt'\n    weights_path = 'model_data/yolo_weights.h5'\n    class_names = get_classes(classes_path)\n    anchors = get_anchors(anchors_path)\n    num_classes = len(class_names)\n    num_anchors = len(anchors)\n    log_dir = 'logs/'\n    input_shape = (416,416)\n\n    K.clear_session()\n\n    image_input = Input(shape=(None, None, 3))\n    h, w = input_shape\n\n    print('Create YOLOv3 model with {} anchors and {} classes.'.format(num_anchors, num_classes))\n    model_body = yolo_body(image_input, num_anchors//3, num_classes)\n    \n    print('Load weights {}.'.format(weights_path))\n    model_body.load_weights(weights_path, by_name=True, skip_mismatch=True)\n    \n    y_true = [Input(shape=(h//{0:32, 1:16, 2:8}[l], w//{0:32, 1:16, 2:8}[l], \\\n        num_anchors//3, num_classes+5)) for l in range(3)]\n\n    loss_input = [*model_body.output, *y_true]\n    model_loss = Lambda(yolo_loss, output_shape=(1,), name='yolo_loss',\n        arguments={'anchors': anchors, 'num_classes': num_classes, 'ignore_thresh': 0.5})(loss_input)\n\n    model = Model([model_body.input, *y_true], model_loss)\n\n    freeze_layers = 249\n    for i in range(freeze_layers): model_body.layers[i].trainable = False\n    print('Freeze the first {} layers of total {} layers.'.format(freeze_layers, len(model_body.layers)))\n\n    logging = TensorBoard(log_dir=log_dir)\n    checkpoint = ModelCheckpoint(log_dir + 'ep{epoch:03d}-loss{loss:.3f}-val_loss{val_loss:.3f}.h5',\n        monitor='val_loss', save_weights_only=True, save_best_only=False, period=2)\n    reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=2, verbose=1)\n    early_stopping = EarlyStopping(monitor='val_loss', min_delta=0, patience=6, verbose=1)\n\n    val_split = 0.2\n    with open(annotation_path) as f:\n        lines = f.readlines()\n    np.random.seed(10101)\n    np.random.shuffle(lines)\n    np.random.seed(None)\n    num_val = int(len(lines)*val_split)\n    num_train = len(lines) - num_val\n    \n    if True:\n        model.compile(optimizer=Adam(lr=1e-3), loss={\n            'yolo_loss': lambda y_true, y_pred: y_pred})\n\n        batch_size = 1\n        print('Train on {} samples, val on {} samples, with batch size {}.'.format(num_train, num_val, batch_size))\n        model.fit_generator(data_generator(lines[:num_train], batch_size, input_shape, anchors, num_classes),\n                steps_per_epoch=max(1, num_train//batch_size),\n                validation_data=data_generator(lines[num_train:], batch_size, input_shape, anchors, num_classes),\n                validation_steps=max(1, num_val//batch_size),\n                epochs=50,\n                initial_epoch=0,\n                callbacks=[logging, checkpoint])\n        model.save_weights(log_dir + 'trained_weights_stage_1.h5')\n\n    for i in range(freeze_layers): model_body.layers[i].trainable = True\n\n    if True:\n        model.compile(optimizer=Adam(lr=1e-4), loss={\n            'yolo_loss': lambda y_true, y_pred: y_pred})\n\n        batch_size = 1\n        print('Train on {} samples, val on {} samples, with batch size {}.'.format(num_train, num_val, batch_size))\n        model.fit_generator(data_generator(lines[:num_train], batch_size, input_shape, anchors, num_classes),\n                steps_per_epoch=max(1, num_train//batch_size),\n                validation_data=data_generator(lines[num_train:], batch_size, input_shape, anchors, num_classes),\n                validation_steps=max(1, num_val//batch_size),\n                epochs=100,\n                initial_epoch=50,\n                callbacks=[logging, checkpoint])\n        model.save_weights(log_dir + 'last1.h5')\n"}, {"ctype": "p", "data": "11、然后运行trainyolo.py 的代码 开始训练了。 当出现下图所示，训练完成  训练好的权重都放在 logs 文件夹下的 000 文件夹里：  这两个权重文件都可以用一样的  然后和之前一样加载权重，识别照片就可以了！"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327163812854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2NzYwMA==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "Python数据分析入门（五）：Pandas的对齐运算", "作者": "松鼠爱吃饼干", "发布时间": "2021-03-27 14:39:45", "内容": [{"ctype": "p", "data": "是数据清洗的重要过程，可以按索引对齐进行运算，如果没对齐的位置则补NaN，最后也可以填充NaN"}, {"ctype": "p", "data": "Python爬虫、数据分析、网站开发等案例教程视频免费在线观看"}, {"ctype": "code", "data": "https://space.bilibili.com/523606542 \n"}, {"ctype": "head", "data": "Python学习交流群：1039649593"}, {"ctype": "p", "data": "Series的对齐运算"}, {"ctype": "p", "data": "1. Series 按行、索引对齐"}, {"ctype": "p", "data": "示例代码："}, {"ctype": "code", "data": "s1 = pd.Series(range(10, 20), index = range(10))\ns2 = pd.Series(range(20, 25), index = range(5))\n\nprint('s1: ' )\nprint(s1)\n\nprint('') \n\nprint('s2: ')\nprint(s2)"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "code", "data": "s1: \n0    10\n1    11\n2    12\n3    13\n4    14\n5    15\n6    16\n7    17\n8    18\n9    19\ndtype: int64\n\ns2: \n0    20\n1    21\n2    22\n3    23\n4    24\ndtype: int64"}, {"ctype": "p", "data": "2. Series的对齐运算"}, {"ctype": "p", "data": "示例代码："}, {"ctype": "code", "data": "# Series 对齐运算\ns1 + s2"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "code", "data": "0    30.0\n1    32.0\n2    34.0\n3    36.0\n4    38.0\n5     NaN\n6     NaN\n7     NaN\n8     NaN\n9     NaN\ndtype: float64"}, {"ctype": "p", "data": "DataFrame的对齐运算"}, {"ctype": "p", "data": "1. DataFrame按行、列索引对齐"}, {"ctype": "p", "data": "示例代码："}, {"ctype": "code", "data": "df1 = pd.DataFrame(np.ones((2,2)), columns = ['a', 'b'])\ndf2 = pd.DataFrame(np.ones((3,3)), columns = ['a', 'b', 'c'])\n\nprint('df1: ')\nprint(df1)\n\nprint('') \nprint('df2: ')\nprint(df2)"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "code", "data": "df1: \n     a    b\n0  1.0  1.0\n1  1.0  1.0\n\ndf2: \n     a    b    c\n0  1.0  1.0  1.0\n1  1.0  1.0  1.0\n2  1.0  1.0  1.0"}, {"ctype": "p", "data": "2. DataFrame的对齐运算"}, {"ctype": "p", "data": "示例代码："}, {"ctype": "code", "data": "# DataFrame对齐操作\ndf1 + df2"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "code", "data": "     a    b   c\n0  2.0  2.0 NaN\n1  2.0  2.0 NaN\n2  NaN  NaN NaN"}, {"ctype": "p", "data": "填充未对齐的数据进行运算"}, {"ctype": "p", "data": "1. fill_value"}, {"ctype": "p", "data": "使用add,sub,div,mul的同时，通过fill_value指定填充值，未对齐的数据将和填充值做运算"}, {"ctype": "p", "data": "示例代码："}, {"ctype": "code", "data": "print(s1)\nprint(s2)\ns1.add(s2, fill_value = -1)\n\nprint(df1)\nprint(df2)\ndf1.sub(df2, fill_value = 2.)"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "code", "data": "# print(s1)\n0    10\n1    11\n2    12\n3    13\n4    14\n5    15\n6    16\n7    17\n8    18\n9    19\ndtype: int64\n\n# print(s2)\n0    20\n1    21\n2    22\n3    23\n4    24\ndtype: int64\n\n# s1.add(s2, fill_value = -1)\n0    30.0\n1    32.0\n2    34.0\n3    36.0\n4    38.0\n5    14.0\n6    15.0\n7    16.0\n8    17.0\n9    18.0\ndtype: float64\n\n\n# print(df1)\n     a    b\n0  1.0  1.0\n1  1.0  1.0\n\n# print(df2)\n     a    b    c\n0  1.0  1.0  1.0\n1  1.0  1.0  1.0\n2  1.0  1.0  1.0\n\n\n# df1.sub(df2, fill_value = 2.)\n     a    b    c\n0  0.0  0.0  1.0\n1  0.0  0.0  1.0\n2  1.0  1.0  1.0"}, {"ctype": "p", "data": "算术方法表:"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/f643c2a5cba6f737a83349a22ca113d5.png"}], "cate": "Python"}
{"题目": "python爬虫 双色球数据更新", "作者": "格子衫你懂吗", "发布时间": "2021-03-27 17:54:50", "内容": [{"ctype": "head", "data": "python爬虫 双色球数据更新"}, {"ctype": "p", "data": " 解析网站并获取数据 # 彩票数据所在的url\nurl = 'http://datachart.500.com/ssq/'\n# 提取数据\nresponse = requests.get(url, headers={\"User-Agent\": UserAgent().chrome})\n# 通过xpath去解析\ne = etree.HTML(response.text)\ndate_times = e.xpath('//tbody[@id=\"tdata\"]/tr/td[1]/text()')\ntrs = e.xpath('//tbody[@id=\"tdata\"]/tr[not(@class)]')\n  链接数据库 # 链接数据库\nclient = pymysql.connect(host='localhost', port=3306, user='root', password='123456', charset='utf8', db='bangumi')\ncursor = client.cursor()\n  普通获取数据 # 插入数据的sql\nsql = 'insert into doubleballs values(0,%s,%s,%s)'\nfor data_time, tr in zip(date_times, trs):\n    red_ball = '-'.join(tr.xpath('./td[@class=\"chartBall01\"]/text()'))\n    blue_ball = tr.xpath('./td[@class=\"chartBall02\"]/text()')[0]\n    print(\"第\" + data_time + \"红球是：\" + red_ball + \" 蓝球：\" + blue_ball)\n    cursor.execute(sql, [data_time, red_ball, blue_ball])\n    client.commit()\n  更新数据这部分从数据库中获取数据，然后反转顺序，index作为计数器，循环遍历假如有新数据要更新，那result返回值为0，index+1。 # 查看数据是否存在\nselect_new_sql = \"select * from doubleballs where date_time = %s\"\ndate_times.reverse()\n# 记录有多少条新数据\nindex = 0\nfor data_time in date_times:\n    result = cursor.execute(select_new_sql, [data_time])\n    # 判断数据是否存在\n    if result == 1:\n        break\n    index+=1\n  数据顺序反转，按照网站上xpath写法获取第1个数据，即最新的数据放到数据库中。 # 数据从新到旧排序\ntrs.reverse()\nfor i in range(index):\n    # 提取红球\n    red_ball = '-'.join(trs[i].xpath('./td[@class=\"chartBall01\"]/text()'))\n    # 提取蓝球\n    blue_ball = trs[i].xpath('./td[@class=\"chartBall02\"]/text()')[0]\n    print(\"第\" + date_times[i] + \"红球是：\" + red_ball + \" 蓝球：\" + blue_ball)\n    cursor.execute(sql, [date_times[i], red_ball, blue_ball])\n    client.commit()\n  完整代码 import requests\nfrom fake_useragent import UserAgent\nfrom lxml import html\nimport pymysql\n\netree = html.etree\n# 彩票数据所在的url\nurl = 'http://datachart.500.com/ssq/'\n# 提取数据\nresponse = requests.get(url, headers={\"User-Agent\": UserAgent().chrome})\n# 通过xpath去解析\ne = etree.HTML(response.text)\ndate_times = e.xpath('//tbody[@id=\"tdata\"]/tr/td[1]/text()')\ntrs = e.xpath('//tbody[@id=\"tdata\"]/tr[not(@class)]')\n# 链接数据库\nclient = pymysql.connect(host='localhost', port=3306, user='root', password='123456', charset='utf8', db='bangumi')\ncursor = client.cursor()\n# 插入数据的sql\nsql = 'insert into doubleballs values(0,%s,%s,%s)'\n# 查看数据是否存在\nselect_new_sql = \"select * from doubleballs where date_time = %s\"\ndate_times.reverse()\n# 记录有多少条新数据\nindex = 0\nfor data_time in date_times:\n    reslut = cursor.execute(select_new_sql, [data_time])\n    # 判断数据是否存在\n    if reslut == 1:\n        break\n    index += 1\n# 数据从新到旧排序\ntrs.reverse()\nfor i in range(index):\n    # 提取红球\n    red_ball = '-'.join(trs[i].xpath('./td[@class=\"chartBall01\"]/text()'))\n    # 提取蓝球\n    blue_ball = trs[i].xpath('./td[@class=\"chartBall02\"]/text()')[0]\n    print(\"第\" + date_times[i] + \"红球是：\" + red_ball + \" 蓝球：\" + blue_ball)\n    cursor.execute(sql, [date_times[i], red_ball, blue_ball])\n    client.commit()\n# for data_time, tr in zip(date_times, trs):\n#     red_ball = '-'.join(tr.xpath('./td[@class=\"chartBall01\"]/text()'))\n#     blue_ball = tr.xpath('./td[@class=\"chartBall02\"]/text()')[0]\n#     print(\"第\" + data_time + \"红球是：\" + red_ball + \" 蓝球：\" + blue_ball)\n#     cursor.execute(sql, [data_time, red_ball, blue_ball])\n#     client.commit()\ncursor.close()\nclient.close()\n  这样排序会让更新之后最新的在数据最后，但是一开始排序的时候不会出现问题，是从新到旧的排序。于是因为有点强迫症，最后还是改成从旧到新排序。只需要改动几行代码即可，反转数据在提取红球蓝球数据前，保证数据最新，判断时每次存在就让index+1，之后加入index = count - index其中count = data_time.__len__()。接着将循环中的i变成index-i-1。最终代码如下， import requests\nfrom fake_useragent import UserAgent\nfrom lxml import html\nimport pymysql\n\netree = html.etree\n# 彩票数据所在的url\nurl = 'http://datachart.500.com/ssq/'\n# 提取数据\nresponse = requests.get(url, headers={\"User-Agent\": UserAgent().chrome})\n# 通过xpath去解析\ne = etree.HTML(response.text)\ndate_times = e.xpath('//tbody[@id=\"tdata\"]/tr/td[1]/text()')\ntrs = e.xpath('//tbody[@id=\"tdata\"]/tr[not(@class)]')\ncount =date_times.__len__()\n# 链接数据库\nclient = pymysql.connect(host='localhost', port=3306, user='root', password='123456', charset='utf8', db='bangumi')\ncursor = client.cursor()\n# 插入数据的sql\nsql = 'insert into doubleballs values(0,%s,%s,%s)'\n# 查看数据是否存在\nselect_new_sql = \"select * from doubleballs where date_time = %s\"\n# date_times.reverse()\n# 记录有多少条新数据\nindex = 0\nfor data_time in date_times:\n    reslut = cursor.execute(select_new_sql, [data_time])\n    # 判断数据是否存在\n    if reslut == 1:\n        index += 1\nindex = count - index\n# 数据从新到旧排序\n# trs.reverse()\ndate_times.reverse()\ntrs.reverse()\nfor i in range(index):\n    # 提取红球\n    red_ball = '-'.join(trs[index-i-1].xpath('./td[@class=\"chartBall01\"]/text()'))\n    # 提取蓝球\n    blue_ball = trs[index-i-1].xpath('./td[@class=\"chartBall02\"]/text()')[0]\n    print(\"第\" + date_times[index-i-1] + \"红球是：\" + red_ball + \" 蓝球：\" + blue_ball)\n    cursor.execute(sql, [date_times[index-i-1], red_ball, blue_ball])\n    client.commit()\n# for data_time, tr in zip(date_times, trs):\n#     red_ball = '-'.join(tr.xpath('./td[@class=\"chartBall01\"]/text()'))\n#     blue_ball = tr.xpath('./td[@class=\"chartBall02\"]/text()')[0]\n#     print(\"第\" + data_time + \"红球是：\" + red_ball + \" 蓝球：\" + blue_ball)\n#     cursor.execute(sql, [data_time, red_ball, blue_ball])\n#     client.commit()\ncursor.close()\nclient.close()\n\n "}], "cate": "Python"}
{"题目": "python 多线程元气壁纸爬虫", "作者": "尊暮萧", "发布时间": "2021-03-27 20:47:59", "内容": [{"ctype": "head", "data": "声明"}, {"ctype": "p", "data": "此爬虫仅用于学习交流，且用且珍惜。这里的id已经锁定了动漫，所以需要修改类别，那就自行分析叭。。。因为这个文件写完有一段时间了，所以我也忘记具体位置了，可能是[“cate_id”:2]这个。还有，这里爬的时静态壁纸，动态的原则也是可以的。"}, {"ctype": "head", "data": "技术点"}, {"ctype": "p", "data": "threadingrequestsjson"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "import requests\nimport json\nimport threading\nimport random\n\n\ndef get_requestHeaders():\n    headers = {\n        'accept': 'application/json, text/plain, */*',\n        'accept-encoding': 'gzip, deflate, br',\n        'accept-language': 'zh-CN,zh;q=0.9',\n        'content-length': '172',\n        'content-type': 'application/json;charset=UTF-8',\n        'dnt': '1',\n        'origin': 'https://wallpaper.zhhainiao.com',\n        'referer': 'https://wallpaper.zhhainiao.com/',\n        'sec-ch-ua': '\"Google Chrome\";v=\"89\", \"Chromium\";v=\"89\", \";Not A Brand\";v=\"99\"',\n        'sec-ch-ua-mobile': '?0',\n        'sec-fetch-dest': 'empty',\n        'sec-fetch-mode': 'cors',\n        'sec-fetch-site': 'same-site',\n        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36',\n        'x-cf-device-id': 'xxxx-xxx-xxx',\n        'x-cf-platform': 'webview',\n\n    }\n    return headers\n\n\ndef thd(dt,page):\n    for i in dicts:\n        if i[\"Jpg4kUrl\"] != \"\":\n            url = i[\"Jpg4kUrl\"] # 存在4k就下载4k的\n        elif i[\"Jpg1920Url\"] != \"\":\n            url = i[\"Jpg1920Url\"]\n        name = i[\"wname\"]\n        if name == '':\n            name = str(random.randint(1, 9)) + str(random.randint(1, 99)) + str(random.randint(1, 999999)) + \".jpg\"  # 没有文件名就随便起一个\n        print(url, name,page)\n        pic = requests.get(url).content\n        with open(\"z:/spider/\" + name + \".jpg\", 'wb') as f: # 文件保存路径，我这里用到时z盘内存盘，emm，自行修改叭\n            f.write(pic)\n\n\nif __name__ == '__main__':\n\n    for page in range(1, 100):\n        r = requests.post(\"https://pcwallpaper.zhhainiao.com/wallpaper/static/list\",\n                          headers=get_requestHeaders(),\n                          data='{\"login_info\":{},\"cate_id\":2,\"tag_id\":null,\"sort_type\":2,\"page\":' + str(page) +\n                               ',\"page_size\":24,'\n                               '\"common\":{\"open_id\":null,\"token\":null,\"device_id\":null,\"player_version\":0,\"platform\":\"pc\"}}')\n        json_data = r.text\n        dumps = json.loads(json_data)\n        dicts = dumps[\"data\"][\"list\"]\n        url = \"\"\n        name = \"\"\n        threading.Thread(target=thd, args=(dicts,page,)).start()\n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327204607633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thcnVzZW55,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "小白学python（opencv（numpy部分数组操作））", "作者": "mcl19909949541", "发布时间": "2021-03-28 15:33:00", "内容": [{"ctype": "head", "data": "介绍"}, {"ctype": "p", "data": "NumPy是Python中科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。 （百度百科啦）"}, {"ctype": "head", "data": "使用"}, {"ctype": "code", "data": "import numpy as np\n"}, {"ctype": "p", "data": "如果我们希望两个列表对应项相加，则我们需要这样做，使用Python列表这样的代码是冗余的，而使用numpy则大大减少了代码的冗余。 eg："}, {"ctype": "code", "data": "#使用Python列表\na = [1,2,3,4]\nb = [4,5,6,7,8]\nout = []\nfor i,j in zip(a,b):\n    out.append(i+j)\nprint(out)\n#output\n[ 5,  7,  9, 11]\n\n#使用numpy\nimport numpy as np\na = np.array([1,2,3,4])\nb = np.array([4,5,6,7])\nprint(a+b)\n#output\narray([ 5,  7,  9, 11])\n\n"}, {"ctype": "p", "data": "这里内容太多，我就用啥学啥了，有机会再更numpy"}, {"ctype": "head", "data": "numpy.ones（）函数："}, {"ctype": "code", "data": "ones(shape, dtype=None, order='C')\n"}, {"ctype": "p", "data": "shape是一个int或一个int元组，用于定义数组的大小。 如果我们仅指定一个int变量，则将返回一维数组。 对于一个整数元组，将返回给定形状的数组。 dtype是一个可选参数，默认值为float。 它用于指定数组的数据类型，例如int。 order该顺序定义是在内存中以行优先（C风格）还是列优先（Fortran风格）顺序存储多维数组。 eg："}, {"ctype": "code", "data": "import numpy as np\n \narray_1d = np.ones(3)\nprint(array_1d)\n#output为[1. 1. 1.]\n\narray_2d = np.ones((2, 3))\nprint(array_2d)\n#output为\n[[1. 1. 1.]\n [1. 1. 1.]]\n \narray_2d_int = np.ones((2, 3), dtype=int)\nprint(array_2d_int)\n#output为\n[[1 1 1]\n [1 1 1]]\nimport numpy as np\n \narray_mix_type = np.ones((2, 2), dtype=[('x', 'int'), ('y', 'float')])\nprint(array_mix_type)\n#output为\n[[(1, 1.) (1, 1.)]\n [(1, 1.) (1, 1.)]]\n"}, {"ctype": "head", "data": "zeros（）："}, {"ctype": "p", "data": "在给数组赋初始值的时候，Python中，我们使用zero（）函数来实现。 ones函数可以创建任意维度和元素个数的数组，其元素值均为1；"}, {"ctype": "head", "data": "求反色图片"}, {"ctype": "p", "data": "这里先写一个小函数求图片的反色图片："}, {"ctype": "code", "data": "def access_pixels(image):\n    print(image.shape)\n    height = image.shape[0]\n    width = image.shape[1]\n    channels = image.shape[2] #blue , green , red\n    for row in range(height):\n        for col in range(width):\n            for c in range(channels):\n                pv = image[row,col,c]\n                image[row,col,c] = 255-pv\n    cv.imshow(\"pixels_demo\",image)\n"}, {"ctype": "head", "data": "创建图片"}, {"ctype": "p", "data": "用numpy创建图片"}, {"ctype": "code", "data": "ef create_iamge():\n    img = np.zeros([400,400,4],np.uint8) #创建黑色图片\n    #img[ :, :, 0] = np.ones([400,400])*255  #三通道为0，1，2\n    #可以用此句将图片变为蓝色\n    cv.imshow(\"new\",img)\n"}, {"ctype": "p", "data": "unit8为dtype（格式）  目前函数主体为："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328150510612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import cv2  as cv\nimport  numpy as np\ndef main():\n    src = cv.imread(\"C:/Users/POG/Pictures/Autumn is coming WallPack/Timon Studler Mod.jpg\")\n    #cv.namedWindow(\"input image\",cv.WINDOW_AUTOSIZE)\n    # cv.imshow(\"input image\",src)\n    #access_pixels(src)  #h获取反色图片\n    #video_demo()\n    #create_iamge()\n    cv.waitKey(0)\n    cv.destroyAllWindows()\n    # get_image_info(src)\n    #cv.imwrite(\"D:/result.png\",src)\n\n\ndef get_image_info(image):#获取图像信息\n    print(type(image))\n    print(image.shape)\n    print(image.size)\n    print(image.dtype)\n    pixel_data = np.array(image)\n    print(pixel_data)\n\n\ndef video_demo():#调用摄像头\n    capture = cv.VideoCapture(0)\n    while(True):\n        ret,frame = capture.read()\n        frame=cv.flip(frame,1)\n        cv.imshow(\"video\",frame)\n        c = cv.waitKey(50)\n        if (c==27):    #esc为27\n            break\n\ndef access_pixels(image):#获得反色图片\n    print(image.shape)\n    height = image.shape[0]\n    width = image.shape[1]\n    channels = image.shape[2] #blue , green , red\n    for row in range(height):\n        for col in range(width):\n            for c in range(channels):\n                pv = image[row,col,c]\n                image[row,col,c] = 255-pv\n    cv.imshow(\"pixels_demo\",image)\n\ndef create_iamge():#创建图片\n    img = np.zeros([400,400,3],np.uint8) #创建图片\n    img[ :, :, 0] = np.ones([400,400])*255  #三通道为0，1，2\n    cv.imshow(\"new\",img)\nif __name__ ==\"__main__\":\n    main()\n"}, {"ctype": "p", "data": "能力有限，我还得慢慢学，先记到这里。"}], "cate": "Python"}
{"题目": "计算机视觉编程第二章 局部图像描述子（python）", "作者": "XDXAI", "发布时间": "2021-03-28 17:37:16", "内容": [{"ctype": "head", "data": "一、Harris角点检测"}, {"ctype": "head", "data": "1.基本原理"}, {"ctype": "p", "data": "Harris角点检测算法（也称Harris&Stephens角点检测器）是一个极为简单的角点检测算法。该算法的主要思想是，如果像素周围显示存在多于一个方向的边，我们认为该点为兴趣点。该点就称为角点。"}, {"ctype": "p", "data": "我们把图像域中点x上的对称半正定矩阵MI=MI(x)定义为：  其中∇I为包含导数Ix和Iy的图像梯度。由于该定义，MI的秩为1，特征值为λ1=|∇I|2和λ2=0。现在对于图像的每个像素，我们可以计算出该矩阵。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032714465050.png#pic_center"}, {"ctype": "p", "data": "选择权重矩阵W（通常为高斯滤波器Gσ），我们可以得到卷积：  该卷积的目的是得到MI在周围像素上的局部平均。计算出的矩阵MI-有称为Harris矩阵。W的宽度决定了在像素x周围的感兴趣区域。像这样在区域附近对矩阵MI-取平均的原因是，特征值会依赖于局部图像特性而变化。如果图像梯度在该区域变化，那么MI-的第二个特征值将不再为0.如果图像的梯度没有变换，MI-的特征值也不会变化。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327145435347.png#pic_center"}, {"ctype": "p", "data": "取决于该区域∇I的值，Harris矩阵MI-的特征值有三种情况： 1）如果λ1和λ2都是很大的正数，则该x点为角点； 2）如果λ1很大，λ2≈0，则该区域内存在一个边，该区域内的平均MI-的特征值不会变化太大； 3）如果λ1≈λ2≈0，则该区域为空。"}, {"ctype": "p", "data": "在不需要实际计算特征值的情况下，为了把重要的情况和其他情况分开，Harris和Stephens在文献中引入了指示函数：  为了去除加权常数κ，我们通常使用商数："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327145519267.png#pic_center"}, {"ctype": "head", "data": "2.实现代码"}, {"ctype": "code", "data": "# -*- coding: utf-8 -*-\nfrom array import array\nfrom pylab import *\nfrom PIL import Image\nfrom PCV.localdescriptors import harris\n# 读入图像\nim = array(Image.open('../data/sift/xx02.jpg').convert('L'))\n\n# 检测harris角点\n'''\ncompute_harris_response函数是在在一幅灰度图像中，\n对每个像素计算harris角点检测器响应函数，返回像数值为Harris响应值的一幅图像\n'''\nharrisim = harris.compute_harris_response(im)\n\n# Harris响应函数\nharrisim1 = 255 - harrisim\nfigure()\ngray()\n#画出Harris响应图\nsubplot(141)\nimshow(harrisim1)\naxis('off')\naxis('equal')\n# 阈值\nthreshold = [0.01, 0.05, 0.1]\nfor i, thres in enumerate(threshold):\n    filtered_coords = harris.get_harris_points(harrisim, 6, thres)\n    subplot(1, 4, i+2)\n    imshow(im)\n    print(im.shape)\n    plot([p[1] for p in filtered_coords], [p[0] for p in filtered_coords], '*')\n    axis('off')\nshow()\n"}, {"ctype": "head", "data": "3.运行结果"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328165857258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMzc5OA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "4.结果分析"}, {"ctype": "p", "data": "从代码运行的结果来看，角点周围有很多响应值很大的角点，使得角点比较密集，这是因为角点周围的点的角点响应函数值一般会比较大，所以导致角点周围有很多点被当作是角点。"}, {"ctype": "head", "data": "二、SIFT图像匹配"}, {"ctype": "head", "data": "1.SIFT（尺度不变特征变换）算法描述"}, {"ctype": "p", "data": "SIFT算法主要包括两个阶段，一个是SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量；第二阶段是SIFT特征向量的匹配。SIFT方法中的低层次特征提取是选取那些显特征，这些特征具有图像尺度(特征大小)和旋转不变性，而且对光照变化也具有一定程度的不变性。此外，SIFT方法还可以减少由遮挡、杂乱和噪声所引起的低提取概率。"}, {"ctype": "head", "data": "2.实现代码"}, {"ctype": "code", "data": "from array import array\n\nfrom numpy import loadtxt, arange, pi, cos, sin, zeros, dot, arccos, concatenate\nfrom numpy.core import vstack\nfrom numpy.linalg import linalg\nfrom pylab import *\nfrom PIL import Image\nfrom numpy import *\nimport os\n\n\ndef process_image(imagename, resultname, params=\"--edge-thresh 10 --peak-thresh 5\"):\n    \"\"\"处理一幅图像，然后将结果保存在文件中\"\"\"\n\n    if imagename[-3:] != 'pgm':\n        # 创建一个pgm文件\n        im = Image.open(imagename).convert('L')\n        im.save('tmp.pgm')\n        imagename = 'tmp.pgm'\n\n    cmmd = str(\"sift \" + imagename + \" --output=\" + resultname + \" \" + params)\n    os.system(cmmd)\n    print('processed', imagename, 'to', resultname)\n\n\ndef read_features_from_file(filename):\n    \"\"\"读取特征值属性值，然后将其以矩阵形式返回\"\"\"\n\n    f = loadtxt(filename)\n    return f[:, :4], f[:, 4:]  # 特征位置，描述子\n\ndef plot_features(im, locs, circle=False):\n    \"\"\"显示带有特征的图像\n        输入：im（数组图像），locs（每个特征的行、列、尺度和方向角度）\"\"\"\n\n    def draw_circle(c,r):\n        t = arange(0,1.01,.01)*2*pi\n        x = r*cos(t) + c[0]\n        y = r*sin(t) + c[1]\n        plot(x,y,'b',linewidth=2)\n\n    imshow(im)\n    if circle:\n        for p in locs:\n            draw_circle(p[:2],p[2])\n    else:\n        plot(locs[:,0],locs[:,1],'ob')\n    axis('off')\n    return\n\ndef match(desc1, desc2):\n    \"\"\"对于第一幅图像的每个描述子，选取其在第二幅图像中的匹配\n        输入：desc1（第一幅图像中的描述子），desc2（第二幅图像中的描述子）\"\"\"\n\n    desc1 = array([d/linalg.norm(d) for d in desc1])\n    desc2 = array([d/linalg.norm(d) for d in desc2])\n\n    dist_ratio = 0.6\n    desc1_size = desc1.shape\n\n    matchscores = zeros((desc1_size[0],1), 'int')\n    desc2t = desc2.T    #预先计算矩阵转置\n    for i in range(desc1_size[0]):\n        dotprods = dot(desc1[i,:], desc2t) #向量点乘\n        dotprods = 0.9999*dotprods\n        # 反余弦和反排序，返回第二幅图像中特征的索引\n        index = argsort(arccos(dotprods))\n\n        # 检查最近邻的角度是否小于dist_ratio乘以第二近邻的角度\n        if arccos(dotprods)[index[0]] < dist_ratio * arccos(dotprods)[index[1]]:\n            matchscores[i] = int(index[0])\n\n    return matchscores\n\ndef match_twosided(desc1,decs2):\n    \"\"\"双向对称版本的match\"\"\"\n\n    matches_12 = match(desc1, decs2)\n    matches_21 = match(decs2, decs2)\n\n    ndx_12 = matches_12.nonzero()[0]\n\n    # 去除不对称匹配\n    for n in ndx_12:\n\n        if matches_21[int(matches_12[n])] != n:\n            matches_12[n] = 0\n\n    return matches_12\n\ndef appendimages(im1, im2):\n    \"\"\"返回将两幅图像并排拼接成的一幅新图像\"\"\"\n\n    # 选取具有最少行数的图像，然后填充足够的空行\n    row1 = im1.shape[0]\n    row2 = im2.shape[0]\n\n    if row1 < row2:\n        im1 = concatenate((im1,zeros((row2-row1,im1.shape[1]))), axis=0)\n    elif row1 > row2:\n        im2 = concatenate((im2,zeros((row1-row2,im2.shape[1]))), axis=0)\n\n    # 如果这些情况都没有，那么他们的行数相同，不需要进行填充\n\n    return concatenate((im1,im2), axis=1)\n\ndef plot_matches(im1, im2, locs1, locs2, matchscores, show_below=True):\n    \"\"\"显示一幅带有连接匹配之间连线的图片\n        输入：im1，im2（数组图像），locs1，locs2（特征位置），matchscores（match的输出），\n        show_below（如果图像应该显示再匹配下方）\"\"\"\n\n    im3 = appendimages(im1,im2)\n    if show_below:\n        im3 = vstack((im3,im3))\n\n    imshow(im3)\n\n    cols1 = im1.shape[1]\n    for i in range(len(matchscores)):\n        if matchscores[i] > 0:\n            plot([locs1[i, 0], locs2[matchscores[i, 0], 0] + cols1], [locs1[i, 1], locs2[matchscores[i, 0], 1]], 'c')\n    axis('off')\n\nif __name__ == '__main__':\n    im1f = r'../data/f.jpg'\n    im2f = r'..//data/f.jpg'\n    im1 = array(Image.open(im1f))\n    im2 = array(Image.open(im2f))\n\n    process_image(im1f, 'out_sift_1.txt')\n    l1, d1 = read_features_from_file('../out_sift_1.txt')\n    figure()\n    gray()\n    subplot(121)\n    plot_features(im1, l1, circle=False)\n\n    process_image(im2f, 'out_sift_2.txt')\n    l2, d2 = read_features_from_file('../out_sift_2.txt')\n    subplot(122)\n    plot_features(im2, l2, circle=False)\n\n    matches = match_twosided(d1, d2)\n    print('{} matches'.format(len(matches.nonzero()[0])))\n    figure()\n    gray()\n    plot_matches(im1, im2, l1, l2, matches, show_below=True)\n    show()\n"}, {"ctype": "head", "data": "3.运行结果"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328163938286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMzc5OA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "4.结果分析"}, {"ctype": "p", "data": "根据运行结果可以看出，SIFT图像匹配能够较好的处理光线不一致、尺度变换、角度旋转问题，尽管目标角度发生了变化，也能够较好的匹配到两幅相似图像。"}, {"ctype": "head", "data": "三、地理特征匹配"}, {"ctype": "head", "data": "1.测试图片"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328162747719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMzc5OA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "2.实现代码"}, {"ctype": "code", "data": "from numpy import zeros\nfrom pylab import *\nfrom PIL import Image\nfrom PCV.localdescriptors import sift\nfrom PCV.tools import imtools\nimport pydot\nimport os\nos.environ[\"PATH\"] += os.pathsep + 'D:/Graphviz/bin/'\n\n\"\"\" This is the example graph illustration of matching images from Figure 2-10.\nTo download the images, see ch2_download_panoramio.py.\"\"\"\n\ndownload_path = \"C:\\\\Users\\\\VIVACIOUS\\\\PycharmProjects\\\\JiSuanJiShiJue\\\\shiyan2\\\\image\\\\sift\"  # set this to the path where you downloaded the panoramio images\npath = \"C:\\\\Users\\\\VIVACIOUS\\\\PycharmProjects\\\\JiSuanJiShiJue\\\\shiyan2\\\\image\\\\sift\\\\\"  # path to save thumbnails (pydot needs the full system path)\n\n# list of downloaded filenames\nimlist = imtools.get_imlist(download_path)\nnbr_images = len(imlist)\n\n# extract features\nfeatlist = [imname[:-3] + 'sift' for imname in imlist]\nfor i, imname in enumerate(imlist):\n    sift.process_image(imname, featlist[i])\n\nmatchscores = zeros((nbr_images, nbr_images))\n\nfor i in range(nbr_images):\n    for j in range(i, nbr_images):  # only compute upper triangle\n        print('comparing ', imlist[i], imlist[j])\n        l1, d1 = sift.read_features_from_file(featlist[i])\n        l2, d2 = sift.read_features_from_file(featlist[j])\n        matches = sift.match_twosided(d1, d2)\n        nbr_matches = sum(matches > 0)\n        print('number of matches = ', nbr_matches)\n        matchscores[i, j] = nbr_matches\nprint(\"The match scores is: \\n\", matchscores)\n\n# copy values\nfor i in range(nbr_images):\n    for j in range(i + 1, nbr_images):  # no need to copy diagonal\n        matchscores[j, i] = matchscores[i, j]\n\n#可视化\nthreshold = 2  # min number of matches needed to create link\n\ng = pydot.Dot(graph_type='graph')  # don't want the default directed graph\n\nfor i in range(nbr_images):\n    for j in range(i + 1, nbr_images):\n        if matchscores[i, j] > threshold:\n            # first image in pair\n            im = Image.open(imlist[i])\n            im.thumbnail((100, 100))\n            filename = path + str(i) + '.png'\n            im.save(filename)  # need temporary files of the right size\n            g.add_node(pydot.Node(str(i), fontcolor='transparent', shape='rectangle', image=filename))\n\n            # second image in pair\n            im = Image.open(imlist[j])\n            im.thumbnail((100, 100))\n            filename = path + str(j) + '.png'\n            im.save(filename)  # need temporary files of the right size\n            g.add_node(pydot.Node(str(j), fontcolor='transparent', shape='rectangle', image=filename))\n\n            g.add_edge(pydot.Edge(str(i), str(j)))\ng.write_png('jmu.png')\n\n"}, {"ctype": "head", "data": "3.运行结果"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328162653301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwMzc5OA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "4.结果分析"}, {"ctype": "p", "data": "首先，从结果可以看出，测试使用了10张图片，但最终只有8张图片出来，缺少了两张。这是因为代码设定了阈值theshhold=2，所以有些图片特征点匹配的数量小于2，在可视化图片匹配的时候就没有显示出来。"}, {"ctype": "p", "data": "其次，图片xx01和xx04原本不是同一栋楼，但是却被匹配在了一起。原因可能是这两张图片的颜色和纹理比较相似，所以他俩才匹配到了一起。"}, {"ctype": "p", "data": "最后，根据实验结果，可以发现SIFT的一些缺点，例如，如果存在外表很像的两幅图像，有可能会被匹配在一起；如果两幅图像因为角度旋转太大等问题导致了特征点消失，那么这两幅图像可能不会被匹配在一起。"}], "cate": "Python"}
{"题目": "Python 每日一题（返回给定字符串中第一个不重复的字符）", "作者": "Oblning", "发布时间": "2021-03-28 09:38:28", "内容": [{"ctype": "head", "data": "Python 每日一题：锻炼Python语法的运用，思维逻辑的锻炼，算法能力的培养。"}, {"ctype": "head", "data": "题目："}, {"ctype": "p", "data": "   返回给定字符串中第一个不重复的字符。"}, {"ctype": "head", "data": "分析："}, {"ctype": "p", "data": "   1、按需存储字符串中每个字符及对应字符的次数。"}, {"ctype": "p", "data": "   2、从左至右查找，返回第一个次数为0的元素。"}, {"ctype": "head", "data": "实现："}, {"ctype": "code", "data": "def first_not_repeating_char(strings):\n    '''\n        查找给定字符串中第一个次数为1的字符\n    :param strings: str，查找字符串\n    :return: str，第一个次数为1的字符\n    '''\n    chars = []\n    times = []\n    for s in strings:\n        if s not in chars:\n            chars.append(s)\n            times.append(1)\n        else:\n            char_index = chars.index(s)\n            times[char_index] += 1\n\n    for t in times:\n        if t == 1:\n            times_index = times.index(t)\n            return chars[times_index]\n    return False\n\nstrings = input('请输入长字符串：')\nprint('结果：', first_not_repeating_char(strings))"}, {"ctype": "head", "data": "结果："}, {"ctype": "code", "data": "请输入长字符串：abcdsabc\n结果： d"}, {"ctype": "p", "data": "【结语】以上整个程序的实现逻辑，还存在很多不全面的地方，欢迎各位大佬指点；如果觉得笔者不易，请给予点赞，给予我记录更多文章的动力！！"}], "cate": "Python"}
{"题目": "Python（十七）- Excel操作：xlsxwriter绘制图表", "作者": "Alfred_|_derflA", "发布时间": "2021-03-28 18:01:18", "内容": [{"ctype": "p", "data": "上一篇用一个简单实例描述了openpyxl和xlsxwriter对Excel表格的操作，本文则实例介绍一下xlsxwriter图表的绘制。"}, {"ctype": "head", "data": "一、Chart类简介"}, {"ctype": "p", "data": "Chart类是用于在 XlsxWriter中实现图表的模块基础类。支持的图表类型有：面积、条形图、柱形图、折线图、饼图、散点图、股票和雷达等。"}, {"ctype": "head", "data": "1.图表创建："}, {"ctype": "p", "data": "Chart通过指定图表类型的工作簿的add_chart()方法来创建图表对象。"}, {"ctype": "code", "data": "# e.g.\n chart = workbook.add_chart({'type': 'column'})\n"}, {"ctype": "head", "data": "2.图表类型"}, {"ctype": "p", "data": "type类型字段值的选择有："}, {"ctype": "head", "data": "3.图表插入"}, {"ctype": "code", "data": "# e.g.\nworksheet.insert_chart('A4', chart, {'x_offset': 25, 'y_offset': 10})\n"}, {"ctype": "head", "data": "4.图表方法"}, {"ctype": "p", "data": "图表的常用方法："}, {"ctype": "head", "data": "二、案例Demo"}, {"ctype": "head", "data": "1.构造数据"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032816311857.png"}, {"ctype": "code", "data": "def construct_test_data(dimension='all'):\n    \"\"\"\n    构造数据\n    \"\"\"\n    if dimension == 'all':\n    \tsheetName = '国内_整体'\n        data = [\n            ['指标', '加速线路', '安全加速', '精品EIP', '普通EIP', '腾讯', 'AWS', '阿里云'],\n            ['延时（ms）', 51.22, 56.12, 65.61, 92.76, 116.02, 76.02, 66.02],\n            ['丢包率（%）', 1.45, 3.21, 0.74, 6.18, 2.32, 1.32, 0.62]\n        ]\n    else:\n    \tsheetName = '国内_运营商'\n        data = [\n            ['运营商', '加速线路', None, '安全加速', None, '精品EIP', None, '普通EIP', None, '腾讯', None, 'AWS', None, '阿里云', None],\n            [None, '延时（ms）', '丢包率（%）', '延时（ms）', '丢包率（%）', '延时（ms）', '丢包率（%）', '延时（ms）', '丢包率（%）', '延时（ms）', '丢包率（%）', '延时（ms）', '丢包率（%）', '延时（ms）', '丢包率（%）'],\n            ['中国电信', 52.68, 2, 42.1, 0.82, 24.21, 1.08, 52.32, 0.12, 50.97, 2, 121.2, 6.8, 90.33, 0.54],\n            ['中国移动', 53.92, 0.3, 56.12, 2, 34, 0.27, 68.21, 1.45, 89.21, 0.42, 77.8, 0.52, 44.3, 0],\n            ['中国联通', 67.31, 0.69, 65.15, 0.38, 88, 0.52, 55.52, 0.66, 80.2, 0.22, 92.3, 0.44, 210.2, 2.21]\n        ]\n    return sheetName, data\n\n"}, {"ctype": "head", "data": "2.绘制图表"}, {"ctype": "code", "data": "import xlsxwriter\n\ncolor_lst = [\n   ['#000000', '#312D30', '#444245'],  # 黑色\n   ['#DDEBCF', '#9CB86E', '#156B13'],  # 绿色\n   ['#0000FF', '#6A98CC', '#46A7F5'],  # 蓝色\n   ['#800000', '#633915', '#A45D2D'],  # 棕色\n   ['#00FFFF', '#29CFCD', '#006054'],  # 青色\n   ['#808080', '#76797E', '#878785'],  # 灰色\n   ['#FF0000', '#801801', '#D70F19'],  # 红色\n   ['#C0C0C0', '#C2C2C2', '#8A8687'],  # 银色\n   ['#800080', '#621C9B', '#46024F'],  # 紫色\n   ['#FFFF00', '#F2BF04', '#FFE057'],  # 黄色\n   ['#FFFFFF', '#FCFAFB', '#CECECC'],  # 白色\n]\n\ndef export_simple_excel(filename=None, sheetLst=None, contents=None, dimensions=None):\n    filename = filename if filename else '竟对_xlsxwriter_Test.xlsx'\n    sheetLst = sheetLst if sheetLst else ['竟对分析测试']\n    contents = contents if contents else []\n    dimensions = dimensions if dimensions else ['all', 'isp']\n    wb = xlsxwriter.Workbook(filename)\n\n    # 设置风格\n    style1 = wb.add_format({\n        \"bold\": True,\n        'font_name': '仿宋',\n        'font_size': 12,\n        'bg_color': '#4DCFF6',\n        \"align\": 'center',\n        \"valign\": 'vcenter',\n        'text_wrap': 1\n    })\n    style2 = wb.add_format({\n        'font_size': 11,\n        'font_color': '#217346',\n        'bg_color': '#E6EDEC',\n        \"align\": 'center',\n        \"valign\": 'vcenter',\n    })\n\n    for index_, sheetName in enumerate(sheetLst):\n        ws = wb.add_worksheet(name=sheetName)\n        dimension = dimensions[index_]\n        # ws.set_default_row(35)  # 设置默认行高\n        ws.set_column(0, len(contents[index_][0])-1, 20)  # 设置列宽\n        # 写入\n        if dimension == 'all':\n            for i, row_lst in enumerate(contents[index_]):\n                style = style2 if i != 0 else style1\n                ws.write_row(f'A{i+1}', row_lst, style)\n        else:\n            line1, line2 = list(filter(lambda col: col, contents[index_][0])), list(filter(lambda col: col, contents[index_][1]))\n            isp, titleLine1 = line1[0], line1[1:]\n            titleLine2 = line2\n            ws.set_column(0, 0, 20)  # 设置列宽\n            ws.set_column(1, len(titleLine2), 15)  # 设置列宽\n            # 标题\n            ws.merge_range(0, 0, 1, 0, isp, style1)\n            [ws.merge_range(0, 2*i+1, 0, 2*(i+1), name, style1) for i, name in enumerate(titleLine1)]\n            [ws.write(1, i+1, name, style1) for i, name in enumerate(titleLine2)]\n            # 内容\n            for i, row_lst in enumerate(contents[index_][2:]):\n                ws.write_row(f'A{i+3}', row_lst, style2)\n        \n        # 画图\n        y1_name = '延时（ms）'\n        y2_name = '丢包率（%）'\n        x_name = '产品类型'\n        title_name = sheetName\n\n        # 柱状图\n        column_chart = wb.add_chart({'type': 'column'})\n        # 折线图\n        line_chart = wb.add_chart({'type': 'line'})\n\n        if dimension == 'all':  # 整体维度\n            column_name = f'={sheetName}!A2'\n            line_name = f'={sheetName}!A3'\n            categories = f'={sheetName}!B1:H1'\n            column_values = f'={sheetName}!B2:H2'\n            line_values = f'={sheetName}!B3:H3'\n\n            column_chart.add_series({\n                'name':       column_name,\n                'categories': categories,\n                'values':     column_values,\n            })\n            line_chart.add_series({\n                'name':       line_name,\n                'categories': categories,\n                'values':     line_values,\n                'marker':       {'type': 'circle'},  # 系列标记\n                'data_labels': {  # 数据标签\n                    'value': True,\n                    'series_name': True,\n                    'position': 'above',\n                    'separator': \"\\n\",\n                    'font': {'name': 'Consolas', 'color': 'red', 'size': 8}\n                },\n                'y2_axis':    True,\n            })\n        else:  # 运营商维度\n            # 添加规则\n            d_lst = ['B', 'D', 'F', 'H', 'J', 'L', 'N']\n            l_lst = ['C', 'E', 'G', 'I', 'K', 'M', 'O']\n\n            for i, c in enumerate(d_lst):\n                # 写法一\n                categories_str = f'={sheetName}!A3:A5'\n                column_name_str = f'={sheetName}!{c}1:{c}2'\n                line_name_str = f'={sheetName}!{l_lst[i]}1:{l_lst[i]}2'\n                column_values_str = f'={sheetName}!{c}3:{c}5'\n                line_values_str = f'={sheetName}!{l_lst[i]}3:{l_lst[i]}5'\n\n                # 添加数据选项\n                column_chart.add_series({\n                    'name':       column_name_str,\n                    'categories': categories_str,\n                    'values':     column_values_str,\n                    'gap':        50,  # 间隙\n                    'overlap':    -5,  # 系列重叠\n                    'gradient': {  # 渐变填充\n                        'colors': color_lst[i],\n                        'type': 'radial'\n                    },\n                })\n                line_chart.add_series({\n                    'name':       line_name_str,\n                    'categories': categories_str,\n                    'values':     line_values_str,\n                    'marker':       {'type': 'circle'},  # 系列标记\n                    'data_labels': {  # 数据标签\n                        'value': True,\n                        'series_name': True,\n                        'position': 'above',\n                        'separator': \"\\n\",\n                        'font': {'name': 'Consolas', 'color': 'yellow', 'size': 8}\n                    },\n                    'y2_axis':    True,\n                })\n\n        # 设置副坐标\n        line_chart.set_y2_axis({\n            'name': y2_name, \n            'name_font': {'name': 'Calibri','color': 'red' },  # 轴标题设置\n            'num_font': {'name': 'Arial', 'color': '#00B0F0', 'size': 8},  # 轴参数设置\n        })\n        # 设置前、背景色\n        column_chart.set_plotarea({\n            'pattern': {\n                'pattern': 'percent_5',\n                'fg_color': '#555555',\n                'bg_color': '#595959',\n            }\n        })\n        # 组合\n        column_chart.combine(line_chart)\n        column_chart.set_title({'name': title_name, 'name_font': {'name': 'Calibri','color': 'red' , 'size': 15}}) \n        column_chart.set_x_axis({'name': x_name, 'name_font': {'name': 'Calibri','color': 'green' }, 'num_font': {'name': 'Arial', 'color': 'green', 'size': 9}}) \n        column_chart.set_y_axis({'name': y1_name, 'name_font': {'name': 'Calibri','color': 'blue' }, 'num_font': {'name': 'Arial', 'color': 'blue', 'size': 8}})\n        # 样式\n        column_chart.set_style(2)\n        column_chart.set_legend({'font': {'size': 8, 'bold': False}})\n        column_chart.set_size({'width': 720, 'height': 576})\n        # 插入\n        ws.insert_chart('A4', column_chart, {'x_offset': 25, 'y_offset': 10})  # 在A4单元格插入图表\n    # 保存关闭文件\n    wb.close()\n\n"}, {"ctype": "head", "data": "3.运行测试"}, {"ctype": "code", "data": "import os\n\nFILE_PATH = os.path.join(os.path.dirname(__file__), 'files/')\n\ndef simple_test():\n    dimension_lst = ['all', 'isp']\n\n    # 方式一：按文件拆分\n    for dimension in dimension_lst:\n        filename = os.path.join(FILE_PATH, f'竟对分析_SimpleTest_{dimension}.xlsx')\n        sheetName, data = construct_test_data(dimension=dimension)\n        export_simple_excel(filename=filename, sheetLst=[sheetName], contents=[data], dimensions=[dimension])\n    # 方式二：按sheet拆分\n    file = os.path.join(FILE_PATH, '竟对分析_SimpleTest.xlsx')\n    sheetLst = []\n    contents = []\n    for dimension in dimension_lst:\n        sheetName, data = construct_test_data(dimension=dimension)\n        sheetLst.append(sheetName)\n        contents.append(data)\n    export_simple_excel(filename=file, sheetLst=sheetLst, contents=contents, dimensions=dimension_lst)\n\n\nif __name__ == '__main__':\n    simple_test()\n\n"}, {"ctype": "head", "data": "4.图表显示"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328181909330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTU5OTg1OA==,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328182027236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTU5OTg1OA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "以上就是利用XlsxWriter包的Chart类绘制的简单的组合图。"}], "cate": "Python"}
{"题目": "解决问题:Jupyter-notebook不弹出默认浏览器", "作者": "33-Hope", "发布时间": "2021-03-28 17:11:33", "内容": [{"ctype": "head", "data": "写给自己"}, {"ctype": "head", "data": "1. 首先，确定你的问题是：Jupyter-notebook可以正常运行，但是不弹出默认浏览器，例如下图（只有下图，浏览器死活没动静！）："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328165215721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1TTUyMw==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "解决方案："}, {"ctype": "p", "data": "电脑存在多个浏览器，且没有设置默认浏览器，请选择一个设置为默认浏览器。（方法由https://zhuanlan.zhihu.com/p/33266087该作者提供，但是对我没效果）"}, {"ctype": "p", "data": "修改Jupyter-notebook的配置文件"}, {"ctype": "code", "data": "import webbrowser\nwebbrowser.register(\n    \"Firefox\",  #自定义名字，复制时请删除该注释\n    None, \n    webbrowser.GenericBrowser(u\"D:\\\\Program Files\\\\Firefox\\\\firefox.exe\"))\nc.NotebookApp.browser = \"Firefox\"\n"}, {"ctype": "p", "data": "（代码来自：添加链接描述一定成功！！！Jupyter-notebook 修改默认浏览器和默认打开位置）"}, {"ctype": "p", "data": "这里有需要注意的地方："}, {"ctype": "p", "data": "webbrowser.GenericBrowser(u\"D:\\\\Program Files\\\\Firefox\\\\firefox.exe\"))#指定程序所在位置 这段代码中的程序所在位置，根据你自己的程序所在位置写，不要直接复制我的。如果自己不知道浏览器安装在里面，可以在桌面找到图标，右键，属性： 查到后的注意，根据上面给的代码进行修改，即\\需要改成两个“\\” webbrowser.GenericBrowser(u\"E:\\\\Software\\\\Firefox\\\\firefox.exe\"))什么浏览器都可以，我使用的火狐。但是要求：浏览器的安装目录不要有中文，（我的谷歌有中文，所有换的火狐的）至于有中文如何解决，请自行百度 我累了，不想百度了。"}], "cate": "Python"}
{"题目": "python字典（dictionary）", "作者": "qq_35624469", "发布时间": "2021-03-28 22:12:58", "内容": [{"ctype": "head", "data": "python字典（dictionary）"}, {"ctype": "head", "data": "基础知识："}, {"ctype": "head", "data": "四、遍历"}, {"ctype": "head", "data": "（一）dict[key]直接进行值得获取"}], "cate": "Python"}
{"题目": "数据分析Python习题01", "作者": "猫狗记", "发布时间": "2021-03-28 22:53:12", "内容": [{"ctype": "p", "data": "喜欢的话，关注我，谢谢点赞"}, {"ctype": "head", "data": "title-1"}, {"ctype": "p", "data": "自定义字符串，完成字符串的索引/切片/find/count/replace/split/乘法/连接操作，并写出输出结果"}, {"ctype": "code", "data": ">>> str='hello'\n>>> print(\"第二个字符是'{:}'\".format(str[1]))\n第二个字符是'e'\n>>> print('{:}'.format(str[0:2]))\nhe\n>>> strFind='lo'\n>>> print(str.find(strFind))\n3\n>>> sub='l'\n>>> print(str.count(sub))\n2\n>>> print(str.replace(\"llo\",\"666\"))\nhe666\n>>> print(str.split('o',1))\n['hell', '']\n>>> str*3\n'hellohellohello'\n>>> p=' python'\n>>> str+p\n'hello python'\n"}, {"ctype": "head", "data": "title-2"}, {"ctype": "p", "data": "打印99乘法表"}, {"ctype": "code", "data": "# 九九乘法表\nfor i in range(1, 10):\n    for j in range(1, i+1):\n        print('{}x{}={}\\t'.format(j, i, i*j), end='')\n    print()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/15b4392bcd4faa1f74b77e907d135812.png"}, {"ctype": "head", "data": "title-3"}, {"ctype": "p", "data": "定义一个函数，函数的参数是分数，把分数转化成A(2%)B(10%)C(70%)D(15%)E(3%)五个等级"}, {"ctype": "code", "data": "def fun(score):\n  if score<60:\n    print(\"E\")\n  elif score<70:\n    print(\"D\")\n  elif score<80:\n    print(\"C\")\n  elif score<90:\n    print(\"B\")\n  else:\n    print(\"A\")\n\n>>> fun(10)\n>>> E\n>>> fun(98)\n>>> A\n"}, {"ctype": "code", "data": "a=eval(input())\nif a<60:\n  print(\"E\")\nelif a<70:\n  print(\"D\")\nelif a<80:\n  print(\"C\")\nelif a<90:\n  print(\"B\")\nelse:\n  print(\"A\")\n"}, {"ctype": "code", "data": "a=eval(input())\nif a>=90:\n  print(\"A\")\nelif 90>a>=80:\n  print(\"B\")\nelif 80>a>=70:\n  print(\"C\")\nelif 70>a>=60:\n  print(\"D\")\nelif a<60:\n  print(\"E\")\n"}], "cate": "Python"}
{"题目": "如何为Jupyter Notebook配置PyTorch以及Tensorflow运行环境", "作者": "sweettea~", "发布时间": "2021-03-28 11:17:08", "内容": [{"ctype": "head", "data": "如何为Jupyter Notebook配置PyTorch以及Tensorflow运行环境"}, {"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "上学期曾成功为Jupyter Notebook配置PyTorch和Tensorflow运行环境，但是寒假进行环境整理时，不慎误删，当时宅家没有科研任务，一直没有在意它。忘了当时看的哪个教程安装的，昨天又看了许多博客不同方法进行配置，但是有的方法在本人电脑并非有效，花费了较多的时间重新配置PyTorch，Tensorflow则是基于PyTorch，配置很快。由于以后还常需用PyTorch和Tensorflow，因此现记下对我有效的方法，毕竟能抓到老鼠的才是好猫，非常感谢一位大佬的分享，对我的帮助很大。"}, {"ctype": "head", "data": "PyTorch具体安装方法"}, {"ctype": "p", "data": "1、首先需要安装 Anaconda 2、Anaconda环境管理 Anaconda的默认环境是base环境，为方便管理可以创建不同的子环境，它们之间相互独立。个人习惯一个新项目创建一个新环境，这样同时也能满足参考代码各库版本不同的问题。conda create -n name python=python版本，名字可以自己取，python版本即为自己版本，我的python版本是3.8.5。由于我取名为pytorch，所以我输入的命令即为 conda create -n pytorch python=3.8.5，创建的文件夹默认为envs文件夹下。"}, {"ctype": "code", "data": "// conda create -n name python=你的python版本\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328103352906.png"}, {"ctype": "p", "data": "首先需要创建一个PyTorch环境，遇到安装提示输入y，然后继续安装。conda info -e可以查看当前anaconda中的环境，其中带*号的环境表示当前所处的环境。  conda activate name或者直接使用activate name可以进入新环境。  此外，conda activate可以退出当前环境，conda remove -n name --all可以删除不想要的环境。 3、PyTorch的安装 PyTorch的安装方法有很多，例如直接从官网进行安装，官网链接: https://pytorch.org/.根据自己的电脑配置进行选择，复制官网给出的命令行，直接进行安装，需要安装在自己配置的pytorch环境中，根据提示输入y进行安装，如在学校，建议用校园网安装。查看电脑是否有GPU可看下这篇博客。https://blog.csdn.net/sweet_tea_/article/details/115273463   安装完毕后即可以查看是否安装成功，但是从官方安装的方法对我不太友好，反复多次安装测试也行不通，因此采用的是在anaconda prompt中输入pytorch安装命令行conda install pytorch也可以用 pip install packages直接进行安装，packages是需要安装的包，同样要注意切换到配置好的pytorch环境，遇到安装提示选择y。因为安装时我没有截图，下面是安装完毕后的结果。  安装完毕后可以测试下pytorch是否安装成功。在anaconda prompt输入python，然后输入import torch，如果没有报错就说明安装成功。  4、安装mxnet 首先，以管理员身份打开Anaconda Prompt，然后在命令行输入conda install nb_conda，遇到提示同样输入y进行安装。 同样以管理员身份打开Anaconda Prompt，然后进入创建的pytorch环境，然后在命令行输入 conda install ipykernel，根据提示输入y进行安装。安装成功的界面如下。  打开Jupyter Notebook，如果安装成功那么语言增加两个，选择安装了pytorch的进行测试，，如果import torch无误，则说明安装终于彻底完事了。  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328103257477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3ZWV0X3RlYV8=,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "Tensorflow具体安装方法"}, {"ctype": "p", "data": "1、首先同样需要安装 Anaconda。 2、Anaconda环境管理方式也一样，不再赘述。 3、Tensorflow的安装 我建立了一个新的环境为“tf\"，由于我需要安装的版本是Tensorflow == 1.14.0，在创建新的环境时我直接安装的python ==3.8.5,但是安装Tensorflow == 1.14.0时则出现了问题，因为Tensorflow == 1.14.0只兼容python ==3.6~3.7的版本，因此我重新安装了python ==3.7。然后直接安装Tensorflow == 1.14.0即可， pip install tensorflow==1.14.0或者 conda install tensorflow==1.14.0均可进行安装。  安装完毕后可以直接用pip list查看是否安装成功。   4、安装mxnet，方法与pytorch相同，不再赘述。安装完毕后可以打开jupyter notebook查看是否成功。  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210329165656731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3ZWV0X3RlYV8=,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "参考文章：对我帮助很大的那位大佬的文章传送门，再次表示感谢，尤其是conda环境管理总结的很到位！ https://blog.csdn.net/cqldqsb/article/details/104550999/."}], "cate": "Python"}
{"题目": "Python计算机视觉实验一——图像的基本操作与处理", "作者": "大湿人� 李黑", "发布时间": "2021-03-28 09:57:26", "内容": [{"ctype": "head", "data": "1.图像的轮廓与直方图"}, {"ctype": "p", "data": "绘制图像轮廓（或其他二维函数的等轮廓线）在工作中非常有用。因为绘制轮廓需要对每个坐标[x,y]的像素值施加同一个阈值，所以首先需要将图像灰度化（将convert参数设置为L，L 为8位像素黑白图）。 直方图是数值数据分布的精确图形表示。它是一种条形图。图像的灰度直方图表征的是该图像的灰度分布。 绘图都可以调用matplotlib.pyplot库来进行，其中的hist函数可以直接绘制直方图。hist() 函数的第二个参数指定小区间的数目。需要注意的是,因为 hist() 只接受一维数组作为输入,所以我们在绘制图像直方图之前,必须先对图像进行压平处理。flatten() 方法将任意数组按照行优先准则转换成一维数组。"}, {"ctype": "code", "data": "from PIL import Image\nfrom pylab import *\n\nif __name__=='__main__':\n    im = array(Image.open('1.jpg').convert('L'))\n\n    figure()\n    gray()\n    contour(im,origin='image')\n    axis('equal')\n    axis('off')\n\n    figure()\n    hist(im.flatten(),128)\n    show()\n"}, {"ctype": "p", "data": "下面是运行结果：  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328093659221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM0MDI1NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2.直方图均衡化"}, {"ctype": "p", "data": "直方图均衡化是指将一幅图像的灰度直方图变平，使变换后的图像中每个灰度值的分布概率都相同。在对图像做进一步处理之前，直方图均衡化通常是对图像灰度值进行归一化的一个非常好 的方法，并且可以增强图像的对比度。"}, {"ctype": "code", "data": "from PIL import Image\nfrom pylab import *\nfrom numpy import *\nfrom PCV.tools import imtools\n\nif __name__=='__main__':\n\n    im = array(Image.open('1.jpg').convert('L'))\n    im2, cdf = imtools.histeq(im)\n\n    figure()\n    subplot(2, 2, 1)\n    axis('off')\n    gray()\n    title('(a)Original Image')\n    imshow(im)\n\n    subplot(2, 2, 2)\n    axis('off')\n    title('(b)Image After Histogram Equalization')\n    imshow(im2)\n\n    subplot(2, 2, 3)\n    axis('off')\n    title('(c)Histogram Of Original Image')\n    hist(im.flatten(), 128, density=True)\n\n    subplot(2, 2, 4)\n    axis('off')\n    title('(d)Histogram After Equalization')\n    hist(im2.flatten(), 128, density=True)\n\n    show()\n"}, {"ctype": "p", "data": "下面是运行结果：  运行中出现的错误："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328094307114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM0MDI1NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "错误一： ModuleNotFoundError: module ‘imtools’ has no attribute 'histteq 解决办法： 安装PCV库，然后将imtools库更换成PCV的imtools库。 即，添加`from PCV.tools import imtools"}, {"ctype": "p", "data": "错误二： plt.hist中的参数normed参数报错 解决办法： 将normed参数改为density参数"}, {"ctype": "head", "data": "3.图像的高斯模糊"}, {"ctype": "p", "data": "高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：**用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值用。**高斯平滑滤波器对于抑制服从正态分布的噪声非常有效。"}, {"ctype": "code", "data": "from PIL import Image\nfrom numpy import *\nfrom scipy.ndimage import filters\nfrom pylab import *\n\nif __name__=='__main__':\n    im = array(Image.open('1.jpg').convert('L'))\n    gray()\n    subplot(1,4,1)\n    axis('off')\n    title('Original Image')\n    imshow(im)\n\n    for bi, blur in enumerate([2, 5, 10]):\n        im2 = zeros(im.shape)\n        im2 = filters.gaussian_filter(im, blur)\n        im2 = np.uint8(im2)\n        imNum = str(blur)\n        subplot(1, 4, 2 + bi)\n        axis('off')\n        title('GaussVar = ' + imNum)\n        imshow(im2)\n    show()\n"}, {"ctype": "p", "data": "下面是运行结果： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328095657164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM0MDI1NA==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python：分类变量转换哑元 pd.get_dummies()+OLS", "作者": "小白小白小小白w", "发布时间": "2021-03-28 18:09:20", "内容": [{"ctype": "head", "data": "分类变量转换哑元"}, {"ctype": "p", "data": "pd.get_dummies()"}, {"ctype": "p", "data": "pandas.get_dummies(data, prefix=None, prefix_sep=’_’, dummy_na=False, columns=None, sparse=False, drop_first=False)[source]"}, {"ctype": "p", "data": "①data，即需要转换的分类型数据 ②prefix：str, list of str, or dict of str, 默认为None ③drop_first：是否删除每个分类变量的第一个哑元变量 官方文档： pandas.get_dummies"}, {"ctype": "p", "data": "哑元 哑元。又称虚设变量、名义变量或哑变量，用以反映质的属性的一个人工变量，是量化了的自变量，通常取值为0或1。引入哑变量可使线形回归模型变得更复杂，但对问题描述更简明，一个方程能达到两个方程的作用，而且接近现实。 处理问卷调查收集的多选题数据。"}, {"ctype": "code", "data": "import pandas as pd\nimport numpy as np\ndiamonds=pd.read_csv('D:/diamonds.csv')\ndiamonds.head()\n"}, {"ctype": "p", "data": " 下标为1，2，3的变量为分类变量，接下来使分类变量哑元化："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328161512375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2MDA3MQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "code", "data": "print(diamonds.columns)\nprint(diamonds.shape)\n"}, {"ctype": "p", "data": "diamonds.shape为(53940, 10)"}, {"ctype": "code", "data": "a=[1,2,3]  #分类变量下标\nb=list(set(range(10))-set(a))#数值变量下标\ndiamonds1=diamonds  #不在原数据上做改动\ndiamonds1['const']=np.ones(diamonds.shape[0])\ndiamonds1\nb1=list(set(range(11))-set(a))  #数值变量下标 多了一列const\nnew=diamonds1[diamonds1.columns[b1]]\n#new\nfor i in diamonds1[diamonds1.columns[a]]:\n    #print(i)\n    z=pd.get_dummies(diamonds1[i],drop_first=True)\n    z.columns=i+'_'+z.columns\n    new=pd.concat([new,z],axis=1)\nprint(new.shape)\nnew\n"}, {"ctype": "code", "data": "#另 创建一列含const的DataFrame后和数据pd.concat\na=[1,2,3]  #分类变量下标\nb=list(set(range(10))-set(a))#数值变量下标\nnew=pd.DataFrame({'const':np.ones(diamonds.shape[0])})\nnew=pd.concat([new,diamonds[diamonds.columns[b]]],axis=1)\nnew\n#for i in diamonds[diamonds.columns[a]]:  同 print(i) cut color clarity\nfor i in diamonds.columns[a]:\n    z=pd.get_dummies(diamonds[i],drop_first=True)\n    z.columns=i+'_'+z.columns\n    new=pd.concat([new,z],axis=1)\nprint(new.shape)\nnew\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/202103281833548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2MDA3MQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "数据处理好之后，new的shape变为(53940, 25)。"}, {"ctype": "code", "data": "beta=(np.linalg.inv(x.T.dot(x)).dot(x.T)).dot(np.log(y)) #公式\nyhat=x.dot(beta)\nres=np.log(y)-yhat\nprint('coef={}\\n'.format(beta))\n"}, {"ctype": "p", "data": "最小二乘回归，price为y，进行取对数变换。"}], "cate": "Python"}
{"题目": "小白学python（opencv图像加载与保存）", "作者": "mcl19909949541", "发布时间": "2021-03-28 14:32:52", "内容": [{"ctype": "head", "data": "图像加载"}, {"ctype": "code", "data": "import cv2  as cv\n\nsrc = cv.imread(\"C:/Users/POG/Pictures/Autumn is coming WallPack/Timon Studler Mod.jpg\")#读取图片\ncv.namedWindow(\"input image\",cv.WINDOW_AUTOSIZE)#创建窗口\ncv.imshow(\"input image\",src)#把图片放到窗口中去\ncv.waitKey(0) #没有的话直接就退出了\ncv.destroyAllWindows()\n"}, {"ctype": "p", "data": "上面是主体，用上面的图片进行读取里面的格式类型 我们定义一个测试函数"}, {"ctype": "code", "data": "def get_image_info(image):\n\tprint(type(image))#图像类型\n    print(image.shape)#高，宽，通道数目\n    print(image.size)#大小\n\tprint(image.dtype)\n"}, {"ctype": "p", "data": "此处注意python为解释型语言，一行一行运行，所以先定义函数再运行主体。 也可以定义主函数，用"}, {"ctype": "code", "data": "if __name__ ==\"__main__\":\n    main()\n"}, {"ctype": "p", "data": "方式并放到结尾，程序就会所有读取完再进行主函数，那么单个函数就无所谓放哪了。 结果为：  类型为numpy.ndarray 即高为2880，长5120，三通道； 44236830=288051203；"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328135812488.png"}, {"ctype": "head", "data": "图像保存"}, {"ctype": "p", "data": "在main加一句："}, {"ctype": "code", "data": "cv.imwrite(\"D:/result.png\",src)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328142919135.png"}, {"ctype": "head", "data": "视频操作"}, {"ctype": "head", "data": "摄像头操作"}, {"ctype": "p", "data": "代码为"}, {"ctype": "code", "data": "def video_demo():\n    capture = cv.VideoCapture(0) #0为打开一个摄像头\n    while(True):\n        ret,frame = capture.read()\n        frame= cv.flip(frame,1) #镜像调换\n        cv.imshow(\"video\",frame)\n        c = cv.waitKey(50)\n        if (c==27):    #esc为27，按esc即退出\n            break\n\n"}, {"ctype": "p", "data": "运行结果为：  cap.read（）：返回一个布尔值（True / False）。如果帧被正确读取，则返回true，否则返回false。可以通过检查这个返回值来判断视频是否结束。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328141443658.png"}, {"ctype": "head", "data": "从文件中播放视频"}, {"ctype": "p", "data": "和从相机捕获视频相同，只需更改相机索引与视频文件名。 在显示帧时，选择适当的cv2.waitKey（）时间，如果该值太小，视频会非常快，如果它太大，视频会很慢（这可以用来慢动作显示视频）。 正常情况下，25毫秒即可。（差不多？？）"}, {"ctype": "code", "data": "def video_demo():\n    capture = cv.VideoCapture(\"E:/电影/[阳光电影www.ygdy8.com].疾速特攻.BD.720p.中英双字幕.mkv\") #简简单单把0改为电影路径即可\n    while(True):\n        ret,frame = capture.read()\n        frame= cv.flip(frame,1) #镜像调换\n        cv.imshow(\"video\",frame)\n        c = cv.waitKey(50)\n        if (c==27):    #esc为27，按esc即退出\n            break\n\n"}, {"ctype": "head", "data": "添加读取fps，大小，时长功能"}, {"ctype": "code", "data": "def video_demo():#调用摄像头\n    capture = cv.VideoCapture(\"E:/电影/[阳光电影www.ygdy8.com].疾速特攻.BD.720p.中英双字幕.mkv\")\n    while(True):\n        ret,frame = capture.read()\n        frame=cv.flip(frame,1)\n        # 读取视频的fps,  大小\n        fps=capture.get(cv.CAP_PROP_FPS)\n        size=(capture.get(cv.CAP_PROP_FRAME_WIDTH),capture.get(cv.CAP_PROP_FRAME_HEIGHT))\n        print(\"fps: {}\\nsize: {}\".format(fps,size))\n        # 读取视频时长（帧总数）\n        total = int(capture.get(cv.CAP_PROP_FRAME_COUNT))\n        print(\"[INFO] {} total frames in video\".format(total))\n        cv.imshow(\"video\",frame)\n        c = cv.waitKey(50)\n        if (c==27):    #esc为27\n            break\n\n"}, {"ctype": "head", "data": "总体代码："}, {"ctype": "code", "data": "import cv2  as cv\nimport  numpy as np\ndef main():\n    src = cv.imread(\"C:/Users/POG/Pictures/Autumn is coming WallPack/Timon Studler Mod.jpg\")\n    cv.namedWindow(\"input image\",cv.WINDOW_AUTOSIZE)\n    cv.imshow(\"input image\",src)\n    video_demo()\n    cv.waitKey(0)\n\n    cv.destroyAllWindows()\n    get_image_info(src)\n    cv.imwrite(\"D:/result.png\",src)\n\ndef get_image_info(image):\n    print(type(image))\n    print(image.shape)\n    print(image.size)\n    print(image.dtype)\n    pixel_data = np.array(image)\n    print(pixel_data)\n\n\ndef video_demo():#调用摄像头\n    capture = cv.VideoCapture(\"E:/电影/[阳光电影www.ygdy8.com].疾速特攻.BD.720p.中英双字幕.mkv\")\n    while(True):\n        ret,frame = capture.read()\n        frame=cv.flip(frame,1)\n        # 读取视频的fps,  大小\n        fps=capture.get(cv.CAP_PROP_FPS)\n        size=(capture.get(cv.CAP_PROP_FRAME_WIDTH),capture.get(cv.CAP_PROP_FRAME_HEIGHT))\n        print(\"fps: {}\\nsize: {}\".format(fps,size))\n        # 读取视频时长（帧总数）\n        total = int(capture.get(cv.CAP_PROP_FRAME_COUNT))\n        print(\"[INFO] {} total frames in video\".format(total))\n        cv.imshow(\"video\",frame)\n        c = cv.waitKey(50)\n        if (c==27):    #esc为27\n            break\n\nif __name__ ==\"__main__\":\n    main()\n"}, {"ctype": "p", "data": "运行截图： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032816054438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python多线程效率低下！不升反降！", "作者": "云朵拥有雨滴", "发布时间": "2021-03-28 14:26:13", "内容": [{"ctype": "head", "data": "情景描述"}, {"ctype": "p", "data": "最近在做实验时，想到用多线程来加快对数据集的加载速度。在尝试后总感觉时间依旧很慢，于是查阅资料得知：python多线程是个天坑！"}, {"ctype": "p", "data": "Python中的多线程是假的多线程！ 因为Cpython解释器有一个东西叫全局解释器锁（GIL）。在解释器解释执行 Python 代码时，先要得到这把锁，意味着，任何时候只可能有一个线程在执行代码，其它线程要想获得 CPU 执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。所以python多线程实际上等价于单线程，而且还在切换线程上浪费很多时间！"}, {"ctype": "head", "data": "测试"}, {"ctype": "p", "data": "运行下面的函数testadd()10次，分别使用单线程、多线程、多进程"}, {"ctype": "code", "data": "import time\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\n\n\ndef testadd():\n    s = 0\n    for i in range(int(1e7)):\n        s += i\n        s /= 2\n    return s\n\n\nif __name__ == '__main__':\n    time1 = time.perf_counter()\n\n    for i in range(10):\n        testadd()\n    time2 = time.perf_counter()\n    print(f'{time2 - time1:.2f}')\n\n    pool = ThreadPoolExecutor(max_workers=8)\n    tasks = [pool.submit(testadd) for i in range(10)]\n    for t in tasks:\n        t.result()\n    time3 = time.perf_counter()\n    print(f'{time3 - time2:.2f}')\n\n    pool = ProcessPoolExecutor(max_workers=8)\n    tasks = [pool.submit(testadd) for i in range(10)]\n    for t in tasks:\n        t.result()\n    time4 = time.perf_counter()\n    print(f'{time4 - time3:.2f}')\n"}, {"ctype": "p", "data": "运行结果："}, {"ctype": "code", "data": "6.33\n17.38\n1.06\n"}, {"ctype": "p", "data": "可以看出，当单线程耗时6秒时，多线程耗时17秒！几乎3倍的时间！而多进程时间仅为1秒！"}], "cate": "Python"}
{"题目": "pyQT 视频播放器（三） 实现视频截图、获取每一帧数据", "作者": "皮尔菲特", "发布时间": "2021-03-28 16:59:00", "内容": [{"ctype": "head", "data": "背景"}, {"ctype": "p", "data": "在 “PyQt5 实现视频播放器（二） ，详细版本 ，适合新手入门“ 中已经想写的介绍了如何使用pyQT 自带的一些控件，实现简单的视频播放功能（例如播放、暂停、进度条跳转、声音控制、全屏播放等），通过评论区的交流，发现大家除了这些简单功能外，还有一个比较强烈的需求就是视频截图，所以下面就来实现一下视频截图功能"}, {"ctype": "head", "data": "方法调研"}, {"ctype": "p", "data": "在方法调研的前分享一下自己在遇到一个新问题的时候的“搜索方法”，希望能够起到抛砖引玉的作用。（有了正确的搜索方式，对于开发能少走弯路，提高效率）"}, {"ctype": "p", "data": "问题定义：这一步也容易也难，特别是工作之后会有更加深刻的体验，简单来说就是如何将你的需求/问题与实际程序实现逻辑进行对应，比如说想实现视频进度条展示，那么对应到具体的pyqt的开发中可能就是，如何使用qt的slider来展示qmediaplayer 播放的媒体进度。这就要求你能对需求/问题进行分解、对使用的程序逻辑/程序组件功能有充分的了解。有点啰嗦了，回归正题，问题定义为： “qt实现视频截图”、如何获取qt视频播放中的每一帧数据、“qt mediaplayer 截图 ”, 会用英文更好： get frame data using QMediaPlayer搜索： pyQT作为QT的一个python版本接口使用方式，整体的资料虽然不如QT的多，但是QT的使用方式都能够在pyQT上使用，因此我在搜索的时候基本上都是不区分pyqt和QT的，比如这次搜索的时候就是查询qt 如何获取，参考的代码也都是QT的源码，改成python的时候只需要注意import 的位置、以及c++写法到python写法的切换即可。筛选：搜索到的方案比较多，大致可以归纳为如下几种： （1）使用“截屏”的方式来完成截图，我稍微尝试了一下发现对于qmediaplayer输出的widget无法截取到画面图像，另外即使截取到了也只是UI界面上大小原始原始图像的大小，因此放弃这个方案 （2）qt + ffmpeg或qt + vlc或qt+ opencv 等进行视频解码播放，功能强大，能够比较方便的进行功能较复杂的图像处理需求，例如使用opencv可以对图像进行复杂的操作（识别、检测、画框） （3）QMediaPlayer + QAbstractVideoSurface，比较方便，转换的是QImage，可以获取每一帧数据。 方案筛选上，由于我们只需要完成截图功能，而且之前用的就是Qmediaplayer,选方案二，能够最快速的实现这个功能。"}, {"ctype": "head", "data": "详细代码说明"}, {"ctype": "p", "data": "采用 QMediaPlayer + QAbstractVideoSurface 这个方案重点需要了解一下QAbstractVideoSurface 这个类，结合查询到的资料以及Assistant中的说明：QAbstractVideoSurface class is a base class for video presentation surfaces. 其中 [pure virtual] 的有两个函数： （1）supportedPixelFormats() # 支持的视频解码后的数据格式 （2）present(const QVideoFrame &frame) # 获取视频解码的数据frame，进行展示 因此我们只需要新写一个类，继承这个抽象的QAbstractVideoSurface 类，然后重写里面的这个两个纯虚函方法，就能从present 输入的Frame中获取每一帧的数据。 如下："}, {"ctype": "code", "data": "from PyQt5.QtMultimedia import QAbstractVideoSurface, QVideoFrame, QAbstractVideoBuffer\nfrom PyQt5.QtCore import pyqtSignal, QDateTime\nfrom PyQt5.QtGui import QImage\nclass myVideoSurface(QAbstractVideoSurface):\n\n    FinishGrab = pyqtSignal()  # 截图完成信号\n\n    def __init__(self, parent=None):\n        super(QAbstractVideoSurface, self).__init__(parent)\n\n    def supportedPixelFormats(self, type=None):\n        support_format = [\n            QVideoFrame.Format_ARGB32,\n            QVideoFrame.Format_ARGB32_Premultiplied,\n            QVideoFrame.Format_ARGB8565_Premultiplied,\n            QVideoFrame.Format_AYUV444,\n            QVideoFrame.Format_AYUV444_Premultiplied,\n            QVideoFrame.Format_BGR24,\n            QVideoFrame.Format_BGR32,\n            QVideoFrame.Format_BGR555,\n            QVideoFrame.Format_BGR565,\n            QVideoFrame.Format_BGRA32,\n            QVideoFrame.Format_BGRA32_Premultiplied,\n            QVideoFrame.Format_BGRA5658_Premultiplied,\n            QVideoFrame.Format_CameraRaw,\n            QVideoFrame.Format_IMC1,\n            QVideoFrame.Format_IMC2,\n            QVideoFrame.Format_IMC3,\n            QVideoFrame.Format_IMC4,\n            QVideoFrame.Format_Jpeg,\n            QVideoFrame.Format_NV12,\n            QVideoFrame.Format_NV21,\n            QVideoFrame.Format_RGB24,\n            QVideoFrame.Format_RGB32,\n            QVideoFrame.Format_RGB555,\n            QVideoFrame.Format_RGB565,\n            QVideoFrame.Format_User,\n            QVideoFrame.Format_UYVY,\n            QVideoFrame.Format_Y16,\n            QVideoFrame.Format_Y8 ,\n            QVideoFrame.Format_YUV420P,\n            QVideoFrame.Format_YUV444,\n            QVideoFrame.Format_YUYV,\n            QVideoFrame.Format_YV12,\n        ]\n        return support_format\n\n    def present(self, frame: 'QVideoFrame'):\n        print(\"width:{},heigth:{},format:{},start_time:{},endtime{}\".format(\n            frame.width(), frame.height(), frame.pixelFormat(), frame.startTime(), frame.endTime()\n        ))\n        if frame.isValid():\n            frame.map(QAbstractVideoBuffer.ReadOnly)\n            img = QImage(frame.bits(), frame.width(), frame.height(),\n                         QVideoFrame.imageFormatFromPixelFormat(frame .pixelFormat()))\n            grab_jpg = './'+QDateTime.currentDateTime().toString(\"yyyy-MM-dd hh-mm-ss-zzz\")+'.jpg'\n            save_state = img.save(grab_jpg)\n            print(\"截图状态：\"+str(save_state))\n            frame.unmap()\n            self.FinishGrab.emit()\n            return True\n        else:\n            return False\n"}, {"ctype": "p", "data": "其中 supportedPixelFormats 中的支持的格式只要后面present中能够支持即可，由于我们并不是真的展示，在present中只是转成了QImage，然后完成截图。在这里有两种方案： （1）使用present中每一帧数据进行展示（这里已经转成QImage图像数据了，接着想怎么画图都可以，然后图像展示就可以），这个方案的话就是图像转换比较耗时，可能会影响到播放的流畅度，如果不是每一帧图像都需要处理的话，不建议用这种方式 （2）播放然后采用“PyQt5 实现视频播放器（二） ，详细版本 ，适合新手入门“ 中介绍的widget进行播放，只有需要截图的将player的输出切换到videosurface进行截图，截完图在切换回去，这种方式播放就是在截图的时候由于切换了player的输出因此会导致截图的时候视频界面会就“黑“一下（此时没有输出）， 这里考虑到截图功能不是每一帧都需要截（由界面上得按钮触发），因此采用了方案（2）"}, {"ctype": "head", "data": "最终效果"}, {"ctype": "p", "data": "首先在原先 “PyQt5 实现视频播放器（二） ，详细版本 ，适合新手入门“中的界面基础上增加了一个截图按钮：  在视频播放的时候，点击截图按钮，会自动截取当前时刻的图片，由于只是demo（抛砖引玉的作用），因此图片会保存到demo所在的当前目录下面（保存的代码在present函数中）： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328164830297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI1NTIyOTY=,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "某张具体的截图如下：（获取到720x480的原始尺寸大小） "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328163444394.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI1NTIyOTY=,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "总结："}, {"ctype": "p", "data": "（1）基本完成视频截图的功能，如果需要复杂的功能可以在这个上面继续扩展（例如截图的列表展示、截图的帧号等） （2）截图的时候已经能够获取每一帧的数据，那么对应的“画框”、图像检测、分类等等都可以在这个上面进行扩展 （3）完整的演示demo 已经打包上传到csdn上：https://download.csdn.net/download/u012552296/16184221"}, {"ctype": "head", "data": "参考资料"}, {"ctype": "p", "data": "如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 [1]How to save a frame using QMediaPlayer? https://stackoverflow.com/questions/37724602/how-to-save-a-frame-using-qmediaplayer [1]原来Qt从视频中获取每一帧数据如此简单: https://blog.csdn.net/jxbinwd/article/details/81034339"}], "cate": "Python"}
{"题目": "使用matlab将长图按分割线分成若干张图片", "作者": "ThinkZtoA", "发布时间": "2021-03-28 16:17:06", "内容": [{"ctype": "head", "data": "分割图片"}, {"ctype": "code", "data": "a=imread('a.jpg');\nfor i=1:70\n    eval(['Q',num2str(i),'=a((i-1)*1400+1:i*1400,:,:);']);\nend   \nfor i=1:70\neval(['imwrite(Q',num2str(i), ',''result',num2str(i),'.jpg'');']);\nclose all\nend\n"}, {"ctype": "p", "data": "这里使用imwrite函数将matlab绘图白边去掉"}, {"ctype": "head", "data": "找到分割线"}, {"ctype": "code", "data": "close all\nlen_r=[];\nfor tt=1:70\n    xy_r=[];\neval(['I=imread(''result',num2str(tt),'.jpg'');']);\nI = rgb2gray(I);\n%I = imrotate(I,33,'crop');\n% figure\n% imshow(rotI);\nBW = edge(I,'canny');\n% figure\n% imshow(BW);\n[H,T,R] = hough(BW);\n\n% figure\n% imshow(H,[],'XData',T,'YData',R,'InitialMagnification','fit');\n% xlabel('\\theta'), ylabel('\\rho');\n% axis on\n% axis normal\n% hold on\n\n\nP  = houghpeaks(H,5,'threshold',ceil(0.3*max(H(:))));\nx = T(P(:,2)); y = R(P(:,1));\n% plot(x,y,'s','color','white');\n% Find lines and plot them\nlines = houghlines(BW,T,R,P,'FillGap',5,'MinLength',7);\nfigure, imshow(I),hold on\n\n\n\nfor k = 1:length(lines)\n    xy = [lines(k).point1; lines(k).point2];\n    plot(xy(:,1),xy(:,2),'LineWidth',2,'Color','green');\n    \n    % Plot beginnings and ends of lines\n    plot(xy(1,1),xy(1,2),'x','LineWidth',2,'Color','yellow');\n    plot(xy(2,1),xy(2,2),'x','LineWidth',2,'Color','red');\n    \n    % Determine the endpoints of the longest line segment\n    len = norm(lines(k).point1 - lines(k).point2);\n    if (len>950)&&xy(1,1)~=xy(2,1)\n        xy_long = xy;\n        len_r=[len_r;tt,len,xy(1,2)];\n        xy_r=[xy_r,xy];\n    end\nend\n% highlight the longest line segment\nfor i=1:size(xy_r,2)/2\n  plot(xy_r(:,2*i-1),xy_r(:,2*i),'LineWidth',2,'Color','blue');\nend\nend\n\n"}, {"ctype": "head", "data": "按照分割线分割"}, {"ctype": "code", "data": "close all\nfor tt=1:70\neval(['I=imread(''result',num2str(tt),'.jpg'');']);\n\nif tt>1\n  eval(['I1=imread(''result',num2str(tt-1),'.jpg'');']);\n  I2=I1(len_r(tt-1,3):end,:,:);\n  a=[I2;I(1:len_r(tt,3),:,:)];\nelse\n    a=I(1:len_r(tt,3),:,:);\nend\neval(['imwrite(a,''final',num2str(tt),'.jpg'');']);\nend\n"}], "cate": "Python"}
{"题目": "（一）python的数据类型和部分内置函数", "作者": "拥有一只傻猫和蠢狗的测试媛", "发布时间": "2021-03-28 21:53:35", "内容": [{"ctype": "head", "data": "数据类型"}, {"ctype": "p", "data": "一、整型 int int 既是整型的代表，又是定义整型的内置函数 python2中有long类型，在python3中已被弃用"}, {"ctype": "code", "data": "count = int(100)\ncount = 100\n"}, {"ctype": "p", "data": "二、浮点型 float float 既是浮点型的代表，又是定义浮点型的内置函数 定义float类型的时候，并不需要一定使用float来声明**"}, {"ctype": "code", "data": "p = float(3.14)\np = 3.14\n"}, {"ctype": "p", "data": "三、字符串 str 用’’ 或\"\" 包裹的信息，就是字符串，字符串中可以包含任意字符：字母，数字，符号。且没有顺序 字符串不可改变"}, {"ctype": "code", "data": "safe = str('体温36.5')\nname = \"yanmai\"\ndata = 'friday'\n"}, {"ctype": "p", "data": "字符串不是数字不能做加减乘除法，字符串的拼接，用“+”这个符号"}, {"ctype": "p", "data": "四、布尔类型与空类型 bool与None 布尔类型：对于结果真假的判断，True->真，False->假  空类型：不属于任何数据类型，就是空类型，空类型属于False的范畴"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328205655369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk4NDc3Mw==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "a = None\nprint(bool(a))  # False\nprint(type(a))\t#<class 'NoneType'>\n"}, {"ctype": "p", "data": "五、列表 list 列表就是队列，是各种数据类型的集合，也是一种数据结构，且是一种有序的，内容可重复的集合类型。 列表中的元素存在于一个[]中"}, {"ctype": "code", "data": "names_01 = list(['xiaomi','xixi','shaishai'])\nnames_02 = ['xiaomi','xixi','shaishai']\nprint(type(names_02),type(names_01))  # <class 'list'> <class 'list'>\n"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328211317240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk4NDc3Mw==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " 读取  新增  修改  删除 六、列表 tuple 元祖和列表很相似，但是元祖比列表占用资源更小，元祖不可变，列表为可变   七、字典 dict 字典是由多个建（key）及其对应的值（value）所组成的一种数据类型；key支持字符串，数字和元祖类型，但列表是不支持的。value支持所有python的数据类型。 字典中的每一个key一定是唯一的 "}, {"ctype": "code", "data": "person = {'name': 'xixi','age': '2'}\nnum = {1:'one',(1,2,3):[1,2,3]}\ndict_array = [{1:1,2:2},{'one':1}]\ndict_array = ({1:1,2:2},{'one':1})\n"}, {"ctype": "head", "data": "内置函数"}, {"ctype": "p", "data": "一、内置函数 id 返回变量的内存地址，每一次复制都会生成一个内存地址"}, {"ctype": "code", "data": "name = 'yanmai'\nnew_name = name\nprint(id(name))   # 140282428483600\nprint(id(new_name))   # 140282428486785\n"}, {"ctype": "p", "data": "二、内置函数 len 返回字符串的长度，无法返回数字类型的长度，因为数字类型没有长度"}, {"ctype": "code", "data": "name = 'yanmai'\naddress = \"深圳\"\nnum = '12'\no = 1\nprint(len(name))  # 6\nprint(len(address))  # 2\nprint(len(num))  # 2\nprint(len(o))  # TypeError: object of type 'int' has no len()\n"}, {"ctype": "p", "data": "三、内置函数 type 可以使用type返回数据的类型"}, {"ctype": "code", "data": "age = 18\nnum = 3.88\nprint(type(age))  # 输出结果 <class 'int'>\nprint(type(num))  # 输出结果 <class 'floatt'>\n"}, {"ctype": "p", "data": "四、内置函数 in/not in 用来判断你的数据中是否存在你想要的成员，如果为真，结果返回True，如果假，结果返回False"}, {"ctype": "code", "data": "print(max('今天是3月28日！'))\ninfo = 'python 是一个有魅力的语言'\nresult = '魅力' in info\nprint(result)       # True\nresult = '语言' not in info\nprint(result)\t\t#  False\n"}, {"ctype": "p", "data": "五、内置函数 max 返回数据中最大的成员 中文符号>字母>数字>英文字符 中文按照拼音的首字母来计算"}, {"ctype": "code", "data": "print(max('今天是3月28日!')) # 月\n"}, {"ctype": "p", "data": "六、内置函数 in 返回数据中最大的成员 中文符号>字母>数字>英文字符 中文按照拼音的首字母来计算"}, {"ctype": "code", "data": "print(min('今天是3月28日!')) # !\n"}], "cate": "Python"}
{"题目": "Jupyter-阿里云jupyter部署到本地并在本地浏览器打开", "作者": "戏命师。", "发布时间": "2021-03-28 20:58:03", "内容": [{"ctype": "p", "data": "提出问题： 阿里云是win版本，我想在本地部署阿里云juoyter服务器"}, {"ctype": "p", "data": "解决问题 1.首先要安装anaconda 2.然后生成JN的配置文件（阿里云的cmd端口实现）"}, {"ctype": "code", "data": "1.jupyter notebook --generate-config\n"}, {"ctype": "p", "data": "3.设置远成访问代码（阿里云的cmd端口实现）"}, {"ctype": "code", "data": "1.ipython #打开ipython\n2.from notebook.auth import passwd\n3.passwd() #生成密码\n"}, {"ctype": "p", "data": "运行以上代码，输入两遍远程访问的密码，就会生成哈希值，它本身不是密码，但这个值后面要用到 4.修改 JN 配置文件："}, {"ctype": "code", "data": "vi ~/.jupyter/jupyter_notebook_config.py\n"}, {"ctype": "p", "data": "用 文本编辑器打开第一步生成的配置文件，然后添加下列内容："}, {"ctype": "code", "data": "1.c.NotebookApp.ip='*'  \n2.c.NotebookApp.password = u'密码哈希值'\n3.c.NotebookApp.open_browser = False\n4.c.NotebookApp.port =8888 #随便指定一个端口\n\n"}, {"ctype": "p", "data": "（注：这里的ip设置为私有ip，注意是私有ip哦 在vim ~/.jupyter/jupyter_notebook_config.py里面的ip是私网ip，在浏览器输入的ip是公网ip！！！！！！）"}, {"ctype": "p", "data": "注意："}, {"ctype": "p", "data": "在 JN 某次更新之后，"}, {"ctype": "code", "data": "1.c.NotebookApp.ip='*'\n"}, {"ctype": "p", "data": "需改为"}, {"ctype": "code", "data": "c.NotebookApp.ip='0.0.0.0'\n\n"}, {"ctype": "p", "data": "另外，根据指定的端口和后面运行 JN 时的提示，记得把阿里云端的防火墙端口打开。（关闭防火墙好像是cmd输入ufw disable） （这块的注意第一次配置时候并没有用到，可能是更新之后需要这样改）"}, {"ctype": "p", "data": "5.打开阿里云的8888端口 修改jupyter_notebook文件之后发现一个错误： OSError: [Errno 99] Cannot assign requested address，这时需要打开8888端口"}, {"ctype": "p", "data": "（1） "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328205407621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzEyMzIy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "（2）  进去后点击回到旧版  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328205531930.png"}, {"ctype": "p", "data": "6.在阿里云cmd里，运行jupyter.(之前没有操作这步，导致我在本地浏览器输入http://xxxx:8888的时候，被拒绝访问)"}, {"ctype": "code", "data": "jupyter notebook --ip=0.0.0.0 --allow-root\n"}, {"ctype": "p", "data": "7.然后在浏览器输入"}, {"ctype": "code", "data": "http://xxxx:8888(xxxx是你的公网ip)\n"}, {"ctype": "p", "data": "需要输入密码就可以了"}], "cate": "Python"}
{"题目": "利用神经网络识别12306验证码——（二）收集文字验证码图片", "作者": "jay_wonder", "发布时间": "2021-03-28 21:50:52", "内容": [{"ctype": "p", "data": "惊喜.jpg——给大家分享一份我整理的粗糙的数据集 网盘链接 提取码：n51k 这部分数据样本有点少，拿去训练的话准确率比较低，只能达到50%左右。 12306验证码图片包含两部分，一部分是上边的文字，一部分是下面的图片 对于文字部分，可以直接从上面的验证码图片抠出来。所以，先爬个几千张验证码图片，程序如下。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328204345888.jpg#pic_center"}, {"ctype": "code", "data": "import requests\nimport base64\nimport time\nimport random\nimport os\n\npath = 'D:/captcha/'\nos.mkdir(path)  #创建文件夹\nsleep_lst = [0.5, 0.8, 0.7, 0.6, 1, 1.5, 2]\ncap_url = 'https://kyfw.12306.cn/passport/captcha/captcha-image64'\nfor i in range(1, 5001):\n    response = requests.get(cap_url)\n    if response.status_code == 200:\n        json = response.json()\n        img = json['image']\n        img = base64.b64decode(img)\n        picture_name = str(i) + '.jpg'\n        with open(path + picture_name, 'wb') as f:\n            f.write(img)\n    time.sleep(random.choice(sleep_lst))\n"}, {"ctype": "p", "data": "图片下载好之后，就可以开始抠文字了，文字部分也有两种情况：1、一个词，2、两个词；根据区域长度来判断是哪种情况。程序如下"}, {"ctype": "code", "data": "from PIL import Image\nimport numpy as np\nimport os\nimport shutil\n\n#判断文字部分词的数量\ndef judge_image_bk(raw_image):\n    if isinstance(raw_image, str):\n        raw_image = Image.open(raw_image)\n    try:\n        image = raw_image.crop((118, 0, 230, 28))\n    except:\n        return\n    image = image.convert('P')\n    image_array = np.asarray(image)\n\n    image_array = image_array[24:28]\n    if np.mean(image_array) > 200:\n        return 1\n    else:\n        return 2\n\n#把文字抠出来\ndef split_image_text(raw_image, image_shape, name, mode=1):\n    if isinstance(raw_image, str):\n        raw_image = Image.open(raw_image)\n\n    image = raw_image.crop((118, 0, 230, 28))\n    res = []\n    if mode == 1:\n        image_array = np.asarray(image)\n        image_array = image_array[6:22]\n        image_array = np.mean(image_array, axis=2)\n        image_array = np.mean(image_array, axis=0)\n        image_array = np.reshape(image_array, [-1])\n        indices = np.where(image_array < 240)\n        res.append([indices[0][0], indices[0][-1]])\n\n    if mode == 2:\n        image_p = image.convert('P')\n        image_array = np.asarray(image_p)\n        image_array = image_array[6:22]\n        image_array = np.mean(image_array, axis=0)\n        avg_image = np.reshape(image_array, [-1])\n        indices = np.where(avg_image < 190)\n        start = indices[0][0] - 1\n        end = indices[0][0] - 1\n        for i in indices[0]:\n            if i == end + 1:\n                end = i\n            else:\n                if end - start > 10:\n                    res.append([start+1, end])\n                start = i\n                end = i\n        if end - start > 10:\n            res.append([start+1, end])\n    text = [image.crop((x1, 0, x2, 28)).resize(image_shape) for x1, x2 in res]\n    \n    if len(text) == 1:\n        text[0].save(path + str(name) + '.jpg')\n    else:\n        text[0].save(path + str(name[0]) + '.jpg')\n        text[1].save(path + str(name[1]) + '.jpg')\n    \n#在抠文字之前，先创建一个文件夹，保存结果.文件夹路径可根据自己的情况更改\npath = 'D:/text_captcha/'\nos.mkdir(path)\n\nitems = os.listdir('D:/captcha')  #获取前面下载的5000张验证码图片\ncount = 0\nfor item in items:\n    count += 1\n    try:\n        mode = judge_image_bk('D:/captcha/' + item)\n        print(mode)\n        name = count if mode == 1 else [count, count+1]\n        count = count if mode == 1 else count + 1\n        split_image_text('D:/captcha/' + item, (64, 64), name, mode)\n    except:\n        print('图片错误：', item)\n"}, {"ctype": "p", "data": "不出意外的话，文字图片已经抠出来了。下图是我标注过的文字图片部分。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328225027602.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pheV93b25kZXI=,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "重点来了，抠下来的图片是不知道对应的标签的，所以又得进行人工标注了。。。 祝各位开心标注！如果不想自己标注，可以联系我，但是这个不能免费提供噢，实在是花了我不少时间，请理解！！！"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328214158759.jpg#pic_center"}], "cate": "Python"}
{"题目": "Python爬虫学习 - 从零开始 9 (爬取慕课网免费课程清单 - 练习使用 bs4 和 xlwings）", "作者": "Alice", "发布时间": "2021-03-28 00:42:44", "内容": [{"ctype": "p", "data": "更新日期: 2021.03.28"}, {"ctype": "p", "data": "已经学习的内容："}, {"ctype": "p", "data": "爬取网页：掌握 requests 的常用方法。解析代码：掌握 bs4 的常用方法并建立常用解析方法清单, 掌握 re 的常用方法。保存信息：txt，Excel (使用 xlwings 库) 。"}, {"ctype": "p", "data": "本节学习内容 ："}, {"ctype": "p", "data": "练习使用 bs4 和 xlwings - 爬取慕课网免费课程清单并存为 Excel 文件。"}, {"ctype": "head", "data": "1. 目标信息"}, {"ctype": "p", "data": "2020.03.28日 慕课网免费课程清单有20个网页, 每页有40个课程, 点击课程的链接可进一步获取课程的难度和时长等信息。"}, {"ctype": "head", "data": "2. 爬取步骤"}, {"ctype": "head", "data": "3. 代码"}, {"ctype": "p", "data": "学习了几种爬虫工具，然后做小练习，已经预计到会遇到问题，没想到…那么多…"}, {"ctype": "p", "data": "大部分是因为自己的粗心，小部分是真的不知道…"}, {"ctype": "code", "data": "import requests\nfrom requests.exceptions import RequestException\nfrom bs4 import BeautifulSoup\nimport re\nimport time\nimport random\nimport xlwings as xw\n\nheaders={'User Agent': 'replace with your header'}\ncourse_names, course_links =[], []\n\n\n# 获取一个网页的代码\ndef get_one_page(url):\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200: # 检查状态是否正常，只有\"200\"代码表示正常状态\n            html = response.text\n            return html\n        else:\n            print(\"Failed to get website codes due to status_code nok\")\n    except RequestException:\n        print(\"Exception found when get website codes, maybe no more link to be worked on~\")\n\n\ndef fetch_info():\n    wb = xw.Book()\n    sheet = wb.sheets.active\n    # 依次打开19个课程清单页面，获取课程名称及链接，并存储在列表中\n    for list_page_num in range(1, 20):\n        url = \"https://www.imooc.com/course/list?page=\"+str(list_page_num)\n        time.sleep(random.uniform(1.0, 1.1))\n        soup = BeautifulSoup(get_one_page(url), 'lxml')\n        tags = soup.find_all(class_=\"item free\")\n        for tag in tags:\n            course_names.append(tag[\"data-title\"])\n            course_links.append(\"https:\" + tag[\"href\"])\n        if list_page_num % 3 == 0:\n            print(\"Received \" + str(list_page_num) + \" pages course names & links\")\n\n    # 将列表中的课程名称及链接存储到文件中\n    sheet.range(\"A1\").options(transpose=True).value = course_names\n    sheet.range('B1').options(transpose=True).value = course_links\n    print(\"Completed ---\" + str(list_page_num) + \" names & links saved into file 'a20210327_imooc_course_info.xlsx'\")\n\n\n    # 从 B 列获取每个课程页面的链接，然后依次打开页面，获取具体信息\n    for i in range(1, len(course_links)+1):\n        soup = BeautifulSoup(get_one_page(sheet.range(\"B\"+str(i)).value), 'lxml')\n        time.sleep(random.uniform(1.0, 1.1))\n\n        sheet.range(\"C\" + str(i)).value = soup.find(\"span\", string=re.compile(\"难度\")).next_sibling.string\n        sheet.range(\"D\" + str(i)).value = soup.find(\"span\", string=re.compile(\"时长\")).next_sibling.string\n        sheet.range(\"E\" + str(i)).value = soup.find(\"span\", string=re.compile(\"综合评分\")).next_sibling.string\n        sheet.range(\"F\" + str(i)).value = soup.find(class_=\"path-split\").next_sibling.string\n        sheet.range(\"G\" + str(i)).value = soup.find(class_=\"path-split\").next_sibling.next_sibling.next_sibling.next_sibling.string\n        sheet.range(\"H\" + str(i)).value = soup.find(\"span\", class_=\"tit\").next_element.next_element.string\n        sheet.range(\"I\" + str(i)).value = soup.find(\"span\", class_=\"job\").string\n        sheet.range(\"J\" + str(i)).value = soup.find(\"div\", class_=\"course-description course-wrap\").string\n        if i % 3 ==0:\n            print(\"Saved \" + str(i) + \" records into file 'a20210327_imooc_course_info.xlsx'\")\n    print(\"Completed --- Saved \" + str(i) + \" records into file 'a20210327_imooc_course_info.xlsx'\")\n    wb.save(\"a20210327_imooc_course_info.xlsx\")\n    wb.close()\n\nif __name__ == '__main__':\n    fetch_info()\n"}, {"ctype": "head", "data": "5. 几个想法~~"}, {"ctype": "p", "data": "对上面的代码有几个想法，以后再实现~"}], "cate": "Python"}
{"题目": "高级编程和编程规范总结", "作者": "wakeyo", "发布时间": "2021-03-28 00:10:15", "内容": [{"ctype": "head", "data": "高级编程和编程规范总结"}, {"ctype": "head", "data": "1. 可迭代对象"}, {"ctype": "p", "data": "对list、tuple、dict、set、str等类型的数据使用for…in…的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫迭代。把可以通过for…in…这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象（Iterable）。"}, {"ctype": "head", "data": "2. 推导式"}, {"ctype": "p", "data": "推导式语法"}, {"ctype": "code", "data": "ls = ['chenny','amy','body','heading','粒子']   #列表\ndef fun(ls):\n    ls_1 = []  # 定义一个空列表\n    for i in ls:          #遍历列表\n        if len(i) > 3:    #条件判断，判断ls中字符串长度是否>3\n            ls_1.append(i)    #将符合条件的字符串添加到新列表ls_1\n    print(ls_1)\nfun(ls)\n#推导式\nls_2 = [i for i in ls if len(i)>3]\nprint(ls_2)\n"}, {"ctype": "code", "data": "#需求：求1-100之间的整数\nls_3 = [i for i in range(1,101) if i % 2 == 0]\nprint(ls_3)\n\n#需求：求1-100之间的整数,且还能被4整除的数\nls_4 = [i for i in range(1,101) if i % 2 == 0 and i % 4 == 0 ]\nprint(ls_4)\n"}, {"ctype": "head", "data": "3.生成器"}, {"ctype": "p", "data": "创建生成器的方式"}, {"ctype": "p", "data": "使用类似列表推导式的方法得到生成器"}, {"ctype": "code", "data": "#方法一：使用类似列表推导式的方法得到生成器\n\n#获得1-10之间数*2\nls = [i*2 for i in range(1,11)]\nprint(ls)\n\n#不希望一次性得到太多的数据，需要时要多少数据就能够获得多少数据\ngen = (i*2 for i in range(1,11))\nprint(gen,type(gen))\nprint(gen.__next__())\n#通过next函数来获取\ni = 1\nwhile i < 10:\n    print(next(gen))\n    i += 1\n\n"}, {"ctype": "p", "data": "使用函数+yield来实现"}, {"ctype": "code", "data": "#方法二：使用函数+yield来实现\ndef fun():\n    i = 0\n    while True:\n        i += 1\n        yield i       #生成器yield\n\nr = fun()\nprint(r)\nprint(next(r))   #按生成的顺序依次往下取\nprint(next(r))\n\n"}, {"ctype": "p", "data": "只要在函数中出现yield关键字它就是一个生成器函数"}, {"ctype": "p", "data": "生成器的特性"}, {"ctype": "p", "data": "生成器会记住上一次取数据的位置，然后下一次取数据时继续从上一次的位置运行\\生成器生成一次数据，当第一次生成的数据取完就会结束生命周期，第二次去取就没有数据了"}, {"ctype": "code", "data": "#生成器的特性：1.生成器会记住上一次取数据的位置，然后下一次取数据时继续从上一次的位置运行\\\n#            2.生成器生成一次数据，当第一次生成的数据取完就会结束生命周期，第二次去取就没有数据了\ngen = (i*2 for i in range(1,11))\nprint(gen,type(gen))\nls = [i for i in gen]   #第一次取生成器里的数据\nls_1 = [i for i in gen]  #第二次取生成器里的数据\nprint(ls)\nprint(ls_1)\n"}, {"ctype": "head", "data": "4. 迭代器"}, {"ctype": "code", "data": "#迭代器\nclass Test():     #创建一个类\n    def __init__(self,data=1):    #定义一个方法\n        self.data = data\n\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.data > 5:\n            raise StopIteration     #扔出错误\n        else:\n            self.data += 1\n            return self.data\nfor item in Test(3):\n    print(item)\n"}, {"ctype": "code", "data": "ls = [1,2,3,4,5,6]\nls_1 = (1,2,3,4,5,6)\nite1 = iter(ls)\nite2 = iter(ls_1)\nprint(ite1)\nprint(ite2)\n"}, {"ctype": "head", "data": "5. 规范编写代码"}, {"ctype": "p", "data": "缩进使用4个空格, 空格是首选的缩进方式. Python3 不允许混合使用制表符和空格来缩进.每一行最大长度限制在79个字符以内.顶层函数、类的定义, 前后使用两个空行隔开.import 导入"}, {"ctype": "code", "data": "import os\nimport sys\n"}, {"ctype": "code", "data": "import os,sys\n"}, {"ctype": "code", "data": "from subprocess import Popen, PIPE\n"}, {"ctype": "p", "data": " 导包位于文件顶部, 在模块注释、文档字符串之后, 全局变量、常量之前. 导入按照以下顺序分组: 标准库导入 相关第三方导入 本地应用/库导入 在每一组导入之间加入空行  Python 中定义字符串使用双引号、单引号是相同的, 尽量保持使用同一方式定义字符串. 当一个字符串包含单引号或者双引号时, 在最外层使用不同的符号来避免使用反斜杠转义, 从而提高可读性.  表达式和语句中的空格 "}, {"ctype": "code", "data": "if foo == 'blah': do_blah_thing()\nfor x in lst: total += x\nwhile t < 10: t = delay()\n"}, {"ctype": "p", "data": " 永远不要使用字母 ‘l’(小写的L), ‘O’(大写的O), 或者 ‘I’(大写的I) 作为单字符变量名. 在有些字体里, 这些字符无法和数字0和1区分, 如果想用 ‘l’, 用 ‘L’ 代替.  类名一般使用首字母大写的约定.  函数名应该小写, 如果想提高可读性可以用下划线分隔.  如果函数的参数名和已有的关键词冲突, 在最后加单一下划线比缩写或随意拼写更好. 因此 class_ 比 clss 更好.(也许最好用同义词来避免这种冲突).  方法名和实例变量使用下划线分割的小写单词, 以提 高可读性. "}, {"ctype": "head", "data": "6. 练习"}, {"ctype": "p", "data": "请使用装饰器实现已存在的函数的执行所花费的时间。 • time模块"}, {"ctype": "code", "data": "# 1. 请使用装饰器实现已存在的函数的执行所花费的时间。\n# • time模块\nimport time      #导包\n\ndef fun_1(fn):        #定义外层函数\n    def new_fun(*args,**kwargs):     #定义内层内层函数，不定长参数\n        print('程序开始')\n        fn(*args,**kwargs)\n        print('程序结束')\n    return new_fun\n\n@fun_1   #生成器的语法糖写法\ndef fun(a):\n    t1 = time.time()  # 获取开始时间\n    for i in range(1,a):\n        print('{:@^15}'.format(i))\n    t2 = time.time()  # 获取结束时间\n    m = t2 - t1  # 计算时间差\n    print(f'整个程序耗时：{m}s')\n\nn = eval(input(\"请输入尽可能大的任意整数：\"))\nfun(n)\n"}, {"ctype": "head", "data": "总结"}, {"ctype": "p", "data": "本文为学习笔记，转载请标明出处，本文仅供交流学习，请勿用于非法途径，希望本文对大家有帮助。"}, {"ctype": "p", "data": "仅是个人意见，如有不足之处或者侵权，请留言"}], "cate": "Python"}
{"题目": "我用Python + PAGE(Tkinter GUI) + pandas做了个企查查导出模板转机器人模板的小工具", "作者": "水墨熊猫", "发布时间": "2021-03-28 21:33:16", "内容": [{"ctype": "head", "data": "产品需求"}, {"ctype": "p", "data": "企查查导出的Excel文件是这样的  客户的机器人软件需要导入的模板是这样的  简单说就是要做个小工具将企查查导出的Excel通过pandas分析整理后按照客户给出的模板表头生成新的Excel文件。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327235607489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Ymlu,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "效果图"}, {"ctype": "head", "data": "成品效果图"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328211157440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Ymlu,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "PAGE Gui效果图"}, {"ctype": "code", "data": "statusbar = tk.Label(root, text=\"技术支持：山东中达物联科技有限公司 18678709906\", bd=1, relief=tk.SUNKEN, anchor=tk.W)\nstatusbar.pack(side=tk.BOTTOM, fill=tk.X)\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328000352943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Ymlu,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "代码实现"}, {"ctype": "p", "data": "项目简单，都写到main.py一个文件里了，代码如下："}, {"ctype": "code", "data": "import os\n# import sys\nimport platform\nimport subprocess\nimport pandas as pd\nimport tkinter as tk\nfrom tkinter import filedialog\nfrom tkinter import messagebox\n\noutput_file_name = '导出客户模板.xlsx'\ndesktop_path = os.path.join(os.path.expanduser('~'), \"Desktop\")\n\n\n# system_os = platform.system()\n\n\n# 导入文件\ndef set_upload_file():\n    # askopenfilename 1次上传1个；askopenfilenames1次上传多个\n    select_file = filedialog.askopenfilename(\n        filetypes=[('Excel 文件', '*.xls;*.xlsx'), ('Excel 文件', '*.xlsx'), ('Excel 97-2003文件', '*.xls')])\n    file_path.set(select_file)\n\n\n# 企查查电话排序\ndef qcc_sort(arr):\n    arr1 = []\n    arr2 = []\n    for v in arr:\n        if v.find('1') == 0:\n            arr1.append(v)\n        elif v.find('0') == 0:\n            arr2.append(v)\n    return arr1 + arr2\n\n\n# 设置导出路径\ndef set_output_path():\n    path = filedialog.askdirectory()\n    output_path.set(path + os.sep + output_file_name)\n\n\n# 导出文件\ndef output_file(file, product, output):\n    # pass\n    # file_path = r'./file/企查查导出.xls'\n    try:\n        df = pd.read_excel(file, header=1)\n    except Exception as e:\n        messagebox.showerror('打开转换文件失败', f'打开转换文件失败，请检查文件是否无误{e}')\n    else:\n        df_out = pd.DataFrame()\n        check_col = {'法定代表人', '电话', '更多电话', '企业名称', '企业地址', '经营范围'}\n        if check_col.issubset(df.columns) == False:\n            messagebox.showwarning('文件错误', '该转换文件不是标准的企查查导出表格，请检查后重新导入')\n        else:\n            df_out['客户名称'] = df['法定代表人']\n            df_out['phones'] = df['电话'] + '；' + df['更多电话']\n            df_out['手机'] = ''\n            df_out['手机2'] = ''\n            df_out['公司名称'] = ''\n            df_out['所属工号'] = ''\n            df_out['手机3'] = ''\n            df_out['备注'] = ''\n            df_out['手机4'] = ''\n            df_out['手机5'] = ''\n            df_out['手机6'] = ''\n            df_out['微电同号'] = ''\n            df_out['修改电话'] = ''\n            df_out['手机7'] = ''\n            df_out['介绍电话1'] = ''\n            df_out['介绍电话2'] = ''\n            df_out['有效电话'] = ''\n            df_out['产品'] = product\n            df_out['单位'] = df['企业名称']\n            df_out['地址'] = df['企业地址']\n            df_out['经营范围'] = df['经营范围']\n            df_out['phones'] = df_out['phones'].str.replace('；-', '')\n            df_out['phones'] = df_out['phones'].str.replace('-', '')\n            # 遍历列\n            for index, row in df_out.iterrows():\n                phones = row['phones'].split('；')\n                # 倒叙排列 固话在手机号后边\n                # phones.sort(reverse=True)\n                # print(phones)\n                phones = qcc_sort(phones)\n                # print(phones)\n                i = len(phones)\n                for phone in phones:\n                    if i >= 1:\n                        row['手机'] = phones[0]\n                    if i >= 2:\n                        row['手机2'] = phones[1]\n                    if i >= 3:\n                        row['手机3'] = phones[2]\n                    if i >= 4:\n                        row['手机4'] = phones[3]\n                    if i >= 5:\n                        row['手机5'] = phones[4]\n                    if i >= 6:\n                        row['手机6'] = phones[5]\n                    if i >= 7:\n                        row['手机7'] = phones[6]\n\n            # 删除临时列并导出\n            df_out = df_out.drop('phones', axis=1)\n            try:\n                df_out.to_excel(output, index=False)\n            except Exception as e:\n                messagebox.showerror('保存文件失败', f'保存表格文件失败，请确认文件是否被打开!\\n 详细错误信息：错误号-{e.errno} [{e.strerror}]')\n            else:\n                messagebox.showinfo('保存成功', '保存文件成功,点击确定打开文件')\n                if platform.system() == 'Windows':\n                    os.startfile(output)\n                elif platform.system() == 'Linux':\n                    subprocess.call([\"xdg-open\", output])\n                elif platform.system() == 'Darwin':\n                    subprocess.call([\"open\", output])\n\n\nwindow = tk.Tk()\n# 获取桌面路径\noutput_path = tk.StringVar()\nfile_path = tk.StringVar()\nproduct = tk.StringVar()\noutput_path.set(desktop_path + os.sep + output_file_name)\nwindow.title('企查查专用通讯录模板转换程序')\n\nlable_product = tk.Label(window)\nlable_product.place(x=80, y=90, height=23, width=66)\nlable_product.configure(text='''产品标识：''')\n\ntxt_product = tk.Entry(window)\ntxt_product.place(x=160, y=90, height=27, width=284)\ntxt_product.configure(textvariable=product)\n\nbtn_file = tk.Button(window)\nbtn_file.place(x=70, y=140, height=28, width=69)\nbtn_file.configure(text='''转换文件''')\nbtn_file.configure(command=set_upload_file)\n\ntxt_file_path = tk.Entry(window)\ntxt_file_path.place(x=160, y=140, height=27, width=284)\ntxt_file_path.configure(textvariable=file_path)\n\nbtn_setpath = tk.Button(window)\nbtn_setpath.place(x=70, y=200, height=28, width=69)\nbtn_setpath.configure(text='''保存为''')\nbtn_setpath.configure(command=set_output_path)\n\ntxt_output_path = tk.Entry(window)\ntxt_output_path.place(x=160, y=200, height=27, width=284)\ntxt_output_path.configure(textvariable=output_path)\n\n\nbtn_output = tk.Button(window)\nbtn_output.place(x=190, y=290, height=38, width=109)\nbtn_output.configure(text='''导出转换表格''')\nbtn_output.configure(command=lambda : output_file(txt_file_path.get(), txt_product.get(), txt_output_path.get()))\n\nstatusbar = tk.Label(window, text=\"技术支持：山东中达物联科技有限公司 18678709906（同微信）\", bd=1, relief=tk.SUNKEN, anchor=tk.W)\nstatusbar.pack(side=tk.BOTTOM, fill=tk.X)\n'''\n# 这部分是没有用 PAGE Gui实现的，第一次写，有很多不足\nfrm = tk.Frame(window)\nfrm.grid(padx='20', pady='30')\nlable_product = tk.Label(frm, text=\"产品标识：\")\nlable_product.grid(row=0, column=0, ipadx='3', ipady='3', padx='10', pady='5')\ntxt_product = tk.Entry(frm, width='40', textvariable=product)\ntxt_product.grid(row=0, column=1)\n\nbtn_file = tk.Button(frm, text='转换文件', command=set_upload_file)\nbtn_file.grid(row=1, column=0, ipadx='3', ipady='3', padx='10', pady='20')\ntxt_file_path = tk.Entry(frm, width='40', textvariable=file_path)\ntxt_file_path.grid(row=1, column=1)\n\nbtn_setpath = tk.Button(frm, text='保存为', command=set_output_path)\nbtn_setpath.grid(row=2, column=0, ipadx='3', ipady='3', padx='10', pady='20')\ntxt_output_path = tk.Entry(frm, width='40', textvariable=output_path)\ntxt_output_path.grid(row=2, column=1)\n\nbtn_output = tk.Button(window, text=\"导出转换表格\", command=lambda : output_file(txt_file_path.get(), txt_product.get(), txt_output_path.get()))\nbtn_output.grid(row=2, column=0)\n\nstatus_bar_frame = tk.Frame(window, bg=\"#dfdfdf\")\nstatus_bar_frame.grid(row=3, column=0, columnspan=2, sticky=\"we\")\nstatus_bar = tk.Label(status_bar_frame, text=\"技术支持：济宁小墨匠智能科技有限公司 18678709906\", bg=\"#dfdfdf\")\nstatus_bar.pack()\n'''\n\n# 窗口居中于屏幕\nscreen_width = window.winfo_screenwidth()\nscreen_height = window.winfo_screenheight()\nw = 520\nh = 390\nx = (screen_width - w) / 2\ny = (screen_height - h) / 2\n\nwindow.geometry(\"%dx%d+%d+%d\" % (w, h, x, y))\n\nwindow.mainloop()\n\n# pyinstaller 打包：pyinstaller -i icon.ico -w -F main.py\n"}, {"ctype": "head", "data": "项目总结"}, {"ctype": "head", "data": "遇到的一些坑"}, {"ctype": "head", "data": "python读写excel文件的库依赖问题"}, {"ctype": "p", "data": "虽然只import了pandas，但是执行pd.read_excel的时候还是需要依赖xlrd模块，如果是xls文件还需要依赖openpyxl模块。不然会有报错。  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328211024132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Ymlu,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "打包的若干问题"}, {"ctype": "head", "data": "问题1：win10下打包在win7下无法打开"}, {"ctype": "p", "data": "原因分析： 很可能的原因是我打包的环境是Python3.9 64位，查了一下3.9是不支持win7的，还有就是64位机器打包的exe在32位机器上可能会打不开（没有测试）。 如果提示api-ms-win-core-path-l1-1-0.dll 丢失，十有八九是C++环境的问题，安装 Visual C++ Redistributable for Visual Studio 2015 就能解决。"}, {"ctype": "p", "data": " 如果出现下图的报错就是python3.9不支持win7造成的，在python3.8及以下虚拟环境下重新打包解决。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328212659619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Ymlu,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "解决方案： 下载安装python3.8 32位，创建python3.8的虚拟环境，重新打包"}, {"ctype": "head", "data": "问题2：pyinstaller打包太大"}, {"ctype": "p", "data": "一定要在虚拟环境下打包！一定要在虚拟环境下打包！一定要在虚拟环境下打包！ 开始打包的时候没有在虚拟环境下，打完包居然100多M，还运行报错，直接懵掉了。至于虚拟环境，pycharm自带的虚拟环境功能就挺好用。"}, {"ctype": "head", "data": "扩展"}, {"ctype": "head", "data": "资源下载"}, {"ctype": "p", "data": "PAGE - Python Tkinter GUI 可视化生成软件"}, {"ctype": "p", "data": "ActiveTcl"}, {"ctype": "head", "data": "Tkinter 文档/教程"}, {"ctype": "p", "data": "Graphical User Interfaces with Tk Tkinter Tutorial Python GUI编程(Tkinter)"}], "cate": "Python"}
{"题目": "Python计算机视觉编程--第一章", "作者": "fishbb0406", "发布时间": "2021-03-28 23:19:27", "内容": [{"ctype": "head", "data": "一.读入一副图片"}, {"ctype": "p", "data": "PIL (Python Imaging Library)图像库提供了很多常用的图像处理及很多有用的图像基本操作。"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": "# -*- coding: utf-8 -*-\nfrom PIL import Image\nfrom pylab import *\n\n# 添加中文字体支持\nfrom matplotlib.font_manager import FontProperties\nfont = FontProperties(fname=r\"c:\\windows\\fonts\\SimSun.ttc\", size=14)\nfigure()\n\npil_im = Image.open('C:/Users/PC/Desktop/Python/tuzi.jpg')\ngray()\nsubplot(121)\ntitle(u'原图',fontproperties=font)\naxis('off')\nimshow(pil_im)\n\npil_im = Image.open('C:/Users/PC/Desktop/Python/tuzi.jpg').convert('L')\nsubplot(122)\ntitle(u'灰度图',fontproperties=font)\naxis('off')\nimshow(pil_im)\n\nshow()\n\n"}, {"ctype": "p", "data": "2.结果： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210308232332997.png"}, {"ctype": "head", "data": "二.图像轮廓和直方图"}, {"ctype": "p", "data": "在画图像轮廓前需要转换为灰度图像，因为轮廓需要获取每个坐标[x,y]位置的像素值。"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": " # -*- coding: utf-8 -*-\nfrom PIL import Image\nfrom pylab import *\n\n# 添加中文字体支持\nfrom matplotlib.font_manager import FontProperties\nfont = FontProperties(fname=r\"c:\\windows\\fonts\\SimSun.ttc\", size=14)\nim = array(Image.open('C:/Users/PC/Desktop/Python/tuzi.jpg').convert('L'))  # 打开图像，并转成灰度图像\n\nfigure()\nsubplot(121)\ngray()\ncontour(im, origin='image')\naxis('equal')\naxis('off')\ntitle(u'图像轮廓', fontproperties=font)\n\nsubplot(122)\nhist(im.flatten(), 128)\ntitle(u'图像直方图', fontproperties=font)\nplt.xlim([0,260])\nplt.ylim([0,11000])\n\nshow()\n"}, {"ctype": "p", "data": "2.结果： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210308232807155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hiYjA0MDY=,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "三.直方图均衡化"}, {"ctype": "p", "data": "图像均衡化作为预处理操作，在归一化图像强度时是一个很好的方式，并且通过直方图均衡化可以增加图像对比度。"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": " # -*- coding: utf-8 -*-\n\n\nfrom PIL import Image\nfrom pylab import *\nfrom PCV.tools import imtools\n\n# 添加中文字体支持\nfrom matplotlib.font_manager import FontProperties\nfont = FontProperties(fname=r\"c:\\windows\\fonts\\SimSun.ttc\", size=14)\n\nim = array(Image.open('E:\\\\Python计算机视觉实验\\\\第一章\\\\tuzi.jpg').convert('L'))  # 打开图像，并转成灰度图像\n#im = array(Image.open('../data/AquaTermi_lowcontrast.JPG').convert('L'))\nim2, cdf = imtools.histeq(im)\n\nfigure()\nsubplot(2, 2, 1)\naxis('off')\ngray()\ntitle(u'原始图像', fontproperties=font)\nimshow(im)\n\nsubplot(2, 2, 2)\naxis('off')\ntitle(u'直方图均衡化后的图像', fontproperties=font)\nimshow(im2)\n\nsubplot(2, 2, 3)\naxis('off')\ntitle(u'原始直方图', fontproperties=font)\n#hist(im.flatten(), 128, cumulative=True, normed=True)\nhist(im.flatten(), 128 )\n\nsubplot(2, 2, 4)\naxis('off')\ntitle(u'均衡化后的直方图', fontproperties=font)\n#hist(im2.flatten(), 128, cumulative=True, normed=True)\nhist(im2.flatten(), 128,)\n\nshow()\n"}, {"ctype": "p", "data": "2.结果： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327224237302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hiYjA0MDY=,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "四.图像模糊"}, {"ctype": "p", "data": "代码："}, {"ctype": "code", "data": "from PIL import Image\nfrom numpy import *\nfrom scipy.ndimage import filters\nfrom pylab import *\n\nif __name__=='__main__':\n    im = array(Image.open('E:\\\\Python计算机视觉实验\\\\第一章\\\\tuzi.jpg').convert('L'))\n    gray()\n    subplot(1,4,1)\n    axis('off')\n    title('Original Image')\n    imshow(im)\n\n    for bi, blur in enumerate([2, 5, 10]):\n        im2 = zeros(im.shape)\n        im2 = filters.gaussian_filter(im, blur)\n        im2 = np.uint8(im2)\n        imNum = str(blur)\n        subplot(1, 4, 2 + bi)\n        axis('off')\n        title('GaussVar = ' + imNum)\n        imshow(im2)\n    show()\n\n"}, {"ctype": "p", "data": "结果： "}, {"ctype": "head", "data": "五–实验遇到的问题"}, {"ctype": "p", "data": "1.安装PCV库的方法和步骤"}, {"ctype": "p", "data": "下载PCV库文件数据，下载地址：https://github.com/jesolem/PCV 将下载的文件解压 打开cmd，执行如下指令： （1）执行cd命令，转到你所解压到的PCV的文件夹中。 （2）输入python setup.py install。 （3）重启命令行，输入pip install pcv ，接着输入python import PCV，如果没有报错，则说明PCV库安装成功。"}, {"ctype": "p", "data": "如图所示： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327233741790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hiYjA0MDY=,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "2.文件夹下的文件夹下的py文件如何导入"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327234113846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hiYjA0MDY=,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "3.画直方图的hist()函数运行不过去"}, {"ctype": "p", "data": "书上的代码版本太老，画直方图的hist()函数的normed参数被取消了，删除normed参数，运行通过。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327234707585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hiYjA0MDY=,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "PyQt5+Pycharm的安装", "作者": "酡颜～", "发布时间": "2021-03-28 21:03:43", "内容": [{"ctype": "head", "data": "PyQt5的安装"}, {"ctype": "p", "data": "安装PyQt5"}, {"ctype": "code", "data": "pip install PyQt5 -i https://pypi.douban.com/simple\n"}, {"ctype": "p", "data": "安装PyQt5-tools"}, {"ctype": "code", "data": "pip install PyQt5-tools -i https://pypi.douban.com/simple\n"}, {"ctype": "p", "data": "使用pip install命令 安装完PyQt,PyQt-tools之后，会在E:\\Program Files\\python\\Lib\\site-packages目录下看到安装包PyQt5,PyQt5-tools。"}, {"ctype": "p", "data": " 安装目录可以在这里找到  为了让windows系统正确的识别PyQt5-tools的常用命令，还需要把PyQt5-tools的安装目录添加到系统环境变量path中。 我的电脑（右键）——属性——高级系统设置——高级，单击环境变量按钮，在系统变量path中添加以下变量值 E:\\Program Files\\python\\Lib\\site-packages\\pyqt5_tools（这是博主的安装目录）"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210324223250715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3MDYzOQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " 注意，三个确定一定都要点！ 然后在Windows命令窗口中输入path。如果成功，则会在所返回的路径中看到PyQt5-tools的安装路径  最后测试环境是否安装成功，运行以下代码"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210324225030777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3MDYzOQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import sys \t\nfrom PyQt5 import QtWidgets \napp = QtWidgets.QApplication(sys.argv)\nwidget = QtWidgets.QWidget()\nwidget.resize(360, 360)\nwidget.setWindowTitle(\"hello, pyqt5\")\nwidget.show()\nsys.exit(app.exec_())\n\n"}, {"ctype": "p", "data": "出现如下所示的窗口界面，说明环境安装成功  第一次发文章，如果有错误的地方请多多指教"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328210050973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3MDYzOQ==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "《Python金融大数据风控建模实战》 第16章 支持向量机模型", "作者": "小成星际", "发布时间": "2021-03-28 11:35:13", "内容": [{"ctype": "head", "data": "本章引言"}, {"ctype": "p", "data": "在感知机模型中得到的超平面不是唯一的，每一次参数的更新都是向着分类错误的样本更近一些，直到完全分类正确为止。因此，虽然感知器模型在训练集上表现优异，但训练集中的“顽固样本”稍微增加一些噪声就会错误分类，导致在测试集上的表现很不理想。而支持向量机模型在训练集上得到了较好的表现，同时进一步提高了模型的泛化能力，并得到了唯一的最优超平面。 支持向量机由简单到复杂分为以下三种："}, {"ctype": "p", "data": " 线性可分支持向量机 样本是线性可分，如感知器模型可以解决的问题。此时，对应的最大间隔类型为硬间隔最大化，即分类超平面要严格满足每个样本都分类正确。  线性支持向量机 当样本近似线性可分，引入松弛因子，可以得到一个线性分类器，如线性可分的样本中增加一些错分的噪声数据。对应的最大间隔类型为软间隔最大化，即战略性地将那些噪声数据放弃，得到一个对于大部分样本都可以正确分类的超平面。这里所说的样本近似线性可分，是通过放弃某些线性不可分的样本后，大部分样本都是线性可分的，这时依然采用线性超平面做分隔，如果不放弃那些线性不可分的样本，就是一个非线性问题。  非线性支持向量机 当样本非线性可分时，即使引入松弛因子也不能得到一个近似线性可分的结果时，采用核技术进行特征映射，在高维空间采用软间隔最大化方法得到一个非线性模型，如感知器模型解决不了的异或问题。对应的最大间隔类型为核映射+软间隔最大化。这里所说的样本非线性是在第二种情况中，当非线性样本更多时，我们无法放弃大部分样本而得到一个线性的超平面，所以这里采用核函数的方法进行空间转化，得到一个线性或近似线性的结果，然后再采用线性支持向量机的方法得到超平面。 "}, {"ctype": "p", "data": "在实际应用中很少有线性问题，因此支持向量机模型应用最多的就是第三种模型。"}, {"ctype": "head", "data": "Python代码实现及注释"}, {"ctype": "code", "data": "# 第16章：SVM模型\n\nimport os\nimport sys\n#path = __file__\n#path = os.path.abspath(path + ((os.sep + '..') * 2))\n#sys.path.append(path)\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nimport variable_encode as var_encode\nimport numbers\nfrom sklearn.metrics import confusion_matrix,recall_score, auc, roc_curve,precision_score,accuracy_score\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import LinearSVC,SVC\nfrom sklearn.metrics import precision_recall_curve\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['font.sans-serif']=['SimHei']   # 用黑体显示中文\nmatplotlib.rcParams['axes.unicode_minus']=False     # 正常显示负号\nimport warnings\nwarnings.filterwarnings(\"ignore\") ##忽略警告\n\n##数据读取\ndef data_read(data_path,file_name):\n    df = pd.read_csv( os.path.join(data_path, file_name), delim_whitespace = True, header = None )\n    ##变量重命名\n    columns = ['status_account','duration','credit_history','purpose', 'amount',\n               'svaing_account', 'present_emp', 'income_rate', 'personal_status',\n               'other_debtors', 'residence_info', 'property', 'age',\n               'inst_plans', 'housing', 'num_credits',\n               'job', 'dependents', 'telephone', 'foreign_worker', 'target']\n    df.columns = columns\n    ##将标签变量由状态1,2转为0,1;0表示好用户，1表示坏用户\n    df.target = df.target - 1\n      ##数据分为data_train和 data_test两部分，训练集用于得到编码函数，验证集用已知的编码规则对验证集编码\n    data_train, data_test = train_test_split(df, test_size=0.2, random_state=100,stratify=df.target)\n    return data_train, data_test\n##离散变量与连续变量区分   \ndef category_continue_separation(df,feature_names):\n    categorical_var = []\n    numerical_var = []\n    if 'target' in feature_names:\n        feature_names.remove('target')\n    ##先判断类型，如果是int或float就直接作为连续变量\n    numerical_var = list(df[feature_names].select_dtypes(include=['int','float','int32','float32','int64','float64']).columns.values)\n    categorical_var = [x for x in feature_names if x not in numerical_var]\n    return categorical_var,numerical_var\nif __name__ == '__main__':\n    path = 'D:\\\\code\\\\chapter17'\n    data_path = os.path.join(path ,'data')\n    file_name = 'german.csv'\n    ##读取数据\n    data_train, data_test = data_read(data_path,file_name)\n    sum(data_train.target ==0)\n    data_train.target.sum()\n    ##区分离散变量与连续变量\n    feature_names = list(data_train.columns)\n    feature_names.remove('target')\n    categorical_var,numerical_var = category_continue_separation(data_train,feature_names)\n    \n    ###离散变量直接WOE编码\n    var_all_bin = list(data_train.columns)\n    var_all_bin.remove('target')\n    ##训练集WOE编码\n    df_train_woe, dict_woe_map, dict_iv_values ,var_woe_name = var_encode.woe_encode(data_train,data_path,categorical_var, data_train.target,'dict_woe_map', flag='train')\n    ##测试集WOE编码\n    df_test_woe, var_woe_name = var_encode.woe_encode(data_test,data_path,categorical_var, data_test.target, 'dict_woe_map',flag='test')\n    \n    #####连续变量缺失值做填补\n    for i in numerical_var:\n        if sum(data_train[i].isnull()) >0:\n            data_train[i].fillna(data_train[i].mean(),inplace=True)\n        if sum(data_test[i].isnull()) >0:\n            data_test[i].fillna(data_test[i].mean(),inplace=True)\n\n    ###组成分箱后的训练集与测试集\n    data_train.reset_index(drop=True,inplace=True)\n    data_test.reset_index(drop=True,inplace=True)\n    var_1 = numerical_var\n    var_1.append('target')\n    data_train_1 = pd.concat([df_train_woe[var_woe_name],data_train[var_1]],axis=1)\n    data_test_1 = pd.concat([df_test_woe[var_woe_name],data_test[var_1]],axis=1) \n    \n    ####取出训练数据与测试数据\n    var_all = list(data_train_1.columns)\n    var_all.remove('target')\n    ####变量归一化\n    scaler = StandardScaler().fit(data_train_1[var_all])\n    data_train_1[var_all] = scaler.transform(data_train_1[var_all])  \n    data_test_1[var_all] = scaler.transform(data_test_1[var_all])\n    \n    x_train = np.array(data_train_1[var_all])\n    y_train = np.array(data_train_1.target)\n    \n    x_test = np.array(data_test_1[var_all])\n    y_test = np.array(data_test_1.target)\n        \n   \n    ########线性支持向量机模型\n    ##设置待优化的超参数\n    lin_svm_param = {'C': np.arange(0.1,5,0.1),\n                'class_weight': [{1: 1, 0: 1}, {1: 2, 0: 1}, {1: 3, 0: 1}]  }\n    ##初始化网格搜索\n    lin_svm_gsearch = GridSearchCV(estimator=LinearSVC(),param_grid=lin_svm_param, \n                  cv=3, scoring='roc_auc', n_jobs=-1, verbose=2)\n    ##执行超参数优化\n    lin_svm_gsearch.fit(x_train, y_train)\n    print('linearSVC model best_score_ is {0},and best_params_ is {1}'.format(lin_svm_gsearch.best_score_,\n                                                                             lin_svm_gsearch.best_params_))\n    \n    ##用最优参数，初始化模型\n    lin_svm_model = LinearSVC(C = lin_svm_gsearch.best_params_['C'],\n                                    class_weight=lin_svm_gsearch.best_params_['class_weight'])\n    ##模型训练\n    lin_svm_model_fit = lin_svm_model.fit(x_train, y_train)\n    \n    \n    ##模型预测\n    y_pred = lin_svm_model_fit.predict(x_test)\n    ##计算混淆矩阵与recall、precision\n    cnf_matrix = confusion_matrix(y_test, y_pred)\n    recall_value = recall_score(y_test, y_pred)\n    precision_value = precision_score(y_test, y_pred)\n    acc = accuracy_score(y_test, y_pred)\n    print(cnf_matrix)\n    print('Validation set:  model recall is {0},and percision is {1}'.format(recall_value,\n                 precision_value)) \n    \n   \n    #########非线性支持向量机模型\n    ##设置待优化的超参数\n    svm_param = {'C': np.arange(0.1,5,0.1),\n                 'gamma':np.arange(0.01,10,1),\n                'class_weight': [{1: 1, 0: 1}, {1: 2, 0: 1}, {1: 3, 0: 1}]  }\n    ##初始化网格搜索\n    svm_gsearch = GridSearchCV(estimator=SVC(kernel='rbf'),param_grid=svm_param, \n                  cv=3, scoring='roc_auc', n_jobs=-1, verbose=2)\n    ##执行超参数优化\n    svm_gsearch.fit(x_train, y_train)\n    print('DecisionTreeClassifier model best_score_ is {0},and best_params_ is {1}'.format(svm_gsearch.best_score_,\n                                                                             svm_gsearch.best_params_))\n    \n    ##用最优参数，初始化模型\n    svm_model = SVC(kernel='rbf',C =svm_gsearch.best_params_['C'],gamma=svm_gsearch.best_params_['gamma'],\n                                    class_weight=svm_gsearch.best_params_['class_weight'],probability=True)\n     ##模型训练\n    svm_model_fit = svm_model.fit(x_train, y_train)\n    \n     ##模型预测\n    y_pred = svm_model_fit.predict(x_test)\n    ##计算混淆矩阵与recall、precision\n    cnf_matrix = confusion_matrix(y_test, y_pred)\n    recall_value = recall_score(y_test, y_pred)\n    precision_value = precision_score(y_test, y_pred)\n    acc = accuracy_score(y_test, y_pred)\n    print(cnf_matrix)\n    print('Validation set:  model recall is {0},and percision is {1}'.format(recall_value,\n                 precision_value))\n    \n    ##给出概率预测结果\n    y_score_test = svm_model_fit.predict_proba(x_test)[:, 1]\n    ##计算AR。gini等\n    fpr, tpr, thresholds = roc_curve(y_test, y_score_test)\n    roc_auc = auc(fpr, tpr)\n    ks = max(tpr - fpr)\n    ar = 2*roc_auc-1\n    print('test set:  model AR is {0},and ks is {1},auc={2}'.format(ar,\n                 ks,roc_auc)) \n    ####ks曲线\n    plt.figure(figsize=(10,6))\n    fontsize_1 = 12\n    plt.plot(np.linspace(0,1,len(tpr)),tpr,'--',color='black')\n    plt.plot(np.linspace(0,1,len(tpr)),fpr,':',color='black')\n    plt.plot(np.linspace(0,1,len(tpr)),tpr - fpr,'-',color='grey')\n    plt.grid()\n    plt.xticks( fontsize=fontsize_1)\n    plt.yticks( fontsize=fontsize_1)\n    plt.xlabel('概率分组',fontsize=fontsize_1)\n    plt.ylabel('累积占比%',fontsize=fontsize_1)\n\n"}], "cate": "Python"}
{"题目": "LeetCode刷题日记2021-3-27/61.旋转链表", "作者": "在努力的路上1024", "发布时间": "2021-03-27 09:14:10", "内容": [{"ctype": "p", "data": "仅供自己学习记录"}, {"ctype": "head", "data": "Leetcode每日一题 2021-3-27"}, {"ctype": "p", "data": "给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。"}, {"ctype": "p", "data": "示例 1："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327083852886.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjI1NzQ2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3]"}, {"ctype": "p", "data": "示例 2："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327083819140.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjI1NzQ2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "输入：head = [0,1,2], k = 4 输出：[2,0,1]"}, {"ctype": "head", "data": "解题思路来自负雪明烛大佬"}, {"ctype": "head", "data": "解题思路："}, {"ctype": "p", "data": "将链表的每个节点向右移动K个位置，相当于把链表后k%len个节点移动到链表最前端"}, {"ctype": "p", "data": "1.求出链表长度 定义cur指针指向头节点，计数器 2.找出倒数k+1个节点 定义快慢两个指针fast，slow指向头部 先将fast向后移动k个节点 此时fast跟slow相距k个节点 fast指向第k+1个节点 当fast.next存在时 fast跟slow同时后移 当fast指向尾部时 slow.next为倒数第k个节点"}, {"ctype": "p", "data": "3.链表重整：将链表倒数第k+1个节点和倒数第k个节点断开，并且把后半部分拼接到头部 将slow.next指向为空 fast.next指向头部"}, {"ctype": "p", "data": "题解代码如下："}, {"ctype": "p", "data": "Definition for singly-linked list. class ListNode: def init(self, val=0, next=None): self.val = val self.next = next class Solution: def rotateRight(self, head: ListNode, k: int) -> ListNode: #链表为空或者为单节点 if not head or not head.next: return head len=0 cur=head #计算链表长度 while cur: len+=1 cur=cur.next #计算向右移动步长 k%=len if k==0: return head #定义快慢指针且快指针先走K%len步 fast,slow=head,head while k: fast=fast.next k-=1 while fast.next: slow=slow.next fast=fast.next #慢指针此时所对应的节点正为尾节点且慢指针的下个节点正是新链表的头节点快指针下个节点对应节点为头节点 newhead=slow.next slow.next=None fast.next=head return newhead"}], "cate": "Python"}
{"题目": "【pytorch】unet网络结构分析及代码实现", "作者": "Xavier Jiezou", "发布时间": "2021-03-28 12:56:45", "内容": [{"ctype": "head", "data": "原始论文"}, {"ctype": "head", "data": "网络结构"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327133051736.png#pic_center"}, {"ctype": "head", "data": "注意事项"}, {"ctype": "p", "data": "论文中进行卷积操作的时候没有用padding，导致卷积后图片尺寸变小。推荐可能是当年padding操作并不流行。我们这里复现的时候用了padding，保持卷积后图片尺寸不变。输入给网络是什么尺寸的图像，那么输出也将是一样的尺寸。比如输入64 x 64的图像，那么输出也将是64 x 64。论文中并没有用到Batch Normalization。推测是当时需要作医学图像分割的数据集很小，不需要用。我们这里复现的时候加上。论文中提到的跳层连接，推测应该是使用torch.cat()进行通道数合并。"}, {"ctype": "head", "data": "实现思路"}, {"ctype": "p", "data": "首先将网络结构中出现次数较多的两个蓝色箭头（Conv+Relu）进行封装。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328003004702.png#pic_center"}, {"ctype": "code", "data": "class DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, 3, 1, 1),\n            nn.BatchNorm2d(out_channels),\n            nn.ReLU(),\n            nn.Conv2d(out_channels, out_channels, 3, 1, 1),\n            nn.BatchNorm2d(out_channels),\n            nn.ReLU()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n"}, {"ctype": "p", "data": "然后将整个网络结构分为左、中、右三部分，具体划分方式如下：  左边由4个下采样（Pooling）和4个双卷积组成；中间一个双卷积；右边是4个上采样（反卷积）和4个双卷积，最后接一个1 x 1的卷积输出。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328125254220.png#pic_center"}, {"ctype": "head", "data": "完整代码"}, {"ctype": "code", "data": "import torch\nimport torch.nn as nn\n\n\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, 3, 1, 1),\n            nn.BatchNorm2d(out_channels),\n            nn.ReLU(),\n            nn.Conv2d(out_channels, out_channels, 3, 1, 1),\n            nn.BatchNorm2d(out_channels),\n            nn.ReLU()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\n\nclass UNet(nn.Module):\n    def __init__(self):\n        super().__init__()\n        # left\n        self.left_conv_1 = DoubleConv(3, 64)\n        self.down_1 = nn.MaxPool2d(2, 2)\n\n        self.left_conv_2 = DoubleConv(64, 128)\n        self.down_2 = nn.MaxPool2d(2, 2)\n\n        self.left_conv_3 = DoubleConv(128, 256)\n        self.down_3 = nn.MaxPool2d(2, 2)\n\n        self.left_conv_4 = DoubleConv(256, 512)\n        self.down_4 = nn.MaxPool2d(2, 2)\n\n        # center\n        self.center_conv = DoubleConv(512, 1024)\n\n        # right\n        self.up_1 = nn.ConvTranspose2d(1024, 512, 2, 2)\n        self.right_conv_1 = DoubleConv(1024, 512)\n\n        self.up_2 = nn.ConvTranspose2d(512, 256, 2, 2)\n        self.right_conv_2 = DoubleConv(512, 256)\n\n        self.up_3 = nn.ConvTranspose2d(256, 128, 2, 2)\n        self.right_conv_3 = DoubleConv(256, 128)\n\n        self.up_4 = nn.ConvTranspose2d(128, 64, 2, 2)\n        self.right_conv_4 = DoubleConv(128, 64)\n\n        # output\n        self.output = nn.Conv2d(64, 3, 1, 1, 0)\n\n    def forward(self, x):\n        # left\n        x1 = self.left_conv_1(x)\n        x1_down = self.down_1(x1)\n\n        x2 = self.left_conv_2(x1_down)\n        x2_down = self.down_2(x2)\n\n        x3 = self.left_conv_3(x2_down)\n        x3_down = self.down_3(x3)\n\n        x4 = self.left_conv_4(x3_down)\n        x4_down = self.down_4(x4)\n\n        # center\n        x5 = self.center_conv(x4_down)\n\n        # right\n        x6_up = self.up_1(x5)\n        temp = torch.cat((x6_up, x4), dim=1)\n        x6 = self.right_conv_1(temp)\n\n        x7_up = self.up_2(x6)\n        temp = torch.cat((x7_up, x3), dim=1)\n        x7 = self.right_conv_2(temp)\n\n        x8_up = self.up_3(x7)\n        temp = torch.cat((x8_up, x2), dim=1)\n        x8 = self.right_conv_3(temp)\n\n        x9_up = self.up_4(x8)\n        temp = torch.cat((x9_up, x1), dim=1)\n        x9 = self.right_conv_4(temp)\n\n        # output\n        output = self.output(x9)\n\n        return output\n"}, {"ctype": "head", "data": "测试一下"}, {"ctype": "p", "data": "如果代码实现如果任何问题，那么网络的输出维度和输入维度应该是一样的。"}, {"ctype": "code", "data": "if __name__ == \"__main__\":\n    a = torch.rand(10, 3, 32, 32)\n    model = UNet()\n    b = model(a)\n    print(b.size())  # torch.Size([10, 3, 32, 32])\n"}, {"ctype": "head", "data": "引用参考"}], "cate": "Python"}
{"题目": "【Python】【教程】Python的安装，新手友善型说明", "作者": "题桥十三", "发布时间": "2021-03-27 17:00:46", "内容": [{"ctype": "head", "data": "获取安装文件"}, {"ctype": "head", "data": "找到官网"}, {"ctype": "p", "data": "百度python，跳过一堆广告，找到python的官网，打开它："}, {"ctype": "p", "data": " 然后点击下载： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327171652948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "下载安装文件"}, {"ctype": "p", "data": "点开以后，直接下载最新版本3.9.2（时间：2021.03.26）："}, {"ctype": "p", "data": " 下载完成后，就看到了安装文件："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164740726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164812992.png"}, {"ctype": "head", "data": "执行安装"}, {"ctype": "p", "data": "打开安装程序，选择自定义："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164911651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "接下来这一步全选就行："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164923348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "可以选择为所有用户安装（标记1），其他的我们目前都可以先不管，也就是勾选前三个就行。之后把标记2处的路径更改得简单一点。接下来点install："}, {"ctype": "p", "data": " 完成！"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165229779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165335968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "请开始享受您的编程之旅！"}, {"ctype": "head", "data": "安装后的说明"}, {"ctype": "p", "data": "安装完成后，可以在Python的目录下看到这么4个程序：  下面针对他们给出说明："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165455517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "IDLE"}, {"ctype": "p", "data": "IDLE,Integrated Development and Learning Environment，集成开发和学习环境，是Python的集成开发环境 ，已与该语言的默认实现捆绑在一起。它完全用Python和Tkinter GUI工具包编写（ Tcl / Tk的 包装函数）。（https://baike.baidu.com/item/Idle/3823402） 打开以后就可以直接进行编程，这种方式很适合新手："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165559954.png"}, {"ctype": "head", "data": "Python"}, {"ctype": "p", "data": "第二个是python的应用程序，用的比较少，如果你看上了它的简洁界面，想用它直接编程，为什么不选择同样原生简洁且功能更完善的IDLE？"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165618184.png"}, {"ctype": "head", "data": "Manuals"}, {"ctype": "p", "data": "第三个，使用手册，说明书："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165647306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "来自官方的最权威的说明书！如果对自己的英文有自信，可以尝试对其进行深入研究。"}, {"ctype": "head", "data": "Module Docs"}, {"ctype": "p", "data": "最后一个，模块说明："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327165656367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODY2NTg2,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "滴滴出行2020数据分析面试题", "作者": "pengzhijun888", "发布时间": "2021-03-27 18:05:57", "内容": [{"ctype": "head", "data": "数据来源"}, {"ctype": "p", "data": "滴滴国际部2020年2月数据分析实习生笔试题 内容：2018年3月5日-2018年3月11日期间100名巴西乘客的订单基础信息"}, {"ctype": "head", "data": "字段释义"}, {"ctype": "table", "data": "字段中文名称解释order_id订单ID呼叫订单识别号passenger_id乘客ID乘客识别号call_time呼叫时间乘客从应用上发出需要用车的请求的时间点（北京时间）grab_time应答时间司机点击接单的时间点（北京时间）cancel_time取消时间司机或者乘客取消订单的时间（北京时间）finish_time完单时间司机点击到达目的地的时间点（北京时间）"}, {"ctype": "head", "data": "指标释义"}, {"ctype": "table", "data": "指标名称含义统计口径应答率呼叫订单被应答的比例应答订单/呼叫订单完单率呼叫订单被完成率完成订单/呼叫订单呼叫应答时间被应答订单从呼叫到被应答平均时长被应答订单从呼叫到被应答时长总和/被应答订单数量"}, {"ctype": "head", "data": "其他信息"}, {"ctype": "p", "data": "巴西比中国慢11小时"}, {"ctype": "head", "data": "加载包"}, {"ctype": "code", "data": "import numpy as np\nimport pandas as pd\nimport datetime\n"}, {"ctype": "head", "data": "加载数据"}, {"ctype": "code", "data": "data = pd.read_csv('dididata.csv')\ndata.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032717465645.png"}, {"ctype": "head", "data": "数据预处理"}, {"ctype": "code", "data": "# 查看各字段格式\ndata.info()\n"}, {"ctype": "p", "data": " 4个时间数据为object，需要将其改为datetime"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327175107806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "data['call_time'] = pd.to_datetime(data['call_time'])\ndata['grab_time'] = pd.to_datetime(data['grab_time'])\ndata['cancel_time'] = pd.to_datetime(data['cancel_time'])\ndata['finish_time'] = pd.to_datetime(data['finish_time'])\ndata.info()\n"}, {"ctype": "p", "data": " 没有空值，说明未应答、未取消、未完成的订单时间不是以空值存储，检查后发现这些数据是记为1971-01-01 00:00:00 将其替换为空值，便于后续分析"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327175349346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "data.loc[data['grab_time']=='1971-01-01 00:00:00','grab_time']= np.nan\ndata.loc[data['cancel_time']=='1971-01-01 00:00:00','cancel_time'] = np.nan\ndata.loc[data['finish_time']=='1971-01-01 00:00:00','finish_time']= np.nan\ndata.info()\n"}, {"ctype": "p", "data": "巴西比中国慢11小时，将表中北京时间转换为巴西时间"}, {"ctype": "code", "data": "data['call_time']-=datetime.timedelta(hours=11)\ndata['grab_time']-=datetime.timedelta(hours=11)\ndata['cancel_time']-=datetime.timedelta(hours=11)\ndata['finish_time']-=datetime.timedelta(hours=11)\ndata.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327175547288.png"}, {"ctype": "head", "data": "问题"}, {"ctype": "head", "data": "1 订单的应答率、完单率分别是多少？"}, {"ctype": "code", "data": "print('应答率：',data['grab_time'].count()/data['call_time'].count())\nprint('完单率：',data['finish_time'].count()/data['call_time'].count())\n"}, {"ctype": "p", "data": "应答率： 0.7239057239057239 完单率： 0.4713804713804714"}, {"ctype": "head", "data": "2 呼叫应答时间多长？"}, {"ctype": "code", "data": "diff = (data['grab_time']-data['call_time']).sum()/data['grab_time'].count()    # 获取平均时间，得到numpy.timedelta64 纳秒时间差\ndiff = diff / np.timedelta64(1,'m')    # 将 纳秒 转换为 分钟\nprint('呼叫应答时间：',diff,'分钟')\n"}, {"ctype": "p", "data": "呼叫应答时间： 0.7255813953333333 分钟"}, {"ctype": "head", "data": "3 呼叫量最高的是哪一个小时（当地时间）？呼叫量最少的是哪一个小时（当地时间）？"}, {"ctype": "code", "data": "data.groupby(data['call_time'].dt.hour).call_time.count().sort_values(ascending=False)\n"}, {"ctype": "p", "data": "call_time 18 40 20 25 23 21 19 21 14 20 16 18 13 15 9 14 0 14 15 13 12 12 22 10 10 10 21 10 8 9 17 8 7 8 11 8 5 7 6 6 4 3 1 3 3 1 2 1 Name: call_time, dtype: int64 呼叫量最高的是18时，呼叫量最少的是2时和3时。（当地时间）"}, {"ctype": "head", "data": "4 呼叫订单第二天继续呼叫的比例有多少？"}, {"ctype": "head", "data": "（1）按订单数计算"}, {"ctype": "code", "data": "# 新增一列呼叫日期的天数，方便计算\ndata['day'] = data['call_time'].dt.day\n# 将表根据passenger_id进行左连接\ndata2 = data.merge(data,on='passenger_id',how='left')\n# 筛选出第二次呼叫比第一次呼叫晚一天的数据\ndata2 = data2[(data2['day_y']-data2['day_x'])==1]\n# 为避免前一天有多个订单，造成第二天的订单重复计算，对第二天的订单号进行去重\nprint('结果为：',data2.drop_duplicates(subset=['order_id_y']).order_id_x.count() / data.day.count())\n"}, {"ctype": "p", "data": "结果为： 0.32996632996632996"}, {"ctype": "head", "data": "（2）按乘客数计算"}, {"ctype": "code", "data": "# 在连接好的表中，对乘客id进行去重，得到第二天继续呼叫乘客数\nresult = data2.drop_duplicates(subset='passenger_id').passenger_id.count() / data.drop_duplicates(subset='passenger_id').passenger_id.count()\nprint('结果为：',result)\n"}, {"ctype": "p", "data": "结果为： 0.3472222222222222"}, {"ctype": "head", "data": "5 如果要对表中乘客进行分类，你认为需要参考哪一些因素？"}, {"ctype": "p", "data": "基于已有的表格中数据，可以用RFM模型对用户进行分类， R：乘客上一次打车距离3月11日的时间间隔 F：乘客在数据期间的打车频率 M：打车消费金额（表中无打车金额，可以用完成订单总时长代替） "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327175950971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "data['time'] = data['finish_time'] - data['call_time']\n​\nrfm = data.groupby('passenger_id').aggregate({\n    'call_time': max,\n    'order_id': 'count',\n    'time': sum\n})\nrfm.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327180250283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "rfm['R'] = (rfm['call_time'].max() - rfm['call_time'])/np.timedelta64(1,'D')\nrfm['time'] = rfm['time']/np.timedelta64(1,'m')\nrfm.rename(columns={'order_id':'F','time':'M'},inplace=True)\nrfm.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327180323345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "rfm.describe()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327180413608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "def RFM(x):\n    level = x.apply(lambda x:'1' if x>0 else '0')\n    label = level['R']+level['F']+level['M']\n    d = {\n        '011':'重要价值客户',\n        '001':'重要发展客户',\n        '111':'重要保持客户',\n        '101':'重要挽留客户',\n        '010':'一般价值客户',\n        '000':'一般发展客户',\n        '110':'一般保持客户',\n        '100':'一般挽留客户'\n    }\n    result = d[label]\n    return result\nrfm['label'] = rfm[['R','F','M']].apply(lambda x:(x-x.mean())).apply(RFM,axis=1)\nrfm.head()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327180449342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aGlqdW44ODg=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "rfm.groupby(['label']).aggregate({\n    'F':'count',\n    'M':sum\n})\n"}, {"ctype": "p", "data": "一般挽留客户和一般发展客户比较多，都是21人； 重要价值客户有13人，乘车时长远高于其他客户群"}], "cate": "Python"}
{"题目": "django orm实现乐观锁", "作者": "pushiqiang", "发布时间": "2021-03-27 22:36:33", "内容": [{"ctype": "head", "data": "乐观锁"}, {"ctype": "p", "data": "乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。"}, {"ctype": "p", "data": "乐观锁机制采取了更加宽松的加锁机制，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。"}, {"ctype": "p", "data": "乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。"}, {"ctype": "p", "data": "通过版本号控制实现乐观锁 github：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新（即在update的where条件附加version条件判断，eg: update test set name=‘xxx’, version=1 where id=123 and version=0）。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。"}, {"ctype": "p", "data": "django orm model层实现乐观锁："}, {"ctype": "code", "data": "import time\nfrom django.db import models\n\n\nclass OptimisticLockError(Exception):\n    pass\n\n\nclass Model(models.Model):\n    \"\"\"\n    1. 对象字段值变化差异更新 BaseModel（不包含外键对象）\n    2. 版本号version控制实现乐观锁（version字段类型只允许整型或时间戳类型）\n    \"\"\"\n    VERSION_FIELD_NAME = 'version'\n\n    version = models.FloatField(verbose_name='版本号', default=0)\n\n    class Meta:\n        abstract = True\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._init_data = {}\n        self._version = getattr(self, self.VERSION_FIELD_NAME, None)\n        for field in iter(self._meta.fields):\n            self._init_data[field.attname] = getattr(self, field.attname, None)\n\n    def _get_changed_fields(self):\n        _changed_field = [field.attname for field in iter(self._meta.fields)\n                          if getattr(self, field.attname, None) != self._init_data.get(field.attname)]\n        return _changed_field or None\n\n    def save(self, force_insert=False, force_update=False, using=None,\n             update_fields=None):\n        update_fields = update_fields or self._get_changed_fields()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def _prepare_optimistic_lock(self, qs, values):\n        if self._version is not None:\n            qs = qs.filter(**{self.VERSION_FIELD_NAME: self._version})\n            version_field = self._meta.get_field(self.VERSION_FIELD_NAME)\n            # int\n            if isinstance(self._version, int):\n                new_version = self._version + 1\n                values.append((version_field, None, new_version))\n                setattr(self, version_field.attname, new_version)\n            # timestamp: float\n            elif isinstance(self._version, float):\n                new_version = time.time()\n                values.append((version_field, None, new_version))\n                setattr(self, version_field.attname, new_version)\n            else:\n                raise ValueError('Optimistic locking version field type must be `integer` or `float`')\n\n        return qs, values\n\n    def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):\n        base_qs, values = self._prepare_optimistic_lock(base_qs, values)\n        updated = super()._do_update(base_qs, using, pk_val, values, update_fields, forced_update)\n        if update_fields and not updated:\n            raise OptimisticLockError(\"Failed to add optimistic lock for update {}.\".format(self))\n        return updated\n\n"}], "cate": "Python"}
{"题目": "HMM-Viterbi algorithm（Python实现）", "作者": "Zhou zhou ya", "发布时间": "2021-03-28 02:46:35", "内容": [{"ctype": "p", "data": "求解最可能的隐状态序列是HMM的三个典型问题之一，通常用维特比算法解决。维特比算法就是求解HMM上的最短路径（-log(prob)，也即是最大概率）的算法。"}, {"ctype": "p", "data": "算法思路："}, {"ctype": "p", "data": "从状态t到初始状态，需要寻找最短路径，运用逆推递归的方法来寻找这条最短路径。状态t由状态(t-1)直接决定，从状态(t-1)到状态t一定有一条最短路径，问题的求解就变成了求初始状态到状态(t-1)的最短路径。一直逆推到初始状态，问题就变成了求从初始状态到状态1的n条路径，然后找出状态1到状态2的最短的n条路径（实际上会有n*n条路径），一直递归到状态t，从最短的n条路径里寻找真正的最短路径。"}, {"ctype": "p", "data": "该图(图片来源: 通俗易懂讲解HMM（隐马尔可夫模型）)清晰地显示了隐马模型的状态转移过程："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/img_convert/ee92126de2ef6ad1fd0feca7b3d84a74.png"}, {"ctype": "p", "data": "下面展示Viterbi algorithm 的完整代码（Python）。"}, {"ctype": "code", "data": "import numpy as np\n#寻找最短路径（最大概率）函数\ndef maxpossibilitypath(obs,states,start_p,trans_p,emit_p):\n    path = np.zeros((len(states),len(obs))) #存储路径\n    finalpath = np.zeros((len(states),len(obs))) #用于路径的位置更换\n    fp = np.zeros((len(obs))) #输出最终的路径\n    maxp = np.zeros((len(obs),len(states))) #存储第n次的m种路径长度（即概率）\n    max_p = 0 #用于作比较\n    for i in range(len(start_p)): #第一次状态输出 \n        k = obs[0]\n        maxp[0][i] = start_p[i]*emit_p[i][k] #第一次发生状态x的概率\n        path[i][0] = i\n        finalpath[i][0] = i\n    max_p = 0\n    for i in range(len(start_p)): #将各条路径长度（概率）作比较 得出最优路径\n        if (maxp[0][i]>max_p):\n            max_p = maxp[0][i]\n            fp = path[i]           \n#    maxp[0] = max_p\n    for i in range(len(obs)-1):\n        for j in range(len(states)):\n            max_p = 0 \n            for k in range(len(states)):\n                if(maxp[i][k] * trans_p[k][j] * emit_p[j][(obs[i+1])] > max_p): #第i+1次时各路径长度\n                    max_p = maxp[i][k] * trans_p[k][j] * emit_p[j][(obs[i+1])]\n                    maxp[i+1][j] = max_p\n                    path[k][i+1] = j #因为第i+1次继承了第i次的k状态，所以只需在路径k上更改第i+1的值\n                    finalpath[j] = path[k]#赋值给flinalpath是为了让path与maxp的位置对应\n        max_p = 0\n        for l in range(len(states)):\n            if (maxp[i+1][l] > max_p):\n                max_p = maxp[i+1][l]\n                fp = finalpath[l]\n            path[l] = finalpath [l] #因为前一个循环的path修改只对第i+1次做更新，所以需要对path进行更新再做下一次循环，否则会出现错误\n    return(fp)\n#隐状态\nhidden_state = ['rainy', 'sunny']\n#观测序列\nobsevition = ['walk', 'shop', 'clean']\n#隐状态对应的数字\nstate_s = [0, 1]\n#实际观测的序列 walk:0 shop:1 clean:2\nobser = [0,1,2,0,1,2,1,1,1,1,1,0,0,0,2,1,0,1,1,0,2,2,1]\n#初始状态，测试集中，0.6概率观测序列以rainy开始\nstart_probability = [0.6, 0.4]\n#转移概率\ntransititon_probability = np.array([[0.7, 0.3], [0.4, 0.6]])\n#发射概率\nemission_probability = np.array([[0.1, 0.4, 0.5], [0.6, 0.3, 0.1]])\nresult = maxpossibilitypath(obser, state_s, start_probability, transititon_probability, emission_probability)\nprint(result)\nfor k in range(len(result)):\n    d = int(result[k])\n    print(hidden_state[d])\n"}, {"ctype": "p", "data": "天气转移概率矩阵"}, {"ctype": "table", "data": "rainysunnyrainy0.70.3rainy0.40.6"}, {"ctype": "p", "data": "每种天气（隐状态）对应行为（可观测）的概率矩阵"}, {"ctype": "table", "data": "walkshopcleanrainy0.10.40.5rainy0.60.30.1"}, {"ctype": "head", "data": "最终输出结果"}, {"ctype": "p", "data": "[1. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 1. 1. 1. 0. 0. 1. 1. 1. 1. 0. 0. 0.] sunny rainy rainy sunny rainy rainy rainy rainy rainy rainy rainy sunny sunny sunny rainy rainy sunny sunny sunny sunny rainy rainy rainy"}, {"ctype": "p", "data": "初学Python，代码的实现比较笨拙。这也是本人第一次发表文章，有很多纰漏，还望大家多多包涵，谢谢！！！"}], "cate": "Python"}
{"题目": "Python 下载安装和配置", "作者": "IT邦德", "发布时间": "2021-03-28 07:47:41", "内容": [{"ctype": "p", "data": "微信公众号：IT邦德 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032807453860.png"}, {"ctype": "p", "data": " 进入官网 www.python.org/downloads/  下载   安装（和安装一般软件区别不大）  环境变量问题 勾选：“Add Python to environment variable”。 这样就会将 Python 添加到环境变量 Path 中，我们可以在 windows 的命令行模式下运行 Python 解释器。   4.Python 开发环境 开发环境，英文是 IDE（ Integrated Development Environment 集成开发环境 ）不要纠结于使用哪个开发环境，开发环境本质上就是对 Python 解释器 python.exe 的封装，核心都一样。可以说：“开发环境 IDE，只是解释器的一个外挂而已”，只是为了让程序员更加方便编 程，减少出错率，尤其是拼写错误。 常用的开发环境如下： IDLE、Pycharm、wingIDE、Eclipse、IPython  交互模式(脚本 shell 模式) 进入命令行窗口，输入：python  5. IDLE 开发环境使用 IDLE 常用快捷键 Alt+N Alt+P：查看历史命令上一条、下一条 Ctrl+F6：重启 shell，以前定义的变量全部失效 F1：打开帮助文档 Alt+/：自动补全前面曾经出现过的单词 Ctrl + [ Ctrl + ] ：缩进代码和取消缩进 Alt+M ：打开模块代码，先选中模块，然后按下此快捷键，会帮你打开改模块的 py 源码供浏览 Alt+C ：打开类浏览器，方便在源码文件中的各个方法体之间切换 F5：运行程序 "}, {"ctype": "p", "data": "7.第一个 Python 源程序"}, {"ctype": "code", "data": "print(\"a\")\nprint(\"b\")\nprint(\"c\")\n"}, {"ctype": "p", "data": "第一个 Python 程序中需要注意的小要点："}, {"ctype": "p", "data": "不要在程序中，行开头处增加空格。空格在 Python 中有缩进的含义。符号都是英文符号，不是中文。比如：(,”"}], "cate": "Python"}
{"题目": "用Python爬取GDP数据", "作者": "何方圆", "发布时间": "2021-03-28 15:13:45", "内容": [{"ctype": "p", "data": "废话少说，直接上代码，然后再详细介绍构造过程。"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "import urllib.request\nimport re\nimport pandas as pd\nimport time\n\ndef getdata(url):\n    req=urllib.request.Request(url)\n    req.add_header('User-Agent',' Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36')\n    data=urllib.request.urlopen(req).read().decode('utf-8')\n    str1=str(data)\n    pat='''<tr>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)\\(.*?</td>\n                                        <td>.*?</td>\n                                </tr>'''\n    result=re.compile(pat).findall(str1)\n    return result\n       \nif __name__ == '__main__':\n    for i in range(1968,2020):\n        print('正在收集第%d年数据'%i)\n        rank=[]\n        country=[]\n        zhou=[]\n        total=[]\n        url='https://www.kuaiyilicai.com/stats/global/yearly/g_gdp/'+str(i)+'.html'\n        data=getdata(url)\n        for j in range(0,len(data)):\n            rank.append(data[j][0])\n            country.append(data[j][1])\n            zhou.append(data[j][2])\n            total.append(data[j][3])\n        dataframe = pd.DataFrame({ '排名': rank, '国家/地区': country, '所在洲': zhou, 'GDP(美元计)': total})\n        dataframe.to_csv(str(i)+\"年世界gdp排名.csv\", index=False, sep=',', encoding=\"utf_8_sig\", mode=\"a+\")\n        print(i,'年数据收集完成')\n        time.sleep(2)\n"}, {"ctype": "p", "data": " "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328145304662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcyMzcwNQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "Step1:确定网址"}, {"ctype": "p", "data": "数据爬取的是世界各国GDP数据，解析网页信息并解码。"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "req=urllib.request.Request(url)\ndata=urllib.request.urlopen(req).read().decode('utf-8')\n"}, {"ctype": "head", "data": "Step2:反爬机制"}, {"ctype": "p", "data": "有些网站需要定义反爬机制。"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "req.add_header('User-Agent',' Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36')\n"}, {"ctype": "p", "data": "有关User-Agent的知识可参考Python爬虫：将User-Agent添加进网页请求头。"}, {"ctype": "head", "data": "Step3:正则式匹配"}, {"ctype": "p", "data": "打开源数据网页，查看源代码，确定爬取数据的位置。见下图：  则爬取的位置是："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328150512581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcyMzcwNQ==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "code", "data": " <tr>\n                                    <td>2</td>\n                                    <td>中国</td>\n                                    <td>亚洲</td>\n                                    <td>2019</td>\n                                    <td>14.34万亿 (14,342,903,006,431)</td>\n                                        <td>16.3362%</td>\n                                </tr>\n"}, {"ctype": "p", "data": "确定正则匹配式："}, {"ctype": "code", "data": "<tr>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)\\(.*?</td>\n                                        <td>.*?</td>\n                                </tr>\n"}, {"ctype": "p", "data": "则最后完整的正则匹配式是："}, {"ctype": "code", "data": "    pat='''<tr>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)</td>\n                                    <td>(.*?)\\(.*?</td>\n                                        <td>.*?</td>\n                                </tr>'''\n    result=re.compile(pat).findall(str1)\n"}, {"ctype": "head", "data": "Step4:将爬取数据写入表格并保存"}, {"ctype": "p", "data": "首先导入pandas库。"}, {"ctype": "code", "data": "import pandas as pd\n"}, {"ctype": "p", "data": "写入表格并保存："}, {"ctype": "code", "data": "dataframe = pd.DataFrame({ '排名': rank, '国家/地区': country, '所在洲': zhou, 'GDP(美元计)': total})\ndataframe.to_csv(str(i)+\"年世界gdp排名.csv\", index=False, sep=',', encoding=\"utf_8_sig\", mode=\"a+\")\n"}, {"ctype": "p", "data": "至此所有的步骤都已完成。 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328151251940.gif#pic_center"}], "cate": "Python"}
{"题目": "python的环境管理", "作者": "第五只狗", "发布时间": "2021-03-28 15:39:14", "内容": [{"ctype": "head", "data": "虚拟环境"}, {"ctype": "p", "data": "虚拟环境是一个 Python 环境，安装到其中的 Python 解释器、库和脚本与其他虚拟环境中的内容是隔离的，且（默认）与“系统级” Python（操作系统的一部分）中安装的库是隔离的。"}, {"ctype": "p", "data": "虚拟环境是一个目录树，其中包含 Python 可执行文件和其他文件，其他文件指示了这是一个是虚拟环境。"}, {"ctype": "p", "data": "常用安装工具如 setuptools 和 pip 可以在虚拟环境中按预期工作。换句话说，当虚拟环境被激活，它们就会将 Python 软件包安装到虚拟环境中，无需明确指示。"}, {"ctype": "p", "data": "当虚拟环境被激活（即虚拟环境的 Python 解释器正在运行），属性 sys.prefix 和 sys.exec_prefix 指向的是虚拟环境的基础目录，而 sys.base_prefix 和 sys.base_exec_prefix 指向非虚拟环境的 Python 安装，即曾用于创建虚拟环境的那个 Python 安装。如果虚拟环境没有被激活，则 sys.prefix 与 sys.base_prefix 相同，且 sys.exec_prefix 与 sys.base_exec_prefix 相同（它们均指向非虚拟环境的 Python 安装）。"}, {"ctype": "p", "data": "当虚拟环境被激活，所有 distutils 配置文件中更改安装路径的选项都会被忽略，以防止无意中将项目安装在虚拟环境之外。"}, {"ctype": "p", "data": "在命令行 shell 中工作时，用户可以运行虚拟环境可执行文件目录中的 activate 脚本来激活虚拟环境（调用该文件的确切文件名和命令取决于 shell），这会将虚拟环境的可执行文件目录添加到当前 shell 的 PATH 环境变量。在其他情况下，无需激活虚拟环境。安装到虚拟环境中的脚本有 “shebang” 行，指向虚拟环境的 Python 解释器。这意味着无论 PATH 的值如何，脚本都将与该解释器一起运行。在 Windows 上，如果已安装 Python Launcher for Windows，则支持处理 “shebang” 行（此功能在 Python 3.3 中添加，详情请参阅 PEP 397）。这样，在 Windows 资源管理器中双击已安装的脚本，应该会使用正确的解释器运行该脚本，而在 PATH 中无需指向其虚拟环境。"}, {"ctype": "head", "data": "虚拟环境管理器"}, {"ctype": "head", "data": "virtualenv"}, {"ctype": "head", "data": "virtualenv的安装和使用："}, {"ctype": "p", "data": "安装"}, {"ctype": "code", "data": "pip3 install virtualenv\n"}, {"ctype": "p", "data": "创建虚拟环境"}, {"ctype": "code", "data": "virtualenv envname\n"}, {"ctype": "p", "data": "这个命令创建虚拟环境，会在当前所在目录进行创建 进入虚拟环境后并进行激活"}, {"ctype": "code", "data": "cd scrapy3env\\Scripts\nactivate.bat\n"}, {"ctype": "p", "data": "退出虚拟环境"}, {"ctype": "code", "data": "deactivate.bat\n"}, {"ctype": "head", "data": "虚拟环境的配置"}, {"ctype": "p", "data": "virtualenvwrapper-win可以更方便的配置virtualenv 安装 virtualenvwrapper-win"}, {"ctype": "code", "data": "pip3 install virtualenvwrapper-win\n"}, {"ctype": "p", "data": "使用workon查看是否安装成功 workon是简化操作的命令之一"}, {"ctype": "code", "data": "workon\n"}, {"ctype": "p", "data": "给虚拟环境设置一个专门存放的目录 通过设置WORKON_HOME路径，就给我们的python虚拟环境指定了一个存放位置 可以把之前创建的虚拟环境目录拷贝的WORKON_HOME下"}, {"ctype": "p", "data": "配置之后的常用命令"}, {"ctype": "code", "data": "列出虚拟环境列表：workon\n新建虚拟环境：mkvirtualenv [虚拟环境名称]   ->应该就是make的简写方便理解  \n启动/切换虚拟环境：workon [虚拟环境名称]\n离开虚拟环境：deactivate\n"}, {"ctype": "p", "data": "以上用法已过时，不建议使用。见下"}, {"ctype": "head", "data": "venv"}, {"ctype": "p", "data": "venv 模块支持使用自己的站点目录创建轻量级“虚拟环境”，可选择与系统站点目录隔离。每个虚拟环境都有自己的 Python 二进制文件（与用于创建此环境的二进制文件的版本相匹配），并且可以在其站点目录中拥有自己独立的已安装 Python 软件包集。"}, {"ctype": "head", "data": "创建虚拟环境"}, {"ctype": "p", "data": "通过执行 venv 指令来创建一个 虚拟环境:"}, {"ctype": "code", "data": "python3 -m venv /path/to/new/virtual/environment\n"}, {"ctype": "p", "data": "运行此命令将创建目标目录（父目录若不存在也将创建），并放置一个 pyvenv.cfg 文件在其中，文件中有一个 home 键，它的值指向运行此命令的 Python 安装（目标目录的常用名称是 .venv）。它还会创建一个 bin 子目录（在 Windows 上是 Scripts），其中包含 Python 二进制文件的副本或符号链接（视创建环境时使用的平台或参数而定）。它还会创建一个（初始为空的） lib/pythonX.Y/site-packages 子目录（在 Windows 上是 Lib\\site-packages）。如果指定了一个现有的目录，这个目录就将被重新使用。"}, {"ctype": "p", "data": "3.6 版后已移除: pyvenv 是 Python 3.3 和 3.4 中创建虚拟环境的推荐工具，不过 在 Python 3.6 中已弃用。"}, {"ctype": "p", "data": "在 3.5 版更改: 现在推荐使用 venv 来创建虚拟环境。"}, {"ctype": "p", "data": "在 Windows 上，调用 venv 命令如下:"}, {"ctype": "code", "data": "c:\\>c:\\Python35\\python -m venv c:\\path\\to\\myenv\n"}, {"ctype": "p", "data": "或者，如果已经为 Python 安装 配置好 PATH 和 PATHEXT 变量:"}, {"ctype": "code", "data": "c:\\>python -m venv c:\\path\\to\\myenv\n"}, {"ctype": "p", "data": "本命令如果以 -h 参数运行，将显示可用的选项:"}, {"ctype": "code", "data": "usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]\n            [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps]\n            ENV_DIR [ENV_DIR ...]\n\nCreates virtual Python environments in one or more target directories.\n\npositional arguments:\n  ENV_DIR               A directory to create the environment in.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --system-site-packages\n                        Give the virtual environment access to the system\n                        site-packages dir.\n  --symlinks            Try to use symlinks rather than copies, when symlinks\n                        are not the default for the platform.\n  --copies              Try to use copies rather than symlinks, even when\n                        symlinks are the default for the platform.\n  --clear               Delete the contents of the environment directory if it\n                        already exists, before environment creation.\n  --upgrade             Upgrade the environment directory to use this version\n                        of Python, assuming Python has been upgraded in-place.\n  --without-pip         Skips installing or upgrading pip in the virtual\n                        environment (pip is bootstrapped by default)\n  --prompt PROMPT       Provides an alternative prompt prefix for this\n                        environment.\n  --upgrade-deps        Upgrade core dependencies: pip setuptools to the\n                        latest version in PyPI\n\nOnce an environment has been created, you may wish to activate it, e.g. by\nsourcing an activate script in its bin directory.\n"}, {"ctype": "p", "data": "除非采用 --without-pip 选项，否则将会调用 ensurepip 将 pip 引导到虚拟环境中。"}, {"ctype": "p", "data": "可以向 venv 传入多个路径，此时将根据给定的选项，在所给的每个路径上创建相同的虚拟环境。"}, {"ctype": "p", "data": "创建虚拟环境后，可以使用虚拟环境的二进制目录中的脚本来“激活”该环境。不同平台调用的脚本是不同的（须将 替换为包含虚拟环境的目录路径）："}, {"ctype": "table", "data": "平台Shell用于激活虚拟环境的命令POSIXbash/zsh$ source /bin/activatefish$ source /bin/activate.fishcsh/tcsh$ source /bin/activate.cshPowerShell Core$ /bin/Activate.ps1Windowscmd.exeC:> \\Scripts\\activate.batPowerShellPS C:> \\Scripts\\Activate.ps1"}, {"ctype": "p", "data": "当一个虚拟环境被激活时，VIRTUAL_ENV 环境变量会被设为该虚拟环境的路径。 这可被用来检测程序是否运行在虚拟环境中。"}, {"ctype": "p", "data": "激活环境不是 必须 的，激活只是将虚拟环境的二进制目录添加到搜索路径中，这样 “python” 命令将调用虚拟环境的 Python 解释器，可以运行其中已安装的脚本，而不必输入其完整路径。但是，安装在虚拟环境中的所有脚本都应在不激活的情况下可运行，并自动与虚拟环境的 Python 一起运行。"}, {"ctype": "p", "data": "在 shell 中输入 “deactivate” 可以退出虚拟环境。具体机制取决于不同平台，并且是内部实现（通常使用脚本或 shell 函数）。"}, {"ctype": "head", "data": "安装的virtualenv"}, {"ctype": "p", "data": "如果您使用的是Python 3.3或更高版本，则该venv模块是创建和管理虚拟环境的首选方式。venv包含在Python标准库中，不需要其他安装。如果您使用的是venv，则可以跳过本节。"}, {"ctype": "p", "data": "virtualenv用于管理不同项目的Python软件包。使用virtualenv可以避免在全球安装Python软件包，这可能会破坏系统工具或其他项目。您可以使用pip安装virtualenv。"}, {"ctype": "p", "data": "在macOS和Linux上："}, {"ctype": "code", "data": "python3 -m pip install --user virtualenv\n"}, {"ctype": "p", "data": "在Windows上："}, {"ctype": "code", "data": "py -m pip install --user virtualenv\n"}, {"ctype": "head", "data": "创建虚拟环境"}, {"ctype": "p", "data": "venv（对于Python 3）和virtualenv（对于Python 2）使您可以管理不同项目的单独软件包安装。从本质上讲，它们使您可以创建“虚拟”隔离Python安装并将软件包安装到该虚拟安装中。切换项目时，您可以简单地创建一个新的虚拟环境，而不必担心破坏其他环境中安装的软件包。在开发Python应用程序时，始终建议使用虚拟环境。"}, {"ctype": "p", "data": "要创建虚拟环境，请转到项目目录并运行venv。如果您使用的是Python 2，请 在以下命令中替换venv为virtualenv。"}, {"ctype": "p", "data": "在macOS和Linux上："}, {"ctype": "code", "data": "python3 -m venv env\n"}, {"ctype": "p", "data": "在Windows上："}, {"ctype": "code", "data": "py -m venv env\n"}, {"ctype": "p", "data": "第二个参数是创建虚拟环境的位置。通常，您可以在项目中创建它并调用它env。"}, {"ctype": "p", "data": "venv将在该env文件夹中创建虚拟Python安装。"}, {"ctype": "p", "data": "笔记"}, {"ctype": "p", "data": "您应该使用.gitignore或类似方法将虚拟环境目录从版本控制系统中排除。"}, {"ctype": "head", "data": "激活虚拟环境"}, {"ctype": "p", "data": "您需要先激活它，然后才能开始在虚拟环境中安装或使用软件包。激活虚拟环境将会把虚拟环境的具体 python和pip可执行文件到你的shell PATH。"}, {"ctype": "p", "data": "在macOS和Linux上："}, {"ctype": "code", "data": "source env/bin/activate\n"}, {"ctype": "p", "data": "在Windows上："}, {"ctype": "code", "data": ".\\env\\Scripts\\activate\n"}, {"ctype": "p", "data": "您可以通过检查Python解释器的位置来确认您处于虚拟环境中，该解释器应指向该env目录。"}, {"ctype": "p", "data": "在macOS和Linux上："}, {"ctype": "code", "data": "which python\n.../env/bin/python\n"}, {"ctype": "p", "data": "在Windows上："}, {"ctype": "code", "data": "where python\n.../env/bin/python.exe\n"}, {"ctype": "p", "data": "只要激活了虚拟环境，pip就会将软件包安装到该特定环境中，您将能够在Python应用程序中导入和使用软件包。"}, {"ctype": "head", "data": "离开虚拟环境"}, {"ctype": "p", "data": "如果要切换项目或以其他方式离开虚拟环境，只需运行："}, {"ctype": "code", "data": "deactivate\n"}, {"ctype": "p", "data": "如果要重新进入虚拟环境，请按照上述有关激活虚拟环境的相同说明进行操作。无需重新创建虚拟环境。"}, {"ctype": "head", "data": "conda"}, {"ctype": "head", "data": "conda 的安装和使用"}, {"ctype": "code", "data": "创建虚拟环境\nconda create --name $ENVIRONMENT_NAME\n\n激活环境\nconda activate $ENVIRONMENT_NAME\n\n停止环境\nconda deactivate $ENVIRONMENT_NAME\n\n删除环境\nconda env remove --name $ENVIRONMENT_NAME\n\n导出到环境文件\nconda env export > $FILE_NAME\n\n从一个文件中创建环境\nconda env create -f $FILE_NAME\n\n列出所有环境\nconda info --envs / conda info -e / conda env list \n\n\n下面的代码是一个简单的示意：创建一个名为 py27 的环境，在其中安装 IPython，并执行一行 Python 2.7.x 代码。\nroot@py4fi:~# conda create --name py352 python=3.5.2\n"}, {"ctype": "p", "data": "有时候，你需要与其他人共享环境信息，或者在多台机器上使用环境信息。为此，可 以用 conda env export 将已安装程序包列表导出到一个文件中。这只默认适用于 使用相同操作系统的机器，因为结果 YAML 文件中指定构建版本，但可以将其删掉， 只指定软件包版本。"}, {"ctype": "code", "data": "(py27) root@py4fi:~# conda env export --no-builds > py27env.yml \n(py27) root@py4fi:~# cat py27env.yml\n"}, {"ctype": "p", "data": "从技术上说，虚拟环境不过是一个特定的（子）文件夹结构，创建它们往往是为了进行一 些快速测试。在这种情况下，停止后的环境很容易用 conda env remove 删除。"}, {"ctype": "code", "data": " (py27) root@py4fi:/# conda deactivate\n root@py4fi:~# conda env remove -y --name py27\n"}, {"ctype": "head", "data": "conda软件源管理"}, {"ctype": "p", "data": "法一："}, {"ctype": "p", "data": "查看文件位置：conda config --show-sources"}, {"ctype": "p", "data": ".condarc文件是切换源的文件"}, {"ctype": "code", "data": "channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n  - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n  - defaults\nshow_channel_urls: true\nssl_verify: true\n"}, {"ctype": "p", "data": "法二："}, {"ctype": "p", "data": "添加清华源"}, {"ctype": "code", "data": "conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge \nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/\n# 设置搜索时显示通道地址\nconda config --set show_channel_urls yes\n"}, {"ctype": "p", "data": "注意如果需要pytorch, 还需要添加pytorch的镜像"}, {"ctype": "code", "data": "conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\n"}, {"ctype": "head", "data": "为jupyter notebook添加多版本python内核"}, {"ctype": "p", "data": "一、用conda创建python3.5.2版本虚拟环境"}, {"ctype": "code", "data": "conda create --name py352\n"}, {"ctype": "p", "data": "二、激活进入环境"}, {"ctype": "code", "data": "conda activate py352\n"}, {"ctype": "p", "data": "三、下载ipykernel,通过ipykernel为jupyter添加python3.5.2环境"}, {"ctype": "code", "data": "pip install ipykernel\npython -m ipykernel install --name py352\n"}, {"ctype": "p", "data": "在命令行查看Jupyter Notebook的kernel列表"}, {"ctype": "code", "data": "ipython kernelspec list\n"}, {"ctype": "p", "data": "报错："}, {"ctype": "p", "data": "具体创建了一个新的conda环境，python版本是3.6，当我想把此版本更新到jupyter notebook的内核时（此前已经安装了ipykernel），发现报错："}, {"ctype": "p", "data": "执行python -m ipykernel --version也会报同样的错误。 ImportError: cannot import name ‘AsyncGenerator’"}, {"ctype": "p", "data": "解决办法"}, {"ctype": "p", "data": "将原来的prompt-toolkit-3.0.2版本降为 2.0.10版本："}, {"ctype": "code", "data": "pip install prompt-toolkit==2.0.10\n"}, {"ctype": "p", "data": "问题 Anaconda自动进入虚拟环境base , 我们发现安装完anaconda后 打开terminal会自动进入到base虚拟环境 , 解决办法 执行下面的命令"}, {"ctype": "code", "data": "conda config --set auto_activate_base false\n"}, {"ctype": "p", "data": "PS：常见命令如下"}, {"ctype": "code", "data": "安装ipykernel：\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple ipykernel\n\n\n查看kernel列表：\njupyter kernelspec list\n\n\n删除某个kernel：\njupyter kernelspec remove ts_py36\n\n\n在当前用户环境下安装kernel（如果不加--user，会应用全局，这个选项在多人合作中需要用到）：\npython -m ipykernel install --name ts_py36 --display-name \"py36_tf18\" --user\n\n\n卸载pip\npython3 -m pip uninstall pip setuptools\n\n\n安装新的pip\ncurl https://bootstrap.pypa.io/get-pip.py | python3\n\n"}], "cate": "Python"}
{"题目": "python自动爬取WOS(web of science)文献引用信息及作者h索引", "作者": "pingfanren2", "发布时间": "2021-03-28 17:00:17", "内容": [{"ctype": "head", "data": "背景"}, {"ctype": "p", "data": "前段时间导师有个小目标，把实验室发的文章汇总一下，看看都被谁引用过，其中哪些是大牛，跳出来，给脸上贴金，于是催生了这样一个需求："}, {"ctype": "head", "data": "需求"}, {"ctype": "p", "data": "查找实验室发的文献信息，爬下来每一篇文献的所有施引文献信息，爬下来每一篇施引文献的作者h-index，爬下来"}, {"ctype": "head", "data": "思路"}, {"ctype": "head", "data": "需要四个函数，分别实现以下功能"}, {"ctype": "head", "data": "整体实现思路"}, {"ctype": "p", "data": "搜索结果的网页url传入extract_frame，获取实验室发表文章的所有信息，期中施引文献所在的超链接最关键，因为要找施引文献遍历实验室发表文章，将每一篇文章的施引文献超链接传入extract_frame，得到当前施引文献的所有信息，期中标题所在的超链接最关键，因为要进去看作者遍历所有施引文献，将标题所在的超链接传入到find_author_url，得到所有作者的主页地址和姓名遍历所有作者主页连接，获取当前hindex"}, {"ctype": "head", "data": "结果"}, {"ctype": "p", "data": "ps:现在已经查询到一万三千多行数据，中间断过一次"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328165806700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpbmdmYW5yZW4y,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "隐藏的坑"}, {"ctype": "p", "data": "施引文献为0时没有链接，request发起请求会报错，需要判断有些作者没有主页，这些作者没有daisIds，发起请求会报错，需要判断获取hindex需要构造地址和请求头，这个不同于另外两个函数依然会有中断，186篇文献会有中断，不知名原因，可能网络问题，但是继续执行就没事了"}, {"ctype": "head", "data": "代码"}, {"ctype": "code", "data": "import requests,time,random\nfrom lxml import etree\nfrom urllib import parse\n\n# 全局变量定义\nsearch_records_list = []\nauthor_homepage='https://app.webofknowledge.com/api/wosnx/rrc/author/'\nurl_base = 'https://apps.webofknowledge.com'\nurl_head = {\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.57'\n}\nlog_file_name=f\"log{time.localtime().tm_hour}_{time.localtime().tm_min}_{time.localtime().tm_sec}.txt\"\n\n\ndef log(str):\n    logfile=open(log_file_name,mode='a+',encoding='utf-8')\n    logfile.write(str)\n    print(str, end='')\n    if set(str)!={'\\t'}:\n        logfile.write('\\n')\n        print('\\n',end='')\n    logfile.close()\n\ndef extract_frame(url,list):\n    time.sleep(0.5+random.random())\n    response=session.get(url,headers=url_head)\n    response_html = etree.HTML(response.text)\n    records = response_html.xpath('//div[contains(@id,\"RECORD_\")]')\n    record_dict={}\n    for record in records:\n        record_dict['num_index']=record.xpath('.//div[@class=\"search-results-number-align\"]/text()')[0]\n        record_dict['title_paper'] =record.xpath('.//div[@class=\"search-results-content\"]/div[1]/div[1]/descendant::value/text()')[0]\n        record_dict['title_url'] =url_base+record.xpath('.//div[@class=\"search-results-content\"]/div[1]/div[1]/descendant::a[@class=\"smallV110 snowplow-full-record\"]/@href')[0]\n        timescited=record.xpath('.//div[@class=\"search-results-data-cite\"]/text()')[0]\n        if timescited=='被引频次: 0' or timescited=='Times Cited: 0':#判断如果没有被引频次，则不需要添加施引文献链接，直接返回list，需要按被引频次排序\n            record_dict['cited_number']=0\n            record_dict['cited_url']=None\n        else:\n            record_dict['cited_number'] =record.xpath('.//a[@class=\"snowplow-times-cited-link\"]/text()')[0]\n            record_dict['cited_url'] =url_base+record.xpath('.//a[@class=\"snowplow-times-cited-link\"]/@href')[0]\n        print(f\"{record_dict['num_index']} 《{record_dict['title_paper']}》 Has Been Built Successfully\")\n        list.append(record_dict.copy())\n    nextpage_url=response_html.xpath('//a[contains(@class,\"paginationNext\")]/@href')[0]\n    if not nextpage_url=='javascript: void(\\'paginationNext\\')':#如果存在下一页，则递归下一页\n        extract_frame(nextpage_url,list)\n    return list\n\ndef find_author_url(url):\n    time.sleep(0.5 + random.random())\n    response=session.get(url,headers=url_head)\n    response_html = etree.HTML(response.text)\n    name_list = response_html.xpath('//a[@title=\"Find more records by this author\"]/text()')\n    name_url = response_html.xpath('//a[@title=\"Find more records by this author\"]/@href')\n    name_dict=dict(list(zip(name_list,name_url)))#把姓名和url两个列表元素一一对应生成字典\n    print(f\"\\tAuthors: {name_list} Have Been Found\")\n    return name_dict\n\ndef find_author_hindex(url):\n    url_parts = parse.urlparse(url)\n    url_params = parse.parse_qs(url_parts.query)\n    author_head={\n        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36',\n        'x-1p-wos-sid': url_params['SID'][0]\n    }\n    if 'daisIds' in url_params.keys():#部分作者没有主页\n        author_detail_url=author_homepage+url_params['daisIds'][0]+'?coAuthor=true'\n        time.sleep(0.5 + random.random())\n        author_detail_response=session.get(author_detail_url,headers=author_head)\n        author_detail_dict=eval(author_detail_response.text)\n        return author_detail_dict['hIndex']\n    else:\n        return 0\n\n\n\nif __name__==\"__main__\":\n    url_test='***手动打码***'\n    session=requests.session()\n    search_records_list=extract_frame(url_test,search_records_list)\n    for search_record in search_records_list:\n        log(search_record['num_index']+search_record['title_paper'])\n        num_index_float=float(search_record['num_index'])\n        if num_index_float<115:#意外结束后跳到指定文章继续运行\n            continue\n        if search_record['cited_number']==0:\n            log('\\tNo Cited Record Found')\n            continue\n        cited_records_list=[]\n        cited_records_list=extract_frame(search_record['cited_url'],cited_records_list)\n        for cited_record in cited_records_list:\n            log('\\t')\n            log(cited_record['num_index']+cited_record['title_paper'])\n            log('\\t')\n            log(cited_record['title_url'])\n            authors_dict=find_author_url(cited_record['title_url'])\n            for key in authors_dict.keys():\n                author_hindex=find_author_hindex(authors_dict[key])\n                log('\\t\\t')\n                log('Hindex：\\t'+str(author_hindex)+'\\tauthor：\\t'+key)\n    print('end')\n\n"}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "Python + docxtpl + MongoDB快速生成word", "作者": "٩(●˙ε˙●)۶", "发布时间": "2021-03-28 16:57:32", "内容": [{"ctype": "p", "data": "Python + docxtpl + MongoDB快速生成word"}, {"ctype": "head", "data": "安装所需要的环境"}, {"ctype": "p", "data": "安装Python环境 安装MongoDB数据库 安装所需要的第三方包(pymongo,docxtpl)"}, {"ctype": "head", "data": "实现过程及原理"}, {"ctype": "p", "data": "查询mongdb数据库，准备好要生成word文档的数据，在word模板中进行渲染，保存生成的word"}, {"ctype": "head", "data": "详细步骤"}, {"ctype": "head", "data": "获取命令行参数"}, {"ctype": "p", "data": "由于我的功能函数所需要的参数是由命令行传过来的，我需要接收命令行参数，接收代码如下,返回的参数为命令行参数的获取字典.这里我接收参数的格式为python python.py -p ‘proj_id’ -t ‘模板路径’ -v ‘version’ -r ‘run_id’"}, {"ctype": "code", "data": "import getopt\nimport sys\n\ndef get_args():\n    \"\"\"\n    获取命令行参数\n    \"\"\"\n    arg_path = {}\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"p:r:v:t:\", [\n            \"--proj_id\", \"--run_id\", \"version\", \"template\"])\n        del args\n    except getopt.GetoptError:\n        raise ValueError('输入参数错误')\n    for name, value in opts:\n        if name in (\"-p\", \"--proj_id\"):\n            arg_path[\"proj_id\"] = value\n        if name in (\"-r\", \"--run_id\"):\n            arg_path[\"run_id\"] = value\n        if name in (\"-v\", \"--version\"):\n            arg_path[\"version\"] = value\n        if name in (\"-t\", \"template\"):\n            arg_path[\"template\"] = value\n    return arg_path\n"}, {"ctype": "head", "data": "利用pymongo连接MongoDB数据库"}, {"ctype": "p", "data": "代码如下"}, {"ctype": "code", "data": "import pymongo\n\n\n\ndef comm_db():\n    \"\"\"\n    链接数据库\n    \"\"\"\n    client = pymongo.MongoClient(host='127.0.0.1', port=27017)\n    db = client.mydb #数据库名称mydb\n    return db\n"}, {"ctype": "head", "data": "数据库数据的查询"}, {"ctype": "code", "data": "def get_proj_docx(proj_id, version):\n    if version is None:\n        version = ''\n    file_json = comm_db()['my_collections'].find_one({\"proj_id\": proj_id\"version\": version})\n    if file_json is None:\n        raise Exception('数据库查询错误')\n    return file_json\n"}, {"ctype": "head", "data": "数据的处理"}, {"ctype": "p", "data": "由于一些数据的计算标题的处理需要在代码中完成，这里我做了一些处理"}, {"ctype": "code", "data": "def get_tpoic(children, s):\n    for index, value in enumerate(children):\n        del value\n        children[index]['top'] = s + '.' + str(index + 1)\n        child = children[index].get('children', None)\n        if children[index] and child is not None:\n            get_tpoic(children[index]['children'], children[index]['top'])\n\ndef get_result(run_tree, total):\n    for da in run_tree:\n    \tif run_info is not None:\n                test_data = run_info.get('test_data', None)\n                if test_data is not None:\n                    run_info['test_data'] = json.dumps(test_data, indent=8)\n\ndef findparentdict(parent, node_id):\n    par_get = parent.get('children', None)\n    if parent is None or par_get is None:\n        return None\n    for it in par_get:\n        if it['id'] == node_id:\n            return parent\n    for item in par_get:\n        if it['kind'] == 'dir':\n            res = findparentdict(item, node_id)\n            if res:\n                return res\n    return None\n"}, {"ctype": "p", "data": "这里只展示典型的数据处理"}, {"ctype": "head", "data": "word模板的准备"}, {"ctype": "p", "data": "这就就要用到jinja2的语法，类似于MVC开发模式的前端语法简单举例"}, {"ctype": "p", "data": "{% if True %}{{‘我是小明’}}{% else %}{{ ‘我不是小明’ }}{% endif %} 模板的准备需要根据用户的需求进行自定义模板的类型，模板的语法这里让我头疼了好久，书写错误无法排错，只能慢慢查找（我没有找到好的拍错的方法）"}, {"ctype": "head", "data": "进行模板的渲染"}, {"ctype": "p", "data": "处理好的数据与事先准备好的模板作为参数传进来"}, {"ctype": "code", "data": "def get_word(file, templete):\n\tif isinstance(file, dict):\n        docx = DocxTemplate(template)\n        docx.render(file)\n        name = file['name'] + \".docx\"\n        docx.save(name) #保存在当前路径下\n    else:\n        raise Exception(\"数据格式错误\")\n\n"}], "cate": "Python"}
{"题目": "Pytorch 中的Summary和FLOPs统计  使用窍门", "作者": "爷灬傲奈我何", "发布时间": "2021-03-28 17:16:38", "内容": [{"ctype": "head", "data": "Summary"}, {"ctype": "p", "data": "Summary 中需要输入input_size，如果input其Shape为[256,557]，则其用法和输出结果如下： 用法：summary(model,(557,)) 输出： 同理，如果input的Shape属性为[64,1,28,28]，则其input_size为[1,28,28]"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328171039135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDcwNDc1,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "FLOPs"}, {"ctype": "p", "data": "Summary 中需要输入input_size，如果input其Shape为[256,300]，则其用法和输出结果如下： 使用方法： input = torch.randn(256,300) device = torch.device(“cuda” if torch.cuda.is_available() else “cpu”) input = input.to(device) macs, params = profile(model, inputs=(input,)) macs, params = clever_format([macs, params], “%.3f”) print(‘flops=’, macs) print(‘params=’, params)"}, {"ctype": "p", "data": "输出： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328171325857.png"}, {"ctype": "head", "data": "总结"}, {"ctype": "p", "data": "主要是看网络中的shape，因为两种计算都是采用随机值带入网络，所以假如model函数中有其他函数变量需要赋值，那么可以把其他函数变量都删除，仅用类似def model(self,x)的形式即可正常使用summary与FLOPs。"}], "cate": "Python"}
{"题目": "爬虫案例：中国大学排名及网站更新后爬取问题解决(2021.3.28)", "作者": "明  总  有", "发布时间": "2021-03-28 17:52:43", "内容": [{"ctype": "p", "data": "解答标签string属性Tag.string方法获取不了的问题"}, {"ctype": "p", "data": "本次爬虫的URL（上海软科中国大学排名）: https://www.shanghairanking.cn/rankings/bcur/2020"}, {"ctype": "p", "data": "案例来源：中国大学慕课嵩天老师的“Python网络爬虫与信息提取” 由于该课程的录制时间较早，而案例爬取网站做了部分的代码修改，导致课程中的爬虫案例的部分代码已不适用于今天网站的内容结构，所以就有了开始学习爬虫的你来到了CSDN，哈哈哈哈。"}, {"ctype": "p", "data": "课程中的案例代码这里就不展示了，直接上问题  由于网页中的这部分做了一定的修改，所以这样的方式已不再适用。 接下来我们找到网页中大学排名的Html代码对应的位置，看看是怎样的。  这里和课程文档内的网页对比一下，你应该就发现了问题的所在。以前我们想要爬取的网页完全是直接就在td标签内的，因此可以很方便快捷的照抄案例代码就能爬取数据。   这里可以看出不能再使用Tag.string来获取当前特殊情况下的String属性。 但是我们想要获取数据就需要从这里打印输出数据，于是我想了一个办法把td标签里的内容强制转换为str类型----->输出。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328165909220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzIwMDQy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "复习一下知识点"}, {"ctype": "code", "data": "// strip()删除字符串开头和结尾的空白\n.strip()\n//删除左边的空白\n.lstrip()\n//删除右边的空白\n.rstrip()\n//<tag>所有的儿子节点存入列表\nTag.contents   \n"}, {"ctype": "p", "data": " 到这其实就差不多了，只要能够想到这一点，问题就能迎刃而解了。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328173159443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzIwMDQy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "我的完整代码代码如下："}, {"ctype": "code", "data": "import requests\nimport bs4\nfrom bs4 import BeautifulSoup\n\ndef getHTMLText(url, headers):\n    try:\n        r = requests.get(url=url, headers=headers, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        soup = BeautifulSoup(r.text,\"html.parser\")\n        return soup\n    except:\n        return \"\"\n\ndef fillUnivList(ulist, html):\n\n    for tr in html.find(\"tbody\").children:\n        if isinstance(tr,bs4.element.Tag):\n            tds = tr('td')\n            rank = str(tds[0].contents[0]).strip()\n            school = str(tds[1].a.string)\n            score = str(tds[4].contents[0]).strip()\n            cla = str(tds[5].string).strip()\n            ulist.append([rank, school, score, cla])\n    return ulist\n\n\ndef printUnivList(ulist,num):\n    tplt = \"{0:^10}\\t{1:^10}\\t{2:^10}\\t{3:^10}\"\n    print(tplt.format(\"排名\", \"学校名称\", \"总分\", \"class\"))\n    for i in range(num):\n        u = ulist[i]\n        print(tplt.format(u[0], u[1], u[2], u[3]))\n\n\nif __name__ == \"__main__\":\n    info = []\n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36\"\n    }\n    url = \"https://www.shanghairanking.cn/rankings/bcur/2020\"\n\n    html = getHTMLText(url,headers)\n    info = fillUnivList(info, html)\n    printUnivList(info,30)\n"}, {"ctype": "p", "data": "结果展示如下：  一起学Python,一起写代码"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328174710701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzIwMDQy,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "Python爬取MacWk网站最新软件列表（软件简介、链接、下载次数）", "作者": "weixin_47543264", "发布时间": "2021-03-28 21:23:52", "内容": [{"ctype": "head", "data": "效果图如下："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/202103282009355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU0MzI2NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " 作者是python小白 也是第一次写爬虫 很多地方都是现学现卖的 如果有写的烂和写不好的地方还希望各位大佬多多包容和指点一下🙏"}, {"ctype": "head", "data": "直接上代码"}, {"ctype": "code", "data": "#导入工具\nfrom bs4 import BeautifulSoup\nimport requests\nimport time\n\n#伪装浏览器\nheaders = {\n\t\n\t\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36\"\n}\n\n#网页页数\npage_num = 1\n\n#设置文件名用来存储爬取到的数据/这里我选择用当前时间来命名文件\nfilename = \"./{}.txt\" .format(time.ctime())\n\n#start与后面的end变量记录程序执行时间\nstart = time.time()\n#while循环设置要爬去的页数 这里设置的是10页可以自定义\nwhile  page_num <= 10:\n\t#请求网页 \n\tresponse = requests.get(\"https://macwk.com/soft/all/p{}\".format(page_num))\n\t#创建bs4对象并指定解析对象和解析器\n\tsoup = BeautifulSoup(response.text, \"lxml\")\n\t#根据获取到的html特征获取不同的数据（软件名称、软件地址、软件介绍、下载次数）\n\tSoft_Name = soup.find_all(\"h5\",\"macwk-app__body--title\")\n\tSoft_Url = soup.find_all(\"a\", class_= \"macwk-app border white cursor-pointer\")\n\tSoft_Brief = soup.find_all(\"p\", \"macwk-app__body--info\")\n\tDownload_Count = soup.find_all(\"div\", \"macwk-app__extend--download\")\n\t# 存入数据到txt文件 储存模式为追加\n\twith open(filename, \"a+\") as f:\n\t\t#遍历信息\n\t\tfor A,B,C,D in zip(Soft_Name,Soft_Url,Soft_Brief,Download_Count) :\n\t\t\tprint(\"软件名称: {} 简介:{} 下载次数:{} 下载地址:https://macwk.com{}\".format(A.get_text(), C.get_text(), D.get_text(), B[\"href\"]),file = f)\n\t\t\tprint(\"\", file = f)\n\t\n\tpage_num += 1 #爬取下一页\n\nend = time.time()\n#获取程序总共执行时间\nprint(\"程序共执行：{:.2f}秒\".format(end-start))"}, {"ctype": "p", "data": "代码整体还是比较简单的 除去注释 只用了20几行的代码 说一下整体的思路和编写过程"}, {"ctype": "p", "data": "先是爬虫基本的请求和解析 相关的代码已经在注释里详细解释了一遍"}, {"ctype": "p", "data": "在网站请求成功之后 获取到返回的html码如图所示："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328203812873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU0MzI2NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "通过观察 我发现我想要的信息和数据在其中的<h5> <a> <p> <div>标签里面 "}, {"ctype": "p", "data": "软件名称以及其版本号 <h5>"}, {"ctype": "code", "data": "<h5 class=\"macwk-app__body--title\">\n                <span class=\"fs-12 v-3\">\n                 👍\n                </span>\n                <span>\n                 Adobe M1 系列\n                </span>\n                <span class=\"macwk-app__body--title--version text-muted fs-14\">\n                 <span class=\"mx-1\">\n                  -\n                 </span>\n                 2021\n                </span>\n               </h5>"}, {"ctype": "p", "data": "软件简介及其体积大小 <p>"}, {"ctype": "code", "data": " <p class=\"macwk-app__body--info\">\n                <span>\n                 适用于M1芯片的Adobe全家桶\n                </span>\n                <span class=\"fs-12 opacity-80 ml-1\">\n                 -\n                 <span class=\"ml-1\">\n                  16.0 GB\n                 </span>\n                </span>\n               </p>"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "软件下载次数 <div>"}, {"ctype": "code", "data": "<div class=\"macwk-app__extend\">\n               <div class=\"macwk-app__extend--download\">\n                <i class=\"icon-download2\">\n                </i>\n                <span>\n                 50.6k\n                </span>\n               </div>"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "最后是软件的下载地址 在其中href标记中"}, {"ctype": "code", "data": " <a class=\"macwk-app border white cursor-pointer\" href=\"/soft/adobe-m1\" target=\"_self\">"}, {"ctype": "p", "data": "这时候我们调用BeautifulSoup中的 find_all() 方法来爬取html中需要的代码段"}, {"ctype": "p", "data": "以下是BeautifulSoup4官方文档对这个方法的介绍以及如何使用操作"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328210352828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU0MzI2NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "这时候我们获得了4个不同标签的的html代码段 但直接通过标签爬取会得到很多对我们无用的信息 "}, {"ctype": "p", "data": "所以在这里通过在find_all()方法中第二个参数中加上需要爬取标签的具体特征这就可以获得我们想要的数据啦"}, {"ctype": "code", "data": "    Soft_Name = soup.find_all(\"h5\",\"macwk-app__body--title\")\n\tSoft_Url = soup.find_all(\"a\", class_= \"macwk-app border white cursor-pointer\")\n\tSoft_Brief = soup.find_all(\"p\", \"macwk-app__body--info\")\n\tDownload_Count = soup.find_all(\"div\", \"macwk-app__extend--download\")"}, {"ctype": "p", "data": "然后通过for循环遍历这4个片段中所需要的信息 并且追加到指定文件中就大功告成啦～"}, {"ctype": "p", "data": "而start和end这两个变量来记录程序总共执行的时间"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328211837575.png"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "还有很多操作由于作者刚刚入门且水平有限只能这样了"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328212301690.png"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "Python 批量修改图片文件名，前面补0，实现00001开头（按照初始顺序改名）", "作者": "请你吃水饺吧", "发布时间": "2021-03-28 20:37:06", "内容": [{"ctype": "code", "data": "import os\nimport re\nimport sys\npath = r\"C:\\Users\\78241\\Desktop\\新建文件夹 (2)\\新建文件夹\\2\"  \nfilelist = os.listdir(path)\nfiletype='.jpg'\nfor file in filelist:\n    print(file)\nfor file in filelist:\n    Olddir=os.path.join(path,file)\n    print(Olddir)\n    if os.path.isdir(Olddir):\n        continue\n    \n    #os.path.splitext(\"path\")：分离文件名与扩展名\n    filename=os.path.splitext(file)[0]\n    filetype=os.path.splitext(file)[1]\n    \n    #zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0\n    Newdir=os.path.join(path,filename.zfill(5)+filetype)#数字5是定义为5位数，可随意修改需要的\n    os.rename(Olddir,Newdir)  \n    #复制即可运行\n\n"}], "cate": "Python"}
{"题目": "python 函数的定义、函数参数传递、函数的返回值、函数参数定义\\默认值\\可变个数参数", "作者": "花前墨", "发布时间": "2021-03-28 22:15:07", "内容": [{"ctype": "p", "data": "函数就是能够完成特定功能的一段代码。通过函数可以实现代码的复用、实现细节的隐藏、提高可维护性与可读性。"}, {"ctype": "code", "data": "# python中创建函数的格式：\ndef function(parameter):  # 函数名与输入参数\n\tparameter = 1  # 函数体\n\treturn parameter  # 返回值\n\t\n# python中调用函数的格式\nresult = function(2)\n"}, {"ctype": "p", "data": "函数的参数传递。函数定义是的参数为形参，函数调用时的参数是实参。参数传递是指将实参传递给形参，有两种方式：位置传递与关键字传递（关键字指的是形参）。 函数参数传递时，如果传入的是不可变对象，那么不论函数中如何修改该对象，函数调用结束后，该对象依然不变。如果传入的是可变对象，若函数中改变该对象，则函数调用结束后，该对象会发生相应的改变。因为传入的可变对象会发生改变，若不想让原对象发生变化，应传入原对象的copy()。"}, {"ctype": "code", "data": "# 函数参数传递的两种方式\ndef func1(para1, para2): \n\tanswer = para1 + para2  \n\treturn answer\t\nresult1 = func1(2, 3)  # 位置传递，按照顺序传递\nresult2 = func1(para1=2, para2=3)  # 关键字传递，按照形参名传递\n\n# 可变对象与不可变对象的差异\ndef func2(a, b):\n\ta = a + 1\n\tb.append(a)\n\treturn\na, b = 1, [1, 2, 3]\nfunc2(a, b.copy())  # 传入b的copy\nprint(a, b) # 输出1, [1,2,3]，a与b都没有发生改变\nfunc2(a, b)\nprint(a, b) # 输出1, [1,2,3,2]，a没有发生改变，b发生了改变\n"}, {"ctype": "p", "data": "函数的返回值有三种情况： （1）如果没有返回值，return可以省略； （2）如果只有一个返回值，则返回相应的类型； （3）如果有多个返回值，则返回的是一个元组，元组内是各个返回值。"}, {"ctype": "code", "data": "def func1():  # 没有返回值\n\tprint('hello')\ndef func2():  # 有一个返回值\n\treturn 'hello'\ndef func3():  # 有多个返回值\n\treturn 'hello','world'\nprint(func3())  # 输出为('hello', 'world')\n"}, {"ctype": "p", "data": "函数参数定义。可以为函数形参提供默认值，形参有默认值时，可以不给该形参传入实参；若给其传入实参，则实参会替换掉默认值。 不确定传入参数的个数时，可以使用可变个数参数，有两种形式：*args或 **args。*args指的是可变个数的位置参数，**args指的是可变个数的关键字形参。 两者可以一起使用，一同使用时两者的形参名不能相同，一同使用时可变位置形参需要在可变关键字形参之前；但不能重复。也可以与普通形参一起使用。"}, {"ctype": "code", "data": "# 参数默认值\ndef func1(para1, para2=2):  # para2有默认值\n\treturn para1 + para2\n\n# 可变个数参数\ndef func2(*args):  # 可变个数的位置参数\n\tprint(args)\nfunc2(1, 2)  # 输出(1,2),注意输出的是元组\ndef func3(**args): # 可变个数的关键字参数\n\tprint(args)\nfunc3(a=1, b=2)  #输出{'a': 1, 'b': 2}，注意输出的是字典\n\n# 普通形参、可变个数位置参数、可变个数关键字参数一同使用\n# 注意不管可变还是不可变，位置参数都要在关键字参数之前！\ndef func4(a, *args1, b, **args2):\n    print(a, args1, b, args2)\nfunc4(1, 2, 3, b=4, c=5, d=6)  # 输出为：1 (2, 3) 4 {'c': 5, 'd': 6}\n"}], "cate": "Python"}
{"题目": "而定之年始学PYTHON ,5年后出终于出代码了", "作者": "qq_42886846", "发布时间": "2021-03-28 22:49:33", "内容": [{"ctype": "head", "data": "而定之年始学PYTHON ,5年后出终于出代码了"}, {"ctype": "p", "data": "随着时间变化， 感觉自已与社会的距离越越来大， 于是经过多番研究后，决定学习PYTHON,此时人已到中年， 记忆力也大不如前， 如果现在不开始，估计以后也没有机会了，学不学好没有关系，能让老年痴呆来的晚些就好。奥力给！！！"}, {"ctype": "head", "data": "废话不多说了，直接上代码————高手们忍一下哈~~"}, {"ctype": "p", "data": "用了5年的是业余时间，终于做出了高手一周的水平"}, {"ctype": "code", "data": "import pandas as pd\nimport numpy as np\nimport time \nimport datetime\nimport tushare as ts\n#import psycopg2\n#from bson.objectid import ObjectId   \nfrom threading import Thread, Lock\nimport os\nimport pandas_datareader.data as web\nfrom queue import Queue\n#import json\nimport threading\nfrom io import StringIO\nfrom sqlalchemy import create_engine\nlock=threading.RLock()\nqu=Queue()\nqu1=Queue()\nqu2=Queue()\nthread_num=4\nos.chdir(r'E:\\study_python\\DB')\ncount=0\nerrorlist=[]\n#import psycopg2.extras\n#conn = psycopg2.connect(dbname=\"postgres\", user=\"postgres\",password=\"SY639000\", host=\"127.0.0.1\", port=\"5432\")\nengine = create_engine('postgresql+psycopg2://postgres:SY639000@localhost:5432/postgres')\nconn = engine.raw_connection()\ncurs=conn.cursor()\nprint('connected postgres dbbase')\nts.set_token('****************************')#用户token\npro = ts.pro_api()#实例化\ndef df_db():\n    sql_max='select max(\"Date\"),\"Code\" from postgres group by \"Code\"'\n    curs.execute(sql_max)\n    da=curs.fetchall()\n    df_db=pd.DataFrame(da, columns=['Date','Code'])\n    df_db['Mark']='DB'\n    return df_db\n#print(df_db())    \ndef df_tushare():\n    data1=pro.stock_basic(exchange='',list_status='L',feilds='ts_code,symbol,name,area,insdustry,list_date')#交易日的股票信息\n    df_list_now=pd.DataFrame(data1,columns=['list_date','ts_code'])#数据转在DateFrame 格栅\n    df_list_now.rename(columns={'ts_code':'Code','list_date':'Date'},inplace=True)#列名列改成与yahoo的一致\n    df_list_now['Date']=pd.to_datetime(df_list_now['Date'])# 将日期格式转成YAHOO的格式。\n    df_list_now['Code']=df_list_now['Code'].str.replace('SH','SS')#将'SH',替换成'SS',与yahoo一致.\n    df_tushare=df_list_now[['Date','Code']]\n    df_tushare['Mark']='TS'\n    return df_tushare\nif df_db().empty:\n    cur.execute('''CREATE TABLE postgres\n                   (ID INT PRIMARY KEY     NOT NULL,\n                   Date        DATE ,\n                   High        DECIMAL,\n                   Low         DECIMAL,\n                   Open        DECIMAL,\n                   Close        DECIMAL,\n                   Volume        INTEGER,\n                   Adj Close     DECIMAL,\n                   Code    VARCHAR(20) );'''\n               )\n\n    dft=df_tushare()\nelse:\n    dft=df_tushare().append(df_db(),ignore_index=True)\ndfg=dft.iloc[dft.groupby(['Code']).apply(lambda x: x['Date'].idxmax())]\ndfout=dfg.reset_index()[['Date','Code','Mark']]\n\nlen_count=len(dfout)\nprint(dfout)\nfor i in range(len_count):\n    qu1.put(dfout.loc[i])\n\ndef SaveData(qu):\n    global count\n    while not qu.empty():\n        qu_get=qu.get()\n        try:\n            Code=qu_get['Code']\n            date0=dfout.loc[i]['Date']+pd.Timedelta(days=1)#+datetime.timedelta(day=1)\n            #print('date0 is 0000000000000',date0)\n            #date1=date0.strftime(\"%Y-%m-%d %H:%M:%S\")\n            if dfout.loc[i]['Mark']=='DB':\n                date_begin=date0\n            else:\n                date_begin=dfout.loc[i]['Date']\n            \n            date_end=datetime.datetime.now()\n            dfs=web.DataReader(Code,'yahoo',date_begin,date_end,retry_count=3)\n            dfs['Code']=Code\n            dfs.reset_index(inplace=True)\n            lock.acquire()\n            dfs.to_sql('postgres', engine, if_exists='append',index=False)            \n            count+=1\n            dis=int(50*count/len_count)\n            print('\\r','■'*dis+'□'*(50-dis),'{:.2%} Code: {},Date:{},End:{}'.format(count/len_count,Code,date_begin,date_end),end='')\n            lock.release()\n        except:\n            errorlist.append(Code)\n            if not qu1.empty():\n                qu2.put(dfout.loc[i])\n                continue\n            else:\n                #qu1.put(dfout.loc[i])\n                #for i in qu1.get_nowait():\n                print('下截失败的股票为：',dfout.loc[i])\n                print('\\r',Code,'read error  XXXXXXXXXXXXXXXXX',end='')\n                #continue\n                continue\n\ndef multithread(qu):\n    threads=[]\n    for i in range(thread_num):\n        t=Thread(target=SaveData(qu))#创建线程\n        t.start() #启动线程\n        threads.append(t)\n        #print(f'现在是线程{i}')\n    for t in threads:\n        t.join()\n        #print(f'线程名称为{t}')\n    with open('errorlist.text','a') as file:\n        file.write(','.join(errorlist))\nif __name__=='__main__':\n    multithread(qu1)\n    multithread(qu2)\n    conn.commit()\n    curs.close()\n    conn.close()\n    #engine.close()\n    print('all data over')\n"}, {"ctype": "head", "data": "写在最后"}, {"ctype": "code", "data": "  以上是一个关于从yahoo股票下载的代码，股市是一个专治各种不服的地方， 也许用代码来选股，搞不好就成了一种亏钱的手艺。\n  有相同的爱好的，欢迎留言。\n"}], "cate": "Python"}
{"题目": "刷Leetcode算法的第八天", "作者": "冯宝兴", "发布时间": "2021-03-28 22:01:01", "内容": [{"ctype": "head", "data": "序言"}, {"ctype": "p", "data": "今天是刷LT的一天，好好干饭，好好努力，好好加油哦！"}, {"ctype": "code", "data": "输入：nums = [1,2,1,3,2,5]\n输出：[3,5]\n输入：nums = [-1,0]\n输出：[-1,0]\n输入：nums = [0,1]\n输出：[1,0]\n"}, {"ctype": "head", "data": "方法一 ：利用set函数来做"}, {"ctype": "p", "data": "先创建一个空set（），然后遍历nums，如果num只重复一次的话，则会保留在set（）里；如果num重复里两次，则会被remove掉。具体做法如下："}, {"ctype": "code", "data": "def singleNumber( nums):\n  s = set()           #创建空白set集合\n  for num in nums:\n    if num in s:     #如果出现了重复数，则从s remove掉\n      s.remove(num)\n    else:            #一开始，由于set空白，所有单独出现的数都会录入s中 \n      s.add(num)\n  return list(s)\n"}, {"ctype": "head", "data": "方法二：使用位运算符"}, {"ctype": "p", "data": "回忆之前学习的位运算符 https://blog.csdn.net/Jiana_Feng/article/details/115156834 比如运算符 ^ 的特性： a ^ 0 = a ; a ^ a = 0 【^ 是当两边相同位置都是相同数字，结果返回0，不相同时返回1】 所以，假设出现数组为 [1,1,2,2,3,4] 我们用 ^ 连接： 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 4 = 3 ^ 4 这是因为 1 ^ 1 = 0 且 2 ^ 2 = 0 所以 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 4 = 0 ^ 0 ^ 3 ^ 4 = 0 ^ 3 ^ 4 = 3 ^ 4 这就可以得到 3 和 4 现在的想法是 把题目拆分成 两个以下的问题： 在一个数组里，只有一个元素出现了一次，其他元素都出现了两次，求这个元素的值。即把3 和 4 分别放入两个数组 这个问题我们做过的。 这里将会用上一个逻辑： 把mask = 3 ^ 4 再 mask = mask & (-mask) 这样出来的mask 用上条件 mask & _ == 0 将可以区分 3 和 4 换上任意的两个不相同的数 都可以 做到区分，下面是几个例子 来解析： 当 mask = 3 ^ 4 = 0 0 1 1 ^ 0 1 0 0 = 0 1 1 1 而 -mask = -(0 1 1 1) = 1 0 0 1 最后 mask & （-mask） = 0 1 1 1 & 1 0 0 1 = 0 0 0 1 所以 0 0 0 1 & 0 1 0 0 （4）= = 0 而0 0 0 1 & 0 0 1 1（3）等于 1 从而区分3和4 其他的任意两个数 重复以上过程 都是可以区分 再来一个例子： 6 是 0 1 1 0 4 是 0 1 0 0 所以 mask = 6^4 = 0 1 1 0 ^ 0 1 0 0 = 0 0 1 0 而-mask = 1 1 1 0 最后 mask =mask & （-mask）= 0 0 1 0 & 1 1 1 0 = 0 0 1 0 用上条件 mask & = = 0 也可以区分 4 和 6"}, {"ctype": "p", "data": "笔者认为 这是因为 mask & （-mask） 会找出 A和B这两个数的 二进制的区别，比如A尾数是0 B尾数是 1。如果A和B尾数都一样，则会找出 A和B倒数第二位的区别,从而做到区分A和B。"}, {"ctype": "p", "data": "所以这道题的python code是这样子的："}, {"ctype": "code", "data": "    def singleNumber( nums):\n        a, b = 0, 0\n        mask = 0\n        for num in nums:\n            mask = mask^num \n            #即mask = A ^ A ^ B ^ C = B ^ C (B和C为不一样的数)\n        mask = mask & (-mask) \n        for num in nums:\n        #找出出现频次只有一次的两个不同的数，分别赋予a和b再return a,b \n            if mask & num == 0:\n            \ta ^= num \n            else:\n                b ^= num\n        return [a, b]\n"}], "cate": "Python"}
{"题目": "python基础知识整理 第七节：单例设计模式、异常、模块、包、制作模块、文件", "作者": "Upupup6", "发布时间": "2021-03-28 13:13:54", "内容": [{"ctype": "p", "data": "1、单例设计模式"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327144917304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "单例设计模式就是为对象在内存中分配空间的时候，永远只会返回一个唯一的固定的内存空间。这样就能保证在内存中这个类的对象只有唯一的一份，这个就叫做单例。（为对象分配空间使用的是内置方法__new__方法）"}, {"ctype": "p", "data": "创建对象时，new方法会被自动调用。如果自己重写__new__方法，一定要进行返回分配的内存空间，如果不返回，pyhton的解释器就得不到分配空间的对象引用，如果得不到对象的引用，python的解释器就不会调用初始化方法，把对象的引用传递到初始化的方法内部。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327162000912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "class MusicPlayer(object):\n    #重写new方法\n    def __new__(cls,*args,**kwargs):\n        #1.创建对象时，new方法会被自动调用\n        print(\"创建对象，分配空间\")#1使用print函数覆盖了父类object方法的实现\n        #2、为对象分配空间\n        \"\"\"\n        怎么样为对象分配空间？可以直接调用父类的方法就好了，\n        因为object基类中已经默认的new方法已经可以实现为对象分配空间的动作了，\n        所以我们可以直接调用一下父类的方法，要调用父类的方法，\n        应该找一个特殊的对象是super即super().__new__(cls)，\n        需要注意的是new方法是一个静态的方法，所以我们在调用new方法的时候，\n        必须要把第一个参数cls传递给这个方法。\n        \"\"\"\n        instance=super().__new__(cls)\n        #3、返回对象的引用\n        \"\"\"\n        调用完父类的这个方法之后，怎么样把方法的返回结果返回呢？\n        1、可以直接在上边加一个return\n        2、还可以定义一个变量接收父类的返回结果（例如shiyong instance接收返回结果）\n        \"\"\"\n        return instance#2把对象的引用返回\n    def __init__(self):#3返回之后，这样python的解释器就能够自动调用初始化方法\n        print(\"播放器初始化\")\nplayer=MusicPlayer()\nprint(player)#打印播放器的内存地址（4初始化方法完成之后，在主程序中把创建好的播放器对象打印在控制台）\n        "}, {"ctype": "p", "data": "结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327164602482.png"}, {"ctype": "p", "data": "PS：__new__方法中一定要返回父类方法调用__new__方法的结果就可以，而且new方法是一个静态的方法，所以在调用父类方法的时候，必须要主动传递cls这个参数。"}, {"ctype": "p", "data": "使用单例设计模式来开发设计的类："}, {"ctype": "p", "data": "这就是怎么样使用单例设计模式，在创建对象时，无论调用多少次创建对象的方法，得到的结果永远是第一个创建对象的实例。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327170103896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "class MusicPlayer(object):\n\n    #1、记录第一个被创建对象的引用\n    instance=None#使用None作为初始值，因为类定义完成，第一个对象还没有被创建，必须要主动调用一下创建对象的方法，第一个对象才能够被创建，因此这个类属性的初始值我们把它定义为None\n        #2、改造new方法，因为new方法是负责分配内存空间的\n    def __new__(cls,*args,**kwargs):\n            #1判断类属性是不是空对象，如果是空对象说明第一个对象还没有被创建\n        if cls.instance is None:\n            #2如果对象没有被创建，应该调用父类的方法为第一个对象分配空间（只有为第一个对象分配空间之后我们才能够使用类属性进行记录）\n            cls.instance=super().__new__(cls)\n        #3如果类属性中已经有了值，就直接把类属性中保存的第一个对象引用直接返回给python的解释器就可以了\n        return cls.instance#2把对象的引用返回\n    #这样无论在外界无论调用多少次创建对象的方法，得到的对象内存地址永远都是相同的\n    def __init__(self):#3返回之后，这样python的解释器就能够自动调用初始化方法\n        print(\"播放器初始化\")\nplayer1=MusicPlayer()\nprint(player1)\n\nplayer2=MusicPlayer()\nprint(player2)#地址一样就表明player1和player2本质上是相同的对象"}, {"ctype": "p", "data": "结果："}, {"ctype": "p", "data": "现在实现了内存中只有唯一的一个对象。但是初始化方法被调用了多次，即使用了几次创建对象的方法初始化方法就被调用了几次。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327172036955.png"}, {"ctype": "p", "data": "改进：让初始化的动作只被调用一次。所谓初始化的动作就是我们写在初始化方法内部，对对象进行初始化的代码。"}, {"ctype": "p", "data": "PS：初始化方法的调用我们不能限制，但是我们可以有特殊的方式来解决一下让初始化的动作只被执行一次。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327180001612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "class MusicPlayer(object):\n\n    #1、记录第一个被创建对象的引用\n    instance=None\n    #记录是否执行过初始化动作\n    init_flag=False#表明最开始还未执行过初始化的动作\n    def __new__(cls,*args,**kwargs):\n           \n        if MusicPlayer.instance is None:\n           \n            MusicPlayer.instance=super().__new__(cls)\n        \n        return MusicPlayer.instance#2把对象的引用返回\n  \n    def __init__(self):\n        #判断是否执行过初始化动作\n        if MusicPlayer.init_flag:\n            return#如果类属性为真，表明已经执行过初始化操作，就直接返回\n        #如果没有执行过初始化动作，在此执行初始化动作\n        print(\"播放器初始化\")\n        #修改初始化动作的标记\n        MusicPlayer.init_flag=True\nplayer1=MusicPlayer()\nprint(player1)\n\nplayer2=MusicPlayer()\nprint(player2)#地址一样就表明player1和player2本质上是相同的对象"}, {"ctype": "p", "data": "结果见上图。"}, {"ctype": "p", "data": "2、异常"}, {"ctype": "p", "data": "程序在运行过程中遇到错误就会抛出异常。针对于异常我们要捕获异常。"}, {"ctype": "p", "data": "  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327183805118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "3、模块"}, {"ctype": "p", "data": "在python中每一个独立的源文件(以py结尾)就是模块。"}, {"ctype": "p", "data": "导入模块之后通过模块名.使用模块中提供的工具--------全局变量、函数、类。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327214414937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "写完一个.py模块后，我们需要使用一些测试代码，判断这个模块是否可以正常运行，但是这些测试代码在.py作为模块导入之后，是不需要被执行的。所以我们通过__name__这个属性来判断。"}, {"ctype": "p", "data": "如果我们直接执行当前正在开发的模块(就是直接执行py这个文件)，即直接执行.py(要作为module导入的这个文件)__name__保存的是一个非常固定的字符串，永远都是__main__。即print(__name__)得到的输出结果是__main__。"}, {"ctype": "p", "data": "如果将.py作为模块导入之后，在导入之后的当前的文件下进行打印输出就是模块名。"}, {"ctype": "p", "data": "所以怎么判断.py作为module内的所有未缩进的代码，在作为模块被导入的时候测试代码是否需要被执行呢？我们就可以通过判断__name__这个属性是否是__main__或者是模块名来判断进行判断。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210327224812603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "4、package"}, {"ctype": "p", "data": "包是一个目录(directory)/(python package)。在包的目录下必须要有一个特殊的文件__init__.py"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328103327529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "比如有一个发布模块的目录，下面包含制作好的包，还需要在发布模块这个目录下建立一个setup.py文件，setup.py这个文件和你所制作完成的包同属于发布模块这个目录下。setup.py这个文件的执行必须要进入终端(所有学习都是在ubuntu下安装的pycharm)，使用python的解释器来执行这个文件，不能在pycharm中执行。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328112243757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "5、文件"}, {"ctype": "p", "data": "计算机的CPU如果想要访问保存在磁盘上的文件：第一步应该将磁盘中的文件数据加载到内存中，因为内存的读写速度要比磁盘的读写速度快很多。"}, {"ctype": "p", "data": "计算机能够识别什么样的文件数据？计算机中只能识别0101这种二进制方式的数据，所以我们保存在磁盘上的文件本质上都是以二进制的方式来保存的。"}, {"ctype": "p", "data": "但是在我们日常使用中通常会把文件分为两种类型：第一种叫做文本文件；第二种叫做二进制文件。"}, {"ctype": "p", "data": "所谓文本文件就是可以使用文本编辑软件直接查看文件内容的文件，我们就把他叫做文本文件。比如我们使用python开发的所有源程序是都可以直接查看内容的，我们就把这种文件叫做文本文件。但是文本文件本质上还是一个二进制文件；"}, {"ctype": "p", "data": "那么我们平时所说的二进制文件是指：我们会把图片文件，音频文件，视频文件等这些文件统称为二进制文件。之所以叫做二进制文件是因为我们不能够直接使用文本编辑软件来查看这些文件的内容，因为这些文件是需要使用其他专门的软件来打开的。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328114532790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "读就是将文件在磁盘中的数据加载到内存；而写就是把内存中的内容再重新写回到磁盘文件。"}, {"ctype": "p", "data": "  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328120929241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328122804152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "文本文件中的每一个字符到底是怎样用二进制来表示的呢？"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328130327650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTU3MTYw,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "Python之面向对象基础", "作者": "I先生007", "发布时间": "2021-03-28 15:24:04", "内容": [{"ctype": "p", "data": "目录"}, {"ctype": "p", "data": "一、面向过程和面向对象基本概念"}, {"ctype": "p", "data": "二、类和对象的概念"}, {"ctype": "p", "data": "三、定义简单类"}, {"ctype": "p", "data": "四、初始化方法"}, {"ctype": "p", "data": "五、私有属性和方法"}, {"ctype": "p", "data": "六、单继承"}, {"ctype": "p", "data": "七、方法的重写"}, {"ctype": "p", "data": "面向对象"}, {"ctype": "p", "data": "             面向对象（OOP）基本概念——Object Oriented Programming"}, {"ctype": "p", "data": "            过程和函数"}, {"ctype": "p", "data": "            ✦过程是早期的一个编程概念"}, {"ctype": "p", "data": "            ✦过程类似于函数，只能执行，但是没有返回值"}, {"ctype": "p", "data": "            ✦函数不仅能执行，还可以返回结果"}, {"ctype": "head", "data": "一、面向过程和面向对象基本概念"}, {"ctype": "p", "data": "               ①面向过程——怎么做"}, {"ctype": "p", "data": "            ✦把完成某一个需求的所有步骤从头到尾逐步实现"}, {"ctype": "p", "data": "            ✦根据开发需求，将某些功能独立的代码封装成一个又一个的函数"}, {"ctype": "p", "data": "            ✦最后完成的代码，就顺序地调用不同的函数"}, {"ctype": "p", "data": "            特点："}, {"ctype": "p", "data": "            ✦注重步骤与过程，不注重职责分工"}, {"ctype": "p", "data": "            ✦如果需求复杂，代码会变得很复杂"}, {"ctype": "p", "data": "            ✦开发复杂项目，没有固定的套路，开发难度大"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "             ②面向对象——谁来做"}, {"ctype": "p", "data": "            ✦在完成某一个需求前，首先确定职责——要做的事情（方法）"}, {"ctype": "p", "data": "            ✦根据职责确定不同的对象，在对象内部封装不同的方法（多个）"}, {"ctype": "p", "data": "            ✦最后完成的代码，就顺序地让不同地对象调用不同的方法"}, {"ctype": "p", "data": "            特点："}, {"ctype": "p", "data": "            ✦注重对象和职责，不同的对象承担不同的职责"}, {"ctype": "p", "data": "            ✦更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路"}, {"ctype": "p", "data": "            ✦需要在面向过程基础上，再学习一些面向对象的语法"}, {"ctype": "head", "data": "二、类和对象的概念"}, {"ctype": "p", "data": "          1、类——负责创建对象的"}, {"ctype": "p", "data": "               类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用"}, {"ctype": "p", "data": "            ✦特征被称为 属性"}, {"ctype": "p", "data": "            ✦行为被称为 方法"}, {"ctype": "p", "data": "          2、对象"}, {"ctype": "p", "data": "            对象是由类创建出来的一个具体存在，可以直接使用。由哪一个类创建出来的对象，就拥有在哪一个类中定义的："}, {"ctype": "p", "data": "            ✦属性"}, {"ctype": "p", "data": "            ✦方法"}, {"ctype": "p", "data": "          3、类的设计"}, {"ctype": "p", "data": "              在程序开发中，要设计一个类，通常需要满足三个要素："}, {"ctype": "p", "data": "            ✦类名 这类事物的名字，满足大驼峰命名法"}, {"ctype": "p", "data": "            ✦属性 这类事物具有什么样的特征"}, {"ctype": "p", "data": "            ✦方法 这类事物具有什么样的行为"}, {"ctype": "p", "data": "            "}, {"ctype": "p", "data": "            大驼峰命名法"}, {"ctype": "p", "data": "            CapWords"}, {"ctype": "p", "data": "            ✦每一个单词的首字母大写"}, {"ctype": "p", "data": "            ✦单词与单词之间没有下划线"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "            类名的确定"}, {"ctype": "p", "data": "            ✦名词提炼法 分析整个业务流程"}, {"ctype": "p", "data": "            ✦出现的名词，通常就是找到的类"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "            属性和方法的确定"}, {"ctype": "p", "data": "            ✦对 对象的特征描述，通常可以定义成属性"}, {"ctype": "p", "data": "            ✦对象具有的行为（动词），通常可以定义成 方法"}, {"ctype": "p", "data": "          4、面向对象基础语法"}, {"ctype": "p", "data": "          dir内置函数"}, {"ctype": "p", "data": "          在Python中可以使用一两个方法验证："}, {"ctype": "p", "data": "            ✦在标识符/数据后输入一个“ . ” ，PyCharm会提示该对象能够调用的方法列表"}, {"ctype": "p", "data": "            ✦使用内置函数dir 传入标识符/数据，可以查看对象内的所有属性方法"}, {"ctype": "p", "data": "            提示：_方法名_格式的方法是Python提供的内置方法/属性"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328135021525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDM0ODkxNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "三、定义简单类"}, {"ctype": "p", "data": "          1、定义只包含方法的类"}, {"ctype": "p", "data": "              在python中定义一个只包含方法的类，语法格式如下："}, {"ctype": "p", "data": "                      "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328135407658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDM0ODkxNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "            注意：类名的命名规则要符合大驼峰命名法"}, {"ctype": "p", "data": "          2、创建对象"}, {"ctype": "p", "data": "                当一个类定义完成之后，要使用这个类来创建对象，语法格式如下："}, {"ctype": "p", "data": "                                        对象变量 = 类名（）"}, {"ctype": "p", "data": "案例一："}, {"ctype": "code", "data": "# 定义一个 猫 类\nclass Cat:\n    # 封装 吃 喝\n    def eat(self):\n        print(\"小猫爱吃鱼\")\n\n    def drink(self):\n        print(\"小猫要喝水\")\n\n\n# 根据猫类 创建 猫 对象\ntom = Cat()\ntom.eat()\ntom.drink()\nprint(tom)"}, {"ctype": "p", "data": "执行结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328135852556.png"}, {"ctype": "p", "data": "          3、使用self在方法内部输出每一只猫的名字"}, {"ctype": "p", "data": "                 由哪一个对象调用的方法，方法内的self就是哪一个对象的引用"}, {"ctype": "p", "data": "                 在类封装的方法内部，self就表示当前调用方法的对象自己"}, {"ctype": "p", "data": "                  在方法内部："}, {"ctype": "p", "data": "                        ✦可以通过self访问对象的属性"}, {"ctype": "p", "data": "                        ✦也可以通过self调用其他对象方法"}, {"ctype": "p", "data": "案例二:"}, {"ctype": "code", "data": "class Cat:\n    # 封装 吃 喝\n    def eat(self):\n        print(\"%s猫爱吃鱼\"% self.name)\n\n    def drink(self):\n        print(\"%s猫要喝水\"% self.name)\n\n\n# 根据猫类 创建 猫 对象\ntom = Cat()\ntom.name = \"汤姆\"\ntom.eat()\ntom.drink()"}, {"ctype": "p", "data": "执行结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328141655774.png"}, {"ctype": "head", "data": "四、初始化方法"}, {"ctype": "p", "data": "          提示："}, {"ctype": "p", "data": "            ✦在日常开发中，不推荐在类的外部给对象增加属性。如果在运行时，没有找到属性，程序会报错"}, {"ctype": "p", "data": "            ✦对象包含哪些属性，应该封装在类的内部"}, {"ctype": "p", "data": "          1、初始化方法"}, {"ctype": "p", "data": "                    当使用类名（）创建对象时，会自动执行以下操作 "}, {"ctype": "p", "data": "                        ✦为对象在内存中分配空间——创建对象--__new__"}, {"ctype": "p", "data": "                        ✦为对象的属性设置初始值——初始化方法（__int__）"}, {"ctype": "p", "data": "                      这个初始化方法就是__int__方法，__int__是对象的内置方法。__int__方法是专门用来定义一个类具有哪些属性的方法！"}, {"ctype": "p", "data": "          2、在初始化方法内部定义属性"}, {"ctype": "p", "data": "                    在__int__方法内部使用self.属性名 = 属性的初始值 就可以定义属性。定义属性后，再使用Cat类创建的对象，都会拥有该属性"}, {"ctype": "p", "data": "          3、改造初始化方法——初始化得同时设置初始值"}, {"ctype": "p", "data": "                在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对__int__方法进行改造"}, {"ctype": "p", "data": "            ✦把希望设置的属性值，定义成__int__方法的参数"}, {"ctype": "p", "data": "            ✦把方法内部使用 self.属性 = 形参  接收外部传递的参数"}, {"ctype": "p", "data": "            ✦在创建对象时，使用类名(属性1，属性2)调用"}, {"ctype": "p", "data": "案例三："}, {"ctype": "code", "data": "class Cat:\n    # 初始化方法： 给对象来定义属性\n    def __init__(self, new_name, color):  # 创建对象的时候，需要调用 __init__ 方法，定义对象的属性！\n        print(\"初始化方法！\")\n        self.name = new_name  # 创建对象的时候， 给这个对象 赋予一个  name 的属性，值是 \"Tom\"\n        self.color = color\n\n    def eat(self):\n        print(\"{}爱吃鱼\".format(self.name))\n\n\ntom = Cat(\"Tom\", \"bule\")\nprint(tom.name)\nprint(tom.color)\ntom.eat()\ncoffee = Cat(\"Garfield\", \"orange\")\nprint(coffee.name)\n"}, {"ctype": "p", "data": "执行结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328145323225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDM0ODkxNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "五、私有属性和方法"}, {"ctype": "p", "data": "            ✦在实际开发中，对象的某些属性或方法 可能只希望在对象的内部被使用，而不希望在外部被访问到"}, {"ctype": "p", "data": "            ✦私有属性 就是对象不希望公开的属性"}, {"ctype": "p", "data": "            ✦私有方法 就是对象不希望公开的方法"}, {"ctype": "p", "data": "            1、定义方式"}, {"ctype": "p", "data": "                   在定义属性或方法时，在属性名或者方法名前增加两个下划线，定义的就是私有属性或方法"}, {"ctype": "p", "data": "案例四："}, {"ctype": "code", "data": "class Girl:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        self.__weight = 40\n\n    def __secret(self):  # 私有化方法\n        print(\"{}的年龄是{},体重是{}\".format(self.name, self.age,self.__weight ))\n\n    def ask_weight(self):\n        print(\"{}的体重是{}\".format(self.name,self.__weight))  # 在公有方法中，调用私有属性\n        self.__secret()  # 在公有方法中 调用私有方法\n\n\nxiaomei = Girl(\"小美\", 18)\nxiaomei.ask_weight()  # 在类的外部，调用 包含 私有属性和私有方法的  公有方法， 就能访问到类的私有属性和私有方法"}, {"ctype": "p", "data": "执行结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328160609798.png"}, {"ctype": "head", "data": "六、单继承"}, {"ctype": "p", "data": "            1、面向对象的三大特性"}, {"ctype": "p", "data": "            ✦封装  根据职责将属性和方法封装到一个抽象的类中"}, {"ctype": "p", "data": "            ✦继承  实现代码的重用，相同的代码不需要重复的编写"}, {"ctype": "p", "data": "            ✦多态  不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度"}, {"ctype": "p", "data": "            2、继承的概念："}, {"ctype": "p", "data": "                 子类拥有父类的所有方法和属性"}, {"ctype": "p", "data": "            3、继承的语法"}, {"ctype": "p", "data": "            "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328161351988.png"}, {"ctype": "p", "data": "            ✦子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发"}, {"ctype": "p", "data": "            ✦子类中应该根据职责，封装子类特有的属性和方法"}, {"ctype": "p", "data": "            4、继承的传递性"}, {"ctype": "p", "data": "                 C类从B类继承，B类又从A类继承，那么C类就具有B类和A类的所有属性和方法————即子类拥有父类以及父类的父类中封装的所有属性和方法"}, {"ctype": "p", "data": "案例五:"}, {"ctype": "code", "data": "class Animal:\n    def eat(self):\n        print(\"吃\")\n\n    def drink(self):\n        print(\"drink\")\n\n    def play(self):\n        print(\"play\")\n\n    def happy(self):\n        print(\"happy\")\n\n\nclass Dog(Animal):\n    def bark(self):\n        print(\"旺旺\")\n\nclass XiaoTianDog(Dog):\n    def fly(self):\n        print(\"我竟然会飞了~\")\n\n\ndog = Dog()  # Dog的实例\ndog.bark()\nXiaoTianDog = XiaoTianDog()\nXiaoTianDog.eat()\nXiaoTianDog.bark()\nXiaoTianDog.fly()"}, {"ctype": "p", "data": "执行结果："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328162947291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDM0ODkxNg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "七、方法的重写"}, {"ctype": "p", "data": "            定义：子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发。当父类的方法实现不能满足子类需求时，可以对方法进行重写（override）"}, {"ctype": "p", "data": "            重写父类方法有两种情况："}, {"ctype": "p", "data": "            ✦覆盖父类的方法"}, {"ctype": "p", "data": "            ✦对父类方法进行扩展"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "            1、覆盖父类的方法："}, {"ctype": "p", "data": "            ✦如果在开发中，父类的方法实现和子类的方法实现完全不同，就可以使用覆盖的方式，在子类中重新编写父类的方法实现"}, {"ctype": "p", "data": "            ✦重写之后，在运行时，只会调用子类中重写的方法，而不会再调用父类封装的方法"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "            2、对父类方法进行扩展"}, {"ctype": "p", "data": "                 定义：如果在开发中，子类的方法实现中包含父类的方法实现，就可以使用扩展的方式"}, {"ctype": "p", "data": "            ✦在子类中重写父类的方法"}, {"ctype": "p", "data": "            ✦在需要的位置使用super（）.父类方法  来调用父类方法的执行"}, {"ctype": "p", "data": "            ✦代码其他的位置针对子类的需求，编写子类特有的代码实现"}, {"ctype": "p", "data": "            关于super"}, {"ctype": "p", "data": "            ✦在python中super是一个特殊的类"}, {"ctype": "p", "data": "            ✦super（）就是使用super类创建出来的对象"}, {"ctype": "p", "data": "            ✦最常使用的场景就是在重写父类的方法时，调用在父类中封装的方法实现"}, {"ctype": "p", "data": "               "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328164953841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDM0ODkxNg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "爬虫笔记1", "作者": "厚载", "发布时间": "2021-03-28 11:46:34", "内容": [{"ctype": "head", "data": "爬虫笔记1"}, {"ctype": "head", "data": "第0关"}, {"ctype": "p", "data": "浏览器工作原理    爬虫工作原理   爬虫的四个步骤  这一部分的任务就是学会爬虫的第0步：获取数据。 我们将会利用一个强大的库——requests来获取数据。 requests库可以帮我们下载网页源代码、文本、图片，甚至是音频。其实，“下载”本质上是向服务器发送请求并得到响应。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328100658312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYzMzUwMQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "先来看requests.get()方法。requests.get()"}, {"ctype": "code", "data": "import requests\n#引入requests库，是引用requests库。\nres = requests.get('URL')\n#requests.get是在调用requests库中的get()方法，它向服务器发送了一个请求，括号里的参数是你需要的数据所在的网址，然后服务器对请求作出了响应。\n#服务器返回的结果是个Response对象，我们把这个响应返回的结果赋值在变量res上。\n"}, {"ctype": "p", "data": "如果用图片展示，那就是这样的： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328101640184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYzMzUwMQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "现在，我们试着用requests.get()来下载一个小说——《三国演义》： 小说的URL（网址）是：https://localprod.pandateacher.com/python-manuscript/crawler-html/sanguo.md。"}, {"ctype": "code", "data": "import requests \n#引入requests库\nres = requests.get('https://localprod.pandateacher.com/python-manuscript/crawler-html/sanguo.md') \n#发送请求，并把响应结果赋值在变量res上\n"}, {"ctype": "p", "data": "这就是基本的 request.get()的用法了。"}, {"ctype": "p", "data": "Response对象的常用属性 所以，我们现在来打印看看刚刚用requests.get()获取到的数据是什么"}, {"ctype": "code", "data": "\nimport requests \nres = requests.get('https://res.pandateacher.com/2018-12-18-10-43-07.png') \nprint(type(res))\n#打印变量res的数据类型\n"}, {"ctype": "p", "data": "终端显示：<class ‘requests.models.Response’> 这代表着：res是一个对象，属于requests.models.Response类。好，既然已经知道res是一个Response对象了，我们也就可以去了解它的相应属性和方法了。 我们主要讲Response对象常用的四个属性： 首先是response.status_code "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328102844142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYzMzUwMQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "\nimport requests \nres = requests.get('https://res.pandateacher.com/2018-12-18-10-43-07.png') \nprint(res.status_code)\n#打印变量res的响应状态码，以检查请求是否成功\n"}, {"ctype": "p", "data": "终端结果显示了200，这个数字代表服务器同意了请求，并返回了数据给我们。 除了200，我们还可能收到其他的状态码。下面有一个表格，供你参考不同的状态码代表什么，但不需要记住它们，在遇到问题的时候查询就好。  response.status_code是一个很常用的属性，在我们之后的爬虫代码中也将多次出现。 接着的属性是response.content， 它能把Response对象的内容以二进制数据的形式返回，适用于图片、音频、视频的下载，看个例子你就懂了。 假如我们想下载这张图片，它的URL是：https://res.pandateacher.com/2018-12-18-10-43-07.png 那么代码可以这样写："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328103147874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYzMzUwMQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import requests\nres = requests.get('https://res.pandateacher.com/2018-12-18-10-43-07.png')\n#发出请求，并把返回的结果放在变量res中\npic=res.content\n#把Reponse对象的内容以二进制数据的形式返回\nphoto = open('ppt.jpg','wb')\n#新建了一个文件ppt.jpg，这里的文件没加路径，它会被保存在程序运行的当前目录下。\n#图片内容需要以二进制wb读写。你在学习open()函数时接触过它。\nphoto.write(pic) \n#获取pic的二进制内容\nphoto.close()\n#关闭文件\n"}, {"ctype": "p", "data": "这样，我们的图片就下载成功啦~你也可以在本地运行这个程序。"}, {"ctype": "p", "data": "讲完了response.content，继续看response.text， 这个属性可以把Response对象的内容以字符串的形式返回，适用于文字、网页源代码的下载。 举个例子，我们还是来下载小说《三国演义》的第一章。 代码如下："}, {"ctype": "code", "data": "import requests\n#引用requests库\nres = requests.get('https://localprod.pandateacher.com/python-manuscript/crawler-html/sanguo.md')\n#下载《三国演义》第一回，我们得到一个对象，它被命名为res\nnovel=res.text\n#把Response对象的内容以字符串的形式返回\nprint(novel[:800])\n#现在，可以打印小说了，但考虑到整章太长，只输出800字看看就好。在关于列表的知识那里，你学过[:800]的用法。\n"}, {"ctype": "p", "data": " 接下来，我们看最后一个属性：response.encoding，它能帮我们定义Response对象的编码。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328103959333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYzMzUwMQ==,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import requests\n#引用requests库\nres = requests.get('https://localprod.pandateacher.com/python-manuscript/crawler-html/sanguo.md')\n#下载《三国演义》第一回，我们得到一个对象，它被命名为res\n\nres.encoding='gbk'\n#定义Response对象的编码为gbk\n\nres.encoding='utf-8'\n#定义Reponse对象的编码为utf-8。\n\nnovel=res.text\n#把Response对象的内容以字符串的形式返回\nprint(novel[:800])\n#打印小说的前800个字\n"}, {"ctype": "p", "data": "那在真实的情况中，我们该在什么时候用res.encoding呢？ 首先，目标数据本身是什么编码是未知的。用requests.get()发送请求后，我们会取得一个Response对象，其中，requests库会对数据的编码类型做出自己的判断。但是！这个判断有可能准确，也可能不准确。如果它判断准确的话，我们打印出来的response.text的内容就是正常的、没有乱码的，那就用不到res.encoding；如果判断不准确，就会出现一堆乱码，那我们就可以去查看目标数据的编码，然后再用res.encoding把编码定义成和目标数据一致的类型即可。总的来说，就是遇上文本的乱码问题，才考虑用res.encoding。"}, {"ctype": "p", "data": "好，到这里，requests.get()方法和Response对象常见的四个属性就讲完了。 可以看到，爬虫的第0步：获取数据，本质就是通过URL去向服务器发出请求，服务器再把相关内容封装成一个Response对象返回给我们，这是通过requests.get()实现的，而我们获取到的Response对象下有四个常用的属性。 爬虫伦理 Robots协议是互联网爬虫的一项公认的道德规范，它的全称是“网络爬虫排除标准”（Robots exclusion protocol），这个协议用来告诉爬虫，哪些页面是可以抓取的，哪些不可以。 如何查看网站的robots协议呢，很简单，在网站的域名后加上/robots.txt就可以了。"}], "cate": "Python"}
{"题目": "php调用python脚本", "作者": "跳高高", "发布时间": "2021-03-28 11:01:52", "内容": [{"ctype": "p", "data": "1、python中要返回中文字符，需要在文件头添加代码： import codecs sys.stdout = codecs.getwriter(‘utf-8’)(sys.stdout.detach()) 2、php具体语句实现：(php不能传递数组参数) $py_exe=\"H:/Programs/Python/Python38-32/python.exe\"; # 是你自己的python编译器的路径 exec(\"$py_exe H:/php/test.py $start_date $end_date $dateRange_startDate $dateRange_endDate\",$out,$status); 解释： H:/php/test.py是你的python文件完整路径，"}, {"ctype": "p", "data": "$start_date $end_date $dateRange_startDate $dateRange_endDate这个是传递四个参数，"}, {"ctype": "p", "data": "文件print语句打印出来的数据都会传递到$out数组中，"}, {"ctype": "p", "data": "$status 调用成功则返回0"}], "cate": "Python"}
{"题目": "快递100获取快递信息（爬虫）", "作者": "穆栩萌霖", "发布时间": "2021-03-28 10:59:17", "内容": [{"ctype": "p", "data": "最近搞js逆向，发现个逆向简单的网站，搞一波"}, {"ctype": "p", "data": "1.搞程序先装环境，requests_html库请求加解析于一体，居家旅行必备"}, {"ctype": "code", "data": "pip install requests\n"}, {"ctype": "p", "data": "2.安装完成环境，成功一半，接下来分析网站 （1）打开网网址：https://www.kuaidi100.com/?from=openv （2）F12，一键超神  （3）准备一个快递单号（中通除外，不知为毛查不了）  （4）浏览器搜索快递信息里的某个关键字，运气好搜到了，点进去   （5）请求头，请求体信息全有，python写一波请求，又是运气好发现可以获取到 （6）可疑参数都怎么来的？首先请求头里发现只有Cookie的csrftoken值的变化是关键（等两天Cookie对比下就能知道），搜索一下值，运气再次爆表，搜到了  （7）接下来请求体参数，type快递名字，postid快递单号，temp像是时间戳名字，但不是，phone收件人电话（查顺丰快递需要这个）   搜到开搞，获取快递名函数有了 （8）找temp，值没有搜到，搜字段，回到获取到信息的网址，看看请求怎么来的，这几个地方挨个点进去看并搜索字段名（大佬有高招麻烦告诉我）  找到，原来是个随机数，too young  3.分析完毕，代码走起 （1）头部加载库"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328100958904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzkzMjcw,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "# @Time : 2021/3/22 16:40 \n# @Author : 张穆栩\n# @File : kaudi100pro.py \n# @Software: PyCharm\nimport re\nimport random\nimport requests_html\n"}, {"ctype": "p", "data": "（2）面向对象，实例的参数"}, {"ctype": "code", "data": "class Kuaidi(object):\n    def __init__(self, number):\n        # 转运信息url\n        self.url = 'https://www.kuaidi100.com/query'\n        # token url\n        self.token_url = 'https://www.kuaidi100.com/'\n        # 快递名url\n        self.name_url = 'https://www.kuaidi100.com/autonumber/autoComNum'\n        # 快递名参数\n        self.number_params = {\n            'text': number\n        }\n        self.token_params = {\n            'from': 'openv'\n        }\n        # 转运信息参数\n        self.temp = str(random.random())\n        self.params = {\n            'type': self.getname(),\n            'postid': number,\n            'temp': self.temp,\n            'phone': ''\n        }\n        csrftoken = self.gettoken()\n        self.headers = {\n            'Connection': 'keep-alive',\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.193 Safari/537.36',\n            'Referer': 'https://www.kuaidi100.com/?from=openv',\n            'Cookie': 'csrftoken=' + csrftoken + '; WWWID=WWWF4FCD42239B8DAC700F22E0571D3952D; Hm_lvt_22ea01af58ba2be0fec7c11b25e88e6c=1615603420,1615603495,1616232321,1616289581; Hm_lpvt_22ea01af58ba2be0fec7c11b25e88e6c=1616289592'\n        }\n"}, {"ctype": "p", "data": "（3）获取快递名称"}, {"ctype": "code", "data": "# 获取快递名\n    def getname(self):\n        rous = requests_html.HTMLSession().post(self.name_url, params=self.number_params)\n        name = rous.json()['auto'][0]['comCode']\n        return name\n"}, {"ctype": "p", "data": "（4）获取csrftoken"}, {"ctype": "code", "data": "# 获取token\n    def gettoken(self):\n        rous = requests_html.HTMLSession().get(self.token_url, params=self.token_params)\n        Set_Cookie = rous.headers['Set-Cookie']\n        csrftoken = re.findall(', csrftoken=(.*?);', Set_Cookie)[0]\n        return csrftoken\n"}, {"ctype": "p", "data": "（5）获取所有转运信息"}, {"ctype": "code", "data": "# 获取转运信息\n    def getdata(self):\n        # 转运信息参数\n        Session = requests_html.HTMLSession()\n        rous = Session.get(self.url, headers=self.headers, params=self.params)\n        print(rous.text)\n        datas = rous.json()['data']\n        for data in datas:\n            print(data)\n"}, {"ctype": "p", "data": "（6）然后再启动它，搞定"}], "cate": "Python"}
{"题目": "173. 二叉搜索树迭代器", "作者": "achong_2050", "发布时间": "2021-03-28 11:04:01", "内容": [{"ctype": "head", "data": "1. 题目描述"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328110333564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FjaG9uZ18yMDUw,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "2. 解法1 扁平化法"}, {"ctype": "code", "data": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass BSTIterator:\n    def __init__(self, root: TreeNode):\n        self.id = -1\n        self.elements = []   # 升序保存元素\n        self.in_order(root)  # dfs搜索二叉树\n\n    def in_order(self, root):\n        if root is None:\n            return\n        self.in_order(root.left)\n        self.elements.append(root.val)\n        self.in_order(root.right)\n\n    def next(self) -> int:\n        # 移位取值\n        self.id += 1\n        return self.elements[self.id]\n\n    def hasNext(self) -> bool:\n        num = len(self.elements)\n        if self.id+1 < num:\n            return True\n        return False\n"}], "cate": "Python"}
{"题目": "逻辑教育爬虫班笔记2", "作者": "weixin_49167820", "发布时间": "2021-03-28 12:34:31", "内容": [{"ctype": "p", "data": "1.指数的输入："}, {"ctype": "code", "data": "a=2\nb=a*10**8\nprint(b)\n"}, {"ctype": "p", "data": "结果：  2.字符串与数字的乘积："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328111400748.png"}, {"ctype": "code", "data": "c='4'*3\t\t#等同于'4'+'4'+'4'\nprint(c)\nprint(type(c))\n"}, {"ctype": "p", "data": "结果：  3.负数整除和取余： 规则：余数必须是非负数，-10=d//3+d%3"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328111621705.png"}, {"ctype": "code", "data": "d=-10\nprint(d//3)\nprint(d%3)\n"}, {"ctype": "p", "data": "结果：  而不是-3和-1"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328112435195.png"}, {"ctype": "p", "data": "4.字符串的不等号比较："}, {"ctype": "code", "data": "print('1'<'2')\t\t#ascⅡ\nprint('3'<'2')\t\nprint('13'<'2')\t\t#一个字符一个字符的比较\nprint('a'<'b')\nprint('aa'>'ab')\n"}, {"ctype": "p", "data": "结果：  5.is和is not"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032811294215.png"}, {"ctype": "code", "data": "#is比较两个对象的ID是否相同\n#is not\n\ne=1\nf=e\nprint(f is e)\nprint(f is not e)\n"}, {"ctype": "p", "data": "结果：  6.布尔值：Tue 和 False 在进行逻辑判断的时候，除了0 空串 None 和一些表示空性的值会转换为False,其余的都是True运算。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328113334660.png"}, {"ctype": "code", "data": "g=2==True\nprint(g)\n\nh=1 is True\nprint(h)\n"}, {"ctype": "p", "data": "结果："}, {"ctype": "p", "data": " 7.逻辑与、或的非布尔值"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328113826840.png"}, {"ctype": "code", "data": "#与：找False，如果第一个值是False，则不看第二个值，直接返回第一个值，反之则返回第二个值\nre=1 and 2\nprint(re)\nfr=0 and 3\nprint(fr)\n#或：找True，如果第一个值是True，则不看第二个值，直接返回第一个值，反之则返回第二个值\nk=0 or 3\nprint(k)\ni=False or 0\nprint(i)\n"}, {"ctype": "p", "data": "结果：  8.运算符优先级对照表：其中，and的优先级高于or"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328114547196.png"}, {"ctype": "code", "data": "print(2 or 3 and 4)\n"}, {"ctype": "p", "data": "结果：  9.三元运算符： 语句1 if 条件表达式 else 语句2 (满足表达式就返回语句1，否则返回语句2)"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328114930863.png"}, {"ctype": "code", "data": "x=20\ny=30\np=x if y>x else y\nprint(p)\n\n"}, {"ctype": "p", "data": "结果：  10、a,b=b,a #相当于重新赋值，道理和x=x+1一样"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328115243748.png"}, {"ctype": "code", "data": "a=1\nb=2\na,b=b,a\nprint(a,b)\n\nc=1\nd=2\nc=d\nd=c\nprint(d,c)\n"}, {"ctype": "p", "data": "结果：  "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328115630339.png"}], "cate": "Python"}
{"题目": "python数字类型", "作者": "风之梦丽", "发布时间": "2021-03-28 11:16:41", "内容": [{"ctype": "code", "data": "#!usr/bin/python\n#coding=UTF-8\n\n#Python3数字（Number）\n''''''\n'''\npython数字类型：\n    数字类型不允许改变的，如果改变数据类型的值，则将重新分配内存空间\n    整型（Int）：python3整型没有限制大小，也可以当作Long类型（长整型）使用。\n    浮点型（Float）：浮点型由整数部分与小数部分组成\n    复数（Complex）：复数由实数部分和虚数部分构成\n'''\n\nnum1 = 10\nprint(id(num1)) #输出 2326657985104\nnum1 = 5\nprint(id(num1)) #输出 2326657984944\nnum1 = 10\nprint(id(num1)) #输出 2326657985104\n\n'''\npython数字类型转换\n    int(x)：将x转换为一个整数。\n    float(x)：将x转换到一个浮点数。\n    complex(x)：将x转换到一个复数，实数部分为 x，虚数部分为 0。\n    complex(x, y)：将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n'''\n\nval1 = 10.5\nprint(type(val1))   #输出     <class 'float'>\nval2 = int(val1)\nprint(val2)         #输出     10\nprint(type(val2))   #输出     <class 'int'>\nval3 = complex(val1)\nprint(val3)         #输出     10.5+0j\nprint(type(val3))   #输出     <class 'complex'>\n\na = 10\nb = float(a)\nprint(b,type(b))    #输出     10.0 <class 'float'>\nc = 5.2\nd = complex(a,c)\nprint(d,type(d))    #输出     (10+5.2j) <class 'complex'>\n\n'''\npython数字运算\n    不同类型的数混合运算时会将整数转换为浮点数：\n    +，-，*，/，%，//\n    /   除法  总是返回一个浮点数\n    %   取余  得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。\n    //  取商向下取整  得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。\n'''\n\na = 10\nb = 2\nc = a / b\nprint(c,type(c))    #输出     5.0 <class 'float'>\nd = a % b\nprint(d,type(d))    #输出     0 <class 'int'>\nd = 10.0 % 3\nprint(d,type(d))    #输出     1.0 <class 'float'>\nd = 10 % 3\nprint(d,type(d))    #输出     1 <class 'int'>\nd = 12 % 5.0\nprint(d,type(d))    #输出     2.0 <class 'float'>\n\nd = 12 // 2\nprint(d,type(d))    #输出     6 <class 'int'>\nd = 12.0 // 2\nprint(d,type(d))    #输出     6.0 <class 'float'>\nd = 12 // 2.0\nprint(d,type(d))    #输出     6.0 <class 'float'>\nd = 11 // 2\nprint(d,type(d))    #输出     5 <class 'int'>\nd = 11.2 // 2.0\nprint(d,type(d))    #输出     5.0 <class 'float'>\n\na = 4 * 5.0 - 3\nprint(a,type(a))    #输出     17.0 <class 'float'>\n\n'''\npython数学函数\n    1、abs(x)    返回数字的绝对值\n    2、ceil(x)   返回数字的向上取整整数\n    3、exp(x)    返回x的指数 ex,math.exp(x)\n    4、fabs(x)   返回数字的绝对值\n    5、floor(x)  返回数字的向下取整整数\n    6、log(x)    返回x的自然对数，x > 0。\n    7、log10(x)  返回以10为基数的x对数，x > 0。\n    8、max(x1,x2,x3,...)     返回给定参数的最大值\n    9、min(x1,x2,x3,...)     返回给定参数的最小值\n    10、modf(x)  返回x的整数部分和小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。\n    11、pow(x,y) 返回 xy（x的y次方）的值\n    12、round(x,n)   对x进行四舍五入，n代表保留小数点后的位数\n    13、sqrt(x)  返回x的平方根\n'''\n'''\nabs() 是内置函数。 \nfabs() 函数在 math 模块中定义。\nfabs() 函数只对浮点型跟整型数值有效。 abs() 还可以运用在复数中。\n\npow(x,y) 内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。\n'''\n\nimport math     # 导入 math 模块\na = -20.5\nb = 20.5\nprint(abs(a),abs(b))    #输出 20 20.5\nprint(math.ceil(a),math.ceil(b))    #输出 -20 21\nprint(math.exp(1))      #输出 2.718281828459045\nprint(math.fabs(-10))   #输出 10.0\n#print(math.fabs(5+6j)) #报错 can't convert complex to float\nprint(abs(5+6j))        #输出 7.810249675906654\nprint(math.floor(-10.5),math.floor(5.6))    #输出 -11 5\nprint(math.log(2),math.log(5))    #输出 0.6931471805599453 1.6094379124341003\nprint(math.log10(2),math.log10(5))    #输出 0.3010299956639812 0.6989700043360189\nprint(max(-10,5.5,-6.5,10)) #输出 10\nprint(min(-10.5,5.5,-6,10)) #输出 -10.5\nprint(math.modf(12.5),math.modf(-25.62),math.modf(26)) #输出   (0.5, 12.0) (-0.620000000000001, -25.0) (0.0, 26.0)\nprint(math.pow(2,5),pow(2,5),pow(2.5,5))    #输出 32.0 32 97.65625\nprint(math.sqrt(2),math.sqrt(4)) #输出 1.4142135623730951 2.0\nprint(round(5.235,2),round(-5.235,1),round(10,3),round(10.000,3),round(2.675, 2) )   #输出 5.24 -5.2 10 10.0 2.67\n\nprint(round(6.236,2),round(6.1351,2)) #输出 6.24 6.14\nprint(round(11.5), round(12.5), round(13.5))   #输出 12 12 14\nprint(round(2.5), round(1.5))   #输出 2 2\nprint(round(6.105,2), round(6.115,2), round(6.125,2), round(6.135,2), round(6.145,2), round(6.155,2), round(6.165,2), round(6.175,2), round(6.185,2), round(6.195,2))\n#输出 6.11 6.12 6.12 6.13 6.14 6.16 6.17 6.17 6.18 6.2\nprint(round(2.105,2), round(2.115,2), round(2.125,2), round(2.135,2), round(2.145,2), round(2.155,2), round(2.165,2), round(2.175,2), round(2.185,2), round(2.195,2))\n#输出 2.1 2.12 2.12 2.13 2.15 2.15 2.17 2.17 2.19 2.19\n'''\nround() \n    1、四舍五入成整数时，把 x 四舍五入为最近的偶数倍数；\n    2、浮点数的取舍遵循的是四舍六入五平分，“五平分”就是根据取舍的位数前的小数奇偶性来判断，奇偶平分。奇数则舍弃，偶数则加一。\n    \n    python3.9,按测试数据来看，round() 取舍为整数时 四舍五入是正确的，而浮点数取舍规则好像也不是四舍六入五平分。\n    对于round()方法大家如果有更好的四舍五入规则解释，请留言。\n如果开发中数值精度要求高的，不建议使用该函数。\n'''\n\n\n'''\npython随机数函数\n    choice(seq)     返回一个列表，元组或字符串的随机项,seq 可以是一个列表，元组或字符串。\n    randrange([start,] stop [,step])     返回指定递增基数集合中的一个随机数，基数默认值为1。\n        start   指定范围内的开始值，包含在范围内。\n        stop    指定范围内的结束值，不包含在范围内。\n        step    指定递增基数。\n    randint(statr,stop)     生成一个指定范围内的整数。\n    random()    返回随机生成的一个实数，它在[0,1)范围内。\n    seed()      改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数，没有返回值。\n    shuffle()   将序列的所有元素随机排序。\n    uniform(x,y)将随机生成下一个实数，它在 [x,y] 范围内。\n        返回一个浮点数 N，取值范围为如果 x<y 则 x <= N <= y，如果 y<x 则y <= N <= x。\n'''\nimport random\nprint(random.choice([2,6,4,67,44]),random.choice((2,6,4,67,44)),random.choice('choicetest')) #输出 2 44 c\nprint(random.randrange(1,100,3), random.randrange(100))    #输出 70 60\nprint(random.randint(5,10)) #输出 8\nprint(random.random())   #输出 0.34356751647778594\nrandom.seed(10)\nprint(random.random())   #输出 0.5714025946899135\n\nlist1 = [55,33,22,12,11,5]\nrandom.shuffle(list1)\nprint(list1)    #输出 [22, 33, 11, 55, 5, 12]\nrandom.shuffle(list1)\nprint(list1)    #输出 [5, 12, 22, 33, 11, 55]\n\nprint(random.uniform(1,10)) #输出 3.9499553045988383\n"}], "cate": "Python"}
{"题目": "基于pyvista的三维矩阵数据显示", "作者": "开拓者5号", "发布时间": "2021-03-28 13:43:07", "内容": [{"ctype": "p", "data": "pyvista是对vtk的封装，使用更简单。下面是一个简单的测试，显示三维随机场数据，从文件读取三维矩阵数据，三维网格显示，以及三个方向的切片显示。"}, {"ctype": "code", "data": "import numpy as np\nimport pyvista as pv\nfrom argon2 import __main__\n\n\n\ndef createRegularMesh(values, origin, cellSize):\n    # 首先类似于新建一个空的矩阵\n    grid = pv.UniformGrid()\n    \n    # 然后设置维度，如果想给cell填充数据则维度设置为 矩阵shape + 1，\n    # 如果是给point填充数据指定为矩阵shape\n    # 填充cell，颜色就不是渐变的，是每个块一个颜色，正好和ct的数据一样。\n    grid.dimensions = np.array(values.shape) + 1\n    \n    # 设置origin和spacing，这两个参数正好和ct的参数一个意思。\n    grid.origin = origin  # The bottom left corner of the data set\n    grid.spacing = cellSize  # These are the cell sizes along each axis\n    \n    # 设置（网格）矩阵的值\n    grid.cell_arrays[\"values\"] = values.flatten(order=\"F\")  # Flatten the array!\n    \n    return grid\n    \ndef showRegularGrid3D(values, origin, cellSize):\n    gridMesh = createRegularMesh(values, origin, cellSize)    \n    # plot\n    gridMesh.plot(show_edges=False)\n    \ndef showRegularSlice3D(values, origin, cellSize, slicex, slicey, slicez):\n    #指定三维数据场，顶点坐标，网格尺寸，以及三个方向切片的坐标\n    gridMesh = createRegularMesh(values, origin, cellSize)    \n    #指定x y z三个方向的坐标\n    slices = gridMesh.slice_orthogonal(x=slicex, y=slicey, z=slicez)\n    slices.plot()\n    \ndef readArray3D(ni, nj, nk, fileName, headInfoNum):\n    #读取三维矩阵数据\n    #矩阵数据按行排列，从外向内，分别为k循环，j循环，和i循环。\n    dat=np.loadtxt(fileName, skiprows = headInfoNum)\n    print(dat.shape)\n    #设置矩阵维数\n    values = np.reshape(dat, (nk,nj,ni)).transpose(2,1,0)\n    return values\n    \ndef test1():\n    _values = np.random.rand(10,10,5)\n    print(_values.shape)\n    _origin=(0,0,0)\n    _cellSize=(1,1,1)\n    showRegularGrid3D(_values,_origin, _cellSize)\n\ndef test2():\n    _fileName = R\"./../../../CASE2/readTIArray_temp.ecl\"\n    _ni = 100\n    _nj = 100\n    _nk = 20\n    _headInfoNum=1\n    _origin=(0,0,0)\n    _cellSize=(10,10,5)\n    _values = readArray3D(_ni, _nj, _nk, _fileName, _headInfoNum)\n    print(_values.shape)\n    showRegularGrid3D(_values,_origin, _cellSize)\n\ndef test3():\n    _fileName = R\"./../../../CASE2/readTIArray_temp.ecl\"\n    _ni = 100\n    _nj = 100\n    _nk = 20\n    _headInfoNum=1\n    _origin=(0,0,0)\n    _cellSize=(10,10,5)\n    _values = readArray3D(_ni, _nj, _nk, _fileName, _headInfoNum)\n    print(_values.shape)\n    _slicex=_ni*_cellSize[0]\n    _slicey=1*_cellSize[1]\n    _slicez=_nk*_cellSize[2]\n    showRegularSlice3D(_values,_origin, _cellSize, _slicex, _slicey, _slicez)   \n\nif __name__== \"__main__\":\n    #test1()\n    #test2()\n    test3()"}, {"ctype": "p", "data": "产生随机数三维矩阵，test1()"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032811503966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmZlbmcxMDIy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": "读取三维矩阵数据并显示,test2(),其中矩阵数据按行排列，从外向内，分别为k循环，j循环，和i循环。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328133951915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmZlbmcxMDIy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "切片显示方式"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328144402704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmZlbmcxMDIy,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "参考资料"}, {"ctype": "p", "data": "https://blog.csdn.net/u012925804/article/details/105292081"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "《Python金融大数据风控建模实战》 第17章 集成学习", "作者": "小成星际", "发布时间": "2021-03-28 14:51:06", "内容": [{"ctype": "head", "data": "本章引言"}, {"ctype": "p", "data": "集成学习旨在通过训练多个模型，扩展假设空间，进而逐步接近真实数据集中蕴含的规则。同时，多个训练模型同时陷入局部最小值的概率较低，保证了测试集可以得到相对较优的结果。 目前，集成学习大致可分为两种：并行的集成方法Bagging和串行的集成方法Boosting。并行的集成方法中，基学习器的构建是相互独立的，没有先后顺序，可以同时进行建模。而串行的集成方法中，各个基学习器之间有强烈的依赖关系，即后一个模型是在前一个模型的基础上建立的。集成学习的核心是优势互补，因此如何增加基学习器的独立性和多样性是集成学习的关键，不同的算法有不同的策略。"}, {"ctype": "head", "data": "Python代码实现及注释"}, {"ctype": "code", "data": "# 第17章：集成学习\n\nimport os\nimport sys\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nimport variable_encode as var_encode\nfrom sklearn.metrics import confusion_matrix,recall_score, auc, roc_curve,precision_score,accuracy_score\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom xgboost import XGBClassifier\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['font.sans-serif']=['SimHei']   \nmatplotlib.rcParams['axes.unicode_minus']=False  \nimport warnings\nwarnings.filterwarnings(\"ignore\") ##忽略警告\n##数据读取\ndef data_read(data_path,file_name):\n    df = pd.read_csv( os.path.join(data_path, file_name), delim_whitespace = True, header = None )\n    ##变量重命名\n    columns = ['status_account','duration','credit_history','purpose', 'amount',\n               'svaing_account', 'present_emp', 'income_rate', 'personal_status',\n               'other_debtors', 'residence_info', 'property', 'age',\n               'inst_plans', 'housing', 'num_credits',\n               'job', 'dependents', 'telephone', 'foreign_worker', 'target']\n    df.columns = columns\n    ##将标签变量由状态1,2转为0,1;0表示好用户，1表示坏用户\n    df.target = df.target - 1\n      ##数据分为data_train和 data_test两部分，训练集用于得到编码函数，验证集用已知的编码规则对验证集编码\n    data_train, data_test = train_test_split(df, test_size=0.2, random_state=0,stratify=df.target)\n    return data_train, data_test\n##离散变量与连续变量区分   \ndef category_continue_separation(df,feature_names):\n    categorical_var = []\n    numerical_var = []\n    if 'target' in feature_names:\n        feature_names.remove('target')\n    ##先判断类型，如果是int或float就直接作为连续变量\n    numerical_var = list(df[feature_names].select_dtypes(include=['int','float','int32','float32','int64','float64']).columns.values)\n    categorical_var = [x for x in feature_names if x not in numerical_var]\n    return categorical_var,numerical_var\nif __name__ == '__main__':\n    path = 'D:\\\\code\\\\chapter17'\n    data_path = os.path.join(path ,'data')\n    file_name = 'german.csv'\n    ##读取数据\n    data_train, data_test = data_read(data_path,file_name)\n    sum(data_train.target ==0)\n    data_train.target.sum()\n    ##区分离散变量与连续变量\n    feature_names = list(data_train.columns)\n    feature_names.remove('target')\n    categorical_var,numerical_var = category_continue_separation(data_train,feature_names)\n    \n    ###离散变量直接WOE编码\n    var_all_bin = list(data_train.columns)\n    var_all_bin.remove('target')\n    ##训练集WOE编码\n    df_train_woe, dict_woe_map, dict_iv_values ,var_woe_name = var_encode.woe_encode(data_train,data_path,categorical_var, data_train.target,'dict_woe_map', flag='train')\n    ##测试集WOE编码\n    df_test_woe, var_woe_name = var_encode.woe_encode(data_test,data_path,categorical_var, data_test.target, 'dict_woe_map',flag='test')\n    \n    #####连续变量缺失值做填补\n    for i in numerical_var:\n        if sum(data_train[i].isnull()) >0:\n            data_train[i].fillna(data_train[i].mean(),inplace=True)\n            \n\n    ###组成分箱后的训练集与测试集\n    data_train.reset_index(drop=True,inplace=True)\n    data_test.reset_index(drop=True,inplace=True)\n    var_1 = numerical_var\n    var_1.append('target')\n    data_train_1 = pd.concat([df_train_woe[var_woe_name],data_train[var_1]],axis=1)\n    data_test_1 = pd.concat([df_test_woe[var_woe_name],data_test[var_1]],axis=1) \n    \n    ####取出训练数据与测试数据\n    var_all = list(data_train_1.columns)\n    var_all.remove('target')\n\n    ####变量归一化\n    scaler = StandardScaler().fit(data_train_1[var_all])\n    data_train_1[var_all] = scaler.transform(data_train_1[var_all])  \n    data_test_1[var_all] = scaler.transform(data_test_1[var_all])\n\n    x_train = np.array(data_train_1[var_all])\n    y_train = np.array(data_train_1.target)\n    \n    x_test = np.array(data_test_1[var_all])\n    y_test = np.array(data_test_1.target)\n        \n   \n    ########随机森林模型\n    ##设置待优化的超参数\n    rf_param = {'n_estimators': list(range(50, 400, 50)),\n                'max_depth': list(range(2, 10, 1)),\n                'class_weight': [{1: 1, 0: 1}, {1: 2, 0: 1}, {1: 3, 0: 1}]}\n    ##初始化网格搜索\n    rf_gsearch = GridSearchCV(estimator=RandomForestClassifier(random_state=0, criterion='entropy',\n                                                                max_features=0.8, bootstrap=True),\n                              param_grid=rf_param, cv=3, scoring='f1', n_jobs=-1, verbose=2)\n    ##执行超参数优化\n    rf_gsearch.fit(x_train, y_train)\n    print('RandomForest model best_score_ is {0},and best_params_ is {1}'.format(rf_gsearch.best_score_,\n                                                                                 rf_gsearch.best_params_))\n    ##模型训练\n    ##用最优参数，初始化随机森林模型\n    RF_model_2 = RandomForestClassifier(random_state=0, n_jobs=-1, criterion='entropy',\n                                        n_estimators=rf_gsearch.best_params_['n_estimators'],\n                                        max_depth=rf_gsearch.best_params_['max_depth'],\n                                        max_features=0.8,\n                                        min_samples_split=50,\n                                        class_weight=rf_gsearch.best_params_['class_weight'],\n                                        bootstrap=True)\n    ##训练随机森林模型\n    RF_model_2_fit = RF_model_2.fit(x_train, y_train)\n    \n    ##属性\n#    ss = RF_model_2_fit.estimators_\n#    RF_model_2_fit.classes_\n#    RF_model_2_fit.n_features_\n#    RF_model_2_fit.feature_importances_\n    \n    \n    ##模型预测\n    y_pred = RF_model_2_fit.predict(x_test)\n    ##计算混淆矩阵与recall、precision\n    cnf_matrix = confusion_matrix(y_test, y_pred)\n    recall_value = recall_score(y_test, y_pred)\n    precision_value = precision_score(y_test, y_pred)\n    acc = accuracy_score(y_test, y_pred)\n    print(cnf_matrix)\n    print('Validation set:  model recall is {0},and percision is {1}'.format(recall_value,\n                 precision_value)) \n    \n   \n    ##变量重要性排序\n    ##取出变量重要性结果\n    len_1 = len(RF_model_2.feature_importances_)\n    var_name = [str(x).split('_woe')[0] for x in var_all]\n    ##重要性绘图\n    plt.figure(figsize=(10,6))\n    fontsize_1 = 14\n    plt.barh(np.arange(0,20),RF_model_2.feature_importances_,color =\n     'c',tick_label=var_name)\n    plt.xticks( fontsize=fontsize_1)\n    plt.yticks( fontsize=fontsize_1)\n    plt.show()\n\n    \n    ###Adaboost模型\n    ##设置待优化的超参数\n    ada_param = {'n_estimators': list(range(50, 500, 50)),\n                'learning_rate': list(np.arange(0.1, 1, 0.2))}\n    ##初始化网格搜索\n    ada_gsearch = GridSearchCV(estimator=AdaBoostClassifier(algorithm='SAMME.R',random_state=0),\n                              param_grid=ada_param, cv=3,  n_jobs=-1, verbose=2)\n     ##执行超参数优化\n    ada_gsearch.fit(x_train, y_train)\n    print('AdaBoostClassifier model best_score_ is {0},and best_params_ is {1}'.format(ada_gsearch.best_score_,\n                                                                                 ada_gsearch.best_params_))\n    ##模型训练\n    ##用最优参数，初始化Adaboost模型\n    ada_model_2 = AdaBoostClassifier( n_estimators=ada_gsearch.best_params_['n_estimators'],\n                                        learning_rate=ada_gsearch.best_params_['learning_rate'],\n                                        algorithm='SAMME.R',random_state=0)\n    ##训练adaboost模型\n    ada_model_2_fit = ada_model_2.fit(x_train, y_train)\n    \n    \n    ##模型预测\n    y_pred = ada_model_2_fit.predict(x_test)\n    ##计算混淆矩阵与recall、precision\n    cnf_matrix = confusion_matrix(y_test, y_pred)\n    recall_value = recall_score(y_test, y_pred)\n    precision_value = precision_score(y_test, y_pred)\n    acc = accuracy_score(y_test, y_pred)\n    print(cnf_matrix)\n    print('Validation set:  model recall is {0},and percision is {1}'.format(recall_value,\n                 precision_value)) \n    \n    ###查看模型训练过程准确率的变化\n    ##取出训练过程中模型得分\n    n_estimators = ada_gsearch.best_params_['n_estimators']\n    per_train = list(ada_model_2_fit.staged_score(x_train, y_train))\n    per_test= list(ada_model_2_fit.staged_score(x_test, y_test))\n    ##预测准确率绘图\n    plt.figure(figsize=(10,6))\n    fontsize_1 = 14\n    plt.plot(np.arange(0,n_estimators),per_train,'--',color ='c',label='训练集')\n    plt.plot(np.arange(0,n_estimators),per_test,':',color ='b',label='测试集')\n    plt.xticks( fontsize=fontsize_1)\n    plt.yticks( fontsize=fontsize_1)\n    plt.xlabel('n_estimators',fontsize=fontsize_1)\n    plt.ylabel('score',fontsize=fontsize_1)\n    plt.legend(fontsize=fontsize_1)\n    plt.show()\n    \n    ####GBDT模型\n    ##设置待优化的超参数\n    gbdt_param = {'n_estimators': list(range(50, 400, 50)),\n                'max_depth': list(range(2, 5, 1)),\n                'learning_rate': list(np.arange(0.01, 0.5, 0.05)) }\n    ##初始化网格搜索\n    gbdt_gsearch = GridSearchCV(estimator=GradientBoostingClassifier( subsample=0.8,max_features=0.8, validation_fraction=0.1, \n                                                                   n_iter_no_change =3,random_state=0),param_grid=gbdt_param, \n                                                                   cv=3, scoring='f1', n_jobs=-1, verbose=2)\n    ##执行超参数优化\n    gbdt_gsearch.fit(x_train, y_train)\n    print('gbdt model best_score_ is {0},and best_params_ is {1}'.format(gbdt_gsearch.best_score_,\n                                                                                 gbdt_gsearch.best_params_))\n    ##模型训练\n    ##用最优参数，初始化GBDT模型\n    GBDT_model= GradientBoostingClassifier(subsample=0.8,max_features=0.8, validation_fraction=0.1, \n                                                      n_iter_no_change =3,random_state=0 ,\n                                        n_estimators=gbdt_gsearch.best_params_['n_estimators'],\n                                        max_depth=gbdt_gsearch.best_params_['max_depth'],\n                                        learning_rate=gbdt_gsearch.best_params_['learning_rate'])\n    ##训练GBDT模型\n    GBDT_model_fit = GBDT_model.fit(x_train, y_train)\n    \n    \n    ###看一下混沌矩阵\n    y_pred = GBDT_model_fit.predict(x_test)\n    cnf_matrix = confusion_matrix(y_test, y_pred)\n    recall_value = recall_score(y_test, y_pred)\n    precision_value = precision_score(y_test, y_pred)\n    acc = accuracy_score(y_test, y_pred)\n    print(cnf_matrix)\n    print('Validation set:  model recall is {0},and percision is {1}'.format(recall_value,\n                 precision_value)) \n    \n    ###xgboost模型\n    ##设置待优化的超参数\n    xgb_param = {'max_depth': list(range(2, 6, 1)), 'min_child_weight': list(range(1, 4, 1)),\n                 'learning_rate': list(np.arange(0.01, 0.3, 0.05)), 'scale_pos_weight': list(range(1, 5, 1))}\n    ##初始化网格搜索\n    xgb_gsearch = GridSearchCV(\n        estimator=XGBClassifier(random_state=0, n_estimators=500, subsample=0.8, colsample_bytree=0.8),\n        param_grid=xgb_param, cv=3, scoring='f1', n_jobs=-1, verbose=2)\n    ##执行超参数优化\n    xgb_gsearch.fit(x_train, y_train)\n    print('xgboost model best_score_ is {0},and best_params_ is {1}'.format(xgb_gsearch.best_score_,\n                                                                          xgb_gsearch.best_params_))\n    ##用最优参数，初始化xgboost模型\n    xgboost_model = XGBClassifier(random_state=0, n_jobs=-1,\n                                    n_estimators=500,\n                                    max_depth=xgb_gsearch.best_params_['max_depth'],\n                                    subsample=0.8, colsample_bytree=0.8,\n                                    learning_rate=xgb_gsearch.best_params_['learning_rate'],\n                                    scale_pos_weight=xgb_gsearch.best_params_['scale_pos_weight'])\n    ##训练xgboost模型\n    xgboost_model_fit = xgboost_model.fit(x_train, y_train)\n\n    \n    ##模型预测\n    y_pred = xgboost_model_fit.predict(x_test)\n    ##计算混淆矩阵与recall、precision\n    cnf_matrix = confusion_matrix(y_test, y_pred)\n    recall_value = recall_score(y_test, y_pred)\n    precision_value = precision_score(y_test, y_pred)\n    acc = accuracy_score(y_test, y_pred)\n    print(cnf_matrix)\n    print('Validation set:  model recall is {0},and percision is {1}'.format(recall_value,\n                 precision_value)) \n    \n    ##给出概率预测结果\n    y_score_test = xgboost_model_fit.predict_proba(x_test)[:, 1]\n    ##计算AR。gini等\n    fpr, tpr, thresholds = roc_curve(y_test, y_score_test)\n    roc_auc = auc(fpr, tpr)\n    ks = max(tpr - fpr)\n    ar = 2*roc_auc-1\n    print('test set:  model AR is {0},and ks is {1},auc={2}'.format(ar,\n                 ks,roc_auc)) \n    ####ks曲线\n    plt.figure(figsize=(10,6))\n    fontsize_1 = 12\n    plt.plot(np.linspace(0,1,len(tpr)),tpr,'--',color='black')\n    plt.plot(np.linspace(0,1,len(tpr)),fpr,':',color='black')\n    plt.plot(np.linspace(0,1,len(tpr)),tpr - fpr,'-',color='grey')\n    plt.grid()\n    plt.xticks( fontsize=fontsize_1)\n    plt.yticks( fontsize=fontsize_1)\n    plt.xlabel('概率分组',fontsize=fontsize_1)\n    plt.ylabel('累积占比%',fontsize=fontsize_1)\n    \n\n"}], "cate": "Python"}
{"题目": "python选股并导入通达信自选股", "作者": "Ctp接口量化", "发布时间": "2021-03-28 14:53:36", "内容": [{"ctype": "code", "data": "\"\"\"\n关注公众号: Ctp接口量化\n\"\"\"\nimport time\nfrom 手机版选股 import *\nths_user = Wencai() \n# ths_user.login(Config[\"userid\"],Config[\"password\"])# 登陆交易账号 \ndef 选股():   \n    # # # 交投活跃股    \n    # 条件 = '（成交额/总市值）>5%,成交额>10亿'\n    # 条件 = '连续三天量比>2,成交额>10亿'\n    条件 = '周平均换手率>10%，成交额>10亿'    \n    # # # 超跌选股    \n    # 条件 = '周rsi(rsi24值)上穿30'  \n    # 条件 = '周rsi(rsi24值)上穿30，涨幅<3%'\n    # 条件 = '周rsi(rsi24值)上穿30，涨幅<3%，量比>3'\n    # 条件 = '周rsi(rsi24值)上穿30，涨幅<3%，量比>3,换手率大于3%'\n    # 条件 = '周rsi(rsi24值)上穿30，涨幅<3%，量比>3,换手率大于3%，成交额>10亿'\n     \n    # 条件 = '周rsi(rsi24值)小于30，日kdj金叉，量比大于1'\n    # 条件 = '周rsi(rsi24值)小于30，日k上穿30，量比大于2'\n    # 条件 = '周rsi(rsi24值)小于30，日kdj金叉，量比大于1'\n    # 条件 = '周rsi(rsi24值)小于30，日rsi(rsi24值)上移，量比大于1'\n    # 条件 = '周rsi(rsi24值)小于30，日rsi(rsi24值)上穿30，量比大于1'    \n    # # # 财务选股\n    # 条件 = '连续三年毛利率率大于50%'  \n    # 条件 = '连续三年净利润同比增长率大于10%'  \n    # 条件 = '连续三年净利润同比增长率大于10%,连续三年净资产同比增长率大于10%'\n    # 条件 = '连续三年净利润同比增长率大于10%,连续三年净资产同比增长率大于10%,连续三年营业收入同比增长率大于50%'\n    # 条件 = '连续三年净利润同比增长率大于10%,连续三年净利润同比增长率大于10%，连续三年毛利率同比增长率大于10%，连续三年净资产同比增长率大于10%，连续三年营业收入同比增长率大于10%'\n    # 条件 = '基金重仓'\n    # 条件 = '基金重仓，基金连续3个季度增仓'\n    # 条件 = '基金重仓，基金连续3个季度增仓,机构持股占总股本大于30%'\n    # 条件 = '贸易战受益股'\n    \n    # 条件 = '60分钟周期MACD底背离，涨幅<3%'\n    # 条件 = '60分钟周期MACD底背离，涨幅<3%，量比>1.5'    \n    Data_list = ths_user.Xuangu(条件) #调用选股函数 传入选股条件\n    for i in Data_list:\n        print(i[\"代码\"][:-3])\n        # print(i)      \n        # 开仓 = ths_user.buy(stock_code=i[\"代码\"][:-3],price=i[\"价格\"],amount=1000)      #同花顺\n        # print(开仓)\n        保存(i[\"代码\"][:-3])       \ndef 保存(stock_code):\n    stock_code = str(stock_code)\n    if stock_code.startswith(('50', '51', '60', '688', '73', '90', '110', '113', '132', '204', '78')):\n        code = '1'+stock_code\n    if stock_code.startswith(('00', '13', '18', '15', '16', '18', '20', '30', '39', '115', '1318')):\n        code = '0'+stock_code\n    F = open(\"E:\\\\TDX\\\\T0002\\\\blocknew\\\\ZXG.blk\",\"a\")#添加到通达信自选股\n    F.write(code+'\\n')\n    F.close  \n\ndef 止损止盈(止损=-300,止盈=1500):\n    ths_user.qryChedan()    # 撤销全部委托\n    全部持仓 = ths_user.qryChicang()    # 全部持仓\n    for pos in 全部持仓:\n        print(\"=\"*30)\n        print(\"编号\",pos[\"d_3001\"])\n        print(\"证券代码\",pos[\"d_2102\"])\n        print(\"证券名称\",pos[\"d_2103\"])\n        print(\"可用余额\",pos[\"d_2121\"])\n        print(\"成本价\",pos[\"d_2122\"])\n        print(\"市价\",pos[\"d_2124\"])\n        print(\"市值\",pos[\"d_2125\"])\n        print(\"浮动盈亏\",pos[\"d_2147\"])\n        if float(pos[\"d_2147\"]) <= float(止损) or float(pos[\"d_2147\"]) > float(止盈):\n            stock = ths_user.sell( stock_code=pos[\"d_2102\"], price=pos[\"d_2124\"], amount=pos[\"d_2121\"], volume=0, entrust_prop='limit')\n            print(\"平仓\")\ndef 定时():\n    while True:\n        time.sleep(6)\n        _time = time.strftime('%H%M%S')\n        if _time == '100100':\n            选股()\n        # if _time == '102500' or _time == '112500' or _time == '132600' or _time == '142500':\n            # 止损止盈() \n        止损止盈()        \nif __name__ == '__main__':\n    选股()\n    \n    \n\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032814524782.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTc1MjQ5,size_16,color_FFFFFF,t_70#pic_center"}], "cate": "Python"}
{"题目": "Python刷题——第3周", "作者": "YoungHeez", "发布时间": "2021-03-28 16:59:27", "内容": [{"ctype": "p", "data": "这周刷题情况：  知识点："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328162109278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDM0NTU4NA==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "1.关于字符串的逆序输出方法（接上）： 通过索引"}, {"ctype": "code", "data": "strA = \"123456789\"\nstrA[::-1]\n——————————————\n→'987654321'\n"}, {"ctype": "p", "data": "借组列表进行翻转"}, {"ctype": "code", "data": "#coding=utf-8 \nstrA = raw_input(\"请输入需要翻转的字符串：\")\norder = [] \nfor i in strA:\n  order.append(i)\norder.reverse()         //将列表反转\nprint ''.join(order)    //将list转换成字符串\n\n"}, {"ctype": "p", "data": "2.关于进制的函数使用（3-9） ①int() 其他进制转换到十进制 ②bin() 十进制转换到二进制 ③oct() 十进制转换到八进制 ④hex() 十进制转换到十六进制"}, {"ctype": "code", "data": "v = 265        //任何自然数都成立\nnum = bin(v)   //函数名在这里变化选择\nprint(num)\n\n"}, {"ctype": "p", "data": "3.关于ASCII码与字符的转换"}, {"ctype": "p", "data": "1、输入字符转换为ASCII码输出：ord(‘字符’)"}, {"ctype": "code", "data": "ch=input(\"请输入一个字符：\")\nprint(ch,\"的ASCII码为：\",ord(ch))\n \n#请输入一个字符：A\nA 的ASCII码为： 65\n \n"}, {"ctype": "p", "data": "2、输入ASCII码转换为相应的字符并输出：chr(ASCII码)"}, {"ctype": "code", "data": "ch=input(\"请输入对应的ASCII码：\")\nch=int(ch)     #以字符串的形式接收键盘输入的内容，所以要对其进行转换\nprint(ch,\"的ASCII码为：\",chr(ch))\n \n#请输入对应的ASCII码：99\n99 的ASCII码为： c\n\n"}], "cate": "Python"}
{"题目": "Codility: BinaryGap", "作者": "爱咖啡的野指针", "发布时间": "2021-03-28 16:28:53", "内容": [{"ctype": "head", "data": "BinaryGap: Find longest sequence of zeros in binary representation of an integer (Easy)"}, {"ctype": "p", "data": "A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N."}, {"ctype": "p", "data": "For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps."}, {"ctype": "p", "data": "Write a function:"}, {"ctype": "p", "data": "def solution(N)"}, {"ctype": "p", "data": "that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn’t contain a binary gap."}, {"ctype": "p", "data": "For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation ‘100000’ and thus no binary gaps."}, {"ctype": "p", "data": "Write an efficient algorithm for the following assumptions:"}, {"ctype": "p", "data": "N is an integer within the range [1…2,147,483,647]."}, {"ctype": "code", "data": "# O(n)\ndef solution(N):\n    # write your code in Python 3.6\n    binstr = bin(N)\n    binary = binstr[2:]\n    #print(binary)\n    count = 0\n    temp = 0\n    for i in range(1, len(binary)):\n        a = binary[i]\n        if a == \"0\":\n            temp += 1\n        elif a == \"1\":\n            if temp > count:\n                count = temp\n            temp = 0\n    return count\n"}, {"ctype": "p", "data": "碎碎念： 原来想通过连续两个1的index difference来找……在index(), indexof()的用法上花了一点时间，因为忘记了如果找不到是报错还是返回特定值。好在及时放弃了orz"}], "cate": "Python"}
{"题目": "opencv-python使用cv2.resize()函数批量放大图片", "作者": "Hey.�", "发布时间": "2021-03-28 17:06:27", "内容": [{"ctype": "p", "data": "python代码使用opencv中cv2.resize()函数批量放大图片，缩小也可。"}, {"ctype": "head", "data": "1. 需求描述"}, {"ctype": "p", "data": "最近想做一个人脸的跨数据集对比实验，之前的训练图片大小是240*240的，网络输入要求大小为224*224，现在要做实验的数据集图片大小为100*100，需要调整到符合网络输入要求的大小。"}, {"ctype": "head", "data": "2. 解决方法"}, {"ctype": "p", "data": "可以调整图片分辨率的方法很多，除了opencv之外，python自带的PIL工具包也可以处理，这里只说使用opencv的处理方法。"}, {"ctype": "head", "data": "1）首先了解cv2.resize()函数"}, {"ctype": "p", "data": "官网解释如下：  其中各个参数含义："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328164004403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tyeXN0YWx5eXk=,size_16,color_FFFFFF,t_70"}, {"ctype": "table", "data": "scr:原图可以是一张或多张图片dsize：输出图像尺寸根据自己需要的尺寸指定，数据形状为（H,W,C）fx:沿水平轴的比例因子这个基本不用自己指定，默认就好fy:沿垂直轴的比例因子同上interpolation：插值方法可选最近邻插值、双线性插值（默认设置）、4x4像素邻域的双三次插值等，平衡计算时间和效果，双线性插值效果已经可以达到要求"}, {"ctype": "head", "data": "2）具体代码"}, {"ctype": "code", "data": "import os\nimport cv2\n\ndatadir = \"D:\\\\pycharm_program\\\\RAFDB\\\\test\"\n\n'''设置目标像素大小，此处设为240'''\nIMG_SIZE = 240\n\n'''使用os.path模块的join方法生成路径'''\npath = os.path.join(datadir)\n\n'''使用os.listdir(path)函数，返回path路径下所有文件的名字，以及文件夹的名字'''\nimg_list = os.listdir(path)\n\nfor i in img_list:\n    img_array = cv2.imread(os.path.join(path, i), cv2.IMREAD_COLOR)\n    '''调用cv2.resize函数resize图片'''\n    new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))\n    img_name = str(i)  # 保存的图片与处理前图片同名\n    '''生成图片存储的目标路径'''\n    save_path = 'D:\\\\pycharm_program\\\\RAFDB\\output\\\\test\\\\'+str(i)\n    '''调用cv.2的imwrite函数保存图片'''\n    cv2.imwrite(save_path, new_array)\n\n"}, {"ctype": "p", "data": "此处参考https://blog.csdn.net/weixin_40446557/article/details/103823509，做了一些改动。"}, {"ctype": "head", "data": "3. 执行结果"}, {"ctype": "p", "data": "处理之前 "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328165913611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tyeXN0YWx5eXk=,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "处理之后  我的训练集有12271张图片，计算时间在20s左右，测试集3068张图片，大概5s左右。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328165657890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tyeXN0YWx5eXk=,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "4. 小结"}, {"ctype": "p", "data": "上午鼓捣半天各种插值方法，看到很多代码是从0开始构建，以为会很麻烦，结果opencv直接有现成的，还是要多多学习呀！"}], "cate": "Python"}
{"题目": "Python：给信号添加白噪声", "作者": "强劲九", "发布时间": "2021-03-28 17:12:26", "内容": [{"ctype": "head", "data": "1. 白噪声"}, {"ctype": "p", "data": "信噪比："}, {"ctype": "p", "data": "\n     \n      \n       \n        \n         S\n        \n        \n         N\n        \n        \n         R\n        \n        \n         =\n        \n        \n         10\n        \n        \n         \n          \n           log\n          \n          \n           ⁡\n          \n         \n         \n          10\n         \n        \n        \n         \n          \n           P\n          \n          \n           s\n          \n         \n         \n          \n           P\n          \n          \n           n\n          \n         \n        \n       \n       \n         SNR=10 \\log _{10} \\frac{P s}{P n} \n       \n      \n     SNR=10log10​PnPs​"}, {"ctype": "p", "data": "\n    \n     \n      \n       \n        \n         P\n        \n        \n         s\n        \n       \n      \n      \n       P_s\n      \n     \n    Ps​ 和 \n    \n     \n      \n       \n        \n         P\n        \n        \n         n\n        \n       \n      \n      \n       P_n\n      \n     \n    Pn​ 分别表示信号和噪声的有效功率，信噪比 SNR 的单位为 dB. 如果 \n    \n     \n      \n       \n        x\n       \n       \n        (\n       \n       \n        t\n       \n       \n        )\n       \n      \n      \n       x(t)\n      \n     \n    x(t) 和 \n    \n     \n      \n       \n        n\n       \n       \n        (\n       \n       \n        t\n       \n       \n        )\n       \n      \n      \n       n(t)\n      \n     \n    n(t) 分别为信号和噪声，则"}, {"ctype": "p", "data": "\n     \n      \n       \n        \n         S\n        \n        \n         N\n        \n        \n         R\n        \n        \n         =\n        \n        \n         10\n        \n        \n         \n          \n           log\n          \n          \n           ⁡\n          \n         \n         \n          10\n         \n        \n        \n         \n          \n           \n            ∑\n           \n           \n            \n             t\n            \n            \n             =\n            \n            \n             0\n            \n           \n           \n            \n             N\n            \n            \n             −\n            \n            \n             1\n            \n           \n          \n          \n           \n            x\n           \n           \n            2\n           \n          \n          \n           (\n          \n          \n           t\n          \n          \n           )\n          \n         \n         \n          \n           \n            ∑\n           \n           \n            \n             t\n            \n            \n             =\n            \n            \n             0\n            \n           \n           \n            \n             N\n            \n            \n             −\n            \n            \n             1\n            \n           \n          \n          \n           \n            n\n           \n           \n            2\n           \n          \n          \n           (\n          \n          \n           t\n          \n          \n           )\n          \n         \n        \n       \n       \n         SNR=10 \\log _{10} \\frac{\\sum_{t=0}^{N-1} x^{2}(t)}{\\sum_{t=0}^{N-1} n^{2}(t)} \n       \n      \n     SNR=10log10​∑t=0N−1​n2(t)∑t=0N−1​x2(t)​"}, {"ctype": "head", "data": "2. 给信号添加白噪声"}, {"ctype": "p", "data": "假设想要给信号添加 \n    \n     \n      \n       \n        s\n       \n       \n        n\n       \n       \n        r\n       \n       \n        =\n       \n       \n        50\n       \n      \n      \n       snr=50\n      \n     \n    snr=50 分贝的白噪声，则噪声功率为 \n    \n     \n      \n       \n        \n         P\n        \n        \n         n\n        \n       \n       \n        =\n       \n       \n        \n         \n          P\n         \n         \n          s\n         \n        \n        \n         \n          1\n         \n         \n          \n           0\n          \n          \n           \n            \n             S\n            \n            \n             N\n            \n            \n             R\n            \n           \n           \n            10\n           \n          \n         \n        \n       \n      \n      \n       P_n=\\frac{P_s}{10^{\\frac{SNR}{10}}}\n      \n     \n    Pn​=1010SNR​Ps​​，思路就是，生成标准正态分布随机信号，然后将其增加 \n    \n     \n      \n       \n        \n         \n          P\n         \n         \n          n\n         \n        \n       \n      \n      \n       \\sqrt{P_n}\n      \n     \n    Pn​\n\n\n​ 倍。"}, {"ctype": "code", "data": "import numpy as np\nimport matplotlib.pyplot as plt\n\ndef wgn(x, snr):\n    batch_size, len_x = x.shape\n    Ps = np.sum(np.power(x, 2)) / len_x\n    Pn = Ps / (np.power(10, snr / 10))\n    noise = np.random.randn(len_x) * np.sqrt(Pn)\n    return x + noise\n\nT = 100\nx = np.zeros((1, T)) + 35.\nsnr = 50\nx_noise = wgn(x, snr)\n\nplt.plot(x_noise[0])\nplt.plot(x[0])\nplt.ylim([30, 40])\nplt.show()\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328171043638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTY3OTM2Nw==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "p", "data": "参考："}, {"ctype": "p", "data": "给时序信号添加高斯白噪声python."}], "cate": "Python"}
{"题目": "matplotlib画柱状折线图设置双轴不同颜色，X轴中文标签竖排显示", "作者": "如是我聞……", "发布时间": "2021-03-28 17:49:48", "内容": [{"ctype": "p", "data": "matplotlib画柱状曲线图。从本月数据表、上月数据表两份表格中导入数据，计算环比增减幅度。本期数据画柱状图，环比增减百分比画折线图。 重点：设置双轴显示为不同颜色，主Y轴与柱状图同一颜色；辅助Y轴与折线图同一颜色。环比正增长率标红色，负增长率标蓝色。X轴中文标签竖排显示，这个竖排可不是旋转90度的那种哦。 先看看效果图吧 代码："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328172635429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqbTE5NzI=,size_16,color_FFFFFF,t_70"}, {"ctype": "code", "data": "import numpy as np\nimport pandas as pd #导入pandas库\nimport matplotlib.pyplot as plt\nplt.rcParams['font.sans-serif']=['SimHei']   # 用黑体显示中文\nplt.rcParams['axes.unicode_minus']=False     # 正常显示负号\n\ndata1 =  r'D:\\测试数据\\本月数据表.xlsx'  #指定一个表格，本月数据表\ndata2 =  r'D:\\测试数据\\上月数据表.xlsx'  #指定一个表格，上月的数据表\n# 读取两个表\ndf1 = pd.read_excel(data1, sheet_name=0,dtype=object,na_rep=\"\")#导入数据表\ndf2 = pd.read_excel(data2, sheet_name=0,dtype=object,na_rep=\"\")#导入数据表   \ndf1.rename(columns={'销售量':'本期销售量'},inplace = True)\ndf2.rename(columns={'销售量':'上期销售量'},inplace = True)\ndf2_1= pd.concat([df1,df2['上期销售量']],axis=1,join_axes=[df1.index])\ndf2_1['环比'] = df2_1.apply(lambda x: int(100*(x['本期销售量']-x['上期销售量'])/x['上期销售量']), axis=1)\nprint(df2_1)\ndf2_1.sort_values(by=\"本期销售量\",ascending = False,inplace=True)\nlabel_list0 = df2_1['地区'].values.tolist()#X轴标签名称\nprint(label_list0)\nnum_list1 = df2_1['环比'].values.tolist()#本期销售量环比增减\nnum_list2 = df2_1['本期销售量'].values.tolist()#本期销售量\nnum_list3 = df2_1.apply(lambda x: x['本期销售量']*(-1), axis=1).values.tolist()#本期销售量化成负数，画在X轴下面\n#print(num_list3)\ndf2_1[\"avg\"] = df2_1['环比'].mean(axis=0).round(2)*(-1)#平均增长率\ndf1[\"avg\"] = df1['本期销售量'].mean().round(2)#本期销售量平均增水平\n#print(df1[\"avg\"])\nnum_list4 = df2_1[\"avg\"].values.tolist()#辅助线\nnum_list5 = df1[\"avg\"].values.tolist()#辅助线\n\nplt.close() #清除之前的图形\nfig = plt.figure(figsize=(7,4),dpi=100)\nyy1 = max(num_list1)\nyy1_0 = min(num_list1)\nyy2 = max(num_list2)\nax=[]\nfor i in range(len(label_list0)):#X轴每个标签中插入换行符，让标签文字能竖排\n      ax.append(label_list0[i][0]+\"\\n\"+label_list0[i][-1])\nx=np.arange(len(label_list0))\nax1 = fig.add_subplot(111)\nax1.bar(ax, num_list2,width=0.5, align='center', color=\"r\",alpha=0.4)#label=u'本期销售量',\nax1.set_ylim(0,yy2+yy2/1.5) #Y轴的最大值加3分之一，可随变量而增减\nyy31=(yy2+yy2/2)/6# 轴最大值的6分之一，用于设置刻度标记\nyy21=(yy2+yy2/2)/6\nfor i in range(0,len(num_list2)):\n    if num_list2[i]>num_list5[0]:\n        plt.text(x[i], num_list2[i]/1.3, str(num_list2[i]),color=\"black\", ha='center', va='top',rotation=10,fontsize=9)\n    if num_list2[i]<=num_list5[0] :\n        plt.text(x[i], num_list2[i]/3, str(num_list2[i]),color=\"g\", ha='center', rotation=20,fontsize=9)\nax1.set_title('各地区销售量排名及环比变化图',fontsize=14)\n\nax2 = ax1.twinx()  # 定义双轴的右轴 \nax2.plot(ax,num_list1,linestyle='--',lw=1,marker='o',ms=4, label=u'环比增减％', color=\"b\",alpha=0.7)#环比增减幅度%\nfor line in ax2.yaxis.get_ticklines():# 去掉Y轴上的刻度    \n    line.set_markeredgewidth(0) # 去掉Y轴上的刻度，宽度设为0就是没刻度\nif yy1_0>=-100 and yy1<=100 and yy1>30:\n    ax2.set_ylim(yy1_0-50+yy1_0/2, yy1+50+yy1/4)  # Y轴的最大值加3分之一，可随变量而增减\nelif yy1_0>=-100 and yy1_0<0 and yy1>100 and yy1/yy1_0<-2:\n    ax2.set_ylim(yy1_0-100+yy1_0/4, yy1+yy1/6)  # Y轴的最大值加3分之一，可随变量而增减\nelse:\n    ax2.set_ylim(yy1_0+yy1_0, yy1+yy1/4)  # Y轴的最大值加3分之一，可随变量而增减\nyy11=(yy1+yy1/3)/9\n\nfor i in range(0,len(num_list1)):#设置数据值的位置\n    if num_list1[i]>0:\n        plt.text(x[i], num_list1[i]+yy11/6, str(num_list1[i]),color=\"r\", ha='center', va='bottom',fontsize=10)\n    else:\n        if yy1_0>=-100 and yy1_0<0 and yy1/yy1_0<-5 and yy1>400:\n            plt.text(x[i], num_list1[i]-20+yy1_0/5, str(num_list1[i]),color=\"b\", ha='center', fontsize=10)\n        elif yy1<100:\n            plt.text(x[i], num_list1[i]-5+yy1_0/5, str(num_list1[i]),color=\"b\", ha='center', fontsize=10)\n        else:\n            plt.text(x[i], num_list1[i]-10+yy1_0/5, str(num_list1[i]),color=\"b\", ha='center', fontsize=10)\n\n#设置坐标的大小、颜色\nplt.legend(loc='best', fontsize=10)\nax1.set_ylabel('本期销售数量',fontsize=11,color='r')#主Y轴\nax1.tick_params(axis='y', colors='r')#主Y轴颜色\nax2.set_ylabel('环比增减幅度％',fontsize=11,color='b')#辅助Y轴\nax2.tick_params(axis='y', colors='b')\n\nplt.plot(ax,num_list4,linestyle='--',lw=1, color=\"b\",alpha=0.3)#辅助线,平均值            \nplt.show()\n"}, {"ctype": "p", "data": "上月数据表：  本月数据表： "}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328174747227.png"}], "cate": "Python"}
{"题目": "关于RandomOverSampler与Pipeline的组合", "作者": "今人不见古时月 今月曾经照古人", "发布时间": "2021-03-28 18:03:27", "内容": [{"ctype": "head", "data": "关于RandomOverSampler与Pipeline的组合"}, {"ctype": "p", "data": "在数据预处理时，我尝试把RandomOverSampler放入到Pipeline中进行过采样，代码如下："}, {"ctype": "code", "data": "pipe = Pipeline([\n    ('scaler', MinMaxScaler()),\n    ('oversample', RandomOverSampler(random_state=42,shrinkage=0.1)),\n    ('polyer', PolynomialFeatures(2)),\n    ('selector', SelectKBest(mutual_info_classif, k=10)),\n    ('lda', LinearDiscriminantAnalysis()),\n    ('model', GaussianNB())\n])\n"}, {"ctype": "p", "data": "但是在运行过程中报错了，报错代码："}, {"ctype": "code", "data": "y_pred = cross_val_predict(pipe, X, y, cv=15, n_jobs=8)\n"}, {"ctype": "code", "data": "TypeError: All intermediate steps should be transformers and implement fit and transform or be the string 'passthrough' 'RandomOverSampler(random_state=42, shrinkage=0.1)' (type <class 'imblearn.over_sampling._random_over_sampler.RandomOverSampler'>) doesn't\n"}, {"ctype": "p", "data": "解决方法：imblearn库中的RandomOverSampler与sklearn库中Pipeline是不兼容的，应当使用imblearn中的make_pipeline或者Pipeline"}, {"ctype": "p", "data": "正确的代码如下："}, {"ctype": "code", "data": "from imblearn.pipeline import make_pipeline\npipe = make_pipeline(MinMaxScaler(),\n                     RandomOverSampler(random_state=42, shrinkage=0.05),\n                     LinearDiscriminantAnalysis(),\n                     GaussianNB())\n"}], "cate": "Python"}
{"题目": "transformers中TFBert等模型加载问题(two structures don‘t have the same nested structure)", "作者": "alwayschasing", "发布时间": "2021-03-28 18:56:49", "内容": [{"ctype": "p", "data": "如果将transformers中的tfbert等模型嵌入到自己的模型中，在保存与加载的时候可能会出现以下问题："}, {"ctype": "p", "data": "ValueError: The two structures don’t have the same nested structure."}, {"ctype": "p", "data": "First structure: type=dict str={‘input_ids’: TensorSpec(shape=(None, 5), dtype=tf.int32, name=‘input_ids/input_ids’)}"}, {"ctype": "p", "data": "Second structure: type=dict str={‘token_type_ids’: TensorSpec(shape=(None, 128), dtype=tf.int64, name=‘input_ids/token_type_ids’), ‘attention_mask’: TensorSpec(shape=(None, 128), dtype=tf.int64, name=‘input_ids/attention_mask’), ‘input_ids’: TensorSpec(shape=(None, 128), dtype=tf.int64, name=‘input_ids/input_ids’)}"}, {"ctype": "p", "data": "问题说明： 如果是直接使用bert(inputs) 调用，保存模型再加载就会出现上述问题"}, {"ctype": "p", "data": "原因： call() 函数没有添加@tf.function(signatures)注解，也就是没有定义输入数据格式， 如果直接保存模型恢复的时候没办法恢复输入数据的定义"}, {"ctype": "p", "data": "解决办法： 使用model.serving()函数  可以看出源码是实现了输入数据格式定义的，这样修改之后就咩有加载方面的问题了"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328185311370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpcnVpaG9uZ2JvYg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "python 计算牛顿差商，计算并化简牛顿插值多项式", "作者": "Panda_1875", "发布时间": "2021-03-28 19:10:30", "内容": [{"ctype": "head", "data": "1. 程序"}, {"ctype": "head", "data": "1.1 导入库"}, {"ctype": "code", "data": "import numpy as np\nimport sympy as sy"}, {"ctype": "head", "data": "1.2 函数"}, {"ctype": "code", "data": "def NewtonInt(x_value, y_value):\n    \"\"\"\n    计算牛顿插值差商表\n    :param x_value: x序列\n    :param y_value: y序列\n    :return: 差商表矩阵, 字符串插值多项式\n    \"\"\"\n    N=len(x_value)\n    res= np.zeros((N, N))\n    res[:, 0]= y_value\n    for i in range(1,N):    # i 阶\n        for j in range(N-i):  # j 个\n            res[j, i]= (res[j+1, i-1]- res[j, i-1])/(x_value[i + j] - x_value[j])\n            # print(\"y1=%f; y2=%f; x1=%f; x2=%f; res=%f; \"%(res[j+1, i-1], res[j, i-1],x[i+j], x[j], res[j,i]))\n\n    print(\"\\n 差商表:\\n   {:^16}{:^16}\".format(\"xi\",\"yi\"), end=\"\")\n    for i in range(1,N):\n        print(\"{:^14}\".format(\"{:2d}阶差商\".format(i)), end=\"\")\n    print(\"\")\n    for i in range(N):    # i 阶\n        print(\"%16.4E\" % (x_value[i]), end=\"\")\n        for j in range(i+1):  # j 个\n            print(\"%16.4E\"%res[i-j, j], end=\"\")\n        print(\"\")\n\n    # str_Nx= \"\\n\\nN(x)= \"\n    str_Nx=\"\"\n    for i in range(N):  # i 阶\n        str_Nx+= \"%f\"%res[0 , i]\n        for j in range(i):  # j 个\n            str_Nx +=\"*(x- %f)\" % x_value[j]\n        str_Nx+= \" + \"\n    print(\"\\n\\n原始多项式:\\n\"+ str_Nx[0:-3])\n    print(\"\\n\\n化简的多项式:\")\n    print(sy.simplify(str_Nx[0:-3]))\n    return res, str_Nx[0:-3]"}, {"ctype": "head", "data": "2.测试"}, {"ctype": "head", "data": "2.1 测试程序"}, {"ctype": "code", "data": "x_v=np.array([0.4, 0.55, 0.65, 0.8, 0.9, 1.05])\ny_v=np.array([0.41075, 0.57815, 0.69675, 0.88811, 1.02652, 1.25382])\n# x_v=np.array([0,1,2,5,3])\n# y_v=np.array([2,3,12,147,30])\nres, Nx= NewtonInt(x_v,y_v)"}, {"ctype": "head", "data": "2.2 输出结果"}, {"ctype": "code", "data": "差商表:\n          xi              yi            1阶差商          2阶差商          3阶差商          4阶差商          5阶差商     \n      4.0000E-01      4.1075E-01\n      5.5000E-01      5.7815E-01      1.1160E+00\n      6.5000E-01      6.9675E-01      1.1860E+00      2.8000E-01\n      8.0000E-01      8.8811E-01      1.2757E+00      3.5893E-01      1.9733E-01\n      9.0000E-01      1.0265E+00      1.3841E+00      4.3347E-01      2.1295E-01      3.1238E-02\n      1.0500E+00      1.2538E+00      1.5153E+00      5.2493E-01      2.2867E-01      3.1429E-02      2.9304E-04\n\n\n原始多项式:\n0.410750 + 1.116000*(x- 0.400000) + 0.280000*(x- 0.400000)*(x- 0.550000) + 0.197333*(x- 0.400000)*(x- 0.550000)*(x- 0.650000) + 0.031238*(x- 0.400000)*(x- 0.550000)*(x- 0.650000)*(x- 0.800000) + 0.000293*(x- 0.400000)*(x- 0.550000)*(x- 0.650000)*(x- 0.800000)*(x- 0.900000)\n\n\n化简的多项式:\n0.000293*x**5 + 0.0302711*x**4 + 0.1236151075*x**3 + 0.02961707125*x**2 + 0.9901178008*x + 0.00127484091999994\n"}, {"ctype": "p", "data": "与书本结果对比："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328190905398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eWx2,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": " "}, {"ctype": "p", "data": " "}], "cate": "Python"}
{"题目": "计算机视觉——图像处理", "作者": "Luminita79", "发布时间": "2021-03-28 21:49:10", "内容": [{"ctype": "p", "data": "计算机视觉——图像处理"}, {"ctype": "head", "data": "一、图像处理基本原理"}, {"ctype": "head", "data": "1.1灰度直方图"}, {"ctype": "p", "data": "灰度直方图反映的是一幅图像中各灰度级像素出现的频率。以灰度级为横坐标，纵坐标为灰度级的频率，绘制频率同灰度级的关系图就是灰度直方图。它是图像的一个重要特征，反映了图像灰度分布的情况。 频率公式为： \n    \n     \n      \n       \n        v\n       \n       \n        i\n       \n       \n        =\n       \n       \n        n\n       \n       \n        i\n       \n       \n        /\n       \n       \n        n\n       \n       \n        (\n       \n       \n        n\n       \n       \n        i\n       \n       \n        为\n       \n       \n        灰\n       \n       \n        度\n       \n       \n        为\n       \n       \n        i\n       \n       \n        的\n       \n       \n        像\n       \n       \n        元\n       \n       \n        个\n       \n       \n        数\n       \n       \n        ，\n       \n       \n        \n         n\n        \n        \n         i\n        \n       \n       \n        表\n       \n       \n        示\n       \n       \n        整\n       \n       \n        张\n       \n       \n        图\n       \n       \n        片\n       \n       \n        的\n       \n       \n        像\n       \n       \n        元\n       \n       \n        数\n       \n       \n        ，\n       \n       \n        n\n       \n       \n        表\n       \n       \n        示\n       \n       \n        把\n       \n       \n        灰\n       \n       \n        度\n       \n       \n        分\n       \n       \n        成\n       \n       \n        多\n       \n       \n        少\n       \n       \n        级\n       \n       \n        ，\n       \n       \n        该\n       \n       \n        实\n       \n       \n        验\n       \n       \n        分\n       \n       \n        为\n       \n       \n        256\n       \n       \n        级\n       \n       \n        )\n       \n      \n      \n       vi=ni/n(ni为灰度为i的像元个数，n_i表示整张图片的像元数，n表示把灰度分成多少级，该实验分为256级)\n      \n     \n    vi=ni/n(ni为灰度为i的像元个数，ni​表示整张图片的像元数，n表示把灰度分成多少级，该实验分为256级)"}, {"ctype": "head", "data": "1.2高斯滤波（高斯模糊）"}, {"ctype": "p", "data": "所谓”模糊”，可以理解成每一个像素都取周边像素的平均值。  上图中，2是中间点，周边点都是1。  “中间点”取”周围点”的平均值，就会变成1。在数值上，这是一种”平滑化”。在图形上，就相当于产生”模糊”效果，”中间点”失去细节。 显然，计算平均值时，取值范围越大，”模糊效果”越强烈。"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328191724688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg1ODE0MA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "1.3直方图均衡化"}, {"ctype": "p", "data": "把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布的技术。实质上是对图像进行非线性拉伸,重新分配图像象元值,使一定灰度范围内象元值的数量大致相等。这样,原来直方图中间的峰顶部分对比度得到增强,而两侧的谷底部分对比度降低,输出图像的直方图是一个较平的分段直方图:如果输出数据分段值较小的话,会产生粗略分类的视觉效果。直方图均衡化能起到增强图像对比度的作用。"}, {"ctype": "head", "data": "二、重要函数"}, {"ctype": "p", "data": "1、convert(‘L’)：将图片转变为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。 2、contour()：画出图片轮廓 3、rof.denoise()：基于rof的降噪处理 4、filters.gaussian_filter()：高斯模糊处理 5、imtools.histeq():用自带的工具包生成均衡化直方图"}, {"ctype": "head", "data": "三、实验代码和结果"}, {"ctype": "head", "data": "原图"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/2021032819423964.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg1ODE0MA==,size_16,color_FFFFFF,t_70#pic_center"}, {"ctype": "head", "data": "3.1灰度直方图"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328194331999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg1ODE0MA==,size_16,color_FFFFFF,t_70"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328193631881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg1ODE0MA==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3.2高斯滤波（高斯模糊）"}, {"ctype": "code", "data": "# encoding:utf-8\nfrom array import array\n\nfrom PIL import Image\nfrom pylab import *\n\nmpl.rcParams['font.sans-serif'] = ['SimHei']\nfrom numpy import *\n\nfrom scipy.ndimage import filters\n\nfrom PCV.tools import rof\n\nim = array(Image.open('C:/Users/apple/Desktop/images/1.jpg').convert('L'))\n\nU, T = rof.denoise(im, im)\nG = filters.gaussian_filter(im, 10)  # 第二个参数越大，图像越模糊\n\nfigure()\ngray()\n\nsubplot(1, 3, 1)\nimshow(im)\n# axis(‘equal’)\naxis('off')\ntitle(u'原噪声图像')\n\nsubplot(1, 3, 2)\nimshow(G)\n# axis(‘equal’)\naxis('off')\ntitle(u'高斯模糊后的图像')\n\nsubplot(1, 3, 3)\nimshow(U)\n# axis(‘equal’)\naxis('off')\ntitle(u'ROF降噪后的图像')\n\nshow()\n"}, {"ctype": "head", "data": "3.3直方图均衡化"}, {"ctype": "code", "data": "# -- coding: utf-8 --\nfrom PIL import Image\nfrom pylab import *\nmpl.rcParams['font.sans-serif'] = ['SimHei']\nfrom PCV.tools import imtools\n\nim = array(Image.open('C:/Users/apple/Desktop/images/1.jpg').convert('L'))\n\nim2, cdf = imtools.histeq(im)\n\nfigure()\nsubplot(2, 2, 1)\naxis('off')\ngray()\ntitle(u'原始图像')\nimshow(im)\n\nsubplot(2, 2, 2)\naxis('off')\ntitle(u'直方图均衡化后的图像')\nimshow(im2)\n\nsubplot(2, 2, 3)\naxis('off')\ntitle(u'均衡化后的直方图' )\n\nhist(im.flatten(), 128, normed=True)\n\nsubplot(2, 2, 4)\naxis('off')\ntitle(u'均衡化后的直方图')\n\nhist(im2.flatten(), 128, normed=True)\n\nshow()\n\n"}, {"ctype": "head", "data": "四、总结"}, {"ctype": "p", "data": "1、这些相对基础的图像处理在上学期已经通过数字图像处理这门课中稍微有所了解，只不过当是用matlab编写的，和python相比，有部分相同之处也有所不同。 2、初学python，python可以调用其他许多第三方库之类的，用起来很方便。 3、代码中出现pcv的包安装失败导致代码无法输出结果。"}], "cate": "Python"}
{"题目": "Python实战小项目—绘制圣诞树送给女朋友叭", "作者": "学Python的安娴", "发布时间": "2021-03-28 20:49:30", "内容": [{"ctype": "p", "data": "发现一个很好玩的小实战，今天分享给大家，教你怎样用Python画了一棵圣诞树，快来学习。"}, {"ctype": "p", "data": "如何用Python画一个圣诞树呢？"}, {"ctype": "p", "data": "效果图："}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328204724599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI5MzIwMg==,size_16,color_FFFFFF,t_70"}, {"ctype": "p", "data": "感觉这个还不是很美，嘿嘿我在去找找研究研究看看还有没有更新的优化的圣诞树代码"}, {"ctype": "p", "data": "喜欢的拿走代码记得帮我点个赞，关注留言一下好吗~谢谢啦"}, {"ctype": "p", "data": "源码："}, {"ctype": "code", "data": "from turtle import *\nimport random\nimport time\n\nn = 100.0\n\nspeed(\"fastest\")\nscreensize(bg='seashell')\nleft(90)\nforward(3*n)\ncolor(\"orange\", \"yellow\")\nbegin_fill()\nleft(126)\n\nfor i in range(5):\n    forward(n/5)\n    right(144)\n    forward(n/5)\n    left(72)\nend_fill()\nright(126)\n\ncolor(\"dark green\")\nbackward(n*4.8)\ndef tree(d, s):\n    if d <= 0: return\n    forward(s)\n    tree(d-1, s*.8)\n    right(120)\n    tree(d-3, s*.5)\n    right(120)\n    tree(d-3, s*.5)\n    right(120)\n    backward(s)\ntree(15, n)\nbackward(n/2)\n\nfor i in range(200):\n    a = 200 - 400 * random.random()\n    b = 10 - 20 * random.random()\n    up()\n    forward(b)\n    left(90)\n    forward(a)\n    down()\n    if random.randint(0, 1) == 0:\n            color('tomato')\n    else:\n        color('wheat')\n    circle(2)\n    up()\n    backward(a)\n    right(90)\n    backward(b)\n\ntime.sleep(60)"}, {"ctype": "p", "data": "有什么问题都可以留言咨询我哈"}], "cate": "Python"}
{"题目": "模拟登录1-古诗文网", "作者": "黑啤是真的皮", "发布时间": "2021-03-28 21:29:41", "内容": [{"ctype": "code", "data": "import requests\nfrom lxml import etree\nfrom PIL import Image\nimport pytesseract\n\nurl = 'https://so.gushiwen.cn/user/login.aspx'\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36'\n}\n\ndef login():\n    session = requests.Session()\n    resonpse = session.get(url=url,headers=headers)\n    tree = etree.HTML(resonpse.text)\n    code_img_src = 'https://so.gushiwen.cn/' + tree.xpath('//*[@id=\"imgCode\"]/@src')[0]\n    viewstate = tree.xpath('//*[@id=\"__VIEWSTATE\"]/@value')[0]\n    img_data = session.get(url = code_img_src, headers = headers).content\n    with open('img.jpg','wb') as f:\n        f.write(img_data)\n\n    image = Image.open('img.jpg')\n    #需要将图片转为RGB格式\n    image = image.convert('RGB')\n    code = pytesseract.image_to_string(image)\n    if(len(code) >= 4):\n        code = code[:4]\n        print('验证码为:'+ code)\n        # 组织fromdata\n        data = {\n            '__VIEWSTATE' : viewstate,\n            '__VIEWSTATEGENERATOR': 'C93BE1AE',\n            'email': 'xxxx',\n            'pwd': 'xxxx',\n            'code': code,\n            'denglu': '登录'\n        }\n        response = session.post(url=url,data=data)\n        if(response.status_code == 200):\n            print(len(response.text))\n            tree = etree.HTML(response.text)\n            login_flag = tree.xpath('//*[@id=\"html\"]/body/div[2]/div[1]/span[1]')\n            if(login_flag):\n                print('登录成功！')\n            else:\n                print('login failed !')\n                return login()\n    else:\n        print('识别失败，重新登录！')\n        return login()\n\n\n# 由于tesserate识别准确录太低,所以进行了多次识别，登录成功后才返回\nif __name__ == '__main__': \n    login()\n"}, {"ctype": "p", "data": "对于这种简单的字符验证码可以借助tesseract等orc来进行识别，虽然免费，但是识别准确率较低。"}, {"ctype": "head", "data": "登录效果"}, {"ctype": "code", "data": "AZ3S.\n验证码为:AZ3S\n13011\nlogin failed !\nPM28\n验证码为:PM28\n13853\n登录成功！\n"}, {"ctype": "head", "data": "对于这种简单的字符验证码分为以下几种情况"}, {"ctype": "head", "data": "1.验证码的url不变，验证码也不变"}, {"ctype": "code", "data": "这种情况最简单，直接解析出验证码的url,直接向验证码的url发起请求，保存验证码，然后进行识别\n"}, {"ctype": "head", "data": "2. 验证码的url不变，验证码一直在变"}, {"ctype": "code", "data": "这种情况在向目标网址发起请求时，实例化一个session,用session来维持会话，并用session来向验证码的url发起请求（本例就是此种形式）\n\n"}], "cate": "Python"}
{"题目": "Python编程---while循环", "作者": "yanlaifan", "发布时间": "2021-03-28 21:24:07", "内容": [{"ctype": "head", "data": "                                         while循环"}, {"ctype": "head", "data": "1、产生随机数"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328213733392.png"}, {"ctype": "code", "data": "andy@andy-virtual-machine:~/python_test$ cat example.py \n#! /usr/bin/python\n#coding:utf-8\nimport random\n\na = random.randint(1,100)\nprint a \n\t\nandy@andy-virtual-machine:~/python_test$ ./example.py \n97\nandy@andy-virtual-machine:~/python_test$ ./example.py \n80\nandy@andy-virtual-machine:~/python_test$ ./example.py \n94\nandy@andy-virtual-machine:~/python_test$ ./example.py \n41\nandy@andy-virtual-machine:~/python_test$ \n"}, {"ctype": "head", "data": "2、猜数字游戏"}, {"ctype": "code", "data": "andy@andy-virtual-machine:~/python_test$ cat example.py \n#! /usr/bin/python\n#coding:utf-8\nimport random\n\nrandom_num = random.randint(1,100)\nprint \"random_num is %d\"%(random_num)\n\nguess_num = 0\nguess_count=0\n\nwhile True:\n\tguess_count += 1\n\tprint \"please input your guess number:\"\n\tguess_num = raw_input()\n\tif not guess_num.isdigit():\n\t\tprint \"you need input an integer,please try again\"\n\t\tcontinue\n\telif int(guess_num) > 100 or int(guess_num )< 1:\n\t\tprint \"the integer need between 1 and 100\"\n\t\tcontinue\n\telif int(guess_num) == random_num:\n\t\tprint \"congratulations to you,the number you guessed is correct!!!\"\n\t\tbreak\n\telif guess_count  > 10:\n\t\tprint \"the number of guessing is more than 10\"\n\t\tbreak\n\t\nandy@andy-virtual-machine:~/python_test$ \n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328220940324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmxhaWZhbg==,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "3、continue"}, {"ctype": "p", "data": "退出本次循环，进行下一轮循环。"}, {"ctype": "code", "data": "#! /usr/bin/python\n#coding:utf-8\n\nx=3\nloop = 0\nwhile True:\n\tloop += 1\n\tif x >= 10:\n\t\tprint \"exit program\"\n\t\tbreak\n\telif x > 0:\n\t\tx += 1\n\t\tprint \"loop = %d\"%(loop)\n \t\tcontinue\n\t\tprint \"operate print function after continue\"\n\t\n\t\t\n\t\t\nandy@andy-virtual-machine:~/python_test$ \n"}, {"ctype": "p", "data": " "}, {"ctype": "head", "data": "4、break"}, {"ctype": "p", "data": "退出while循环。代码同3。"}, {"ctype": "head", "data": "5、while....else...."}, {"ctype": "code", "data": "andy@andy-virtual-machine:~/python_test$ cat example.py \n#! /usr/bin/python\n#coding:utf-8\n\nx=1\nloop = 0\nwhile loop  <= 10:\n\tloop += 1\n\tif x >= 10:\n\t\tprint \"x is more than 10\"\n\telif x > 0:\n\t\tx += 1\n\t\tprint \"loop = %d\"%(loop)\n \t\tcontinue\n\t\tprint \"operate print function after continue\"\nelse:\n\tprint \"exit while loop structure!!!\"\n"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210328222731932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmxhaWZhbg==,size_16,color_FFFFFF,t_70"}], "cate": "Python"}
{"题目": "Python爬虫| Ajax动态解密", "作者": "六音公子", "发布时间": "2021-03-28 22:22:15", "内容": [{"ctype": "head", "data": "前言"}, {"ctype": "p", "data": "我们经常浏览网页的时候，用鼠标不断往下滑，总是会刷新出新的网页信息，接着往下滑，还是会刷新出新的网页信息。总之，在一个url链接保持不变的情况下，用鼠标拖着往下滑，总会看到新的网页信息（比如说今日头条，网易新闻，微博，豆瓣电影等）。"}, {"ctype": "p", "data": "那么，对于这类网页，我们用python爬虫要怎么去抓取数据呢？先跟着小编看下面的知识点："}, {"ctype": "head", "data": "Ajax"}, {"ctype": "p", "data": "Ajax全称为 Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），它是一种利用 JavaScript 在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。 对传统的网页来说，如果想更新其内容则必须刷新整个页面。有了 Ajax，便可以在页面不被全部刷新的情况下更新其内容。在此过程中，页面实际上在后台与服务器进行了数据交互，获取到数据之后，再利用 JavaScript 改变网页，这样网页内容就会更新了。如果网页的原始 HTML 不包含任何数据，数据都是通过 Ajax 统一加载后再呈现出来的，这在 Web 开发上可以做到前后端分离，并且降低服务器直接渲染页面带来的压力，也能有效防止爬虫。对于 Ajax，数据加载是一种异步加载方式，原始页面不会包含某些数据，只有在加载完后，才会向服务器请求某个接口获取数据，然后数据才被处理从而呈现到网页上，这个过程实际上就是向服务器接口发送了一个 Ajax 请求。此时我们需要分析网页后台向接口发送的 Ajax 请求，用 requests 来"}], "cate": "Python"}
{"题目": "灰度图mask，里边内容缩小2个像素点", "作者": "心平气和呀", "发布时间": "2021-03-28 22:09:45", "内容": [{"ctype": "code", "data": "import os\nimport cv2\nimport PIL\nfrom unet import unet\nfrom utils import *\nfrom PIL import Image\npath_tu = \"/media/workstation/4.0T/result/skin/\"\n# 该文件夹下所有的文件（包括文件夹）\nfilename_list = os.listdir(path_tu)  # 返回指定路径下的文件和文件夹列表\n#print(filename_list[0][0:5])\nfilename_list.sort(key=lambda x: int(x[:5]))\nfor files_name in filename_list:\n    list=[]\n    #print(os.path.join(path_tu, files_name))\n    img_yuan = cv2.imread(os.path.join(path_tu, files_name), 0)\n    img=img_yuan.copy()\n    for i in range(0, 360):\n        for j in range(0, 360):\n            if img[i][j] > 55:\n                if i!=359 and i!=0 and j!=359 and j!=0: #不在边上，\n                    if  img[i+1][j-1]==0 or img[i+1][j]==0 or img[i+1][j+1]==0 or img[i][j-1]==0  or img[i][j+1]==0 or img[i-1][j-1]==0 or img[i-1][j]==0 or img[i-1][j+1]==0:\n                        #print(i,j)\n                        list.append([i,j])\n    #print(list)\n    #i=0\n    for p in range(int(len(list))):\n        #print(p)\n        img[int(list[p][0])][int(list[p][1])] = 0\n\n        img[int(list[p][0])+1][int(list[p][1])-1]=0\n        img[int(list[p][0])+1][int(list[p][1])] = 0\n        img[int(list[p][0])+1][int(list[p][1])+1] = 0\n\n        img[int(list[p][0])][int(list[p][1])-1] = 0\n        img[int(list[p][0])][int(list[p][1])+1] = 0\n\n        img[int(list[p][0])-1][int(list[p][1])-1] = 0\n        img[int(list[p][0])-1][int(list[p][1])] = 0\n        img[int(list[p][0])-1][int(list[p][1])+1] = 0\n        #img[int(list[p][0])][int(list[p][1])] = 0\n        #print(img[int(list[p][0])][int(list[p][1])])\n        #print(img_yuan[int(list[p][0])][int(list[p][1])],'****')\n\n    for k in range(360): #直接锁定 边上两 列or行 全是黑色\n        img[0][k]=0\n        img[1][k] = 0\n\n        img[358][k]=0\n        img[359][k] = 0\n\n        img[k][0] = 0\n        img[k][1] = 0\n\n        img[k][358] = 0\n        img[k][359] = 0\n    # \n    # for kk in range(360):\n    #     print(img[359][kk])\n    cv2.imwrite(os.path.join('/media/workstation/4.0T/result/skin_min/',files_name[:5] +'_skin_min'+ '.png'), img)  # test_results.\n    print(os.path.join('/media/workstation/4.0T/result/skin_min/',files_name[:5] +'_skin_min'+ '.png'))\n\n\n\n\n\n\n"}], "cate": "Python"}
{"题目": "2021-03-28", "作者": "瑾明达2号", "发布时间": "2021-03-28 22:35:33", "内容": [{"ctype": "p", "data": "题目描述 有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。"}, {"ctype": "p", "data": "现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。"}, {"ctype": "p", "data": "输入描述: 第一行两个整数n, x (2<=n<=10^5, 1<=x<=n)，代表房间房间数量以及最后一个人被分配的房间号； 第二行n个整数 a_i(0<=a_i<=10^9) ，代表每个房间分配后的人数。 输出描述: 输出n个整数，代表每个房间分配前的人数。"}, {"ctype": "p", "data": "示例1： 输入 3 1 6 5 1"}, {"ctype": "p", "data": "输出 4 4 4"}, {"ctype": "code", "data": "n, x = map(int, input().split())\ndata = list(map(int, input().split()))\nend = x - 1\n# 最小值不一定是要分配的房间，但是要重新分配的房间目前的数量一定是最小值\nmin_val = min(data)\ndata = [i- min_val for i in data]\n\ncount = min_val * n\n# data[end] == 0表示此房间之前的房间是分配之前的状态了\nwhile data[end] != 0:\n    data[end] -= 1\n    count += 1\n    end -= 1\n    if end < 0:\n        end = n - 1\ndata[end] = count\n\nprint(' '.join(list(map(str, data))))\n\n\n"}], "cate": "Python"}
{"题目": "天池热身赛——心跳信号模型融合", "作者": "安联之夜", "发布时间": "2021-03-28 23:32:56", "内容": [{"ctype": "p", "data": "代码来源于Datawhale开源社区。"}, {"ctype": "head", "data": "关于模型融合"}, {"ctype": "p", "data": "模型融合是比赛后期一个重要的环节，大体来说有如下的类型方式。"}, {"ctype": "head", "data": "一、简单加权融合:"}, {"ctype": "p", "data": "对于回归问题，可以使用算术平均融合，几何平均融合； 对于分类问题，可以使用投票的方法；"}, {"ctype": "head", "data": "二、构建多层模型"}, {"ctype": "p", "data": "即通过拟合多个模型，再分别预测出结果，再将结果做简单的算术融合。常见的方法有Stacking融合，具体过程可以参考这篇blog，讲得很清楚！"}, {"ctype": "head", "data": "三、boosting/bagging"}, {"ctype": "p", "data": "即通过集成学习的方法，提升准确率。"}, {"ctype": "head", "data": "代码实践"}, {"ctype": "p", "data": "其实模型融合的原理并不难，因此可以直接上代码和数据进行理解。"}, {"ctype": "head", "data": "预处理"}, {"ctype": "head", "data": "导入所需要的库"}, {"ctype": "code", "data": "import pandas as pd\nimport numpy as np\nimport warnings\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nwarnings.filterwarnings('ignore')\n%matplotlib inline\n\nimport itertools\nimport matplotlib.gridspec as gridspec\nfrom sklearn import datasets\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.naive_bayes import GaussianNB \nfrom sklearn.ensemble import RandomForestClassifier,RandomForestRegressor\n# from mlxtend.classifier import StackingClassifier\nfrom sklearn.model_selection import cross_val_score, train_test_split\n# from mlxtend.plotting import plot_learning_curves\n# from mlxtend.plotting import plot_decision_regions\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import train_test_split\nimport lightgbm as lgb\nfrom sklearn.neural_network import MLPClassifier,MLPRegressor\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n"}, {"ctype": "head", "data": "定义降内存的函数"}, {"ctype": "code", "data": "def reduce_mem_usage(df):\n    start_mem = df.memory_usage().sum() / 1024**2 \n    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        else:\n            df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() / 1024**2 \n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) / start_mem))\n    \n    return df\n"}, {"ctype": "head", "data": "导入数据与预处理"}, {"ctype": "code", "data": "train = pd.read_csv('D:/data/train.csv')\ntest=pd.read_csv('D:/data/testA.csv')\n\n# 简单预处理\ntrain_list = []\nfor items in train.values:\n    train_list.append([items[0]] + [float(i) for i in items[1].split(',')] + [items[2]])\n    \ntest_list = []\nfor items in test.values:\n    test_list.append([items[0]] + [float(i) for i in items[1].split(',')])\n\ntrain = pd.DataFrame(np.array(train_list))\ntest = pd.DataFrame(np.array(test_list))\n\n# id列不算入特征\nfeatures = ['s_'+str(i) for i in range(len(train_list[0])-2)] \ntrain.columns = ['id'] + features + ['label']\ntest.columns = ['id'] + features\n\ntrain = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)\n"}, {"ctype": "head", "data": "划分数据集"}, {"ctype": "code", "data": "# 根据8：2划分训练集和校验集\nX_train = train.drop(['id','label'], axis=1)\ny_train = train['label']\n\n# 测试集\nX_test = test.drop(['id'], axis=1)\n\n# 第一次运行可以先用一个subdata，这样速度会快些\nX_train = X_train.iloc[:50000,:20]\ny_train = y_train.iloc[:50000]\nX_test = X_test.iloc[:,:20]\n\n# 划分训练集和测试集\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.2)\n"}, {"ctype": "head", "data": "定义训练函数"}, {"ctype": "p", "data": "提前建立所需的模型，这里分别建立了随机森林、LightGBM和神经网络模型。"}, {"ctype": "code", "data": "# 单模函数\ndef build_model_rf(X_train,y_train):\n    model = RandomForestRegressor(n_estimators = 100)\n    model.fit(X_train, y_train)\n    return model\n\ndef build_model_lgb(X_train,y_train):\n    model = lgb.LGBMRegressor(num_leaves=63,learning_rate = 0.1,n_estimators = 100)\n    model.fit(X_train, y_train)\n    return model\n\ndef build_model_nn(X_train,y_train):\n    model = MLPRegressor(alpha=1e-05, hidden_layer_sizes=(5, 2), random_state=1,solver='lbfgs')\n    model.fit(X_train, y_train)\n    return model\n"}, {"ctype": "head", "data": "加权融合"}, {"ctype": "p", "data": "首先我们进行加权融合，大致思路如下，对每个模型都进行拟合，再进行预测，预测的形式为概率。随后三个模型的概率进行加权计算，得到的最终结果为最终的结果。"}, {"ctype": "head", "data": "拟合与预测"}, {"ctype": "code", "data": "print('predict rf...')\nmodel_rf = build_model_rf(X_train,y_train)\nval_rf = model_rf.predict(X_val)\nsubA_rf = model_rf.predict(X_test)\n\nprint('predict lgb...')\nmodel_lgb = build_model_lgb(X_train,y_train)\nval_lgb = model_lgb.predict(X_val)\nsubA_lgb = model_rf.predict(X_test)\n\nprint('predict NN...')\nmodel_nn = build_model_nn(X_train,y_train)\nval_nn = model_nn.predict(X_val)\nsubA_nn = model_rf.predict(X_test)\n"}, {"ctype": "head", "data": "定义加权函数"}, {"ctype": "p", "data": "在参数缺省的情况下，默认都为1/3。"}, {"ctype": "code", "data": "def Weighted_method(test_pre1,test_pre2,test_pre3,w=[1/3,1/3,1/3]):\n    Weighted_result = w[0]*pd.Series(test_pre1)+w[1]*pd.Series(test_pre2)+w[2]*pd.Series(test_pre3)\n    return Weighted_result\n"}, {"ctype": "head", "data": "进行加权计算"}, {"ctype": "p", "data": "这里自定义权重进行加权计算，加即可得到最终结果进行提交。"}, {"ctype": "code", "data": "w = [0.2, 0.6, 0.2]\nsubA = Weighted_method(subA_rf,subA_lgb,subA_nn,w)\n"}, {"ctype": "head", "data": "stacking"}, {"ctype": "p", "data": "stacking的思路有部分是与加权融合差不多，区别在于stacking的第二层分层的。 对于第一层，一样还可以有多个模型。因此第一层我们选择与加权融合的模型相同，即随机森林、LightGBM和神经网络模型，接着分别进行拟合与预测，但对于预测的结果不再是测试集，也不进行进行加权，而是分别预测训练集和测试集，得到两个不同的数据框，一个数据框有三个不同列，每一个列代表一个模型预测出来的结果。 接着第二层区别比较大，这里的训练集与测试集不再是原始数据。而是第一层最后得到的两个数据框。即三个模型对原始训练集预测出来的原始训练集结果数据框和对测试集预测出来的原始测试集结果数据框。 紧接着，对于第二层的模型我们搭建随机森林模型，对新得到的训练集进行训练(这里标签至始至终没有进行处理)，训练出的模型对测试集进行预测。"}, {"ctype": "head", "data": "第一层"}, {"ctype": "code", "data": "train_rf_pred = model_rf.predict(X_train)\ntrain_lgb_pred = model_lgb.predict(X_train)\ntrain_nn_pred = model_nn.predict(X_train)\n#第二层所需的训练集\nstacking_X_train = pd.DataFrame()\nstacking_X_train['Method_1'] = train_rf_pred\nstacking_X_train['Method_2'] = train_lgb_pred\nstacking_X_train['Method_3'] = train_nn_pred\n#第二层所需的测试集\nstacking_X_test = pd.DataFrame()\nstacking_X_test['Method_1'] = subA_rf\nstacking_X_test['Method_2'] = subA_lgb\nstacking_X_test['Method_3'] = subA_nn\n"}, {"ctype": "head", "data": "第二层"}, {"ctype": "code", "data": "# 第二层是用random forest\nmodel_lr_stacking = build_model_rf(stacking_X_train,y_train)\n\n## 训练集\ntrain_pre_Stacking = model_lr_stacking.predict(stacking_X_train)\nprint('MAE of stacking:',mean_absolute_error(y_train,train_pre_Stacking))\n\n## 验证集\nval_pre_Stacking = model_lr_stacking.predict(stacking_X_val)\nprint('MAE of stacking:',mean_absolute_error(y_val,val_pre_Stacking))\n\n## 预测集\nprint('Predict stacking...')\nsubA_Stacking = model_lr_stacking.predict(stacking_X_test)\n"}, {"ctype": "p", "data": "最后的model_lr_stacking即为最终预测结果。"}], "cate": "Python"}
{"题目": "特征筛选，归一化操作（SelectKBest，随机森林）PCA降维", "作者": "普普通通研究生学代码", "发布时间": "2021-03-28 23:38:35", "内容": [{"ctype": "head", "data": "特征筛选，归一化操作（SelectKBest，随机森林）PCA降维"}, {"ctype": "p", "data": "SelectKBest和卡方检验，随机森林算法降维，归一化操作。"}, {"ctype": "p", "data": "（1）读取数据，分为特征和label值。"}, {"ctype": "code", "data": "from sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import chi2\nimport pandas as pd\n\ncontent=pd.read_csv('dynamic.csv')\nx=content.iloc[:,0:-1]  ##x为特征\ny=content.iloc[:,-1]     ##y 为label值标签\nx.fillna(0,inplace=True)  ##对数据空值简单用0代替，没有做特别详细预处理\n"}, {"ctype": "p", "data": "随机森林算法和SelectKBest中对特征降维在归一化有很大的不同，随机森林是决策树不需要进行归一化/标准化操作。 概率形的算法需要对数据进行归一化，可以加快算法的运行与迭代。SelectKBest算法需要进行归一化。"}, {"ctype": "p", "data": "（2）采取归一化操作"}, {"ctype": "p", "data": "1.max-min 归一化方法"}, {"ctype": "code", "data": "\nfor i in x.columns:\n   # 获取各个指标的最大值和最小值\n    Max = np.max(x[i])\n    Min = np.min(x[i])\n    x[i] = (x[i] - Min)/(Max - Min)\n"}, {"ctype": "p", "data": "2.Z-Score标准化"}, {"ctype": "code", "data": "\nfrom sklearn import preprocessing\n\nzscore = preprocessing.StandardScaler()\n# 实例化Z-Score标准化方法\nzscores = zscore.fit_transform(x)\n# 对数据进行标准化操作\n"}, {"ctype": "p", "data": "两者最大的区别在于，Z-Score标准化可以处理符合正态分布的数据，max-min方法容易受到极端值数据影响，比较适合均匀分布的数据，所以在选定方法之前必须要验证数据符合什么分布。"}, {"ctype": "p", "data": "（3）验证是否符合正态分布"}, {"ctype": "code", "data": "import matplotlib.pyplot as plt\nimport seaborn as sns\nfor i in x.columns:\n    sns.distplot(x[i], rug=True, hist=False)\n    plt.show()\n####画出图像观察图像就知道是否符合正态分布\n\n"}], "cate": "Python"}
{"题目": "Python学习之旅（核心编程爬虫篇004正则表达式）", "作者": "破空星", "发布时间": "2021-03-28 17:21:09", "内容": [{"ctype": "head", "data": "Python核心编程爬虫篇2021.03.16"}, {"ctype": "p", "data": "指导教师：逻辑教育讲师Jerry"}, {"ctype": "head", "data": "一、正则表达式概念"}, {"ctype": "p", "data": "正则表达式是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个规则字符串。是用来对字符串的过滤逻辑公式。"}, {"ctype": "head", "data": "二、应用场景"}, {"ctype": "head", "data": "三、正则表达式的使用（对Python的支持）"}, {"ctype": "head", "data": "1、普通字符"}, {"ctype": "head", "data": "2、元字符"}, {"ctype": "p", "data": "正则表达式中使用了很多元字符，用来表示这些特殊的含义或功能"}, {"ctype": "table", "data": "表达式匹配.匹配除了换行符\\n以外的任意字符|逻辑或操作符[]匹配字符集中的一个字符[^]对字符集求反，^必须放在前面-定义[]里的一个区间，例如a-z\\对一些具有特殊功能的字符进行转义()对表达式进行分组，将括号内的内容当做整体，并获得其所匹配的值"}, {"ctype": "head", "data": "3、预定义匹配字符集"}, {"ctype": "p", "data": "正则表达式中的一些表示方法，可以同时匹配某个预定义字符集中的任意一个 字符。比如，表达式\\d可以匹配任意一个数字，但是只能是一个，不是多个。"}, {"ctype": "table", "data": "表达式匹配\\d0-9中的任意一个数字\\wa-z，A-Z，0-9，_中的任意一个字符\\s空格、制表符、换页符等空白字符中的任意一个字符\\D\\d的反集，非数字中的任意一个字符，等同于[^\\d]\\W\\w的反集，等同于[^\\w]\\S\\s的反集，等同于[^\\s]"}, {"ctype": "head", "data": "4、重复匹配"}, {"ctype": "p", "data": "为了对某个字段进行重复匹配，例如手机号码13666666666，可以使用表达式再加上修饰匹配次数的特殊符号{},例如[abcd][abcd]可以写成[abcd]{2}"}, {"ctype": "table", "data": "表达式匹配{n}表达式重复n次，比如a{3}相当于aaa{m,n}表达式至少重复m次，至多重复n次，比如ab{1,3}可匹配ab,abb,abbb{ m,}表达式至少重复m次?匹配表达式0次或者1次，相当于{0,1}比如 a[cd]?可以匹配a,ac,ab+表达式至少重复1次 ,相当于{1，}，比如a+b可以匹配ab,aab,aaab等*表达式重复0次到任意次，相当于{0，}，比如\\^*b，可以匹配b,^b,^^b,^^^b等"}, {"ctype": "head", "data": "5、位置匹配"}, {"ctype": "p", "data": "有时候，我们对匹配出现的位置有要求，如开头、结尾、单词之间等等"}, {"ctype": "table", "data": "表达式匹配^在字符串开始的地方匹配$在字符串结束的地方匹配\\b匹配一个单词的边界（单词和空格之间的位置）\\B匹配非单词边界"}, {"ctype": "head", "data": "6、贪婪与非贪婪匹配"}, {"ctype": "code", "data": "\"\"\"非贪婪匹配\"\"\"\nimport re\n\ns = r'<div>abc</div><div>bcd<div>'\nptn = '<div>.*?<div>'  # 非贪婪\nptn1 = '<div>.*<div>'\nr = re.match(ptn, s)\nprint(r.group())  # 结果为<div>abc</div><div>\nr1 = re.match(ptn1, s)\nprint(r1.group())  # 结果为<div>abc</div><div>bcd<div>\n"}, {"ctype": "head", "data": "7、校验数字的常用表达式"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322170712754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTk1NTM2,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "8、特殊场景表达式"}, {"ctype": "img", "data": "https://img-blog.csdnimg.cn/20210322170742598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTk1NTM2,size_16,color_FFFFFF,t_70"}, {"ctype": "head", "data": "9、re模块常用方法"}, {"ctype": "table", "data": "方法描述返回值compile(pattern[,flags])根据包含正则表达式的字符串创建模式对象re对象search(pattern,string[,flags])在字符串中查找第一个匹配到的对象或Nonematch(pattern,string[,flags])在字符串开始处匹配的模式在字符串开头匹配的对象或Nonesplit(pattern,string[,maxsplit=0，flags])根据模式的匹配项来分割字符串分割后的字符串列表findall(pattern,string,flags)列出字符串中模式的所有匹配项所有匹配到的字符串列表sub(pat,repl，string[,count=0，flags])将字符串中所有pat的匹配项用repl替换完成替换后的新字符串"}, {"ctype": "table", "data": "匹配模式描述re.AASCII字符模式re.I不区分大小写模式re.L作本地化（locale-aware）识别匹配re.M多行匹配，影响^和$re.S使.能够匹配包括换行在内的所有字符，针对多行匹配re.U根据Unicode字符集解析字符，这个标志影响\\w，\\W，\\b，\\Bre.X以更灵活的方式将正则表达式写的更简洁"}, {"ctype": "head", "data": "10、分组功能"}, {"ctype": "p", "data": "re模块中的分组功能可以将已经匹配到的内容再次筛选，相当于二次过滤。实现分组靠圆括号()，获取分组的内容靠的是group()、groups()"}, {"ctype": "code", "data": "\"\"\"分组功能\"\"\"\nimport re\n\ns = 'apple price is $66,banana price is $77'\nptn = '.*\\$\\d\\d,.*\\$\\d\\d'  # 获取所有\nptn1 = '.*(\\$\\d\\d),.*(\\$\\d\\d)'\nr = re.match(ptn, s)\nr1 = re.match(ptn1, s)\nprint(r.group())  # 获取所有apple price is $66,banana price is $77\nprint(r1.group())  # 获取所有apple price is $66,banana price is $77\nprint(r1.group(0))  # 获取所有apple price is $66,banana price is $77\nprint(r1.group(1))  # 匹配第一个$66\nprint(r1.group(2))  # 匹配第二个$77\nprint(r1.groups())  # 获取所有分组('$66', '$77')\n"}, {"ctype": "head", "data": "练习"}, {"ctype": "code", "data": "\"\"\"\n爬取英雄联盟贴吧图片：https://tieba.baidu.com/p/2129187191\n1、图片url不在网页源码中（列表元素）\n2、for循环双列表遍历zip(lis1,lis2)\n3、图片所存文件夹需提前创建\n4、p_urls = re.findall('\"murl\":\"(.*?)\"', res.text)  # 爬取每页图片url并以列表返回\n   p_names = re.findall('\"index\":.+?,\"descr\":\"(.*?_\\d)', res.text)  # 爬取图片名称，图片url中descr有些带.jpg有些不带\n5、注意文件名：爬取图片url中descr，有些带.jpg有些不带。\n\"\"\"\nimport requests\nimport re\nimport time\n\n\"\"\"https://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=1&ps=195&pe=200&wall_type=h&_=1616908598128\nhttps://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=1&ps=156&pe=195&wall_type=h&_=1616908595996\nhttps://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=1&ps=116&pe=155&wall_type=h&_=1616908593012\nhttps://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=1&ps=78&pe=117&wall_type=h&_=1616908590095\nhttps://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=1&ps=39&pe=78&wall_type=h&_=1616908586162\n每页图片有6个utl，200张图片每个图片信息：\"mwidth\":103,\"mheight\":187,\"mwrapper_width\":103,\"mwrapper_height\":187,\"crop_width\":0,\"crop_height\":0,\"width\":307,\"height\":557,\"mtop\":0,\"mleft\":0,\"pic_id\":\"486eb71c8701a18baf7801109e2f07082938fe1c\",\"index\":155,\"descr\":\"Tristana_5\",\"murl\":\"http://imgsrc.baidu.com/forum/wh%3D103%2C187/sign=bc40d6703a292df59796a4148c027051/486eb71c8701a18baf7801109e2f07082938fe1c.jpg\",\"pwidth\":220,\"pheight\":399,\"purl\":\"http://imgsrc.baidu.com/forum/w%3D220/sign=353b2c1402087bf47dec50ebc2d2575e/486eb71c8701a18baf7801109e2f07082938fe1c.jpg\",\"pwrapper_width\":220,\"pwrapper_height\":400\n其中包含大写、索引、地址、描述等信息\n每页url可写为https://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=1&ps=1&pe=200&wall_type=h&_=1616908598128\nurl中 pn=1 代表页数\n\"\"\"\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0'\n}\nj = 0  # 记录并显示下载图片进度\nfor i in range(1, 7):  # 翻页\n    print(f'开始爬取第{i}页')\n    time.sleep(1)\n    url = 'https://tieba.baidu.com/photo/g/bw/picture/list?kw=英雄联盟&alt=jview&rn=200&tid=2129187191&pn=' + str(\n        i) + '&ps=1&pe=200&info=1&wall_type=h&_=1616908578200'\n    res = requests.get(url, headers=headers)\n    p_urls = re.findall('\"murl\":\"(.*?)\"', res.text)  # 爬取每页图片url并以列表返回\n    p_names = re.findall('\"index\":.+?,\"descr\":\"(.*?_\\d)', res.text)  # 爬取图片名称\n    # print(p_names)\n    for p_url, p_name in zip(p_urls, p_names):  # 爬取每页图片\n        j += 1\n        time.sleep(0.5)\n        rp = requests.get(p_url)\n        with open('picture/' + p_name + '.jpg', 'wb') as f_obj:  # 需要提前建立picture文件夹\n            f_obj.write(rp.content)\n            print(f'正在下载第{j}张')\n"}], "cate": "Python"}
